{
    "paper_id": "48a432943e1c2416fe598ac3c98ee46d06bde105",
    "metadata": {
        "title": "Input Strictly Local Tree Transducers",
        "authors": [
            {
                "first": "Jing",
                "middle": [],
                "last": "Ji",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Stony Brook University",
                    "location": {
                        "settlement": "Stony Brook",
                        "country": "USA"
                    }
                },
                "email": "jing.ji@stonybrook.edu"
            },
            {
                "first": "Jeffrey",
                "middle": [],
                "last": "Heinz",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Stony Brook University",
                    "location": {
                        "settlement": "Stony Brook",
                        "country": "USA"
                    }
                },
                "email": "jeffrey.heinz@stonybrook.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "We generalize the class of input strictly local string functions (Chandlee et al. 2014) to tree functions. We show they are characterized by a subclass of frontier-to-root, deterministic, linear tree transducers. We motivate this class from the study of natural language as it provides a way to distinguish local syntactic processes from non-local ones. We give examples illustrating this kind of analysis.",
            "cite_spans": [
                {
                    "start": 65,
                    "end": 87,
                    "text": "(Chandlee et al. 2014)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Locally Testable sets of strings in the strict sense (Strictly Local, SL) are a subclass of the regular languages with interesting properties [16, 20] . Rogers [18] presents a generalization of SL to sets of trees and shows they characterize the derivations of context-free languages. Chandlee et al. [2, 3] generalize SL formal languages in another direction. They present classes of strictly local string-tostring functions. In this paper, we generalize the SL class to a class of functions over trees. In particular, we present a characterization in terms of frontier-toroot, deterministic, linear tree transducers [5, 7] .",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 146,
                    "text": "[16,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 147,
                    "end": 150,
                    "text": "20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 153,
                    "end": 159,
                    "text": "Rogers",
                    "ref_id": null
                },
                {
                    "start": 160,
                    "end": 164,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 301,
                    "end": 304,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 305,
                    "end": 307,
                    "text": "3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 618,
                    "end": 621,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 622,
                    "end": 624,
                    "text": "7]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "One motivation comes from computational and theoretical linguistics, where the goal of one program is to identify and understand the minimally powerful classes of formal grammars which can describe aspects of natural language [4] . To this end, subregular sets and functions over strings have been used to distinguish and characterize phonological generalizations [11] . More recent research has begun studying natural language syntax from the perspective of subregular sets and functions over trees, as opposed to strings [9, 10] .",
            "cite_spans": [
                {
                    "start": 226,
                    "end": 229,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 364,
                    "end": 368,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 523,
                    "end": 526,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 527,
                    "end": 530,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "One rationale for studying subclasses of regular string/tree sets and relations is that it is known that finite-state methods are sufficient to describe aspects of natural language. For phonology and morphology, finite-state methods over strings appear sufficient [1, 17] . For syntax, finite-state methods over trees similarly appear sufficient. Rogers [19] showed that a syntactic theory of English can be understood in terms of Monadic Second Order (MSO) definable constraints over trees. Languages with more complex constructions can be understood in terms of regular tree languages undergoing regular tree transductions [8, 14] . Tree transducers also have found broad application in machine translation [13, 15] . It remains an open question, however, whether the full power of regular computations are necessary [11] .",
            "cite_spans": [
                {
                    "start": 264,
                    "end": 267,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 268,
                    "end": 271,
                    "text": "17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 354,
                    "end": 358,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 625,
                    "end": 628,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 629,
                    "end": 632,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 709,
                    "end": 713,
                    "text": "[13,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 714,
                    "end": 717,
                    "text": "15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 819,
                    "end": 823,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Another rationale for identifying subregular classes of languages is that learning problems may be easier to solve in the sense of requiring less and time and resources than otherwise [12] .",
            "cite_spans": [
                {
                    "start": 184,
                    "end": 188,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "By defining and characterizing the Input Strictly Local class of tree transducers, we hope to take a first step in developing a more fine-grained perspective on the syntactic transformations present in natural languages. The structure of the paper is as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Section 2 defines trees and associated properties and functions based on their recursive structure. In this way we follow the tree transducer literature [5, 7] . However, we note that we do not adopt the convention of ranked alphabets. Instead we obtain their effects by bounding the largest number of children a tree in some tree set can have and by requiring that the pre-image of the transition function of the tree automata is finite. While this is unconventional, we believe it simplifies our presentation and proofs. Section 2 also reviews strictly local treesets and reviews the proof of the abstract characterization of them [18] .",
            "cite_spans": [
                {
                    "start": 153,
                    "end": 156,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 157,
                    "end": 159,
                    "text": "7]",
                    "ref_id": null
                },
                {
                    "start": 633,
                    "end": 637,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Section 3 presents the main theoretical results. Deterministic, frontier-toroot, finite-state, linear tree transducers (abbreviated DFT) are defined, Input Strictly Local (ISL) tree functions are defined abstractly and then characterized in terms DFTs. Section 4 concludes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Assume a finite alphabet \u03a3 and let \u03a3 * denote the set of all strings of finite length that can be obtained via concatenation of the elements of \u03a3. We denote the empty string with \u03bb.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Consider an alphabet \u03a3 and symbols [ ] which do not belong to it. A tree is defined inductively as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "-Base Case: For each a \u2208 \u03a3, a[ ] is a tree. The tree a[ ] is also called a leaf.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We also write a[\u03bb] for a[ ]. -Inductive Case: If a \u2208 \u03a3 and t 1 t 2 . . . t n is a string of trees of length n (n \u2265 1), then a[t 1 t 2 . . . t n ] is a tree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "For a trees t = a[t 1 t 2 . . . t n ], the trees t 1 , t 2 , . . . t n are the children of t and t i denotes the ith child. \u03a3 T denotes the set of all trees of finite size from \u03a3. The depth, size, yield, root, branch, and the set of subtrees of a tree t, written dp(t), |t|, yld(t), root(t), branch(t) and sub(t), respectively, are defined as follows. For all a \u2208 \u03a3:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "-If t = a[ ], then dp(t) = 1, |t| = 1, yld(t) = a, root(t) = a, branch(t) = 0, and sub(t) = {t}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": ". . t n ] then dp(t) = max{dp(t i )|1 \u2264 i \u2264 n} + 1, and |t| = 1 + n i=1 |t i |, and yld(t) = yld(t 1 )yld(t 2 ) . . . yld(t n ), and root(t) = a, and branch(t) = n, and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The roots of the subtrees of a tree t are called nodes. The root of a tree is also called its root node. Leaves are also called frontier nodes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The branching degree of a tree t is branch degree(t) = max{branch(u) | u \u2208 sub(t)}. Let \u03a3 T n denotes the set of trees {t \u2208 \u03a3 T | branch degree(t) \u2264 n}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "] denotes a tree rooted in S with branch degree of 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Let N * be the set of all sequences of finite length of positive natural numbers. For n = n 1 , n 2 , . . . , n m \u2208 N * (m \u2265 1), the subtree of t at n is written t. n, and it is defined inductively: -Base Case: t. n = t iff n = \u03bb. The Gorn addresses provide a natural ordering of the subtrees of t in terms of the length-lexicographic ordering. For distinct n = n 1 , n 2 , . . . , n k , m = m 1 , m 2 , . . . , m , n precedes m iff either k < , or k = and n 1 < m 1 , or k = and n 1 = m 1 and n 2 , . . . , n k < m 2 , . . . , m . This essentially orders subtrees of t such that the ones closer to the root of t are ordered earlier, and those 'on the same level' in t are ordered 'left to right.' We make use of this ordering in our proof of Theorem 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The largest common subtrees of a set of trees T , denoted lcs(T ), is {d \u2208 t\u2208T sub(t) | \u2200d \u2208 t\u2208T sub(t), |d | \u2264 |d|}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The k-stem (k \u2265 1) of a tree t, written stem k (t), is defined as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "- ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The stems of a tree t, denoted stem(t) is the set {stem k (t) | k \u2265 1}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "It is useful to incorporate boundary markers into the roots and leaves of trees. Informally, given a \u03a3-tree t, boundary markers are added above the root and below the leaves. Formally, we employ symbols , \u2208 \u03a3 for this purpose.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Thus for all a \u2208 \u03a3, t \u2208 \u03a3 T , let add , and add (a[t 1 . . . t n ]) = a[ (t 1 ) \u00b7 \u00b7 \u00b7 (t n )]. Then for any \u03a3-tree t, its augmented counterpartt = add (add (t)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The k-factors of a tree t are defined as the set of k-depth stems of subtrees oft. For all t \u2208 \u03a3 T , let F k (t) = {stem k (u) | u \u2208 sub(t )}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We lift the definition of k-factors to treesets in the natural way. For all T \u2286 \u03a3 T , F k (T ) = t\u2208T F k (t).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A strictly k-local grammar G = (\u03a3, S) where S is a finite subset of F k (\u03a3 T ) and the tree language of G is defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "Note that since S is finite, there exists a smallest number n such that S \u2286\u03a3 T n . It follows that L((\u03a3, S)) is of branching degree n. A treeset T \u2286 \u03a3 T is strictly k-local if there exists a k and a strictly k-local grammar G such that L(G) = T . Such treesets form exactly strictly k-local treesets (SL k ). Strictly local stringsets are a special case of strictly local treesets where all the branching degree is 1; so every node (except leaves) are unary branching.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "Strictly 2-local treesets have been called local treesets in previous literature [18] . Every Strictly 2-local tree language can be generated by a context free grammar [7, 18] .",
            "cite_spans": [
                {
                    "start": 81,
                    "end": 85,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 168,
                    "end": 171,
                    "text": "[7,",
                    "ref_id": null
                },
                {
                    "start": 172,
                    "end": 175,
                    "text": "18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "Comparable to the characterization of strictly local string sets, which is Suffix Substitution Closure [20] , each strictly 2-local tree language satisfies Subtree Substitution Closure [18] . To explain this characterization, we first introduce the notion of subtree-substitution.",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 107,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 185,
                    "end": 189,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "For t, s \u2208 \u03a3 T and n = n 1 , n 2 , . . . , n m \u2208 N * (m \u2265 1), the operation of substituting the subtree of t at n by s, written as t. n \u2190 s, is defined as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "We also define substitution of all the subtrees of t rooted at x (x \u2208 \u03a3) by s, which we write as t ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "Rogers [18] proves the following result and we repeat the proof to set the stage for the sequel.",
            "cite_spans": [
                {
                    "start": 7,
                    "end": 11,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Example 3. The 2-factors of the tree in Example 1 is the set"
        },
        {
            "text": "Proof. If T is strictly 2-local, then there exists a corresponding strictly 2-local grammar G that satisfies L(G) = T . Thus there exists a finite set S \u2282 F k (\u03a3 T ) such that L((\u03a3, S)) = T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Consider any A, B \u2208 T and n 1 , n 2 \u2208 N such that root(A. n 1 ) = root(B. n 2 ). Let t = A. n 1 \u2190 B. n 2 . We show t \u2208 T . First notice that F 2 (A) \u2286 S and F 2 (B) \u2286 S because A, B \u2208 T and T = L((\u03a3, S)). Next consider any element u \u2208 F 2 (t). By definition of t and 2-factor, u must be a 2-stem of a subtree of A. n 1 \u2190 B. n 2 . If u is the 2-stem of a subtree of B. n 2 then u \u2208 F 2 (B) \u2282 S. If not, then u is a 2-stem of a subtree of A and so u \u2208 F 2 (A) \u2282 S. Either way, u \u2208 S and so F 2 (t) \u2286 S. It follows that t \u2208 T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Conversely, consider a treeset T such that whenever there exist two vectors n 1 , n 2 \u2208 N , such that root(A. n 1 ) = root(B. n 2 ) then A. n 1 \u2190 B. n 2 \u2208 T . We refer to this property as the SSC. To show T is Strictly 2-Local, we present a finite set S \u2282 F k (\u03a3 T ) such that L((\u03a3, S)) = T . Let S = F 2 (T ). Since T is of branching degree n, S is finite. In order to prove L((\u03a3, S)) = T , we need to show both L((\u03a3, S)) \u2286 T and T \u2286 L((\u03a3, S)). It is obvious that T \u2286 L((\u03a3, S)) because for any t \u2208 T , F 2 (t) \u2286 S = F 2 (T ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "The following proves that L((\u03a3, S)) \u2286 T by recursive application of SSC. Consider any t \u2208 L((\u03a3, S)). Let t 1 = t. n 1 , t 2 = t. n 2 , . . . t m = t. n m be an enumeration of the m subtrees of t by their Gorn addresses in length-lexicographic order. (Note that t 1 = t).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "The base step of the induction is to choose a tree s 0 \u2208 T that has the same root as t. Such a s 0 \u2208 T exists because [root(t)[ ]] \u2208 S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Next we assume by the induction hypothesis that s i\u22121 \u2208 T and we will construct",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Informally, this construction ensures the nodes and children of s i are identical to those of t from the root of t to the root of the subtree t i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Since each s i is built according to s i\u22121 and s 0 \u2208 T we conclude that s m \u2208 T . Furthermore, since the subtrees are ordered length-lexicographically and we substitute a 2-stem of a subtree of t to build s i , it follows that s m = t. As t was arbitrary in L((\u03a3, S)), we obtain L((\u03a3, S)) \u2286 T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "The catenation operation of two trees u \u00b7 t is defined by substitution in the leaves. Let $ be a new symbol, i.e., $ \u2208 \u03a3. Let \u03a3 T $ denote the set of all trees over \u03a3 \u222a $ which contain exactly one occurrence of label $ in the leaves. The operation of catenation is defined inductively: Notice that the classical catenation of strings can be viewed as a special case of catenation of trees with unary branching. This operation can also be used to represent subtrees. For t \u2208 \u03a3 T \u222a \u03a3 T $ , if t = u \u00b7 s, then s is a subtree of t.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Furthermore, for any t \u2208 T and any tree language T \u2286 \u03a3 T , the quotient of t w.r.t. T is defined",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "Canonical finite-state tree recognizers can be defined in terms of these quotients.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1 (Subtree Substitution Closure). A treeset T \u2286 \u03a3 T is strictly 2-local iff there is n such that T is of branching degree n and for all"
        },
        {
            "text": "In this section we define functions that map trees to trees. After reviewing some basic terminology, we introduce deterministic, frontier-to-root, linear, finite-state Tree Transducers (DFT). We then define Input Strictly Local Tree Transducers (ISLTT) in a grammar-independent way, and then prove they correspond exactly to a type of DFTs. Examples are provided along the way.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "A function f with domain X and co-domain Y can be written f :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "is defined} and the pre-image of f is the set {x \u2208 X|f (x) is defined}. Tree transducers compute functions that map trees to trees f : \u03a3 T n \u2192 \u0393 T . DFTs are defined as a tuple (Q, \u03a3, \u0393, F, \u03b4), where Q is a finite set of states, F \u2286 Q is a set of final states, and \u03b4 is a transition function that maps a sequence of states paired with an element of \u03a3 to a state and a variably-leafed tree. A variably-leafed tree is a tree which may include variables in the leaves of the tree. Let X = {x 1 , x 2 , . . .} be a countable set of variables. If \u03a3 is a finite alphabet then \u03a3 T [X] denotes the set of trees t formed with the alphabet \u03a3 \u222a X such that if the root of a subtree s of t is a variable then s is a leaf (so variables are only allowed in leaves). Thus formally the transition function is \u03b4 :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "Importantly, the pre-image of the transition function must be finite. We sometimes write (q 1 q 2 . . . q m , a, t, q) \u2208 \u03b4 to mean \u03b4(q 1 q 2 . . . q m , a) = (t, q).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "In the course of computing a tree transduction, the variables in variablyleafed trees are substituted with trees. Assume t 1 , t 2 , . . . t m \u2208 \u0393 T and s \u2208 \u0393 T [X], which is a variable leafed tree with any subset of the variables {x 1 , x 2 , ..., x m }. We define a substitution function \u03c6 such that \u03c6(",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "We define the process of transducing a tree recursively using a function \u03c0, which maps \u03a3 T n to Q \u00d7 \u0393 T , which itself is defined inductively with \u03b4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "The tree-to-tree function the transducer M recognizes is the set of pairs",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "We also write M (t) = s whenever (t, s) \u2208 L(M ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "A DFT is linear provided whenever \u03b4(q 1 q 2 . . . q m , a) = (s, q), no variable occurs more than once in s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "Example 5. Wh-movement refers to a syntactic analysis of question words such as English what and who. It is common to analyze this as a relation between tree structures [21] . The input structure describes the relation of the wh-word to its verb (cf. \"John thinks Mary believes Bill buys what?\") and the yield of the output structure reflects the pronunciation (cf. \"What does John think Mary believe Bill buys\").",
            "cite_spans": [
                {
                    "start": 169,
                    "end": 173,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "We use a simplified transformation to make the point. In the alphabet, S represents the root node of a input tree, W stands for a wh-word and P for everything else (P is for phrase). A transducer of wh-movement can be constructed as a Figure 1 illustrates some of the transformations computed by the finite-state machine M wh . The tree with a wh-word in Fig. (1a) is transformed into the tree in Fig. (1b) . (M wh keeps the original wh-word in-situ but it could easily be removed or replaced with a trace). The trees in Fig. (1c) and (d) are the same because there is no wh-word in the input tree and so M wh leaves it unchanged. Next we describe the canonical form of deterministic tree transducers. The quotient of a tree t \u2208 \u03a3 T with respect to a tree-to-tree function f : \u03a3 T \u2192 \u0393 T is a key idea. It will be useful to develop some notation for the largest common subtree of the image under f of the set of trees which includes t as a subtree.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 235,
                    "end": 243,
                    "text": "Figure 1",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 355,
                    "end": 364,
                    "text": "Fig. (1a)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 397,
                    "end": 406,
                    "text": "Fig. (1b)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 521,
                    "end": 530,
                    "text": "Fig. (1c)",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "When f is understood from context, we just write lcsi(t). Then the quotient is defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "(1)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "When f is clear from context, we write qt(t) instead of qt f (t).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "It is worth noting that for a tree t \u2208 \u03a3 T n , the largest common subtree of the image of a linear transducer with the input of \u03a3 T $ \u00b7 {t} is unique if it exists because if there is more than one tree that belongs to lcs(f (\u03a3 T $ \u00b7{t})), they must be produced by copying, which is not allowed by linear DFT. If trees t 1 , t 2 \u2208 \u03a3 T have the same quotient with respect to a function f , they are quotient-equivalent with respect to f and we write t 1 \u223c f t 2 . Clearly, \u223c f is an equivalence relation which partitions \u03a3 T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "As in the string case, to each regular tree language T , there is a canonical DFT accepting T . The characterization given by the Myhill-Nerode theorem can be transferred to the tree case [6] . For any treeset T , the quotients of trees w.r.t. T can be used to partition \u03a3 T into a finite set of equivalence classes.",
            "cite_spans": [
                {
                    "start": 188,
                    "end": 191,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "Analogous to the smallest subsequential finite state transducer for a subsequential function, we can construct the smallest linear DFT for a deterministic tree-to-tree function f and refer to this transducer as the canonical transducer for f , \u03a8 c f . For t 1 , t 2 , . . . , t m \u2208 \u03a3 T n (m \u2264 n) and a \u2208 \u03a3, let the contribution of a w.r.t.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "The term cont f (a,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "Then the canonical DFT for a deterministic tree-to-tree function f is:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "The presentation here differs from Friese et al. [6] , but the only thing we require in the proof of Theorem 2 below is the existence of the canonical DFT whenever \u223c f is of finite index.",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 52,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "We define ISLTT as a subclass of linear DFTs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Input Strictly Local Tree Transducers"
        },
        {
            "text": "In the same way ISL string functions can be used to probe the locality properties of phonological processes, ISL tree functions can used to probe the locality properties of syntactic transformations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Input Strictly Local Tree-to-tree Function). A function f is Input Strictly Local (ISL) if there is a k and n such that for all"
        },
        {
            "text": "To show that a syntactic transformation is not ISL one need only construct a counterexample to Definition 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Input Strictly Local Tree-to-tree Function). A function f is Input Strictly Local (ISL) if there is a k and n such that for all"
        },
        {
            "text": "Example 6. We can show the function computed by M w h from Example 5 is not ISL for any k because there is no bound on the distance the wh-word can 'travel.' Suppose there is a k and n such that for all t 1 , t 2 \u2208 \u03a3 T n , if stem k\u22121 (t 1 ) = stem k\u22121 (t 2 ) then qt f (t 1 ) = qt f (t 2 ). Let u 1 = u 2 . . . = u k\u22121 = P [P $]. Also let u k = P [P P], s = S[P $] and w = P [P W ]. We construct two sentence structures: s \u00b7 t 1 and s \u00b7 t 2 , where t 1 = u 1 \u00b7 u 2 . . . u k\u22121 \u00b7 w and t 2 = u 1 \u00b7 u 2 . . . u k\u22121 \u00b7 u k . It is obvious that stem k\u22121 (t 1 ) = stem k\u22121 (t 2 ). However, qt f (t 1 ) = qt f (t 2 ) since (s, s) \u2208 qt f (t 2 ) but (s, s) / \u2208 qt f (t 1 ). As we can always find such a pair of trees t 1 and t 2 for any k, it is thus proved that wh-movement is not ISL for any k.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Input Strictly Local Tree-to-tree Function). A function f is Input Strictly Local (ISL) if there is a k and n such that for all"
        },
        {
            "text": "Our main result, Theorem 2 below, establishes an automata-theoretic characterization of ISL tree-to-tree functions. As we illustrate after the proof, one can show that a tree transformation is ISL using this theorem. Transducers) . A function f is ISL iff there is some k and n such that f can be described with a DFT for which",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 217,
                    "end": 229,
                    "text": "Transducers)",
                    "ref_id": null
                }
            ],
            "section": "Definition 1 (Input Strictly Local Tree-to-tree Function). A function f is Input Strictly Local (ISL) if there is a k and n such that for all"
        },
        {
            "text": "The transducer is finite since \u03a3 is finite and n bounds the branching degree of the pre-image of f which ensures the finiteness of both Q and \u03b4. Before our proof of the Theorem, we prove a lemma based on these remarks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2 (ISL Tree"
        },
        {
            "text": "For all k,m \u2208 N with k \u2264 m, and for all t \u2208 \u03a3 T n , stem k (stem m (t)) = stem k (t) since both t and stem m (t) share the same k-stem from the root. k \u2208 N, and for all a \u2208 \u03a3 and t 1 , t 2 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 150,
                    "end": 188,
                    "text": "k \u2208 N, and for all a \u2208 \u03a3 and t 1 , t 2",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Remark 1."
        },
        {
            "text": ". This is a direct consequence of Remark 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Remark 2. For all"
        },
        {
            "text": "Let \u03a8 be a ISLTT with the properties defined in Theorem 2. If t \u2208 \u03a3 T n and u \u2208 \u0393 T , \u03c0(t) = (q, u), then q = stem k\u22121 (t).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Proof. The proof is by induction on the depth of the trees to which \u03c0 is applying. The base case follows from the facts that for (\u03bb, a, v, q) \u2208 \u03b4 iff \u03c0(a[ ]) = (q, v) and q = stem k\u22121 (a[ ]).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Next assume for all t 1 , t 2 , . . . , t m \u2208 \u03a3 T n (m \u2264 n) and v 1 , v 2 . . . , v m \u2208 \u0393 T such that \u03c0(t 1 ) = (q 1 , v 1 ) implies q 1 = stem k\u22121 (t 1 ), \u03c0(t 2 ) = (q 2 , v 2 ) implies",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "). Based on the assumption, we know that \u03c0(",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Now we can prove the theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Proof ( Theorem 2). (\u21d0) Assume k \u2208 N and let f be a function described by \u03a8 = {Q, \u03a3, \u0393 , F, \u03b4} constructed as in Theorem. Let t 1 , t 2 \u2208 \u03a3 T n such that stem k\u22121 (t 1 ) = stem k\u22121 (t 2 ). By Lemma 1, both t 1 and t 2 lead to the same state, so qt f (t 1 ) = qt f (t 2 ). Therefore, f is k-ISL.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "(\u21d2) Consider any ISL tree-to-tree function f . Then there is some k and n such that \u2200t 1 , t 2 \u2208 \u03a3 T n , we have stem k\u22121 (t 1 ) = stem k\u22121 (t 2 ) \u21d2 qt f (t 1 ) = qt f (t 2 ). We show that the corresponding ISL tree transducer \u03a8 ISL f exists. Since stem k\u22121 (\u03a3 T n ) is a finite set, the equivalence relation \u223c f partitions \u03a3 T into at most stem k\u22121 (\u03a3 T n ) blocks. Thus there exists a canonical linear DFT \u03a8 c f = {Q c , F c , \u03a3, \u0393, \u03b4 c }. \u03c0 c is the process function derived from \u03b4 c that maps \u03a3 T n to Q c \u00d7 \u0393 T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Construct \u03a8 = {Q, F, \u03a3, \u0393, \u03b4} as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "\u03a8 is ISL by construction, as the states and transitions of \u03a8 meet requirements (1) and (2) of Theorem 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "The following proof show that \u03a8 computes the same function as \u03a8 c f by showing that \u03a8 and \u03a8 c f generate the same function. In other words we show \u2200t \u2208 \u03a3 T n ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "First, we show that \u03c0(t) = (stem k\u22121 (t), u) iff \u03c0 c (t) = (qt(t), u). Clearly, the base case is satisfied. For all a \u2208 \u03a3 and v \u2208 \u0393 T [X], (\u03bb, a, v, q) \u2208 \u03b4 iff (\u03bb, a, v, qt(q)) \u2208 \u03b4 c . Thus \u03c0 c (a[ ]) = (qt(a[ ]), v) and \u03c0(a[ ]) = (stem k\u22121 (a[ ]), v).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Next assume that there exist t 1 , t 2 , . . . , t m \u2208 \u03a3 T n and u 1 , u 2 , . . . , u m \u2208 \u0393 T such that \u03c0(t i ) = (stem k\u22121 (t i ), u i ) iff \u03c0 c (t i ) = (qt(t 1 ), u i ) for each 1 \u2264 i \u2264 m. We show \u2200a \u2208 \u03a3 and \u2200v \u2208 \u03a3 T [X] such that \u03c0(a[t 1 t 2 . . .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": ". By substitution then, we have \u03c0 c (t i ) = (qt(q i ), u i ) for each 1 \u2264 i \u2264 m and qt(q 1 )qt(q 2 ) . . . qt(q m ), a, v, qt(a[q 1 q 2 . . . q m ]) \u2208 \u03b4 c .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "By construction of \u03a8 ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Conversely, consider any a \u2208 \u03a3 and v \u2208 \u03a3 T [X] and suppose \u03c0(a[t 1 t 2 . . . t m ]) = stem k\u22121 (a[t 1 t 2 . . . t m ]), (\u03c6(u 1 u 2 . . . u m ], v)) . By assumption, \u03c0(t i ) equals (stem k\u22121 (t i ), u i ) for each 1 \u2264 i \u2264 m. Thus stem k\u22121 (t 1 )stem k\u22121 (t 2 ) . . .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Let q i = stem k\u22121 (t i ) for each 1 \u2264 i \u2264 m as before. It follows that stem k\u22121 (t i ) = stem k\u22121 (q i ), so qt(t i ) = qt(q i ). Likewise, stem k\u22121 (a[t 1 t 2 . . . t m ]) = stem k\u22121 (a[q 1 q 2 . . . q m ]), so qt(a[t 1 t 2 . . . t m ]) = qt(a[q 1 q 2 . . . q m ]). Therefore, stem k\u22121 (q 1 )stem k\u22121 (q 2 ) . . . stem k\u22121 (q m ), a, v, stem k\u22121 (a[q 1 q 2 . . . q m ]) \u2208 \u03b4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "By construction of \u03a8 , this means qt(q 1 )qt(q 2 ) . . . qt(q m ), a, v, qt(a[q 1 q 2 . . . q n ]) \u2208 \u03b4 c . Since \u03c0 c (t i ) = (qt(t i ), u i ) for each i by assumption, it follows that \u03c0 c (a[t 1 t 2 . . . t m ]) = qt(a[q 1 q 2 . . . q n ]), (\u03c6 (u 1 u 2 . . . u n , v) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 245,
                    "end": 268,
                    "text": "(u 1 u 2 . . . u n , v)",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Lemma 1."
        },
        {
            "text": "We need to further show that stem k\u22121 (t) \u2208 F iff qt(t) \u2208 F c . By construction, we know that q \u2208 F iff qt(q) belongs to F c . Thus stem k\u22121 (t) \u2208 F iff qt(stem k\u22121 (t)) \u2208 F c . By Remark 1, stem k\u22121 (t) = stem k\u22121 (stem k\u22121 (t)). Hence qt(t) = qt(stem k\u22121 (t)). Therefore, stem k\u22121 (t) \u2208 F iff qt(t) \u2208 F c .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "This concludes the proof that \u03a8 and \u03a8 c f generate the same function.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "As mentioned earlier, the value of Theorem 2 is that it can be used to establish that certain tree transformations are ISL by presenting a transducer for the transformation which satisfies the properties specified by the theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Example 7. This example shows that reversing the branch order of a regular tree set T \u2286 \u03a3 T n is ISL. We illustrate with the classic tree language whose yield is the string language a n b n . In other words we wish to show that the transformation that maps t 1 The reader can verify that this transducer correctly reverses the branch order of the trees in its pre-image. Further, this construction shows the function is ISL since it satisfies the requirements in Theorem 2.",
            "cite_spans": [
                {
                    "start": 259,
                    "end": 260,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "This paper took a first step in characterizing local syntactic transformations by generalizing Input Strictly Local string functions to trees. Future work includes defining Output SL tree functions (cf. [3] ) and studying whether these classes of tree functions can be learned more quickly and with fewer resources, and characterizing subclasses of tree transducers which characterize the types of nonlocal processes found in syntax and machine translation.",
            "cite_spans": [
                {
                    "start": 203,
                    "end": 206,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Finite State Morphology",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Beesley",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kartunnen",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Learning strictly local subsequential functions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Chandlee",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Eyraud",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Heinz",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Trans. Assoc. Comput. Linguist",
            "volume": "2",
            "issn": "",
            "pages": "491--503",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Output strictly local functions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Chandlee",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Eyraud",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Heinz",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 14th Meeting on the Mathematics of Language",
            "volume": "",
            "issn": "",
            "pages": "112--125",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The Minimalist Program",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Chomsky",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Tree automata techniques and applications",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Comon",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "12",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Minimization of deterministic bottom-up tree transducers",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Friese",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Seidl",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Maneth",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Gao",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lu",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Seki",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "DLT 2010",
            "volume": "6224",
            "issn": "",
            "pages": "185--196",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-14455-4_18"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Closure properties of minimalist derivation tree languages",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Graf",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "LACL 2011. LNCS (LNAI)",
            "volume": "6736",
            "issn": "",
            "pages": "96--111",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-22221-4_7"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Curbing feature coding: strictly local feature assignment",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Graf",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the Society for Computation in Linguistics (SCiL)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "C-command dependencies as TSL string constraints",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Graf",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Shafiei",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jarosz",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nelson",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "O&apos;connor",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of SCiL",
            "volume": "",
            "issn": "",
            "pages": "205--215",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "The computational nature of phonological generalizations",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Heinz",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Phonological Typology",
            "volume": "",
            "issn": "",
            "pages": "126--195",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Grammatical Inference for Computational Linguistics. Synthesis Lectures on Human Language Technologies",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Heinz",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "De La Higuera",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Van Zaanen",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Applications of weighted automata in natural language processing",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Knight",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "May",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Handbook of Weighted Automata",
            "volume": "",
            "issn": "",
            "pages": "571--596",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-01492-5_14"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Minimalist tree languages are closed under intersection with recognizable tree languages",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "M"
                    ],
                    "last": "Kobele",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "LACL 2011. LNCS (LNAI)",
            "volume": "6736",
            "issn": "",
            "pages": "129--144",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-22221-4_9"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Survey: tree transducers in machine translation",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Maletti",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Bordihn",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Freund",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Hinze",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Holzer",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kutrib",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Otto",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proceedings of the 2nd International Workshop on Non-Classical Models of Automata and Applications. books@ocg.at",
            "volume": "263",
            "issn": "",
            "pages": "11--32",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Counter-Free Automata",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Mcnaughton",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Papert",
                    "suffix": ""
                }
            ],
            "year": 1971,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Computational Approaches to Morphology and Syntax",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Roark",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Sproat",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Strict LT2: regular :: local : recognizable",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Rogers",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "",
            "volume": "1328",
            "issn": "",
            "pages": "366--385",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0052167"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "A Descriptive Approach to Language-Theoretic Complexity",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Rogers",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "CSLI Publications",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Aural pattern recognition experiments and the subregular hierarchy",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Rogers",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Pullum",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "J. Log. Lang. Inf",
            "volume": "20",
            "issn": "",
            "pages": "329--342",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "An Introduction to Syntactic Analysis and Theory",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sportiche",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Koopman",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Stabler",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Inductive Case: Suppose t = a[t 1 t 2 . . . t n ] and n = \u03bb. Then t. n = t. n 1 , n 2 . . . n m = t n1 . n 2 , n 3 . . . n m . -Note: t. n is undefined otherwise. These sequences are the Gorn addresses of the subtrees of t. For example, The first child of t is given by t. 1 (if it exists); the second child by t. 2 (if it exists); the second child of the first child by t. 1, 2 (if it exists); and of course t. = t.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "(t) = [ t ], and add (a[ ]) = a[ [ ]]",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Base Case: If root(t) = x, t x \u2190s = s. -Base Case: If root(t) = x and t = a[ ] (a \u2208 \u03a3), t x \u2190s = t. -Inductive Case: If root(t) = x and t",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Suppose \u03a3 = {S, a, b}. Let u = S [ a[ ] $[ ] b[ ] ] and t = S [ a[ ] b[ ] ]. u\u00b7t = S [(a[ ]\u00b7t) ($[ ]\u00b7t) (b[ ]\u00b7t)] = S [ a[ ] S [ a[ ] b[ ] ] b[ ] ].",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "M wh maps the tree in (a) to the tree in (b) and likewise maps the tree in (c) to itself in (d).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "= S[a[ ]b[ ]] to t 1 = S[b[ ]a[ ]] and S[a[ ]t 1 b[ ]] to S[b[ ]t 1 a[ ]] and so on is ISL. The DFT can be represented as a tuple (Q, \u03a3, F, \u03b4) where the states are expressed by the 1-stems of the subtrees of the pre-image: Q = {a[ ], b[ ], S[ ]}, and F = {S[ ]}, and \u03a3 = {a, b, S}, and \u03b4 = {(\u03bb, a, a[ ], a[ ]), (\u03bb, b, b[ ], b[ ]), (a[ ]b[ ], S, S[x 2 , x 1 ], S[ ]), (a[ ]S[ ]b[ ], S, S[x 3 x 2 x 1 ], S[ ])}.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Base Case: For all a \u2208 \u03a3, if t = a[ ], then stem k (t) = a[ ].",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}