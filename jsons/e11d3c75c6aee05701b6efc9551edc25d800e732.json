{
    "paper_id": "e11d3c75c6aee05701b6efc9551edc25d800e732",
    "metadata": {
        "title": "Complexity Issues of String to Graph Approximate Matching",
        "authors": [
            {
                "first": "Riccardo",
                "middle": [],
                "last": "Dondi",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Bergamo",
                    "location": {
                        "settlement": "Bergamo",
                        "country": "Italy"
                    }
                },
                "email": "riccardo.dondi@unibg.it"
            },
            {
                "first": "Giancarlo",
                "middle": [],
                "last": "Mauri",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Milano-Bicocca",
                    "location": {
                        "settlement": "Milan",
                        "country": "Italy"
                    }
                },
                "email": "mauri@disco.unimib.it"
            },
            {
                "first": "Italo",
                "middle": [],
                "last": "Zoppis",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Milano-Bicocca",
                    "location": {
                        "settlement": "Milan",
                        "country": "Italy"
                    }
                },
                "email": "zoppis@disco.unimib.it"
            }
        ]
    },
    "abstract": [
        {
            "text": "The problem of matching a query string to a directed graph, whose vertices are labeled by strings, has application in different fields, from data mining to computational biology. Several variants of the problem have been considered, depending on the fact that the match is exact or approximate and, in this latter case, which edit operations are considered and where are allowed. In this paper we present results on the complexity of the approximate matching problem, where edit operations are symbol substitutions and are allowed only on the graph labels or both on the graph labels and the query string. We introduce a variant of the problem that asks whether there exists a path in a graph that represents a query string with any number of edit operations and we show that is NP-complete, even when labels have length one and in the case the alphabet is binary. Moreover, when it is parameterized by the length of the input string and graph labels have length one, we show that the problem is fixed-parameter tractable and it is unlikely to admit a polynomial kernel. The NP-completeness of this problem leads to the inapproximability (within any factor) of the approximate matching when edit operations are allowed only on the graph labels. Moreover, we show that the variants of approximate string matching to graph we consider are not fixed-parameter tractable, when the parameter is the number of edit operations, even for graphs that have distance one from a DAG. The reduction for this latter result allows us to prove the inapproximability of the variant where edit operations can be applied both on the query string and on graph labels.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Given a query string s and a directed graph G whose vertices are labeled with strings (referred as labeled graph), the matching and the approximate matching of s to G ask for a path (not necessarily simple) in G that represents s, that is by concatenating the labels of the vertices on the path we obtain s or an approximate occurrence of s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The matching and the approximate matching of a query string to a labeled graph have applications in different areas, from graph databases and data mining to genome research. The problems have been introduced in the context of pattern matching in hypertext [1, 3, 10, 15] , but have found recently new applications. Indeed in computational biology a representation of variants of related sequences is often provided by a labeled graph [11, 17] and the query of a string in a labeled graph has found application in computational pan-genomics [13, 18] .",
            "cite_spans": [
                {
                    "start": 256,
                    "end": 259,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 260,
                    "end": 262,
                    "text": "3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 263,
                    "end": 266,
                    "text": "10,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 267,
                    "end": 270,
                    "text": "15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 434,
                    "end": 438,
                    "text": "[11,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 439,
                    "end": 442,
                    "text": "17]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 540,
                    "end": 544,
                    "text": "[13,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 545,
                    "end": 548,
                    "text": "18]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The exact matching problem is known to be in P [1, 3, 15] . Furthermore, conditional lower bounds for this problem has been recently given in [7] .",
            "cite_spans": [
                {
                    "start": 47,
                    "end": 50,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 51,
                    "end": 53,
                    "text": "3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 54,
                    "end": 57,
                    "text": "15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 142,
                    "end": 145,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The approximate string to graph matching problem, referred to String to Graph Approximate Matching, has the goal of minimizing the number of edit operations (of the query string or of the labels of the graph) such that there exists a path p in G whose labels match the query string. String to Graph Restricted Approximate Matching denotes the variant where edit operations are allowed only on the graph labels. String to Graph Approximate Matching and String to Graph Restricted Approximate Matching are known to be NP-hard [12] , even for binary alphabet [9] . When the edit operations are allowed only on the query string, then String to Graph Approximate Matching is polynomial-time solvable [9] . Moreover, when the input graph is a Directed Acyclic Graph (DAG), String to Graph Approximate Matching and String to Graph Restricted Approximate Matching are polynomial-time solvable [10] .",
            "cite_spans": [
                {
                    "start": 524,
                    "end": 528,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 556,
                    "end": 559,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 695,
                    "end": 698,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 885,
                    "end": 889,
                    "text": "[10]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this contribution, we consider the String to Graph Approximate Matching problem and the String to Graph Restricted Approximate Matching problem, with the goal of deepening the understanding of their complexity. Notice that the edit operations we consider are symbol substitutions of the graph labels or of the query string. Other variants with different edit operations have been considered in literature [3, 9] .",
            "cite_spans": [
                {
                    "start": 408,
                    "end": 411,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 412,
                    "end": 414,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We introduce a variant of String to Graph Restricted Approximate Matching, called String to Graph Compatibility Matching, that asks whether it is possible to find an occurrence of a query string in a graph with any number of edit operations of the graph labels. This decision problem is helpful to characterize whether a feasible solution of String to Graph Restricted Approximate Matching exists or not. We show in Sect. 3 that String to Graph Compatibility Matching is NP-complete, even when the labels of the graph have length one or when the alphabet is binary. The reduction shows also that String to Graph Compatibility Matching when parameterized by the length of the query string is unlikely to have a polynomial kernel 1 (for details on kernelization we refer to [6, 14] ). A consequence of the intractability of String to Graph Compatibility Matching is that String to Graph Restricted Approximate Matching cannot be approximated 1 A problem parameterized by parameter t admits a polynomial kernel if there exists a polynomial-time algorithm that reduces the instance of the problem so that it has a size which is a polynomial in t.",
            "cite_spans": [
                {
                    "start": 772,
                    "end": 775,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 776,
                    "end": 779,
                    "text": "14]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "within any factor in polynomial time. Notice that if we allow edit operations of the query string, then the existence of a path that represents an approximate matching of the query string can be decided in polynomial time. Indeed, it is enough to check whether the input graph contains a (non necessarily simple) path p in G that represents a string of length |s|. We consider in Sect. 4 the parameterized complexity of String to Graph Restricted Approximate Matching and of String to Graph Approximate Matching and we show that they are W[2]-hard when parameterized by the number of edit operations, even for a labeled graph having distance one from a DAG. This result shows that, while String to Graph Restricted Approximate Matching and String to Graph Approximate Matching are solvable in polynomial time when the labeled graph is a DAG [10] , even for graphs that are very close to DAG they become hard. The reduction designed to prove this latter result allows us to show that String to Graph Approximate Matching is not approximable within factor \u03a9(log(|V |)) and \u03a9(log(|s|)), for a labeled graph G = (V, E) and a query string s.",
            "cite_spans": [
                {
                    "start": 841,
                    "end": 845,
                    "text": "[10]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In Sect. 5, we provide a fixed-parameter tractable algorithm for String to Graph Compatibility Matching, when parameterized by size of the query string and when the graph labels have length one. We conclude the paper in Sect. 6 with some open problems, while in Sect. 2 we introduce some definitions and the problems we are interested in. Some of the proofs are not included due to page limit.",
            "cite_spans": [
                {
                    "start": 226,
                    "end": 227,
                    "text": "6",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Given an alphabet \u03a3 and a string s over \u03a3, we denote by |s| the length of s, by s[i], with 1 \u2264 i \u2264 |s|, the i-th symbol of s and by s[i, j], with 1 \u2264 i \u2264 j \u2264 |s|, the substring of s that starts at position i and ends at position j.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "Every graph we consider in this paper is directed. Given a graph G = (V, E) and a vertex v \u2208 V , we define N",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "A labeled graph G = (V, E, \u03c3) is a graph whose vertices are labeled with strings, formally assigned by a labeled function \u03c3 : V \u2192 \u03a3 * , where \u03a3 is an alphabet of symbols. Notice that \u03c3(v), with v \u2208 V , denotes the string associated by \u03c3 to vertex v. Let p = v 1 v 2 . . . v z be a path (non necessarily simple) in G, the set of vertices that induces p is denoted by V (p) and the string associated with p is defined as \u03c3(p) = \u03c3(v 1 )\u03c3(v 2 ) . . . \u03c3(v z ), that is \u03c3(p) is obtained by concatenating the strings that label the vertices of path p.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "Consider a string s on alphabet \u03a3 and a labeled graph G = (V, E, \u03c3). We say that a path p in G is an occurrence of s if \u03c3(p) = s; in this case we call \u03c3(p) an exact matching of s and we say that p matches s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "An edit operation of a string s is a substitution of the symbol in a position i, with 1 \u2264 i \u2264 |s|, of s with a different symbol in \u03a3. An edit operation of G = (V, E, \u03c3) is an edit operation of a string \u03c3(v), with v \u2208 V . A path p in G is an approximate matching of s if, after k 1 \u2265 0 edit operations of labels of G, \u03c3(p) = s , where s is a string obtained with k 2 \u2265 0 edit operations of s. In this case, we say that the approximate matching requires k = k 1 +k 2 edit operations. We say that p in G is a restricted approximate matching of s, if, after after k \u2265 0 edit operations to labels of G, s = \u03c3(p) (that is the edit operations are allowed only on the labels of G).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "Consider a path p that matches (exactly, approximately or restricted approximately) the query string s. If position i, 1 \u2264 i \u2264 |s|, in s and the j-th position, 1 \u2264 j \u2264 |\u03c3(u)|, of the label of vertex u in p match (possibly after an edit operation), we say that position i is mapped in \u03c3(u) [j] ; if |\u03c3(u)| = 1, by slightly abusing the notation, we say that position i is mapped in u.",
            "cite_spans": [
                {
                    "start": 289,
                    "end": 292,
                    "text": "[j]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "Next, we define the first combinatorial problem we are interested in. Consider a labeled graph G = (V, E, \u03c3) and a query string s over \u03a3. If there exists a path p in G which is a restricted approximate matching of s, we say that p is compatible with s. Notice that the definition of compatibility does not put any bound on the number of edit operations of graph labels and that no edit operation is allowed on the query string. In this paper, we introduce a decision problem, called String to Graph Compatibility Matching, related to String to Graph Restricted Approximate Matching, that asks whether there exists a path in G = (V, E, \u03c3) compatible with s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definitions"
        },
        {
            "text": "Input: A labeled graph G = (V, E, \u03c3), a query string s, both on alphabet \u03a3. Output: Does there exist a path in G that is compatible with s?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem 3. String to Graph Compatibility Matching"
        },
        {
            "text": "In this section we consider the computational complexity of String to Graph Compatibility Matching and we prove that the problem is indeed NP-complete and it is unlikely to admit a polynomial kernel. This result, as discussed in Theorem 3, is not only interesting to characterize the complexity of String to Graph Compatibility Matching, but also to give insights into the approximation complexity of String to Graph Restricted Approximate Matching.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of String to Graph Compatibility Matching"
        },
        {
            "text": "We start by proving that String to Graph Compatibility Matching is NPcomplete when the labels of the graph have length one, via a reduction from the h-Path problem. The reduction is inspired by that in [3] to prove the NPhardness of String to Graph Restricted Approximate Matching. Then we modify the reduction so that it holds also for binary alphabet. We recall the definition of h-Path, which is known to be NP-complete [8] .",
            "cite_spans": [
                {
                    "start": 202,
                    "end": 205,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 423,
                    "end": 426,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Hardness of String to Graph Compatibility Matching"
        },
        {
            "text": "Output: Does there exist a simple path in G L of length h?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of String to Graph Compatibility Matching"
        },
        {
            "text": "which is an instance of h-Path, we define an instance of String to Graph Compatibility Matching consisting of a labeled graph G = (V, E, \u03c3) and a query string s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "First, define the alphabet \u03a3 as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "The labeled graph G = (V, E, \u03c3) is defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "The labelling function \u03c3 : V \u2192 \u03a3 * of the graph vertices is defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "Finally, we define the query string s = y 1 y 2 . . . y h .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "The following lemma allows us to prove the hardness of String to Graph Compatibility Matching. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "Notice that p must be a simple path, since s consists of h distinct symbols. As a consequence,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "Lemma 1 and the NP-completeness of h-Path [8] allow to prove the following result.",
            "cite_spans": [
                {
                    "start": 42,
                    "end": 45,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "Theorem 1. String to Graph Compatibility Matching is NP-complete even when the labels of the graph have length one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "Notice that the reduction we have described is also a Polynomial Parameter Transformation [5] from h-Path parameterized by h to String to Graph Compatibility Matching parameterized by |s|, as |s| = h. Since h-Path when parameterized by h does not admit a polynomial kernel unless NP \u2286 coN P/P oly [4] , the reduction leads to the following result. Corollary 1. The String to Graph Compatibility Matching problem parameterized by |s| does not admit a polynomial kernel unless NP \u2286 coN P/P oly even when the labels of the graph have length one.",
            "cite_spans": [
                {
                    "start": 90,
                    "end": 93,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 297,
                    "end": 300,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Graph Labels of Length One"
        },
        {
            "text": "Next, we show that the String to Graph Compatibility Matching problem is NPcomplete even on binary alphabet. The reduction is similar to the reduction of the Sect. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "it is a string consisting of h occurrences of symbol 0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "The construction of the query string s requires the introduction of strings s i , with 1 \u2264 i \u2264 h, having length h and defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "Finally, s is defined as the concatenation of s 1 , s 2 , . . . s n , that is s = s 1 s 2 . . . s n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "Next, we prove the correctness of the reduction. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "such that is associated with string s j . Then the resulting string is an exact match of s,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "Since \u03c3(p) must match s after some symbol substitutions and, by construction, |\u03c3(v j )| = |s l |, for each 1 \u2264 j \u2264 n and 1 \u2264 l \u2264 h, it follows that the positions of s l , 1 \u2264 l \u2264 h, are mapped to the positions of \u03c3(v it ), for some t with 1 \u2264 t \u2264 h. Moreover, since s l = s q , with t = q, all the vertices in p are distinct and p is a simple path in G of length h. As a consequence the corresponding path v l i1 v l i2 . . . v l i h in G L is a simple path of length h, thus concluding the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "Thus, based on Lemma 2, we can prove the following result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Binary Alphabet"
        },
        {
            "text": "The results of Theorems 1 and 2 have a consequence not only on the complexity of String to Graph Compatibility Matching, but also on the approximation of String to Graph Restricted Approximate Matching. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2. String to Graph Compatibility Matching is NP-complete even on binary alphabet."
        },
        {
            "text": "In this section, we consider the parameterized complexity of String to Graph Restricted Approximate Matching and String to Graph Approximate Matching. The reduction we present allows us to prove that String to Graph Restricted Approximate Matching and String to Graph Approximate Matching, when parameterized by the number of edit operations, are W[2]-hard for a labeled graph having distance one from a DAG. Moreover, the same reduction will allow us to prove that String to Graph Approximate Matching is not approximable within factor \u03a9(log(|V |)) and \u03a9(log(|s|)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "We prove these results by presenting a reduction, that is parameterized [6, 14] and approximate preserving [19] , from the Minimum Set Cover problem. We recall here the definition of Minimum Set Cover. Output: A subcollection C of C of minimum cardinality such that for each u i \u2208 U , with 1 \u2264 i \u2264 n, there exists a set in C containing u i . First, we focus on String to Graph Restricted Approximate Matching, then we show that the same reduction can be applied to String to Graph Approximate Matching.",
            "cite_spans": [
                {
                    "start": 72,
                    "end": 75,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 76,
                    "end": 79,
                    "text": "14]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 107,
                    "end": 111,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Given an instance (U, C) of Minimum Set Cover, in the following we define an instance (G = (V, E, \u03c3) , s) of String to Graph Restricted Approximate Matching (see Fig. 1 for an example). We start by defining the alphabet \u03a3:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 91,
                    "end": 100,
                    "text": "(V, E, \u03c3)",
                    "ref_id": null
                },
                {
                    "start": 162,
                    "end": 168,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Then, we define the labeled graph G = (V, E, \u03c3):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Now, we define the labeling \u03c3 of the vertices of G:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "The query string s is defined as follows: s = x 0 z y 1 x 0 z y 2 . . . x 0 z y n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "x 0",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "x 1 x 2 y 4 y 1 y 3 y 2 y 3",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "s = x 0 z y 1 x 0 z y 2 x 0 z y 3 x 0 z y 4 Fig. 1 . A labeled graph G and a query string s associated with the following instance of Minimum Set Cover: U = {u1, u2, u3, u4}; S1 = {u1, u3, u4}, S2 = {u2, u3}, S3 = {u2, u4}. Inside each vertex we represent its label.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 44,
                    "end": 50,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "First, we prove that the labeled graph G, has distance one from a DAG, that is by removing a vertex of G (namely, v 0 ), we obtain a DAG. Next, we present the main result to prove the correctness of the reduction. Proof. We present only one direction of the proof. Consider a path p in G such that p is a restricted approximate matching of s requiring at most h edit operations of the labels of vertices in p. First, we prove some properties of G. If v 0 is removed from G, then the resulting graph G contains paths consisting of at most 2 vertices. Since |s| = 3n, there is no path in G that can be a restricted approximate matching of s. This implies that at least one position of s is mapped in v 0 . Now, assume that the first vertex of p is not v 0 . Assume that the first position of s is mapped in v i , for some i with 1 \u2264 i \u2264 m. By construction,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Then each occurrence of a symbol y q , 1 \u2264 q \u2264 n, in s is mapped in v 0 , while the symbol associated with v 0 can be at most one of y 1 , . . . , y n , thus there is no path in G that starts with a vertex v i and that is a restricted approximate matching of s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Assume that the first vertex of p is some vertex v i,j , with 1 \u2264 i \u2264 m and 1 \u2264 j \u2264 |S i |. By construction, p = v i,j v 0 v l v l,t v 0 . . . . Hence each position of s containing z is mapped in vertex v 0 , while each position of s containing y t , 1 \u2264 t \u2264 n, is mapped in a vertex v q , with 1 \u2264 q \u2264 m. This last mapping requires n > h edit operations of labels of vertices of G, violating the hypothesis that at most h < n edit operations are applied.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "We can conclude that if p is a restricted approximate matching of s requiring h < n edit operations, then v 0 must be the first vertex of p. It follows that each label of a vertex v i , 1 \u2264 i \u2264 n, in path p must be edited to z. Consider the case that position t of s, 1 \u2264 t \u2264 |s|, where s[t] = y q , 1 \u2264 q \u2264 n, is mapped to some vertex v i,j , with 1 \u2264 i \u2264 m and 1 \u2264 j \u2264 |S i |, such that \u03c3(v i,j ) = y q , and that hence the label of v i,j is edited to y q . Let v a , with 1 \u2264 a \u2264 m, be the vertex that precedes v i,j in p. Then, we can modify p, so that the number of edit operations are not increased, by replacing v a with a vertex v b , with 1 \u2264 b \u2264 m, and v i,j with v b,l , with 1 \u2264 l \u2264 |S b |, so that \u03c3(v b,l ) = y q , and by editing the label of v b (if it is no already edited) to z. This implies that the only vertices of p whose labels are edited are vertices v i , 1 \u2264 i \u2264 m. Now, we can define a solution C of Minimum Set Cover consisting of h sets as follows: C = {S i : the label of vertex v i in p is edited to z, 1 \u2264 i \u2264 m}. Since at most h labels of vertices of p are edited (to z), it follows that at most h sets belong to C . Furthermore, since each vertex with label y j , 1 \u2264 j \u2264 n, is connected to a vertex v i in p, 1 \u2264 i \u2264 m, by construction it follows that each element of U belongs to some set in C .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Based on Lemma 3 and on Lemma 4, we can prove the following result. Next, we show that the same reduction allows us to prove the W[2]-hardness and the inapproximability of String to Graph Approximate Matching. Essentially, we will prove that we can avoid edit operations of the query string.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "Theorem 5. The String to Graph Approximate Matching problem is W [2] -hard when parameterized by the number of edit operations, even when the input graph has distance one from a DAG. Moreover, String to Graph Approximate Matching cannot be approximated within factor \u03a9(log(|V |)) and \u03a9(log(|s|)), unless P = NP , even when the input graph has distance one from a DAG.",
            "cite_spans": [
                {
                    "start": 65,
                    "end": 68,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Hardness of Parameterization"
        },
        {
            "text": "We present a fixed-parameter algorithm for String to Graph Compatibility Matching when parameterized by |s|. We consider the case where each vertex of G is labeled with exactly one symbol (notice that in this case, by Theorem 1, String to Graph Compatibility Matching is NP-complete and, by Corollary 1, String to Graph Compatibility Matching parameterized by |s| does not admit a polynomial kernel unless NP \u2286 coN P/P oly).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "String to Graph Compatibility Matching Parameterized by |s|"
        },
        {
            "text": "We start by proving an easy property of an instance of String to Graph Compatibility Matching.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "String to Graph Compatibility Matching Parameterized by |s|"
        },
        {
            "text": "The fixed-parameter algorithm is based on the color-coding technique [2] and on dynamic programming. Consider a path p in G that is compatible with s and the set V (p) of vertices that induces p, where |V (p)| = k. It holds k \u2264 |s|, since each position of s is mapped in at least one vertex of p.",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 72,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 5. |\u03a3| \u2264 |s|."
        },
        {
            "text": "We consider a coloring of V with a set of colors {c 1 , . . . , c k }, where, given a vertex v \u2208 V , we denote by c(v) the color assigned to v. Based on color-coding (see Definition 1), we assume that the coloring is colorful, that is each vertex of V (p) is assigned a distinct color in {c 1 , . . . , c k }. Now, each color c i , with 1 \u2264 i \u2264 k, is associated by a function r: {c 1 , . . . , c k } \u2192 \u03a3, with a symbol in \u03a3, that represents the fact that the vertices of p that are colored by c i , with 1 \u2264 i \u2264 k, must match a position of s containing symbol r(c i ). In this case we say that p satisfies r. The algorithm iterates over the possible colorings of graph G based on a family of perfect hash functions and over the possible functions r. Now, given a coloring of G and a function r, define a function M r [i, v], with 1 \u2264 i \u2264 |s| and v \u2208 V , as follows. M r [i, v] is equal to 1 if there exists a path p of G that is compatible with s [1, i] and such that (1) position i of s is mapped in v, and (2) p satisfies r; else M r [i, v] = 0. Notice that, since s [1, i] is mapped in v, it follows that v is the last vertex of p. Next, we describe the recurrence to compute M r [i, v] . In order to compute a colorful coloring of G, we consider a perfect family of hash functions for the set of vertices of G. ",
            "cite_spans": [
                {
                    "start": 947,
                    "end": 953,
                    "text": "[1, i]",
                    "ref_id": null
                },
                {
                    "start": 1069,
                    "end": 1075,
                    "text": "[1, i]",
                    "ref_id": null
                },
                {
                    "start": 1183,
                    "end": 1189,
                    "text": "[i, v]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Lemma 5. |\u03a3| \u2264 |s|."
        },
        {
            "text": "In this contribution we have presented results on the tractability of the approximate matching of a query string to a labeled graph. There are several open questions related to variants of this problem. It will be interesting to further investigate the approximability of String to Graph Approximate Matching, since it can be trivially approximated within factor |s| in polynomial time, while it cannot be approximated within factor \u03a9(log(|s|)), unless P = NP. Another interesting open question is to investigate the parameterized complexity of String to Graph Approximate Matching when the edit operations are not restricted to symbol substitutions, but include symbol insertions and deletions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "A linear time pattern matching algorithm between a string and a tree",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Akutsu",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "4th Annual Symposium on Combinatorial Pattern Matching, CPM 93",
            "volume": "",
            "issn": "",
            "pages": "1--10",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Color-coding",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Alon",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Yuster",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Zwick",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "J. ACM",
            "volume": "42",
            "issn": "4",
            "pages": "844--856",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Pattern matching in hypertext",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Amir",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lewenstein",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lewenstein",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "J. Algorithms",
            "volume": "35",
            "issn": "1",
            "pages": "82--99",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "On problems without polynomial kernels",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "L"
                    ],
                    "last": "Bodlaender",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "G"
                    ],
                    "last": "Downey",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "R"
                    ],
                    "last": "Fellows",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hermelin",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "J. Comput. Syst. Sci",
            "volume": "75",
            "issn": "8",
            "pages": "423--434",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Kernel bounds for path and cycle problems",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "L"
                    ],
                    "last": "Bodlaender",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "M P"
                    ],
                    "last": "Jansen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kratsch",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theor. Comput. Sci",
            "volume": "511",
            "issn": "",
            "pages": "117--136",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Fundamentals of Parameterized Complexity",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "G"
                    ],
                    "last": "Downey",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "R"
                    ],
                    "last": "Fellows",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-4471-5559-1"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "On the complexity of string matching for graphs",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Equi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Grossi",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "M\u00e4kinen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "I"
                    ],
                    "last": "Tomescu",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "46th International Colloquium on Automata, Languages, and Programming",
            "volume": "132",
            "issn": "",
            "pages": "1--55",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Computers and Intractability: A Guide to the Theory of NP-Completeness",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "R"
                    ],
                    "last": "Garey",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "S"
                    ],
                    "last": "Johnson",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "On the complexity of sequence to graph alignment",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Jain",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Gao",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Aluru",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "RECOMB 2019",
            "volume": "11467",
            "issn": "",
            "pages": "85--100",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Approximate string matching with arbitrary cost for text and hypertext",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Manber",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Advances in Structural and Syntactic Pattern Recognition",
            "volume": "",
            "issn": "",
            "pages": "22--33",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The fragment assembly string graph",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "W"
                    ],
                    "last": "Myers",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Bioinformatics",
            "volume": "21",
            "issn": "2",
            "pages": "79--85",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Improved approximate pattern matching on hypertext",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Navarro",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Theor. Comput. Sci",
            "volume": "237",
            "issn": "1-2",
            "pages": "455--463",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Building a pan-genome reference for a population",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Nguyen",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "J. Comput. Biol",
            "volume": "22",
            "issn": "5",
            "pages": "387--401",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Invitation to Fixed-Parameter Algorithms",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Niedermeier",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "String matching in hypertext",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "K"
                    ],
                    "last": "Kim",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "CPM 1995",
            "volume": "937",
            "issn": "",
            "pages": "318--329",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-60044-2_51"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Non deterministic polynomial optimization problems and their approximations",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Paz",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Moran",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Theor. Comput. Sci",
            "volume": "15",
            "issn": "",
            "pages": "251--277",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "An Eulerian path approach to DNA fragment assembly",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Pevzner",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "S"
                    ],
                    "last": "Waterman",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Proc. Nat. Acad. Sci",
            "volume": "98",
            "issn": "17",
            "pages": "9748--97533",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "The Computational Pan-Genomics Consortium: Computational pan-genomics: status, promises and challenges",
            "authors": [],
            "year": 2018,
            "venue": "Brief. Bioinform",
            "volume": "19",
            "issn": "1",
            "pages": "118--135",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "The Design of Approximation Algorithms",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "P"
                    ],
                    "last": "Williamson",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "B"
                    ],
                    "last": "Shmoys",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "String to Graph Approximate Matching Input: A labeled graph G = (V, E, \u03c3) and a query string s, both on alphabet \u03a3. Output: An approximate matching p of s that requires the minimum number of edit operations. We define now the variant of the problem, called String to Graph Restricted Approximate Matching, where edit operations are allowed only on the labels of the labeled graph. Problem 2. String to Graph Restricted Approximate Matching Input: A labeled graph G = (V, E, \u03c3) and a query string s, both on alphabet \u03a3. Output: A restricted approximate matching p of s that requires the minimum number of edit operations.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Let G L = (V L , E L ) be a graph instance of h-Path and let (G = (V, E, \u03c3), s) be the corresponding instance of String to Graph Compatibility Matching. There exists a simple path of length h in G L if and only if there exists a path in G compatible with s.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "3.1, except for the definition of the query string s and the labeling \u03c3 : V \u2192 \u03a3 * of the labeled graph. Consider a graph G L = (V L , E L ), with V L = {v l 1 , . . . , v l n }, that is an instance of h-Path, we define a corresponding instance (G = (V, E, \u03c3), s) of String to Graph Compatibility Matching. The alphabet is binary, hence \u03a3 = {0, 1}. Next, we define the labeled graph G = (V, E, \u03c3). The sets V of vertices and E of edges are defined as in Sect. 3.1. For each",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Let G L = (V L , E L ) be a graph instance of h-Path and let (G = (V, E, \u03c3), s) be the corresponding instance of String to Graph Compatibility Matching on binary alphabet. There exists a simple path of length h in G L if and only if there exists a path compatible with s in G.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "The String to Graph Restricted Approximate Matching problem cannot be approximated within any factor in polynomial time, unless P = NP, even when the labels of the graph have length one or when the alphabet is binary.Proof. The NP-completeness of String to Graph Compatibility Matching implies that, given an instance (G = (V, E, \u03c3), s), even deciding whether there exists a feasible solution of String to Graph Restricted Approximate Matching, with any number of edit operations in G, is NP-complete. Hence if there exists a polynomial-time approximation algorithm A for String to Graph Restricted Approximate Matching, with some approximation factor \u03b1, it follows that A can be used to decide the String to Graph Compatibility Matching problem: if A returns an approximated solution for String to Graph Restricted Approximate Matching with input (G, s), then it follows that there exists a path in G compatible with s, if A does not return an approximated solution for String to Graph Restricted Approximate Matching with input (G, s), then there is no path in G compatible with s. Since String to Graph Compatibility Matching is NP-complete, when the labels of the graph have length one (by Theorem 1) and on binary alphabet (by Theorem 2), then there does not exist a polynomial-time approximation algorithm with any approximation factor for String to Graph Restricted Approximate Matching when the graph labels have length one or when the alphabet is binary, unless P = NP.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Minimum Set Cover Input: A collection C = {S 1 , . . . , S m } of sets over a universe U = {u 1 , . . . , u n }.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Let (C, U ) be an instance of Minimum Set Cover and let (G = (V, E, \u03c3), s) be the corresponding instance of String to Graph Restricted Approximate Matching. Then, G has distance one from a DAG.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Let (C, U ) be an instance of Minimum Set Cover and let (G = (V, E, \u03c3), s) be the corresponding instance of String to Graph Restricted Approximate Matching. There exists a cover C of U of cardinality h < n if and only if there exists a solution of String to Graph Restricted Approximate Matching that requires h edit operations.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "For i \u2265 2, if r(c(v)) = s[i], then M r [i, v] = 0; if r(c(v)) = s[i], then: M r [i, v] = u\u2208V :(u,v)\u2208E M r [i \u2212 1, u]In the base case, it holds M r[1, v]  = 1 if and only if r(c(v)) = s[1], else M r [1, v] = 0. Next, we prove the correctness of the recurrence.Lemma 6. M r [i, v] is equal to 1 if and only if there exists a path p of G that is compatible with s[1, i] and such that (1) position i of s is mapped in v, and (2) p satisfies r.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Let G = (V, E, \u03c3) be a labeled graph and let C = {c 1 , . . . , c k } be a set of colors. A family F of hash functions fromV to C is called perfect if for each subset V \u2286 V , with |V | = k, there exists a function f \u2208 F such that for each x, y \u2208 V , with x = y, f (x) = c i , f (y) = c j , with 1 \u2264 i, j \u2264 k and i = j.It has been shown in[2] that a perfect family F of hash functions from V to C, having size 2 O(k) O(log |V |), can be computed in time 2 O(k) O(|V | log |V |). From Lemma 6 and by using a perfect family of hash functions to color the vertices in G, we can prove the main result of this section. Theorem 6. The String to Graph Compatibility Matching problem can be decided in time 2 O(|s|) O(|s| |s|+1 |V | 2 log |V |).",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "The String to Graph Restricted Approximate Matching problem is W[2]-hard when parameterized by the number of edit operations, even when the input graph has distance one from a DAG. Proof. Notice that, by Lemma 3, G has distance one from a DAG. The W[2]hardness of String to Graph Approximate Matching follows from Lemma 4 and from the W[2]-hardness of Minimum Set Cover [16].",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}