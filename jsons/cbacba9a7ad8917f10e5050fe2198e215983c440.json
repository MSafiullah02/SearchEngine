{
    "paper_id": "cbacba9a7ad8917f10e5050fe2198e215983c440",
    "metadata": {
        "title": "Reconstructing k-Reticulated Phylogenetic Network from a Set of Gene Trees",
        "authors": [
            {
                "first": "Hoa",
                "middle": [],
                "last": "Vu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Hong",
                    "location": {
                        "settlement": "Kong"
                    }
                },
                "email": ""
            },
            {
                "first": "Francis",
                "middle": [],
                "last": "Chin",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Hong",
                    "location": {
                        "settlement": "Kong"
                    }
                },
                "email": ""
            },
            {
                "first": "W",
                "middle": [
                    "K"
                ],
                "last": "Hon",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Tsinghua University",
                    "location": {
                        "country": "Taiwan"
                    }
                },
                "email": ""
            },
            {
                "first": "Henry",
                "middle": [],
                "last": "Leung",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Hong",
                    "location": {
                        "settlement": "Kong"
                    }
                },
                "email": ""
            },
            {
                "first": "K",
                "middle": [],
                "last": "Sadakane",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Institute of Informatics",
                    "location": {
                        "country": "Japan"
                    }
                },
                "email": ""
            },
            {
                "first": "Ken",
                "middle": [
                    "W K"
                ],
                "last": "Sung",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National University of Singapore",
                    "location": {
                        "country": "Singapore"
                    }
                },
                "email": ""
            },
            {
                "first": "Siu-Ming",
                "middle": [],
                "last": "Yiu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Hong",
                    "location": {
                        "settlement": "Kong"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "The time complexity of existing algorithms for reconstructing a level-x phylogenetic network increases exponentially in x. In this paper, we propose a new classification of phylogenetic networks called k-reticulated network. A k-reticulated network can model all level-k networks and some level-x networks with x > k. We design algorithms for reconstructing kreticulated network (k = 1 or 2) with minimum number of hybrid nodes from a set of m binary trees, each with n leaves in O(mn 2 ) time. The implication is that some level-x networks with x > k can now be reconstructed in a faster way. We implemented our algorithm (ARTNET) and compared it with CMPT. We show that ARTNET outperforms CMPT in terms of running time and accuracy. We also consider the case when there does not exist a 2-reticulated network for the input trees. We present an algorithm computing a maximum subset of the species set so that a new set of subtrees can be combined into a 2-reticulated network.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The study of evolutionary history of a species plays a crucial role in biomedical research. For example, understanding the evolutionary history of a virus (e.g. SARS) may help us deduce the natural reservoirs of the virus, thus identifying the source of the virus. The details of how the virus evolves may help to uncover clues to treat or vaccinate the virus and understand how it evolves resistance to existing drugs. A traditional representation of evolutionary history is phylogenetic tree (a rooted, unordered tree with distinctly labeled leaves, each represents a species or a strain of the species). To construct a phylogenetic tree, a common practice is to select a group of genes, which are believed to be critical for evolution, to represent the species. However, selecting a different set of genes may end up with a different phylogenetic tree (called a gene tree). To deal with this issue, researchers may try to extract the subtrees which are common in all trees (known as the maximum agreement subtree problems, see [1] [2] [3] for examples) and ignore the other non-common parts. This may result in a small tree. Also, information not in the common subtree will be lost. It is now well-known that the differences in the gene trees are not due to errors. There exist evolutionary events (known reticulation events), such as hybridization, horizontal gene transfer, and recombination, that may cause the genes to evolve differently and a phylogenetic tree is not powerful enough to model the resulting evolutionary history [4] . To model the evolutionary history better, phylogenetic network is proposed. Phylogenetic network is a generalization of phylogenetic tree (note that in this paper, we focus on rooted bifurcating (each node has at most 2 descends) phylogenetic tree/network). Phylogenetic network is defined as a rooted, directed acyclic graph in which (1) exactly one node has indegree 0 (the root), and all other nodes have indegree 1 or 2; (2) all nodes with indegree 2 (hybrid nodes or reticulation nodes) have outdegree 1, and all other nodes have outdegree 0 or 2; and (3) all nodes with outdegree 0 (leaves) are distinctly labeled. For a hybrid node h in a phylogenetic network, every ancestor s of h such that h can be reached using two disjoint directed paths starting from the children of s is called a split node of h (and h is called a hybrid node of s). The edges attached to a hybrid node is called hybrid edges. Figure 1 shows an example. Typically, a split node is used to represent a speciation event (two different species are evolved) while a hybrid node is used to represent the reticulation event between the two descendants of the split node. We say that a phylogenetic network N is compatible with (induces or displays) a set of gene trees if each tree can be obtained from N by deleting one of the hybrid edges of each hybrid node and contracting all nodes with outdegree and indegree equal 1 (see Figure 3 for an example). If there is no restriction, for any given set of trees, we can always have a phylogenetic network that induces the trees. However, reticulation events are hard to occur, so a more biological meaningful question is to ask for such a phylogenetic network with the minimum number of hybrid nodes. A common classification of phylogenetic network is the level-x network [11 -12] . A level-x network is one in which each biconnected component (also known as blob [5] ) of the network contains at most x hybrid nodes. A level-0 network is a phylogenetic tree, a level-1 network is also known as a galled tree [5] or a galled network [6] . There are algorithms that reconstruct a level-x network, however, the time complexity increases exponentially in x even if we only consider some restricted cases. Thus, in practice, if x > 2, the algorithm is not fast enough. On the other hand, the evolutionary history of quite many viruses can only be modeled by high level networks (with x > 2). For example, to capture all known reticulation events of HIV [7] , we need to use a level-4 network ( Figure 2 shows the network).",
            "cite_spans": [
                {
                    "start": 1030,
                    "end": 1033,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1034,
                    "end": 1037,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1038,
                    "end": 1041,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1536,
                    "end": 1539,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 3337,
                    "end": 3345,
                    "text": "[11 -12]",
                    "ref_id": null
                },
                {
                    "start": 3429,
                    "end": 3432,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 3574,
                    "end": 3577,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 3598,
                    "end": 3601,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 4014,
                    "end": 4017,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 2451,
                    "end": 2459,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2946,
                    "end": 2954,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 4055,
                    "end": 4063,
                    "text": "Figure 2",
                    "ref_id": "FIGREF9"
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we propose to consider a new classification of networks by restricting the maximum number of hybrid nodes each split node may have, namely a kreticulated network is one in which each split node can correspond to at most k hybrid nodes. This new classification is also supported by evidence in real life cases. Several studies of recombination in bacteria have shown that recombination rates decrease as sequence divergence increases [8] [9] . These studies imply that the number of recombination events of a split node will be limited as the descendants from the same split node will diverge more as the number of generations increases. This observation is also supported by a computer simulation study [10] . Therefore, networks with limited reticulation events for each split node while no limit on the total number of reticulation events in each blob seem to be more biologically relevant and can model the recombination events in nature more appropriately.",
            "cite_spans": [
                {
                    "start": 448,
                    "end": 451,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 452,
                    "end": 455,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 718,
                    "end": 722,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our Contributions. This new classification of phylogenetic networks is more powerful than level-x networks. By definition, every level-x network is also an xreticulated network. And some level-x network can be modeled by a k-reticulated network with k < x (see Figure 2 for an example of a level-4 network which is also a 2-reticulated network). So, even solving the problem for k-reticulated network with k as small as 2, some of the meaningful high level networks can be constructed efficiently. We show that given a set of binary gene trees, one can reconstruct an 1reticulated or 2-reticulated network (if one exists) with minimum number of hybrid nodes compatible with all trees in O(mn 2 ) time where m is the number of trees and n is the number of leaves. We also consider the problem that when a compatible 2reticulated network does not exist, compute a subset of species with maximum size so that a 2-reticulated network exists. This problem is believed to be NP-hard and we provide an O(2 mm n 3m ) algorithm to solve it. We implement the 2-reticulated network reconstruction algorithm (ARTNET) and compare it with the program CMPT [13] that reports a phylogenetic network with the smallest number of hybrid nodes. We only consider the case when a 2-reticulated network exists for the input set of trees. The experiments show that ARTNET is more efficient than CMPT. When the number of hybrid nodes increases, the running time of ARTNET only increases slightly while that of CMPT increases rapidly. Regarding accuracy evaluation, ARTNET also outperforms CMPT.",
            "cite_spans": [
                {
                    "start": 1142,
                    "end": 1146,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [
                {
                    "start": 261,
                    "end": 269,
                    "text": "Figure 2",
                    "ref_id": "FIGREF9"
                }
            ],
            "section": "Introduction"
        },
        {
            "text": "Related Work. Several methods of constructing phylogenetic networks have been proposed. Nakhleh et al. [6] have developed an algorithm for constructing a level-1 phylogenetic network from two phylogenetic trees running in polynomial time.",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 106,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "However, Nakhleh et al.'s algorithm can handle two trees only. Huynh et al. [12] have succeeded in providing a O(|T| 2 n 2 ) algorithm reconstructing a galled network from a set T of multiple phylogenetic trees of arbitrary degree. Huson and Klopper [14] gave an O(n k ) algorithm constructing restricted level-k network from a set of trees. A rooted phylogenetic tree can be uniquely represented by the set of triplets obtained by taking all combinations of three leaves in the tree [12] . It takes O(n 3 ) running time to construct a galled network in the algorithm designed by Jansson, Nguyen and Sung [15] . Extending to level-2 network, Van Iersel et al. [11] developed an O(n 8 ) time algorithm. Habib and To [16] have solved the general problem of constructing level-k network from a dense triplet set T in exponential running-time | | . Gambette et al. [17] have shown that we can decide in optimal O(n 4 ) time whether there exists a simple unrooted level-1 network for a set of all quartets.",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 80,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 250,
                    "end": 254,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 484,
                    "end": 488,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 605,
                    "end": 609,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 660,
                    "end": 664,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 715,
                    "end": 719,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 861,
                    "end": 865,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "= the subtree of T rooted at u, and L(T) = the leaf label set of T. If u is a node in network N, a subnetwork N[u] is obtained from N by only retaining all nodes and their incident edges which are reachable from u, and L(N) is the set of leaf labels of N. Given a subtree t of T, T\\t is a subtree obtained by removing t from T. Similarly, with a subnetwork N' of N, N\\N' is a network obtained by removing N' from N. Given a tree T with the leaf set L, and . T|L' denotes a subtree obtained by first deleting all nodes which are not on any directed path from the root to a leaf in L' along with their incident edges, and then, for every node with outdegree 1 and indegree less than 2, contracting its outgoing edge.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Notations. Let u is a node in a tree T, T[u]"
        },
        {
            "text": "Denote P(N, T i , L) the procedure to reconstruct a k-reticulated network N compatible with T 1 , T 2 , \u2026, T m , where k = 1 or 2. We employ the divide-and-conquer technique.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithms for Reconstructing k-Reticulated Network (k = 1, 2)"
        },
        {
            "text": "Base Case: if each input tree is a single node with the same label, return a network which is that single node of the same label; otherwise consider the following cases: If h i \u2260 r i1 and h i \u2260 r i2 for i = 1\u2026m, the problem can be divided into 3 subproblems:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reconstructing 1-Reticulated Network"
        },
        {
            "text": "Network N can be combined from N 1 , N 2 and N h by first creating a new node r to be the parent of the roots of N 1 and N 2 . Find node u 1 in N 1 and u 2 in N 2 such that for i = 1\u2026m, either u 1 or u 2 corresponds to h i 's sibling s i . Let v 1 and v 2 be the parent of u 1 and u 2 respectively, create nodes p 1 and p 2 on edges (v 1 , u 1 ) and (v 2 , u 2 ) respectively. A new hybrid node h is created, and let h be a child of p 1 and p 2 , and h be the parent of N h 's root (Fig. 5) . Given network N compatible with tree T, a node u in N is said to correspond to a node s in T if T can be converted from N by a series of cuts in which any edge contraction related to node u will create a new node that is labeled u, then u becomes s.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 482,
                    "end": 490,
                    "text": "(Fig. 5)",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Reconstructing 1-Reticulated Network"
        },
        {
            "text": "If there is a tree T i in which h i is a child of the root r i , the network constructed in this case is skew (i.e., there is a split node such that the path from the split node to its hybrid node is 1). The problem can be divided into 2 sub-problems: P(N', T i ', L 1 }; and P(N h , T i [h i ], L h ). If N' and N h can be constructed, N can be obtained by first creating a node r and making r become the parent of the root of N'. Find a node u in N' such that for every tree T i in which h i is not a child of the root r i , u corresponds to s i in T i ', which is the sibling of h i before removing T i [h i ]. Let v be the parent of u, and a new node p on edge (v, u), create a hybrid node h that is the child of p and r, and h is the parent of the root of N h (Fig. 6) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 765,
                    "end": 773,
                    "text": "(Fig. 6)",
                    "ref_id": null
                }
            ],
            "section": "Reconstructing 1-Reticulated Network"
        },
        {
            "text": "To solve this problem, we also consider the base case, Case I and Case II as in the above. In addition, we need to consider Case III -Quadripartition as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reconstructing 2-Reticulated Network"
        },
        {
            "text": "The tree set {T 1 , T 2 , \u2026, T m } is said to admit a leaf-set-quadripartition (L 1 , L h1 , L h2 L 2 ) if for every tree T i with root r i and its children r i1 and r i2 , there exists a node h i2 \u2209 If N' is a non-skew network, N' is created by combining three 2-reticulated networks N 1 , N 2 and N h1 (as case II). Find two nodes a and b in two distinct networks out of three networks N 1 , N 2 and N h1 such that either a or b corresponds to node s i in T i ', which is the sibling of h i2 in T i , for i = 1, 2,\u2026, m. Attaching N h2 to N' is done similarly to case II by creating a new hybrid node h 2 (Fig. 7) . If N' is a skew-network, N' is created by combining two 2-reticulated networks N 1 and N h1 . Find nodes a and b in N 1 and N h1 respectively such that for i = 1\u2026m, either a or b corresponds to node s i in T i ', which is the sibling of h i2 in T i . Attaching N h2 to N' by creating a new hybrid node h 2 . (Fig.8 respectively. We have L 1 \u2229L 2 = \u2205 and L 1 \u222aL 2 = L, so in N and every tree T i , their root is the only common ancestor of any node in L 1 and any node in L 2 . This means the input tree set admit a leaf set bipartition, corresponding to case I in the algorithm. does not correspond to any hybrid node, the argument can be turn back to Case 2. This implies that the tree set admit a leaf set tripartition, corresponding to case 2 of the algorithm.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 606,
                    "end": 614,
                    "text": "(Fig. 7)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 925,
                    "end": 931,
                    "text": "(Fig.8",
                    "ref_id": null
                }
            ],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "Case 4: r corresponds to two hybrid nodes h 1 and h 2 Let p 1 and q 1 be the parents of h 1 , and p 2 and q 2 be the parents of h 2 , then either h 1 lies on one of the merge paths from the root r to h 2 , or none of the merge paths from r to h 2 (resp. h 1 ) go through h 1 (resp. . It takes O(mn) to divide L c into two disjoint subsets L c1 and L c2 , and L d into two disjoint subsets L d1 and L d2 (Fig. 9) . Pick one leaf node v in L c , then",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 403,
                    "end": 411,
                    "text": "(Fig. 9)",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "For every leaf node u \u2208 L c : If LCA(v, u) is not the root of every tree T i ; u is put in L c1 ; else, u is put in L c2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "For every leaf node w \u2208 L d : If LCA(v, w) is the root of every tree T i ; w is put in L d1 ; else w is put in L d2 . Claim 3: If the tree set admits a leaf set quadripartition (L 1 , L h1 , L h2 , L 2 ), one of two sets L c1 \u222aL d1 or L c2 \u222aL d2 can be either (1) L h1 , or (2) L h2 , or (3) L h1 \u222aL h2 . Pick any tree, say T 1 , to find the p 1 = LCA(L c1 \u222aL d1 ) and p 2 = LCA(L c2 \u222a L d2 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "1. One of two nodes p 1 or p 2 is the root r 1 and the other is not. Assume p 1 = r 1 , and p 2 is a proper descendant of r 1 , then L c2 \u222a L d2 = L h1 or L c2 \u222a L d2 = L h2 . 2. If both p 1 and p 2 are r 1 , find j = 1 or 2 such that LCA(L cj ) and LCA(L dj ) are the children of the root r 1 . If j does not exist, return \"null\"; otherwise, assume j = 1, then L h1 \u222aL h2 = L c2 \u222aL d2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "It takes O(n) time to determine L' which is either L h1 , or L h2 or L h1 \u222a L h2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Case III: Quadripartition"
        },
        {
            "text": ", m} admit a leaf set tripartition (L 1 , L h , L 2 ). If yes, L h2 = L' and L h = L h1 ; else return \"null\". If there is a tree T j in which there does not exist any node w such that L(T j [w]) = L' (Fig.10) . If h j is LCA(L'), then L' = L h1 \u222a L h2 , which is examined as case 2 below. Fig. 10 . With a leaf set L h1 , find a node w in T j such that L(T j [w]) = L h1 \u222a L h2",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 200,
                    "end": 208,
                    "text": "(Fig.10)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 289,
                    "end": 296,
                    "text": "Fig. 10",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "Let T k be a tree in which there is no node satisfying L' = L(T k [w] In total, checking whether the input trees admit a leaf set bipartition or tripartition or quadripartition, and partition every tree into proper subtrees takes O(mn). \uf030 Claim: Node u exits iff u i is u or a descendant of u such that all nodes on the path from u to u i are either hybrid node of a skew split node or non-hybrid nodes whose siblings are hybrid nodes. It takes O(mn) to find the set {u 1 , u 2 , \u2026, u m } from N (note that u x can be u y ), and O(n) time to check (i) all nodes {u 1 , u 2 , \u2026, u m } lie on the same directed path; and (ii) The siblings of u i , i = 1, 2, \u2026, m, are all hybrid nodes. If two conditions are satisfied, the node u will be the starting node x of the path created by {u 1 , u 2 ,\u2026, u m } or x's sibling if x's sibling is the hybrid node of a skew split node ; otherwise, return \"null\". ",
            "cite_spans": [
                {
                    "start": 66,
                    "end": 69,
                    "text": "[w]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Case III: Quadripartition"
        },
        {
            "text": "We evaluate and compare the performance of our method, namely ARTNET, with the program CMPT [13] which constructs a network with the smallest number in reticulation from a set of binary trees. NETGET [10] is used to generate random networks. For every 2-reticulated network simulated, we produce a certain number of induced binary trees which are the input of both programs ARTNET and CMPT. We use n (number of leaf node) = 40. Figure 11 shows that we run faster than CMPT. Following [11] , we use split-based false negative (FN) and false positive (FP) rates to measure the error rates of the methods. Figure 12 shows that ARTNET produces fewer false positives than CMPT. On the other hand, CMPT and ARTNET have similar performance in false negative rates. ",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 96,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 200,
                    "end": 204,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 484,
                    "end": 488,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [
                {
                    "start": 428,
                    "end": 437,
                    "text": "Figure 11",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 603,
                    "end": 612,
                    "text": "Figure 12",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Experiments"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Computing the unrooted maximum agreement subtree in sub-quadratic time",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "W"
                    ],
                    "last": "Lam",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "K"
                    ],
                    "last": "Sung",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "F"
                    ],
                    "last": "Ting",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Nordic Journal of Computing",
            "volume": "3",
            "issn": "4",
            "pages": "295--322",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Sparse dynamic programming for evolutionary-tree comparison",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Farach",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Thorup",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "SIAM Journal on Computing",
            "volume": "26",
            "issn": "1",
            "pages": "210--230",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Kaikoura tree theorems: Computing the maximum agreement subtree",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Steel",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "J"
                    ],
                    "last": "Warnow",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "Information Processing Letters",
            "volume": "48",
            "issn": "",
            "pages": "77--82",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Phylogenetic classification and the universal tree",
            "authors": [
                {
                    "first": "Ford",
                    "middle": [],
                    "last": "Doolittle",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Science",
            "volume": "284",
            "issn": "5423",
            "pages": "2124--2128",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A fundamental decomposition theory for phylogenetic networks and incompatible characters",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bansal",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Miyano",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mesirov",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kasif",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Istrail",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "A"
                    ],
                    "last": "Pevzner",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "RECOMB 2005",
            "volume": "3500",
            "issn": "",
            "pages": "217--232",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Reconstructing reticulate evolution in speciestheory and practice",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Warnow",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "R"
                    ],
                    "last": "Linder",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Proceedings of the 8th Annual International Conference on Research in Computational Molecular Biology (RECOMB 2004)",
            "volume": "",
            "issn": "",
            "pages": "337--346",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "RB-finder: An improved distance-based sliding window method to detect recombination breakpoints",
            "authors": [
                {
                    "first": "W.-H",
                    "middle": [],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "W.-K",
                    "middle": [],
                    "last": "Sung",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "RECOMB 2007",
            "volume": "4453",
            "issn": "",
            "pages": "518--532",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Mismatch induced speciation in salmonella: model and data",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Falush",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Torpdahl",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Didelot",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "F"
                    ],
                    "last": "Conrad",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "J"
                    ],
                    "last": "Wilson",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Achtman",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Philos. Trans. R Soc. Lond. B Biol. Sci",
            "volume": "361",
            "issn": "",
            "pages": "2045--2053",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Sexual isolation in bacteria",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Majewski",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "FEMS Microbiol. Lett",
            "volume": "199",
            "issn": "2",
            "pages": "161--169",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Recombination and the nature of bacterial speciation",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Fraser",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "P"
                    ],
                    "last": "Hanage",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "G"
                    ],
                    "last": "Spratt",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Science",
            "volume": "315",
            "issn": "5811",
            "pages": "476--480",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Constructing level-2 phylogenetic networks from triplets",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Van Iersel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Keijsper",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kelk",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Stougie",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Hagen",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Boekhout",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "RECOMB 2008",
            "volume": "4955",
            "issn": "",
            "pages": "450--462",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Constructing a smallest refining galled phylogenetic network",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "N D"
                    ],
                    "last": "Huynh",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jansson",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [
                        "B"
                    ],
                    "last": "Nguyen",
                    "suffix": ""
                },
                {
                    "first": "W.-K",
                    "middle": [],
                    "last": "Sung",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Miyano",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mesirov",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kasif",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Istrail",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "A"
                    ],
                    "last": "Pevzner",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "RECOMB 2005",
            "volume": "3500",
            "issn": "",
            "pages": "265--280",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Algorithms for Reticulate Networks of Multiple Phylogenetic Trees",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zhi-Zhong",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Lusheng",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "IEEE/ACM Transactions on Computational Biology and Bioinformatics (TCBB)",
            "volume": "9",
            "issn": "2",
            "pages": "372--384",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Beyond galled trees -decomposition and computation of galled networks",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "H"
                    ],
                    "last": "Huson",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "H"
                    ],
                    "last": "Kl\u00f6pper",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "RECOMB 2007",
            "volume": "4453",
            "issn": "",
            "pages": "211--225",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Algorithms for combining rooted triplets into a galled phylogenetic network",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jansson",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [
                        "B"
                    ],
                    "last": "Nguyen",
                    "suffix": ""
                },
                {
                    "first": "W.-K",
                    "middle": [],
                    "last": "Sung",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proceedings of the 16th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA)",
            "volume": "",
            "issn": "",
            "pages": "349--358",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Constructing a minimum phylogenetic network from a dense triplet set",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Habib",
                    "suffix": ""
                },
                {
                    "first": "T.-H",
                    "middle": [],
                    "last": "To",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Bioinformatics and Computational Biology",
            "volume": "10",
            "issn": "05",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Quartets and Unrooted Phylogenetic Networks",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gambette",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Berry",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Paul",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Journal of Bioinformatics and Computational Biology",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "An example phylogenetic network Fig. 2. A level-4 network but is an 2-reticulated network for a set of 15 HIV-1 sequences resulting from 9 gene tr",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Network N is compatible with T1, T2. T3",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "for every tree T i with root r i and its children r i1 and r i2 , L(T i [r i1 ]) = L 1 and L(T i [r i2 ]) = L 2 , then find P(N 1 , T i [r i1 ], L 1 ) and P(N 2 , T i [r i2 ], L 2 ). If N 1 and N 2 exist, network N is obtained by creating a new node r becoming the parent of the roots of N 1 and N 2 .(Fig. 4)The tree set admit a leaf set bipartitionCase II: Tripartition {T 1 ,\u2026,T m } admit a leaf-set-tripartition (L 1 , L h , L 2 ) if for every tree T i with root r i and its children r i1 and r i2 , there exists a node h i \u2260 r i such that L(T i [h i ]) = L h ; and if h i \u2260 r i1 and h i \u2260 r i2 for every i = 1\u2026m; {T i ' = T i \\T i [h i ]} admit a leaf-set-bipartition (L 1 , L 2 ). Otherwise, L 1 = L(T i ') and L 2 = \u2205.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Combining N 1 , N 2 and N h to get network N",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "m} admit a leafset-tripartition (L 1 , L h1 , L 2 ). If there exist a 2-reticulated network N' compatible with {T 1 ',\u2026, T m }; and a 2-reticulated network N h2 compatible with {T i [h i2 ], i = 1, \u2026, m}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Combining non-skew network N' and N h2 to get a 2-reticulated network N",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "(figure 7). In both cases, all nodes in the subnetwork N[h 2 ] cannot be reached by any other node outside N[h 2 ] without passing through node h 2 ; otherwise, r would correspond to another hybrid node in N[h 2 ]. From Lemma 1, there exists a node h i2 in every tree T i such that N[h 2 ] is compatible with T i [h i2 ], and L(N[h 2]) = L(T i [h i2 ]). Plus, N\\N(h 2 ) is a compatible 2articulated network of T i \\T i [h i2 ].As the root of N\\N(h 2 ) corresponds to exact 1 hybrid node h 1 , the argument can turn back to Case 3 above. This implies the tree set admit a leaf set quadripartition, corresponding to Case 3 of the algorithm. Determining whether {T 1 , T 2 , \u2026, T m } admit a leaf set bipartition or tripartition or quadripartition and partitioning every tree can be done in O(mn).Proof. Denote LCA(X) the lowest common ancestor of all nodes in set X. For every tree T i , i = 1, 2, \u2026, m, denote r i the root of T i , and r i1 and r i2 are two children of r i . Define a subset L* \u2282 L: L* = \u2205 if the tree set admit the leaf set bipartition. L* = L h if the tree set admit a leaf set tripartition (L 1 , L h , L 2 ). L* = L h1 \u222a L h2 if the tree set admit a leaf set quadripartition (L 1 , L h1 , L h2 , L 2 ). Determine L*: Let L c = L(T 1 [r 11 ]); L d = L(T 1 [r 12 ])",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Partition the leaf set Claim 1: The tree set admits a leaf set bipartition iff L c2 = L d2 = \u2205; otherwise check tripartition property. Claim 2: The tree set admits a leaf set tripartition iff either L* = L c2 \u222a L d2 or L* = L c1 \u222a L d1 , and there exists a node h i in every tree T i such that L(T i [h i ]) = L*, and T i \\T i [h i ] admit a leaf set bipartition if h i is not a child of r i for every i = 1\u2026m, taking O(mn) time; otherwise, check quadripartition property.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Given a network N compatible with m trees {T 1 , T 2 , \u2026, T m } with the same leaf label set L of size n, and a node s i in T i , for i = 1, 2, \u2026, m, then finding whether there is a node u in N corresponding to s 1 , s 2 , \u2026, s m can be done in O(n). Proof. For i = 1, \u2026, m, let u i be a node in N having the lowest height in N such that L(T i [s i ]) \u2286 L(N[u i ]).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Constructing a k-reticulated network (k = 1 or 2) from a set of m binary trees with the same leaf label set L of size n can be done in O(mn 2 ). Proof. From Lemma 2 and Lemma 3, dividing and conquering take O(mn) time complexity. There are O(n) nodes in a tree with n leaf nodes. Hence the time complexity of our algorithm is O(mn 2 ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Time comparison between ARTNET and CMPTFig. 12. Comparing the false positive rate between ARTNET and CMPT Acknowledgement. The project is partially supported by in part by the General Research Fund (GRF) of the Hong Kong Government (HKU 719709E) and Kunihiko Sadakane is supported in part by KAKENHI 23240002.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Fig. 8. Combining skew network N' and N h2 to get a 2-reticulated network N",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "). If there are exact two nodes h k1 and h k2 in T k such thatL(T k [h k1 ]) \u222a L(T k [h k2 ]) = L', then either L(T k [h k1 ]) or L(T k [h k2 ]) is L h2 ; otherwise, return \"null\".Finding h k1 and h k2 takes O(n). It then takes O(mn) to determine which one, L(T k [h k1 ]) or L(T k [h k2 ]), is L h2 , and partition every tree T i into T i ' and T i [h i2 ], for i = 1, 2, \u2026, m.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Given a set of binary trees {T 1 ",
            "cite_spans": [
                {
                    "start": 31,
                    "end": 32,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Maximum 2-Reticulated Network Compatibility Problem"
        },
        {
            "text": "Using brute-force approach by considering all possible subsets of the leaf set, the problem can be done in O(2 n mn 2 ). However, when m \u226a n, the following algorithm produces better time complexity. , if there is a tree whose root is pointed by any _ , 1 (resp. _ , 2 with a specific value (resp. ), then for every other tree containing a node that is pointed by _ , 1",
            "cite_spans": [],
            "ref_spans": [],
            "section": ", T 2, \u2026 T m }, compute the maximum leaf set L* such that there exists a 2-reticulated network N compatible with {T 1 |L*, T 2 |L*, \u2026, T m |L*}."
        },
        {
            "text": "(resp. _ , 2 ), replace in computing .Time Complexity: By applying dynamic programming, and backtracking on the recursive equations, the problem can be computed in O(2 m mn 3m ). \uf030",
            "cite_spans": [],
            "ref_spans": [],
            "section": "MCN(T"
        }
    ]
}