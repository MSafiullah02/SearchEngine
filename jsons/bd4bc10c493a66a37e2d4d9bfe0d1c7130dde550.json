{
    "paper_id": "bd4bc10c493a66a37e2d4d9bfe0d1c7130dde550",
    "metadata": {
        "title": "Cross-data Automatic Feature Engineering via Meta-learning and Reinforcement Learning",
        "authors": [
            {
                "first": "Jianyu",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Tianjin University",
                    "location": {
                        "settlement": "Tianjin",
                        "country": "China"
                    }
                },
                "email": "edzhang@tju.edu.cn"
            },
            {
                "first": "Jianye",
                "middle": [],
                "last": "Hao",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Tianjin University",
                    "location": {
                        "settlement": "Tianjin",
                        "country": "China"
                    }
                },
                "email": "jianye.hao@tju.edu.cn"
            },
            {
                "first": "Fran\u00e7oise",
                "middle": [],
                "last": "Fogelman-Souli\u00e9",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Hub France IA",
                    "location": {
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Feature Engineering (FE) is one of the most beneficial, yet most difficult and time-consuming tasks of machine learning projects, and requires strong expert knowledge. It is thus significant to design generalized ways to perform FE. The primary difficulties arise from the multiform information to consider, the potentially infinite number of possible features and the high computational cost of feature generation and evaluation. We present a framework called Cross-data Automatic Feature Engineering Machine (CAFEM), which formalizes the FE problem as an optimization problem over a Feature Transformation Graph (FTG). CAFEM contains two components: a FE learner (FeL) that learns finegrained FE strategies on one single dataset by Double Deep Q-learning (DDQN) and a Cross-data Component (CdC) that speeds up FE learning on an unseen dataset by the generalized FE policies learned by Meta-Learning on a collection of datasets. We compare the performance of FeL with several existing state-of-the-art automatic FE techniques on a large collection of datasets. It shows that FeL outperforms existing approaches and is robust on the selection of learning algorithms. Further experiments also show that CdC can not only speed up FE learning but also increase learning performance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "As machine learning becomes more and more widespread, it has been recognized that feature engineering (FE) is the most critical factor for models performance [1] . Various researchers have demonstrated the benefit of using additional features [11] . FE aims at reducing the model error and making learning easier by deriving, through mathematical functions (operators), new features from the original ones. Normally a data scientist combines feature generation, selection and model evaluation iteratively, generating a long sequence of decisions before obtaining the \"optimal\" set of derived features. This process heavily relies on expert domain knowledge, intuition and technical expertise to handle the complex feedbacks and make best decisions. As a result, the process is difficult, time-consuming and hard to automate.",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 161,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 243,
                    "end": 247,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Most of existing methods of automatic FE either generate a large set of possible features by predefined transformation operators followed by feature selection [3, 7, 15] or apply simple supervised learning (simple algorithm and/or simple meta-features derived from FE process) to recommend a potentially useful feature [4, 5, 9] . The former makes the process computationally expensive, which is even worse for complex features, while the latter significantly limits the performance boost.",
            "cite_spans": [
                {
                    "start": 159,
                    "end": 162,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 163,
                    "end": 165,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 166,
                    "end": 169,
                    "text": "15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 319,
                    "end": 322,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 323,
                    "end": 325,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 326,
                    "end": 328,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A recently proposed FE approach [5] is based on Reinforcement Learning (RL). It treats all features in the dataset as a union, then applies traditional Qlearning [14] on FE-augmented examples to learn a strategy for automating FE under a given computing budget. RL is more promising in providing general FE solutions. However, this work uses Q-learning with linear approximation and 12 simple manual features, which limits the ability of automatic FE. Furthermore, it ignores the differences between features and applies a transformation operator on all of them at each step. Because of this nondiscrimination of different features, it is computation expensive, especially for large datasets and complex transformation operators.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 35,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 162,
                    "end": 166,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To address the above limitations, in this work, we propose FeL (Feature Engineering Learner ) and CAFEM (Cross-data Automatic Feature Engineering Machine). The former is a novel approach for automatic FE for one particular dataset based on off-policy Deep Reinforcement Learning (DRL). In order to speed up the FE process and take advantage of the FE knowledge learned from a large set of datasets, the latter extends FeL to cross-data level by Meta-Learning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We define a Feature Transformation Graph (FTG), a directed graph representing relationships between different transformed versions of features, to organize the FE process. FeL sequentially trains an agent for each feature by DRL algorithms to learn the strategy for feature engineering on one dataset and corresponding FTG representation. We thus view the goal of FE as maximizing model accuracy by searching through a set of features F + to generate and a set of features F \u2212 to eliminate. CAFEM extends this process to cross-data by training one agent on a large set of datasets to enable the learned policy to perform well on unseen datasets.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this section we review the Reinforcement Learning (RL) [10] background and describe the problem formulation.",
            "cite_spans": [
                {
                    "start": 58,
                    "end": 62,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Background and Problem Formulation"
        },
        {
            "text": "RL is a family of algorithms that formalizes the interaction of an agent A with her environment using a Markov Decision Process (MDP) and allows it to devise an optimal sequence of actions. An MDP is defined by a tuple S, A, T , R, \u03b3 , where S is a set of states, A a set of actions, T : S \u00d7 A \u2192 \u0394(S) a transition function that maps each state-action pair to a probability distribution over the possible successor states, R : S \u00d7 A \u00d7 S \u2192 R a reward function and \u03b3 \u2208 [0, 1] a discount factor for controlling the importance of future rewards. A policy \u03c0 : S \u2192 A is a mapping from states to actions. At every time step t, an agent in state s t produces an action a t = \u03c0(s t ). Based on transition function T the agent gets into next state s t+1 with probability T (s t , a t ) and obtains immediate reward r t = R(s t , a t , s t+1 ). The goal of an agent is to find an optimal policy \u03c0 * maximizing her expected discounted cumulated reward E[R 0 |s 0 ], where R t = \u221e i=t \u03b3 i\u2212t r i is the discounted sum of future rewards. Q-learning is a well-known model-free RL algorithm for finding an optimal policy \u03c0 * for any finite MDP. In Q-learning we define the Q-function or actionvalue function as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reinforcement Learning"
        },
        {
            "text": "Given an optimal policy \u03c0 * , we are interested in the optimal function Q \u03c0 * (s, a), or Q * (s, a) for short, where \u2200\u03c0, s \u2208 S, a \u2208 A, Q \u03c0 * (s, a) \u2265 Q \u03c0 (s, a). As a result, Q * satisfies the following equation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reinforcement Learning"
        },
        {
            "text": "Double Deep Q-network (DDQN) [12] is a model-free RL algorithm, which estimates the state-action value approximately through a deep neural network with parameters \u03b8. It uses an -greedy policy to get the next action.",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 33,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Reinforcement Learning"
        },
        {
            "text": "During training, the tuples s t , a t , r t , s t+1 generated by the -greedy policy are stored in R, the so-called replay buffer. Then the neural network is trained by sampling from the replay buffer, using mini-batch, and performing gradient descent on loss L = E((Q(s t , a t ) \u2212 y t ) 2 ), where y t = r t + \u03b3max a Q(s t+1 , a), Q(s, t) is approximated by the network g with parameter \u03b8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reinforcement Learning"
        },
        {
            "text": "The goal of meta-learning is to quickly train a model for a new task with the help of data from many other similar tasks.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Meta-learning"
        },
        {
            "text": "Model-Agnostic Meta-Learning (MAML) [2] is one of the best meta-learning algorithms that were trained by gradient descent. We denote {T } as a set of tasks. MAML performs one step gradient descent for a task T i on loss L with network g and network parameters \u03b8 and gains \u03b8 i as Equation (2) . Then it performs a second gradient descent \u03b8 step on loss L with network parameters \u03b8 i as Equation (3) . Finally, MAML finds parameters \u03b8 that are close to the optimal parameters of every task.",
            "cite_spans": [
                {
                    "start": 36,
                    "end": 39,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 288,
                    "end": 291,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 394,
                    "end": 397,
                    "text": "(3)",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Meta-learning"
        },
        {
            "text": "where \u03b1 is the learning rate of each task T i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Meta-learning"
        },
        {
            "text": "where \u03b2 is the meta step size.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Meta-learning"
        },
        {
            "text": "We consider a collection of typical supervised learning tasks (binary classification or regression) T = {T 1 , T 2 , ..., T N } and each task T i can be represented as T i = D, L, m , where D = F, y is a dataset with a set of features F = {f 1 , f 2 , ..., f n } and a corresponding target variable y, L is a learning algorithm (e.g. Random Forest, Logistic Regression, Neural Network) to be applied on dataset D and m is an evaluation measure (e.g. log-loss, relevant absolute error, f1-score) to measure the performance. We use P m L (F, y) or P (D) to denote the cross-validation performance of learning algorithm L and evaluation measure m on dataset D. The goal of each task is to maximize P (D).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "A transformation operator \u03c4 in FE is a function that is applied on a set of features to generate a new feature f + = \u03c4 ({f i }) where the order of the operator follows the number of features in {f i }. We denote the set of derived features as F + . For instance, a product transformation applied on two features (Order-2) generates a new feature f + = product(f i , f j ). We use T to denote the set of all transformation operators.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "Feature engineering aims at constructing a subset of features ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "The goal of feature engineering is to find a good policy \u03c0 * that maximizes the model performance for a given algorithm L and measure m on a dataset D.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Formulation"
        },
        {
            "text": "In this section, we present a new framework called Cross-data Automatic Feature Engineering Machine (CAFEM). In order to highlight the differences between features and integrate feature generation and feature selection effectively, we propose a Feature Transformation Graph (FTG) to represent the FE process at feature level. Based on FTG, CAFEM can perform feature engineering for each particular feature based on the information related with it. Thus, it avoids the drawback of generating a large set of features at each step in [5] , especially for complex features and large number of features. One component of CAFEM called FE Learner (FeL) uses Reinforcement Learning to find the optimal feature set F * for each feature iteratively, instead of using expensive graph search algorithm [6] . FeL focus on one particular supervised learning task which gives FeL the ability to dig deeply into that task. However, it loses the opportunity to learn and integrate useful experiments from other tasks which can speed up FE process on a similar task. In order to balance performance and speed, another component of CAFEM called Cross-data Component (CdC) applies a Model-Agnostic Meta-Learning (MAML) [2] method, which is originally designed for supervised learning and on-policy reinforcement learning algorithms, on off-policy reinforcement learning algorithms to speed up FE learning on one particular dataset by integrating the FE knowledges from a set of datasets.",
            "cite_spans": [
                {
                    "start": 531,
                    "end": 534,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 790,
                    "end": 793,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1199,
                    "end": 1202,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Method"
        },
        {
            "text": "We propose a structure called Feature Transformation Graph (FTG) G, which is a directed acyclic dynamic graph, to represent the FE process. Each node f in FTG corresponds to either one original feature in F o or one feature derived from original features. An edge from node",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Transformation Graph"
        },
        {
            "text": "At the start of FE, G contains n nodes which correspond to n original features {f 1 , f 2 , ..., f n }. As FE process goes, FTG dynamically grows up (adds more nodes and edges). So we denote FTG at time step t as G t . An illustrating example is given in Fig. 1 . ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 255,
                    "end": 261,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Feature Transformation Graph"
        },
        {
            "text": "So far, we have introduced the representation of FE with FTG in our automatic FE framework. After that, what we need to do is to find a suitable strategy to control the growth of FTG. An important property is that FTG is not designed for any particular strategy, but to be a general representation of an FE process. As a result, we can apply many different strategies on the FTG to control it, such as graph search or RL. In this paper, we choose RL to learn a strategy that can make a sequence of decisions on top of FTG, due to its efficiency. Consider the FE process with FTG on one dataset D as an MDP problem defined as a tuple S, A, T , R, \u03b3 . At each time step t, a state s t \u2208 S consists of the Feature Transformation graph G t and the features {f t } we are working on. Due to the complexity of transformation operators, {f t } could contain one or more features. For example, {f t } contains one feature for Order-1 operators (e.g. log, square), two features for Order-2 operators (e.g. product, sum).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "MDP Formulation"
        },
        {
            "text": "An action a t \u2208 A = A G A S comes from the following two groups of actions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "MDP Formulation"
        },
        {
            "text": "-A G is a set of actions for feature generation, which apply a transformation \u03c4 \u2208 T on current features {f t } to derive one new feature. -A S contains one action for feature selection by RL, which drops current feature f t and moves back to the previous feature. One special case is that current feature f t \u2208 {f 1 , f 2 , .., f n } belongs to original features. In this case, feature selection action drops it and stops current FE process.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "MDP Formulation"
        },
        {
            "text": "The learning objective here is to find a state s i with feature set F * in FTG that maximizes the model accuracy P m C (F * , y). The trajectory from original feature to a new feature f i indicates the final feature engineering strategy for f i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "MDP Formulation"
        },
        {
            "text": "Since the target of FE is to maximize the performance P (D), the reward r t of this FE problem in FTG at time step t is set as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "MDP Formulation"
        },
        {
            "text": "Until now, we have introduced the organization of FE process and the MDP formulation of FE problem. The most critical part is the algorithm to find a good strategy of FE. We introduce CAFEM framework which mainly contains two parts: 1) an algorithm called FeL that can apply an off-policy DRL algorithm A (such as DQN [8] , Double DQN [12] ) on FTG for one particular dataset to perform automatic FE; 2) an extended version of model-agnostic meta-learning [2] algorithm on off-policy DRL to speed up FE learning by taking advantage of the generalized FE strategies learned from a set of datasets. It is called off-policy, since the policy being learned can be different from the policy being executed. In the following sub-section, we will introduce the details of these two parts.",
            "cite_spans": [
                {
                    "start": 318,
                    "end": 321,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 335,
                    "end": 339,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 456,
                    "end": 459,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "CAFEM Framework"
        },
        {
            "text": "Although FeL works as a component of CAFEM in this paper, it is also a complete algorithm that sequentially optimizes FE strategies for each feature on one particular dataset. The details of FeL algorithm are shown in Algorithm 1. Given a supervised learning task T with n features F = {f 1 , f 2 , ..., f n }, n off-policy DRL agents {A i }, FeL sequentially optimizes a FE policy for each feature (line 2 in Algorithm 1). As traditional training stage of off-policy RL algorithms, FeL starts with performing M episodes of FE process by -greedy and stores corresponding transitions in replay buffer (line 3-10). In this process, FeL either generates a new featuref from feature f by action a t (a t \u2208 A G ) or drops current feature f and moves back to previous featuref (a t \u2208 A S ). Then FeL trains the corresponding agent A i by performing gradient descent on a mini-batch sampled from replay buffer R i (line [11] [12] [13] [14] . During test stage the same FE method as Algorithm 1 with = 0 is used to perform FE for each feature sequentially. Note that the operators in transformation operators set T are not of the same complexity level. For example, some unary features (e.g. log(f i ), square(f i )) are less complex than binary features (e.g. product(f i , f j ), sum(f i , f j )). As in [15] , we introduce features along feature complexity, driving simple features first (e.g. unary features) then complex features (e.g. binary features). for fi in F do 3:",
            "cite_spans": [
                {
                    "start": 913,
                    "end": 917,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 918,
                    "end": 922,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 923,
                    "end": 927,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 928,
                    "end": 932,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1298,
                    "end": 1302,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "for episode = 1, M do 4:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Get initial state s0 5:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "while not terminal do 6: Get an action at by -greedy and execute at on f :f = at(f ) 7:",
            "cite_spans": [
                {
                    "start": 22,
                    "end": 24,
                    "text": "6:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Obtain reward rt and next state st+1 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Store transition (st, at, rt, st+1) in Ri and reset current feature:f \u2190f 9: end while 10: end for 11:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "for t = 1, N do 12:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Sample a mini-batch from replay buffer Ri 13:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Perform one optimization step on Ai 14: end for 15: end for 16:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Reset dataset D = {fi, ..., fn}, y 17: end while Cross-data Component: In order to speed up FE process and take advantage of a large set of datasets, we apply Model-agnostic Meta-Learning [2] on offpolicy RL to perform cross-data level automatic feature engineering. The details of the Cross-data Component (CdC) are shown in Algorithm 2. Given a set of datasets {D = F, y } and an off-policy RL agent A (we use DDQN here as it can gain relevant a good performance in many tasks [12] ) represented by g \u03b8 , Crossdata Component samples a batch of features {f i } and corresponding dataset {D fi } and constructs a batch of supervised learning tasks {T i = D fi , P, m } (line 2). For each task T i \u2208 {T i }, CdC uses the RL agent A together withgreedy exploration to perform M episodes for T i and stores the corresponding transitions in replay buffer R i (line 4-5). Then CdC samples K transitions from R i and computes one step gradient descent as Algorithm 2 (line 7-8) where the loss L is the same as Algorithm 1. Finally, we sample a batch of transitions and perform meta-update (line 9-11).",
            "cite_spans": [
                {
                    "start": 479,
                    "end": 483,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Network Design: Until now, we have discussed the details of FeL algorithm and cross-data component. One remaining part is the structure of the neural network that can approximate the Q-values of DDQN in FeL algorithm. In this project, instead of building one approximation function with parameter \u03b8 for each action a [5] , we use one union function that is approximated by a neural network, for all actions. Thus, we only need to train one DRL model.",
            "cite_spans": [
                {
                    "start": 317,
                    "end": 320,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "As we discussed in Sect. 4.2, the state s t at time t indicates the FTG G t and the features {f t } it is working on at time t. In order to cover these two parts of information in the representation of each state s t , we use the following features to represent s t : Store all transitions in Ri 7:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Sample K transitions T from Ri 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Compute adapted parameters with gradient descent:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "Sample transitions T i from Ri for meta-update 10: end for 11: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Feature Engineering Learner (FeL):"
        },
        {
            "text": "This section describes our experimental results. First, we introduce our experimental settings as well as our training procedure. Then we use F1-score (for classification) and 1 -Relevant Absolute Error (1-RAE) (for regression) criteria to compare the performance of FeL algorithm with several state-of-the-art automatic FE techniques. After that, we evaluate the robustness of our algorithm with respect to different learning algorithms (Random Forest, Logistic Regression). Finally, we show the efficiency of CAFEM on different supervised learning tasks by comparing it with FeL. To our surprise, CAFEM can help improving the prediction performance. Source codes are posted on Github (https://github. com/TjuJianyu/CAFEM.git).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiments"
        },
        {
            "text": "We randomly collect 120 binary classification or regression datasets, which do not contain missing values and too many features and instances, from OpenML. We randomly split them into 100 datasets for training and the other 20 datasets for testing. Following [5, 9] , we choose 13 transformation operators (set T) including Order-1: Log, Round, Sigmoid, Tanh, Square, Square Root, ZScore, Min-Max-Normalization and Order-2: Sum, Difference, Product, Division. Following [9] , we choose Random Forest and Logistic Regression (Lasso for regression) (from Scikit-learn http://scikit-learn.org) as our learning algorithm and use F1score/1-RAE to measure the performance. A 5-fold cross validation (same seed for all experiments) using random stratified sampling is used to measure the average performance. FeL is performed on 20 testing datasets directly, while CAFEM is trained on the 100 training datasets by meta-learning. For Order-2 operators, as the number of candidate features is very large, FeL randomly sample a small batch (100) at each step.",
            "cite_spans": [
                {
                    "start": 259,
                    "end": 262,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 263,
                    "end": 265,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 470,
                    "end": 473,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Settings"
        },
        {
            "text": "To showcase the ability of different FE algorithms, we compare the performance of FeL with the following approaches:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Settings"
        },
        {
            "text": "-Baseline: applies learning algorithm on original dataset (features) directly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Settings"
        },
        {
            "text": "-Random-FeL (RS): is an algorithm where we apply random strategy on FTG rather than the strategy learned by RL like CAFEM to find a set of features that can maximize P (D). This shows the effect of FTG without RL and Meta-learning. This algorithm can be seen as random graph search method on FTG. As some graph search algorithms, such as depth-first search (DFS) or breadth-search algorithm (BFS), are extremely time consuming [5] , we do not compare FeL with DFS or BFS in this paper. -Brute-force (BF): is inspired by DSM [3] , OneBM [7] and [15] . It applies all transformation operators to all original features and performs feature selection on the augmented dataset. (top-down approach). -LFE [9] : uses QSA to generate the representation of each feature in classification problems. Following [9] , a neural network with one hidden layer, L2 regularization and dropout is used to predict whether a feature with a transformation operator will gain 1% model performance improvement. -FERL: organizes the FE problem into a Transformation Graph, where each node is either the original dataset D or a dataset transformed from D. Then it uses Q-learning with linear approximation. We use the same setting as [5] . For Order-2 transformation operators, native FERL is extremely computation expensive since the number of new features is very large. During training stage, we prune the branches in Transformation Graph that would generate more than 10,000 new features next to make it trainable.",
            "cite_spans": [
                {
                    "start": 427,
                    "end": 430,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 524,
                    "end": 527,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 536,
                    "end": 539,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 544,
                    "end": 548,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 699,
                    "end": 702,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 799,
                    "end": 802,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1208,
                    "end": 1211,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Settings"
        },
        {
            "text": "As the source codes of all these methods are not publicly available and some experiments details are not provided (such as, the random seed of learning algorithm and train-test dataset splitting), we implemented ourselves all the benchmarks. For all the FE approaches except Baseline, we evaluate the performance for Order-1 and (Order-1 & Order-2) transformation operators to compare the ability of handling simple and complex transformation operators. In Order-1 transformation operators, FeL outperforms all approaches on most datasets. On average, FeL improves performance by 4.2% on test datasets. In the best two cases, Credit card and Pc4, FeL even improves baseline performance by 18.2% and 9.3%. One interesting phenomenon is that the Random method (random graph search on FTG) can obtain a relevant higher performance on some datasets. This indicates that FTG represents the FE process in an effective way and significantly contributes further strategy learning of FE.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Settings"
        },
        {
            "text": "On Order-1 & Order-2 transformation operators, the complexity of FE increases significantly. Thus, it is expected that an inefficient method would easily run out of time, memory space or even would not work. FeL improves performance by 6.9% on average compared with existing approaches. In the best two cases, Pc4 and Ilpd, it improves by 42.5% and 20.9%. As we mentioned above, some FE approaches would be strongly limited as the complexity of transformation operators increasing. Comparing the performance of each approaches on Order-1 & Order-2 with that on Order-1, we found that LFE and Brute-force approaches get a worse performance (-1.54% in average) on half of the datasets, while FeL does not get any performance decrease. FERL approach is really computation expensive here: most of the datasets run out of time (36 h).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Performance Comparison of FeL"
        },
        {
            "text": "In order to showcase the robustness of FeL, we evaluate the performance of FeL with two learning algorithms: Random Forest (tree-based ensemble learning algorithm) and Logistic Regression (Lasso for regression) (general linear algorithm) on 20 test datasets. FeL gains 10.8% and 4.2% performance increase on average with Logistic regression and Random Forest, respectively. The performance of FeL with Logistic regression ranges from 0.2% to 25.8%. For Random Forest, the performance of FeL ranges from 0% to 18.2%. It shows that our algorithm is robust with respect to different learning algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Robustness of FeL on Different Learning Algorithms"
        },
        {
            "text": "One main aim of Cross-data Component is to speed up FE learning. We evaluate FeL and CAFEM on the test datasets and randomly show the comparison on 4 datasets due to the space limitation. Figure 2 shows that CAFEM can increase model performance more rapidly (gain a high score within the first epoch, outperform the best of FeL within around ten epochs). To our surprise, CAFEM can gain a better final model performance than FeL in most of the cases. We hypothesize the reason of this phenomena as that CAFEM learnt some general FE rules from a large set of datasets to help the agent quickly learn a new dataset and regularize its behavior.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 188,
                    "end": 196,
                    "text": "Figure 2",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Performance of Cross-data Component"
        },
        {
            "text": "In this paper, we present a novel framework called CAFEM to perform automatic feature engineering (FE) and transfer FE experiences from a set of datasets to a particular one. It contains a feature transformation graph (FTG) that organized the process of FE, a Single-data FE learner and a Cross-data component. In most datasets, the framework outperforms state-of-the-art automatic FE approaches for both simple and complex transformation operators. With the help of cross-data component, CAFEM can speed up FE and increase FE performance. Moveover, the framework is robust to the choice of different learning algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "A few useful things to know about machine learning",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Domingos",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Commun. ACM",
            "volume": "55",
            "issn": "10",
            "pages": "78--87",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Model-agnostic meta-learning for fast adaptation of deep networks",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Finn",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Abbeel",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Levine",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 34th International Conference on Machine Learning",
            "volume": "70",
            "issn": "",
            "pages": "1126--1135",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Deep feature synthesis: towards automating data science endeavors",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "M"
                    ],
                    "last": "Kanter",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Veeramachaneni",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "IEEE International Conference on Data Science and Advanced Analytics (DSAA)",
            "volume": "36678",
            "issn": "",
            "pages": "1--10",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Explorekit: automatic feature generation and selection",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Katz",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "C R"
                    ],
                    "last": "Shin",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Song",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the IEEE 16th International Conference on Data Mining ICDM 2016",
            "volume": "",
            "issn": "",
            "pages": "979--984",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Feature engineering for predictive modeling using reinforcement learning",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Khurana",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Samulowitz",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Turaga",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Thirty-Second AAAI Conference on Artificial Intelligence",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Cognito: automated feature engineering for supervised learning",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Khurana",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Turaga",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Samulowitz",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Parthasrathy",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the IEEE 16th International Conference on Data Mining Workshops ICDMW 2016",
            "volume": "",
            "issn": "",
            "pages": "1304--1307",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "One button machine for automating feature engineering in relational databases",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "T"
                    ],
                    "last": "Lam",
                    "suffix": ""
                },
                {
                    "first": "J.-M",
                    "middle": [],
                    "last": "Thiebaut",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sinn",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Mai",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Alkan",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1706.00327"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Human-level control through deep reinforcement learning",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Mnih",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Nature",
            "volume": "518",
            "issn": "7540",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Learning feature engineering for classification",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Nargesian",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Samulowitz",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Khurana",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "B"
                    ],
                    "last": "Khalil",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Turaga",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 26th International Joint Conference on Artificial Intelligence, IJCAI",
            "volume": "17",
            "issn": "",
            "pages": "2529--2535",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Reinforcement Learning: An Introduction",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "S"
                    ],
                    "last": "Sutton",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "G"
                    ],
                    "last": "Barto",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "The BigChaos solution to the Netflix grand prize. Netflix prize documentation",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "T\u00f6scher",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jahrer",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "M"
                    ],
                    "last": "Bell",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "1--52",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Deep reinforcement learning with double Q-learning",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Van Hasselt",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Guez",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Silver",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "",
            "volume": "2",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Quantiles over data streams: an experimental study",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Luo",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Yi",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cormode",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data",
            "volume": "",
            "issn": "",
            "pages": "737--748",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Q-learning",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "J"
                    ],
                    "last": "Watkins",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Dayan",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Mach. Learn",
            "volume": "8",
            "issn": "3-4",
            "pages": "279--292",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Towards automatic complex feature engineering",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Fogelman-Souli\u00e9",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Largeron",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Hacid",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Cellary",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "H.-Y",
                    "middle": [],
                    "last": "Paik",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "WISE 2018",
            "volume": "11234",
            "issn": "",
            "pages": "312--322",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-02925-8_22"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "the set of original features in dataset D, F + the set of derived features and F \u2212 \u2286 F o the set of features that we decide to drop out from original features. For a given dataset D, a feature engineering strategy \u03c0 specifies a derived feature set",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Example of FTG",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "FeL input: An dataset D = F, y with n features F = {f0, ...fn}, n replay buffer {Ri, ..., Rn} for each features, n off-policy DRL agents {Ai}, number of epochs and episodes E, M , batches to train N 1: while epoch = 1, E do 2:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "CrossDataComponent input: a set of tasks {T }, an off-policy DRL agent represented by g \u03b8 , number of epochs and episodes E, M 1: Randomly initialize \u03b8 2: while epoch = 1, E do 3: Sample batch of tasks {Ti} from {T } 4: for all {Ti} do 5: Perform M episodes on task Ti with -greedy 6:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "using each T i and LT i in Equation 3 12: end while 1. Extended Quantile Sketch Array (ExQSA) representation of features. Quantile Sketch Array (QSA) uses quantile data sketch [13] to represent feature values associated with a class label. For each feature f and binary target y, QSA builds equi-width bins for f with target y = 0 and y = 1 separately. For regression problems, we extend QSA (ExQSA) by building equi-width bins for f with numeric target y > median(y) and y < median(y) separately. 2. Previous N-step FE history on FTG. 3. The number of each transformation operators used in G t . 4. The number of next node visited for each action. 5. The number of each operator used from {f t } to its root. 6. Node depth of a feature in HTG. 7. Average performance improvement of each action.Totally, we use 293 features to represent each state. A neural network with three fully connected hidden layers (128-128-64 neurons) and ReLU activation function is used to approximate Q-values.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "4% 27.9% 23.0% 30.3% 32.0% 33.3% 24.6% 27.4% 31.6% -9% 80.0% 75.2% 80.4% 83.0% 82.7% 90.8% 73.2% 81.8% -5% 98.7% 97.8% 99.1% 98.9% 99.5% 97.8% 93.4% 99.4% 98.9% Fig. 2. CAFEM vs FeL over 4 different datasets",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "compares the model performance of our automatic FE approach FeL to other state-of-the-art FE approaches on 20 datasets. The first four columns in this table report the dataset, the number of instances (rows) and original features, the baseline performance (F1-score/1-RAE of 5-fold cross validation) of the datasets. The number of instances ranges from 506 to 14,240 and for features, it ranges from 4 to 971. In the middle five columns, we compare different automatic FE approaches with Order-1 transformation operators, and in the last five columns, the performance with Order-1 & Order-2 transformation operators.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgments. The work is supported by the National Natural Science Foundation of China (Grant Nos.: 61702362, U1836214).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}