{
    "paper_id": "6a1d44bbe7d4946f28a89adf1b96b26968fa747a",
    "metadata": {
        "title": "Deciding Classes of Regular Languages: The Covering Approach",
        "authors": [
            {
                "first": "Thomas",
                "middle": [],
                "last": "Place",
                "suffix": "",
                "affiliation": {
                    "laboratory": "LaBRI",
                    "institution": "Institut Universitaire de France",
                    "location": {
                        "settlement": "Talence",
                        "country": "France"
                    }
                },
                "email": "tplace@labri.fr"
            }
        ]
    },
    "abstract": [
        {
            "text": "We investigate the membership problem that one may associate to every class of languages C. The problem takes a regular language as input and asks whether it belongs to C. In practice, finding an algorithm provides a deep insight on the class C. While this problem has a long history, many famous open questions in automata theory are tied to membership. Recently, a breakthrough was made on several of these open questions. This was achieved by considering a more general decision problem than membership: covering. In the paper, we investigate how the new ideas and techniques brought about by the introduction of this problem can be applied to get new insight on earlier results. In particular, we use them to give new proofs for two of the most famous membership results: Sch\u00fctzenberger's theorem and Simon's theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Historical Context. A prominent question in formal languages theory is to solve the membership problem for classes of regular languages. Given a fixed class C, one must find an algorithm which decides whether an input regular language belongs to C. Such a procedure is called a C-membership algorithm. What motivates this question is the deep insight on the class C that is usually provided by a solution. Intuitively, being able to formulate an algorithm requires a solid understanding of all languages contained in the class C. In other words, membership is used as a mathematical tool whose purpose is to analyze classes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This research effort started with a famous theorem of Sch\u00fctzenberger [36] which describes the class of star-free languages (SF). These are the languages that can be expressed by a regular expression using union, concatenation and complement, but not Kleene star. This is a prominent class which admits natural alternate definitions. For example, the star-free languages are those which can be defined in first-order logic [15] or equivalently in linear temporal logic [11] . Sch\u00fctzenberger's theorem yields an algorithm which decides whether an input regular language is star-free (i.e. an SF-membership algorithm). This provides insight on SF not because of the algorithm itself, but rather because of its proof. Indeed, it includes a generic construction which builds an expression witnessing membership in SF for every input language on which the algorithm answers positively. This result was highly influential and pioneered a very successful line of research. The theorem itself was often revisited [5, 7, 8, 10, 14, 16, 17, 21, 23, 41] and researchers successfully obtained similar results for other prominent classes of languages. Famous examples include the locally testable languages [4, 42] or the piecewise testable languages [38] . However, membership is a difficult question and despite years of investigation, there are still many open problems.",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 73,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 422,
                    "end": 426,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 468,
                    "end": 472,
                    "text": "[11]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1004,
                    "end": 1007,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1008,
                    "end": 1010,
                    "text": "7,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1011,
                    "end": 1013,
                    "text": "8,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1014,
                    "end": 1017,
                    "text": "10,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1018,
                    "end": 1021,
                    "text": "14,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1022,
                    "end": 1025,
                    "text": "16,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1026,
                    "end": 1029,
                    "text": "17,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1030,
                    "end": 1033,
                    "text": "21,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1034,
                    "end": 1037,
                    "text": "23,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 1038,
                    "end": 1041,
                    "text": "41]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 1193,
                    "end": 1196,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1197,
                    "end": 1200,
                    "text": "42]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 1237,
                    "end": 1241,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Among these open problems, a famous one is the dot-depth problem. Brzozowski and Cohen [2] defined a natural classification of the star-free languages: the dot-depth hierarchy. Each star-free language is assigned a \"complexity level\" (called dot-depth) according to the number of alternations between concatenations and complements that are required to define it with an expression. It is known that this hierarchy is strict [3] . Hence, a natural question is whether membership is decidable for each level. This has been a very active research topic since the 70s (see [20, 28, 32] for surveys). Yet, only the first two levels are known to be decidable so far. An algorithm for dot-depth one was published by Knast in 1983 [13] . Despite a lot of partial results along the way, it took thirty more years to solve the next level: the decidability of dot-depth two was shown in 2014 [26, 33] . This situation is easily explained: in practice, getting new membership results always required new conceptual ideas and techniques. In the paper, we are interested in the ideas that led to a solution for dot-depth two.",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 90,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 425,
                    "end": 428,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 570,
                    "end": 574,
                    "text": "[20,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 575,
                    "end": 578,
                    "text": "28,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 579,
                    "end": 582,
                    "text": "32]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 724,
                    "end": 728,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 882,
                    "end": 886,
                    "text": "[26,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 887,
                    "end": 890,
                    "text": "33]",
                    "ref_id": "BIBREF33"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The key ingredient was a new more general decision problem called covering.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Covering. The problem was first considered implicitly in [26] and properly defined later in [31] . Given a class C, the C-covering problem is as follows. The input consists in two objects: a regular language L and a finite set of regular languages L. One must decide whether there exists a C-cover K of L (a finite set of languages in C whose union includes L) such that no language in K intersects all languages in L. Naturally, this definition is more involved than the one of membership and it is more difficult to find an algorithm for C-covering than for Cmembership. Yet, covering was recently shown to be decidable for many natural classes (see for example [6, 24, 25, 30, 34, 35] ) including the star-free languages [29] .",
            "cite_spans": [
                {
                    "start": 57,
                    "end": 61,
                    "text": "[26]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 92,
                    "end": 96,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 664,
                    "end": 667,
                    "text": "[6,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 668,
                    "end": 671,
                    "text": "24,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 672,
                    "end": 675,
                    "text": "25,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 676,
                    "end": 679,
                    "text": "30,",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 680,
                    "end": 683,
                    "text": "34,",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 684,
                    "end": 687,
                    "text": "35]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 724,
                    "end": 728,
                    "text": "[29]",
                    "ref_id": "BIBREF29"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "At the time of its introduction, there were two motivations for investigating this new question. First, while harder, covering is also more rewarding than membership: it yields a more robust understanding of the classes. Indeed, a Cmembership algorithm only yields benefits for the languages of C: we manage to detect them and to build a description witnessing this membership. On the other hand, a C-covering algorithm applies to arbitrary languages. One may view C-covering as an approximation problem: on inputs L and L, we want to overapproximate L with a C-cover while L specifies what an acceptable approximation is. A second key motivation was the application to the dot-depth hierarchy. It turns out that all recent membership results for this hierarchy rely heavily on covering arguments. More precisely, they are based on techniques that allow to lift covering results for a level in the hierarchy as membership results for a higher level (see [32] for a detailed explanation).",
            "cite_spans": [
                {
                    "start": 954,
                    "end": 958,
                    "text": "[32]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In the paper, we are not looking to provide new covering algorithms. Instead, we look at a slightly different question. As we explained, finding an algorithm for C-covering is even harder than for C-membership. Consequently, the recent breakthroughs that were made on this question required developing new ideas, new techniques and new ways to formulate intricate proof arguments. In the paper, we look back at the original membership problem and investigate how these new developments can be applied to get new insight on earlier results. We prove that even if one is only interested in membership, reasoning in terms of \"covers\" is quite natural and rather intuitive when presenting proof arguments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contribution."
        },
        {
            "text": "In particular, C-covers are a very powerful tool for presenting generic constructions which build descriptions of languages in the class C. We illustrate this point by using covers to give new intuitive proofs for two of the most important membership results in the literature: Sch\u00fctzenberger theorem [36] for the star-free languages and Simon's theorem [38] for the piecewise testable languages.",
            "cite_spans": [
                {
                    "start": 301,
                    "end": 305,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 354,
                    "end": 358,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Contribution."
        },
        {
            "text": "Organization of the Paper. We first recall standard terminology about regular languages and define membership in Sect. 2. We introduce covering in Sect. 3 and explain why reasoning in terms of covers is intuitive and relevant even if one is only interested in membership. We illustrate this point in Sect. 4 with a new proof of Sch\u00fctzenberger's theorem. Finally, we present a second example in Sect. 5 with a new proof of Simon's theorem.",
            "cite_spans": [
                {
                    "start": 153,
                    "end": 154,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Contribution."
        },
        {
            "text": "In this section, we briefly recall standard terminology about finite words and classes regular languages. Moreover, we introduce the membership problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Languages. An alphabet is a finite set A. As usual, A * denotes the set of all words over A, including the empty word \u03b5. For w \u2208 A * , we write |w| \u2208 N for the length of w (i.e. the number of letters in w). Moreover, for u, v \u2208 A * , we denote by uv the word obtained by concatenating u and v.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "Given an alphabet A, a language (over A) is a subset of A * . Abusing terminology, we shall often denote by u the singleton language {u}. We lift concatenation to languages: for K, L \u2286 A * , we let KL = {uv | u \u2208 K and v \u2208 L}. Finally, we use Kleene star: if K \u2286 A * , K + denotes the union of all languages K n for n \u2265 1 and K * = K + \u222a {\u03b5}. In the paper, we only consider regular languages. These are the languages that can be equivalently defined by regular expressions, monadic second-order logic, finite automata or finite monoids. We shall use the definition based on monoids which we briefly recall now (see [21] for details).",
            "cite_spans": [
                {
                    "start": 615,
                    "end": 619,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "A monoid is a set M endowed with an associative multiplication (s, t) \u2192 s \u00b7 t (also denoted by st) having a neutral element 1 M . An idempotent of a monoid M is an element e \u2208 M such that ee = e. It is folklore that for any finite monoid M , there exists a natural number \u03c9(M ) (denoted by \u03c9 when M is understood) such that s \u03c9 is an idempotent for every s \u2208 M . Observe that A * is a monoid whose multiplication is concatenation (the neutral element is \u03b5). Thus, we may consider monoid morphisms \u03b1 : A * \u2192 M where M is an arbitrary monoid. Given such a morphism and L \u2286 A * , we say that L is recognized by \u03b1 when there exists a set F \u2286 M such that L = \u03b1 \u22121 (F ). A language L is regular if and only if it is recognized by a morphism into a finite monoid.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "Classes. We investigate classes of languages. Mathematically speaking, a class of languages C is a correspondence A \u2192 C(A) which associates a (possibly infinite) set of languages C(A) over A to every alphabet A. For the sake of avoiding clutter, we shall often abuse terminology and omit the alphabet when manipulating classes. That is, whenever A is fixed and understood, we directly write L \u2208 C to indicate that some language L \u2286 A * belongs to C(A).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "While this is the mathematical definition, in practice, the term \"class\" is used to indicate that C is presented in a specific way. Typically, classes are tied to a particular syntax used to describe all the languages they contain. For example, the regular languages are tied to regular expressions and monadic second-order logic. Consequently, the classes that we consider in practice are natural and have robust properties that we present now.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "A lattice is a class C which is closed under finite union and intersection: for every alphabet A, we have \u2205, A * \u2208 C(A) and for every K, L \u2208 C(A), we have H \u222a L, H \u2229 L \u2208 C(A). Moreover, a Boolean algebra is a lattice C which is additionally closed under complement: for every alphabet A and K \u2208 C(A), we have A * \\ K \u2208 C(A). Finally, we say that a class C is quotient-closed when for every alphabet A, every L \u2208 C(A) and every w \u2208 A * , the following two languages belong to C(A) as well:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "The techniques that we discuss in the paper are meant to be applied for classes that are quotient-closed lattices and contain only regular languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "The two examples that we detail are quotient-closed Boolean algebras of regular languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "Membership. When encountering a new class C, a natural objective is to precisely understand the languages it contains. In other words, we want to understand what properties can be expressed with the syntax defining C. Of course, this is an informal objective. In practice, we rely on a decision problem called membership which we use as a mathematical tool to approach this question. The problem is parameterized by an arbitrary class of languages C: we speak of C-membership. It takes as input a regular language L and asks whether L belongs to C. The key idea is that obtaining an algorithm for C-membership is not possible without a solid understanding of C. In the literature, such an algorithm is also called a decidable characterization of C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular"
        },
        {
            "text": "We are not only interested in C-membership algorithms themselves but also in their correctness proofs. In practice, the deep insight that we obtain on the class C comes from these proofs. Typically, the difficult part in such an argument is to prove that a membership is sound: when it answers positively, prove that the input language does belong to C. Typically, this requires a generic construction for building a syntactic description of the language witnessing its membership in C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "Finding membership algorithms has been an important quest for a long time in formal languages theory. The solutions that were obtained for important classes are milestones in the theory of regular languages [13, 22, 33, 36, 38, 40] . In the paper, we prove two of them: Sch\u00fctzenberger's theorem [36] and Simon's theorem [38] . We frame these proofs using a new formalism based on a more general problem which was recently introduced [31] : covering.",
            "cite_spans": [
                {
                    "start": 207,
                    "end": 211,
                    "text": "[13,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 212,
                    "end": 215,
                    "text": "22,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 216,
                    "end": 219,
                    "text": "33,",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 220,
                    "end": 223,
                    "text": "36,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 224,
                    "end": 227,
                    "text": "38,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "40]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 295,
                    "end": 299,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 320,
                    "end": 324,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 433,
                    "end": 437,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Remark 1."
        },
        {
            "text": "The covering problem generalizes membership. It was first considered implicitly in [26, 27] and was later formalized in [31] (along with a detailed framework designed for handling it). At the time, its introduction was motivated by two reasons. First, an algorithm for covering is usually more rewarding than an algorithm for membership as the former provides more insight on the investigated class of languages. Second, covering was introduced as a key ingredient for handling difficult membership questions. For several important classes, membership is effectively reducible to covering for another simpler class. Recently, this idea was applied to prominent hierarchies of classes called \"concatenation hierarchies\" (see the surveys [28, 32] for details on these results).",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[26,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 88,
                    "end": 91,
                    "text": "27]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 120,
                    "end": 124,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 736,
                    "end": 740,
                    "text": "[28,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 741,
                    "end": 744,
                    "text": "32]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [],
            "section": "The Covering Problem"
        },
        {
            "text": "In the paper, we are interested in covering for a slightly different reason. In particular, we do not present any covering algorithm. Instead, we look at how the new ideas that were recently introduced with covering in mind can be applied in the simpler membership setting. It turns out that even for the early membership results, reasoning in terms of covers is quite natural and allows to present arguments in a very intuitive way. We manage to formulate new proof arguments for two famous membership algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Covering Problem"
        },
        {
            "text": "We first define covering and explain why it generalizes membership as a decision problem. Then, we come back to membership and briefly recall the general approach that is usually followed in order to handle it. We show that this approach can actually be formulated in a convenient and natural way with covering. For the sake of avoiding clutter, we fix an arbitrary alphabet A for the presentation: all languages that we consider are over A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Covering Problem"
        },
        {
            "text": "Similarly to membership, covering is parameterized by an arbitrary class of languages C: we speak of C-covering. It is designed with the same objective in mind: it serves as a mathematical tool for investigating the class C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "For a class C, the C-covering takes a language L and a finite set of languages L as input. It asks whether there exists a C-cover of L which is separating for L. Let us first define these two notions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Given a language L, a cover of L is a finite set of languages K such that L \u2286 K\u2208K K. Additionally, given some class C, a C-cover of L is a cover K of L such that every K \u2208 K belongs to C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Moreover, given two finite sets of languages K and L, we say that K is separating for L if for every K \u2208 K, there exists L \u2208 L which satisfies K \u2229L = \u2205. In other words, there exists no language in K which intersects all languages in L. Given a class C, the C-covering problem is now defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "INPUT: A regular language L and a finite set of regular languages L. OUTPUT: Does there exist a C-cover of L which is separating for L? A simple observation is that covering generalizes another well-known decision problem called separation. Given a class C and two languages L 1 and L 2 , we say that L 1 is C-separable from L 2 when there exists a third language K \u2208 C such that L 1 \u2286 K and K \u2229L 2 = \u2205. We have the following lemma (see [31] for a proof).",
            "cite_spans": [
                {
                    "start": 437,
                    "end": 441,
                    "text": "[31]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Let C be a lattice and L 1 , L 2 two languages. Then L 1 is C-separable from L 2 , if and only if there exist a C-cover of L 1 which is separating for {L 2 }.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2."
        },
        {
            "text": "Lemma 2 proves that C-covering generalizes C-membership as a decision problem. Indeed, given as input a regular language L, it is immediate that L belongs to C if and only if L is C-separable from A * \\ L (which is also regular). Thus, there exists an effective reduction from C-membership to C-covering.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2."
        },
        {
            "text": "Yet, this not the only connection between membership and covering. More importantly, this is not how we use covering in the paper. While each membership algorithm existing in the literature is based on unique ideas (specific to the class under investigation), most of them are formulated and proved within a standard common framework. It turns out that this framework boils down to a particular kind of covering question: this is the property that we shall exploit in the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2."
        },
        {
            "text": "We first summarize the standard general approach that is commonly used to handle membership questions and formulate solutions. Historically, this approach was initiated by Sch\u00fctzenberger who applied it to obtain the first known membership algorithm [36] (for the class of star-free languages). We shall detail and prove this result in Sect. 4.",
            "cite_spans": [
                {
                    "start": 249,
                    "end": 253,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "The syntactic approach. Obtaining a membership algorithm for a given class C is intuitively hard, as it requires to decide a semantic property which may not be apparent on the piece of syntax that defines the input regular language L (be it a regular expression, an automaton or a monoid morphism). To palliate this issue, the syntactic approach relies on the existence of a canonical recognizer for any given regular language. The idea is that while belonging to C may not be apparent on an arbitrary syntax for L, it should be apparent on a canonical representation of L. Typically, the syntactic morphism of L serves as this canonical representation. As the name suggests, this object is a canonical morphism into a finite monoid which recognizes L (and can be computed from any representation of L).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "Let us first define the syntactic morphism properly. Consider a language L. One may associate a canonical equivalence relation \u2261 L over A * to L. Given two words u, v \u2208 A * , we write,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "Clearly, \u2261 L is an equivalence relation and one may verify that it is a congruence for word concatenation:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "Consequently, the quotient set A * /\u2261 L is a monoid called the syntactic monoid of L. Moreover, the map \u03b1 : A * \u2192 A * /\u2261 L which maps each word to its \u2261 L -class is a monoid morphism called the syntactic morphism of L.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "In particular, this morphism recognizes the language L:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "It is well-known and simple to verify that L is regular if and only if its syntactic monoid is finite. Moreover, in that case, one may compute the syntactic morphism of L from any representation of L (such as an automaton or an arbitrary monoid morphism recognizing L).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "We are ready to present the key result behind the syntactic approach: for every quotient-closed Boolean algebra C, membership of an arbitrary regular language in C depends only on its syntactic morphism. This claim is formalized with the following standard result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Application to Membership"
        },
        {
            "text": "Let C be a quotient-closed Boolean algebra, L a regular language and \u03b1 its syntactic morphism. Then L belongs to C if and only if every language recognized by \u03b1 belongs to C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Proof. The right to left implication is immediate since L is recognized by its syntactic morphism. We concentrate on the converse one. Assume that L \u2208 C. We show that every language recognized by \u03b1 belongs to C as well. By definition, these languages are exactly the unions of \u2261 L -classes. Thus, since C is closed under union, it suffices to show that every \u2261 L -class belongs to C. Observe that the definition of \u2261 L can be reformulated as follows. Given u, v \u2208 A * , we have,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Let x, y \u2208 A * . Since L is recognized by \u03b1, it is clear that whether some word w \u2208 A * belongs to x \u22121 Ly \u22121 depends only on its image \u03b1(w). In other words, x \u22121 Ly \u22121 is recognized by \u03b1. Moreover, since L is regular, its syntactic monoid is finite which implies that \u03b1 recognizes finitely many languages. Thus, while there are infinitely many words x, y \u2208 A * , there are finitely many languages x \u22121 Ly \u22121 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Altogether, we obtain that every \u2261 L -class is a finite Boolean combination of languages x \u22121 Ly \u22121 where x, y \u2208 A * . Since L \u2208 C and C is quotient-closed, every such language belongs to C. Hence, since C is a Boolean algebra, we conclude that every \u2261 L -class belongs to C, completing the proof. Proposition 3 implies that membership of a regular language L in some fixed quotient-closed Boolean algebra is equivalent to some property of an algebraic abstraction of L: its syntactic morphism. In particular, this is independent from the accepting set F = \u03b1(L). By itself, this is a simple result. Yet, it captures the gist of the syntactic approach.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Naturally, the proposition tells nothing about the actual the property on the syntactic morphism that one should look for. This question is specific to each particular class C: one has to find the right decidable property characterizing C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Remark 4. This may seem counterintuitive. We replaced the question of deciding whether a single language belongs to the class C by an intuitively harder one: deciding whether all languages recognized by a given monoid morphism belong to C. The idea is that the set of languages recognized by a morphism has a structure which can be exploited in membership arguments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Remark 5. Proposition 3 is restricted quotient-closed Boolean algebras. This excludes quotient-closed lattices that are not closed under complement. One may generalize the syntactic approach to such classes (as done by Pin [19] ). We do not discuss this as our two examples are quotient-closed Boolean algebras.",
            "cite_spans": [
                {
                    "start": 223,
                    "end": 227,
                    "text": "[19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Back to Covering. We proved that for every quotient-closed Boolean algebra C, the associated membership problem boils down to deciding whether all languages recognized by an input morphism belong to C. It turns out that this new question is a particular instance of C-covering. In order to explain this properly, we require a last definition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "Consider a morphism \u03b1 : A * \u2192 M into a finite monoid M and a finite set of languages K. We say that K is confined by \u03b1 if it is separating for the set",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "The following fact can be verified from the definitions and reformulates this property in a way that is easier to manipulate. Fact 6. Let \u03b1 : A * \u2192 M be a morphism into a finite monoid and K a finite set of languages. Then K is confined by \u03b1 if and only if for every K \u2208 K, there exists s \u2208 M such that K \u2286 \u03b1 \u22121 (s).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 3."
        },
        {
            "text": "We show that given a lattice C and a morphism \u03b1 : A * \u2192 M into a finite monoid, all languages recognized by \u03b1 belong to C if and only if there exists a C-cover of A * which is confined by \u03b1. The latter question is a particular case of C-covering. In fact, we prove a slightly more general result that we shall need later when dealing with our two examples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "Proposition 7 Let C be a lattice, \u03b1 : A * \u2192 M a morphism into a finite monoid and H \u2208 C a language. The two following properties are equivalent:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "1. For every language L recognized by \u03b1, we have L \u2229 H \u2208 C. 2. There exists a C-cover of H which is confined by \u03b1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "Proof. Assume first that L \u2229 H \u2208 C for every language L recognized by \u03b1. We",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "Clearly, K is a cover of H and it is a C-cover by hypothesis. Moreover, it is clear from Fact 6 that K is confined by \u03b1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "For the converse direction, assume that there exists a C-cover K of H which is confined by \u03b1. Let L be a language recognized by \u03b1, we show that,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "This implies that L \u2229 H \u2208 C since H \u2208 C, every language in K belongs to C and C is a lattice. The left to right inclusion is immediate since K is a cover of H. We prove the converse one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "Let us combine Propositions 3 and 7. When put together, they imply that for every quotient-closed Boolean algebra C, a regular language L belongs to C if and only if there exists a C-cover of A * which is confined by the syntactic morphism of L.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "The key point is that this formulation is very convenient when writing proof arguments. As we explained in Remark 1, the technical core of membership proofs consists in generic constructions which build descriptions of languages in C. It turns out that building a C-cover which is confined by some input morphism is an objective that is much easier to manipulate than directly proving that all languages recognized by the morphism belong to C. We illustrate this point in the next section with new proofs for two well-known membership algorithms: the star-free languages and the piecewise testable languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof. By definition K is confined by \u03b1 if and only if for every"
        },
        {
            "text": "We now illustrate the discussion of the previous section with a first example: Sch\u00fctzenberger's theorem [36] . This result is important as it started the quest for membership algorithms. It provides such an algorithm for a very famous class: the star-free languages (SF). Informally, these are the languages which can be defined by a regular expression in which the Kleene star is disallowed (hence the name \"star-free\") but a new operator for the complement operation is allowed instead. This class is important as it admits several natural alternate definitions. For example, the star-free languages are those which can be defined in first-order logic [15] or equivalently in linear temporal logic [11] .",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 108,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 654,
                    "end": 658,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 700,
                    "end": 704,
                    "text": "[11]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Star-Free Languages and Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Sch\u00fctzenberger's theorem states an algebraic characterization of SF: a regular language is star-free if and only if its syntactic monoid is aperiodic. This yields an algorithm for SF-membership as aperiodicity is a decidable property of finite monoids. Historically, Sch\u00fctzenberger's theorem was the first result of its kind. It motivated the systematic investigation of the membership problem for important classes of languages. It is often viewed as one of the most important results of automata theory. This claim is supported by the number of times this theorem has been revisited over the years and the wealth of existing proofs [5, 7, 8, 10, 14, 16, 17, 21, 23, 41] .",
            "cite_spans": [
                {
                    "start": 634,
                    "end": 637,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 638,
                    "end": 640,
                    "text": "7,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 641,
                    "end": 643,
                    "text": "8,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 644,
                    "end": 647,
                    "text": "10,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 648,
                    "end": 651,
                    "text": "14,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 652,
                    "end": 655,
                    "text": "16,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 656,
                    "end": 659,
                    "text": "17,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 660,
                    "end": 663,
                    "text": "21,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 664,
                    "end": 667,
                    "text": "23,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 668,
                    "end": 671,
                    "text": "41]",
                    "ref_id": "BIBREF41"
                }
            ],
            "ref_spans": [],
            "section": "Star-Free Languages and Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "In this section, we present our own proof, based on SF-covers. Let us point out that while the formulation is new, the original ideas behind the argument can be traced back to the proof of Wilke [41] . We first recall the definition of the star-free languages. Then, we state the theorem properly and present the proof.",
            "cite_spans": [
                {
                    "start": 195,
                    "end": 199,
                    "text": "[41]",
                    "ref_id": "BIBREF41"
                }
            ],
            "ref_spans": [],
            "section": "Star-Free Languages and Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Let us define the class of star-free languages (SF). For every alphabet A, SF(A) is the least set containing \u2205 and all singletons {a} for a \u2208 A, which is closed under union, complement and concatenation. That is, for every K, L \u2208 SF(A), the languages K \u222a L, A * \\ K and KL belong to SF(A) as well. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Another standard example is (ab) * (where a, b are two distinct letters of A). Indeed, (ab) * is the complement of bA * \u222a A * aaA * \u222a A * bbA * \u222a A * a (provided that A = {a, b}) which is clearly star-free.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "By definition, SF is a Boolean algebra and one may verify that it is quotientclosed (the details are left to the reader). We complete the definition with a standard property that we require to prove the \"easy\" direction of Sch\u00fctzenberger's theorem (every star-free language has an aperiodic syntactic monoid). Another typical application of this property is to show that examples of languages are not star-free. For example, (AA) * (words with even length) is not star-free since since it does not satisfy the following lemma.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Let A be an alphabet and L \u2208 SF(A). There exists a number k \u2265 1 such that for every \u2265 k and w \u2208 A * , we have w \u2261 L w +1 . Proof. We proceed by structural induction on the definition of L as a star-free language. When L = \u2205, it is clear that the lemma holds for k = 1. When L = {a} for a \u2208 A, one may verify that the lemma holds for k = 2. We turn to the inductive cases. Assume first that L = L 1 \u222a L 2 where L 1 , L 2 \u2208 SF are simpler languages. Induction yields k 1 , k 2 \u2265 1 such that for i = 1, 2, if \u2265 k i and w \u2208 A * , we have w \u2261 Li w +1 . Hence, the lemma holds for k = max(k 1 , k 2 ) in that case. We turn to complement: L = A * \\ H where H \u2208 SF is a simpler language. By induction, we get h \u2265 1 such that for every w \u2208 A * and \u2265 h, we have w \u2261 H w +1 . Clearly, the lemma holds for k = h.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 9"
        },
        {
            "text": "We now consider concatenation: L = L 1 L 2 where L 1 , L 2 \u2208 SF are simpler languages. Induction yields k 1 , k 2 \u2265 1 such that for i = 1, 2, if \u2265 k i and w \u2208 A * , we have w \u2261 Li w +1 . Let m be the maximum between k 1 and k 2 . We prove that the lemma holds for k = 2m + 1. Let w \u2208 A * and \u2265 k, we have to show that w \u2261 L w +1 , i.e. xu y \u2208 L \u21d4 xu +1 y \u2208 L for every x, y \u2208 A * . We concentrate on the right to left implication (the converse one is symmetrical). Assume that xu +1 y \u2208 L. Since L = L 1 L 2 , we get w 1 \u2208 L 1 and w 2 \u2208 L 2 such that xu k+1 y = w 1 w 2 . Since k \u2265 2m + 1, it follows that either xu m+1 is a prefix of w 1 or u m+1 y is a suffix of w 2 . By symmetry, we assume that the former property holds: we have w 1 = xu m+1 z for some z \u2208 A * . Observe that since xu k+1 y = w 1 w 2 , it follows that zw 2 = u k\u2212m y. Moreover, we have m \u2265 k 1 by definition of m. Since xu m+1 z = w 1 \u2208 L 1 , we know therefore that xu m z \u2208 L 1 by definition of k 1 . Thus, xu m zw 2 \u2208 L 1 L 2 = L. Since zw 2 = u k\u2212m y, this yields xu k y \u2208 L, concluding the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 9"
        },
        {
            "text": "We may now present and prove Sch\u00fctzenberger's theorem. Let us first define aperiodic monoids. There are several equivalent definitions in the literature. We use an equational one based on the idempotent power \u03c9 available in finite monoids. A finite monoid M is aperiodic when it satisfies the following property:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "We are ready to state Sch\u00fctzenberger's theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Theorem 10 (Sch\u00fctzenberger [36] ). A regular language is star-free if and only if its syntactic monoid is aperiodic.",
            "cite_spans": [
                {
                    "start": 27,
                    "end": 31,
                    "text": "[36]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Theorem 10 illustrates of the syntactic approach presented in Sect. 3. It validates Proposition 3: the star-free languages are characterized by a property of their syntactic morphism. In fact, for this particular class, one does not even need the full morphism, the syntactic monoid suffices.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "The main application is a membership algorithm for the class of star-free languages. Given as input a regular language L, one may compute its syntactic monoid and check whether it satisfies Eq. (1): this boils down to testing all elements in the monoid. By Theorem 10, this decides whether L is star-free. However, as we explained in Remark 1 when we first introduced membership, this theorem is also important for the arguments that are required to prove it. Indeed, providing these arguments requires a deep insight on SF. The right to left implication is of particular interest: \"given a regular language whose syntactic monoid is aperiodic, prove that it is star-free\". This involves devising a generic way to construct a star-free description for every regular language recognized by a monoid satisfying a syntactic property. This is the implication that we handle with covers. On the other hand, the converse implication is simple and standard (essentially, we already proved it with Lemma 9).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Proof. We fix an alphabet A and a regular language L \u2286 A * for the proof. Let \u03b1 : A * \u2192 M be the syntactic morphism of L. We prove that L \u2208 SF(A) if and only if M is aperiodic. Let us first handle the left to right implication.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "From star-free languages to aperiodicity. Assume that L \u2208 SF(A). We prove that M is aperiodic, i.e. that (1) is satisfied. Let s \u2208 M , we have to show that s \u03c9 = s \u03c9+1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Since \u03b1 is a syntactic morphism, it is surjective and there exists w \u2208 A * such that \u03b1(w) = s. Moreover, since L \u2208 SF(A), Lemma 9 yields k \u2265 1 such that w k\u03c9 \u2261 L w k\u03c9+1 . By definition of the syntactic morphism, this implies that \u03b1(w k\u03c9 ) = \u03b1(w k\u03c9+1 ). Since \u03b1(w) = s, this yields s \u03c9 = s \u03c9+1 as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "From aperiodicity to star-free languages. Assume that M is aperiodic. We show that L is star-free. We rely on the notions introduced in the Sect. 3 and directly prove that every language recognized by \u03b1 is star-free.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Remark 11. Intuitively, this property is stronger than L being star-free. Yet, since SF is a quotient-closed Boolean algebra, it is equivalent by Proposition 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "The argument is based on Proposition 7: we use induction to construct an SF-cover K of A * which is confined by \u03b1. By the proposition, this implies that every language recognized by \u03b1 belongs to SF(A). We start with a preliminary definition that we require to formulate the induction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Let B be an arbitrary alphabet, \u03b2 : B * \u2192 M a morphism and s \u2208 M . We say that a finite set of languages K (over B) is (s, \u03b2)-safe if for every K \u2208 K and every w, w \u2208 K, we have s\u03b2(w) = s\u03b2(w ). We first use Lemma 12 to conclude the main argument. We apply the lemma for B = A, \u03b2 = \u03b1 and s = 1 M . This yields an SF-cover K of A * which is (1 M , \u03b1)safe. By definition, it follows that for every K \u2208 K, we have \u03b1(w) = \u03b1(w ) for all K \u2208 K. By Fact 6, this implies that K is confined by \u03b1, completing the main argument.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "It remains to prove Lemma 12. Let B be an alphabet, \u03b2 : B * \u2192 M a morphism, C \u2286 B and s \u2208 M . We build an SF-cover K of C * which is (s, \u03b2)-safe using induction on the three following parameters listed by order of importance: We distinguish two cases depending on the following property of \u03b2, C and s. We say that s is (\u03b2, C)-stable when the following holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "for every c \u2208 C, s\u03b2(C * ) = s\u03b2(C * c).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "(2)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "We first consider the case when s is (\u03b2, C)-stable. This is the base case which we handle using the hypothesis that M is aperiodic.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "Base case: s is (\u03b2, C)-stable. In that case, we define K = {C * } which is clearly an SF-cover of C * (we have C * \u2208 SF(B) as seen in Example 8). It remains to show that K is (s, \u03b2)-safe. For w, w \u2208 C * , we have to show that s\u03b2(w) = s\u03b2(w ). We actually prove that s\u03b2(w) = s for every w \u2208 C * which implies the desired result. Since s is (\u03b2, C)-stable, we have the following fact.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sch\u00fctzenberger's Theorem"
        },
        {
            "text": "For every u \u2208 C * , there exists t \u2208 \u03b2(C * ) such that st\u03b2(u) = s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 14."
        },
        {
            "text": "Proof. We use induction on the length of u \u2208 C * . If u = \u03b5, the fact holds for t = 1 M . Assume now that u \u2208 C + . We have u = cu for u \u2208 C * and c \u2208 C. Induction yields t \u2208 \u03b2(C * ) such that st \u03b2(u ) = s. Moreover, since s is (\u03b2, C)stable, (2) yields t \u2208 \u03b2(C * ) such that st\u03b2(c) = st . Altogether, we obtain that st\u03b2(u) = st\u03b2(c)\u03b2(u ) = st \u03b2(u ) = s which concludes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 14."
        },
        {
            "text": "Consider the word w \u03c9 \u2208 C * (with \u03c9 as the idempotent power of M ). We apply Fact 14 for u = w \u03c9 . This yields t \u2208 \u03b2(C * ) such that s = st(\u03b2(w)) \u03c9 . Since M is aperiodic, we have (\u03b2(w)) \u03c9 = (\u03b2(w)) \u03c9+1 by Eq. (1). This yields s\u03b2(w) = st(\u03b2(w)) \u03c9+1 = st(\u03b2(w)) \u03c9 = s, concluding the base case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 14."
        },
        {
            "text": "Inductive case: s is not (\u03b2, C)-stable. By hypothesis, there exists a letter c \u2208 C such that the following strict inclusion holds s\u03b2(C * c) s\u03b2(C * ). We fix c \u2208 C for the remainder of the argument.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 14."
        },
        {
            "text": "Let D be the sub-alphabet D = C \\ {c}. By definition, |D| < |C|. Hence, induction on our second parameter in Lemma 12 (i.e., the size of C) yields an SFcover H of D * which is (1 M , \u03b2)-safe. Note that it is clear that our first induction parameter (the size of \u03b1(C + )) has not increased since D \u2286 C.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 14."
        },
        {
            "text": "We distinguish two independent sub-cases. Clearly, we have \u03b2(C * c) \u2286 \u03b2(C + ). The argument differs depending on whether this inclusion is strict or not.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 14."
        },
        {
            "text": "Since H is a cover of D * which is (1 M , \u03b2)-safe by definition, there exists some element t H \u2208 \u03b2(D * ) such that \u03b2(w) = t H for every w \u2208 H. The construction of the desired SF-cover K of C * is based on the following fact which we prove using induction on our third parameter (the size of s\u03b2(C * )).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sub-case 1: \u03b2(C * c) = \u03b2(C + ). Consider a language H \u2208 H."
        },
        {
            "text": "Proof. Since t H \u2208 \u03b2(D * ), it is immediate that st H \u03b2(c) \u2208 s\u03b2(D * c). Hence, st H \u03b2(c)\u03b2(C * ) \u2286 s\u03b2(C + ). Moreover, \u03b2(C * c) = \u03b2(C + ) by hypothesis in Subcase 1. Thus, st H \u03b2(c)\u03b2(C * ) \u2286 s\u03b2(C * c). Finally, recall that the letter c satisfies s\u03b2(C * c) s\u03b2(C * ) by definition. Consequently, we have the strict inclusion st H \u03b2(c)\u03b2(C * ) s\u03b2(C * ). Hence, we may apply induction on our third parameter in Lemma 12 (i.e. the size of s\u03b2(C * )) to obtain the desiredn SF-cover U H of C * which is (st H \u03b2(c), \u03b2)-safe. Note that here, our first two parameters have not increased (they only depend on \u03b2 and C which remain unchanged).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 15. For every language H \u2208 H, there exists an SF-cover"
        },
        {
            "text": "We may now use Fact 15 to build the desired cover K of C * . We define K = H \u222a {HcU | H \u2208 H and U \u2208 U H }. Clearly, K is an SF-cover of C * by hypothesis on H and U H since D = C \\{c} and SF is closed under concatenation. We need to show that K is (s, \u03b2)-safe. Let K \u2208 K and w, w \u2208 K, we need to show that s\u03b2(w) = s\u03b2(w ). By definition of K, there are two cases. When K \u2208 H, the result is immediate since H is (1 M , \u03b2)-safe by definition. Otherwise, K = HcU for H \u2208 H and U \u2208 U H . Thus, we get x, x \u2208 H and u, u \u2208 U such that w = xcu and w = x cu . By definition,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 15. For every language H \u2208 H, there exists an SF-cover"
        },
        {
            "text": "Altogether, this yields s\u03b2(xcu) = s\u03b2(x cu ), i.e. s\u03b2(w) = s\u03b2(w ) as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 15. For every language H \u2208 H, there exists an SF-cover"
        },
        {
            "text": "\u03b2(C + ). Let us first explain informally how the cover K of C * is built in this case. Let w \u2208 C * . Since D = C \\ {c}, w admits a unique decomposition w = uv such that u \u2208 (D * c) * and v \u2208 D * (i.e., v is the largest suffix of w in D * and u is the corresponding prefix). Using induction, we construct SF-covers of the possible prefixes and suffixes. Then, we combine them to construct a cover of the whole set C * . Actually, we already covered the suffixes: we have an SF-cover H of C * which is (1 M , \u03b2)-safe. It remains to cover the prefixes. We do so this in the following lemma which we prove using induction on our first parameter (the size of \u03b2(C + )).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sub-case 2: \u03b2(C * c)"
        },
        {
            "text": "There exists an SF-cover V of (D * c) * which is (1 M , \u03b2)-safe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "Proof. Let E = \u03b2(D * c). Using E as a new alphabet, we apply induction on the first parameter in Lemma 12 (i.e., the size of \u03b2(C + )) to build an auxiliary SF-cover of E * which we then use to construct V.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "Since E = \u03b2(D * c) \u2286 M , there exists a natural morphism \u03b3 : E * \u2192 M defined by \u03b3(e) = e for every e \u2208 E. Clearly, \u03b3(E + ) \u2286 \u03b2(C * c). Since \u03b2(C * c) \u03b2(C + ) by hypothesis of Sub-case 2, this implies \u03b3(E + ) \u03b2(C + ) and induction on the first parameter in Lemma 12 yields an SF-cover W of E * which is (1 M , \u03b3)-safe. We use W to construct V. First, we define a map \u03bc : (D * c) * \u2192 E * .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "We let \u03bc(\u03b5) = \u03b5. Otherwise, let w \u2208 (D * c) + be a nonempty word. Since c \u2208 D, w admits a unique decomposition w = w 1 \u00b7 \u00b7 \u00b7 w n with w 1 , . . . , w n \u2208 D * c. Hence, we may define \u03bc(w 1 \u00b7 \u00b7 \u00b7 w n ) = e 1 \u00b7 \u00b7 \u00b7 e n with e i = \u03b2(w i ) for every i \u2264 n (recall that E = \u03b2(D * c) by definition). We are ready to define W. We let,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "It remains to show that V is an SF-cover of (D * c) * which is (1 M , \u03b2)-safe. It is immediate that V is a cover of (D * c) * since W was a cover of E * .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "Let us prove that V is (1 M , \u03b2)-safe. Let V \u2208 V and v, v \u2208 V . We prove that \u03b2(v) = \u03b2(v ). By definition, there exists w \u2208 W such that V = \u03bc \u22121 (W ). Thus, (1 M , \u03b3) -safe by definition. One may now verify from the definitions that \u03b3(\u03bc(v)) = \u03b2(v) and \u03b3(\u03bc(v )) = \u03b2(v ). Thus, we obtain \u03b2(v) = \u03b2(v ) as desired.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 157,
                    "end": 166,
                    "text": "(1 M , \u03b3)",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Lemma 16."
        },
        {
            "text": "It remains to show that every V \u2208 V is star-free. By definition of V, it suffices to show that for every W \u2208 SF(E), we have \u03bc \u22121 (W ) \u2208 SF(B). We proceed by induction on the definition of W as a star-free language. When W = \u2205, it is clear that \u03bc \u22121 (W ) = \u2205 \u2208 SF(B). Assume now that W = {e} for some e \u2208 E. By definition, \u03bc \u22121 (e) = {w \u2208 D * c | \u03b2(w) = e}. This may be reformulated as follows: \u03bc \u22121 (e) = Uc with U = {u \u2208 D * | \u03b2(uc) = e}. Clearly, U is the intersection of D * with a language recognized by \u03b2. Recall that we have an SF-cover H of D * which is (1 M , \u03b2)-safe (and therefore confined by \u03b2). Hence, Proposition 7 implies that U \u2208 SF(B). It follows that \u03bc \u22121 (e) = Uc \u2208 SF(B) as desired. We turn to the inductive cases.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "First, assume that there are simpler languages W 1 , W 2 \u2208 SF(E) such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "We are ready to construct the desired SF-cover K of C * . Let V be the (1 M , \u03b2)-safe SF-cover of (D * c) * given by Lemma 16 and consider our (1 M , \u03b2)safe SF-cover H of D * . We define K = {V H | V \u2208 V and H \u2208 H}. It is immediate by definition that K is an SF-cover of C * since D = C \\ {c} and SF is closed under concatenation. It remains to verify that K is (s, \u03b2)-safe (it is in fact (1 M , \u03b2)-safe). Let K \u2208 K and w, w \u2208 K, we show that \u03b2(w) = \u03b2(w ) (which implies s\u03b2(w) = s\u03b2(w )). By definition, K = V U with V \u2208 V and U \u2208 U. Therefore, w = vu and w = v u with u, u \u2208 U and v, v \u2208 V . Since U and V are both (1 M , \u03b2)-safe by definition, we have \u03b2(u) = \u03b2(u ) and \u03b2(v) = \u03b2(v ). It follows that \u03b2(w) = \u03b2(w ). This concludes the proof of Lemma 12.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 16."
        },
        {
            "text": "We turn to our second example: Simon's theorem [38] . This results states an algebraic characterization of another prominent class of regular languages: the piecewise testable languages (PT). It is quite important in the literature as it was among the first results of this kind after Sch\u00fctzenberger's theorem (which we proved in Sect. 4). Over the years, many different proofs have been found (examples include [1, 9, 12, 18, 38, 39] ). We present a new proof, based on PTcovers and entirely independent from previously known arguments. It relies on a concatenation principle for the piecewise testable languages that can only be formulated with PT-covers.",
            "cite_spans": [
                {
                    "start": 47,
                    "end": 51,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 412,
                    "end": 415,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 416,
                    "end": 418,
                    "text": "9,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 419,
                    "end": 422,
                    "text": "12,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 423,
                    "end": 426,
                    "text": "18,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 427,
                    "end": 430,
                    "text": "38,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 431,
                    "end": 434,
                    "text": "39]",
                    "ref_id": "BIBREF39"
                }
            ],
            "ref_spans": [],
            "section": "Piecewise Testable Languages and Simon's Theorem"
        },
        {
            "text": "We first recall the definition of piecewise testable languages. Then, we state the theorem properly and present the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Piecewise Testable Languages and Simon's Theorem"
        },
        {
            "text": "Let us define the class of piecewise testable languages (PT). Given an alphabet A and u, v \u2208 A * , we say that u is a piece of v and write u v when u can be obtained from v by removing letters and gluing the remaining ones together. More precisely, u v when there exist a 1 , . . . , a n \u2208 A and v 0 , . . . , v n \u2208 A * such that, u = a 1 a 2 \u00b7 \u00b7 \u00b7 a n and v = v 0 a 1 v 1 a 2 v 2 \u00b7 \u00b7 \u00b7 v n\u22121 a n v n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "For instance, acb is a piece of bbabcbcbba. Note that by definition, the empty word \"\u03b5\" is a piece of every word (this is the case n = 0). Furthermore, it is clear that the relation is a preorder on A * .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "For every word u \u2208 A * , we write \u2191u \u2286 A * for the language consisting of all words v such that u is a piece of v. If u = a 1 \u00b7 \u00b7 \u00b7 a n , we have by definition:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "We may now define PT. A language L \u2286 A * is piecewise testable (i.e. L \u2208 PT(A)) when L is a (finite) Boolean combination of languages \u2191w for w \u2208 A * . Example 17. We let A = {a, b} as the alphabet. Then a + b + \u2208 PT(A). Indeed, a + b + = A * aA * bA * \\ A * bA * aA * . Moreover, observe that every finite language is piecewise testable. Since PT is closed under union, it suffices to show that every singleton is piecewise testable. Consider a word w = a 1 \u00b7 \u00b7 \u00b7 a n . By definition, w is the only word belonging to A * a 1 A * a 2 A * \u00b7 \u00b7 \u00b7 a n\u22121 A * a n A * but not to",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": ". . , b n+1 denotes any sequence of n + 1 letters. Hence, {w} is piecewise testable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Clearly PT is a Boolean algebra and one may verify that it is quotientclosed (the details are left to the reader). We complete the definition with two properties of PT. The first one is standard and we shall need it to prove that \"easy\" direction of Simon's theorem (every piecewise testable language satisfies the characterization).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "The second result is specific to our covering-based approach for proving Simon's theorem. It turns out that elegant proof arguments for membership algorithms often apply to classes that are closed under concatenation (or some weak variant thereof). As seen in the previous section, the star-free languages are an example. Unfortunately, PT is not closed under concatenation. For example, consider the alphabet A = {a, b}. We have A * \u2208 PT and {a} \u2208 PT as seen in Example 17. Yet, one may verify with Lemma 18 that A * a \u2208 PT.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "We solve this issue with a \"weak concatenation principle\" for piecewise testable languages. This result can only be formulated using PT-covers. While its proof is rather technical, an interesting observation is that it characterizes the piecewise testable languages. In the proof of Simon's theorem, we only use this concatenation principle and the hypothesis that PT is a Boolean algebra (we never come back to the original definition of PT).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Let u, v \u2208 A * and a \u2208 A. Moreover, let K u and K v be PTcovers of \u2191u and \u2191v respectively. There exists a PT-cover K of \u2191(uav) such that for every",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 19."
        },
        {
            "text": "Proof. We start with standard definitions that we need to describe K. For every k \u2208 N, we associate a preorder k over A * . For w, w \u2208 A * , we write w k w to indicate that for every x \u2208 A * such that |x| \u2264 k, we have x w \u21d2 x w . Clearly, k is a preorder which is coarser than : for every w, w such that w w , we have w k w . Moreover, we write \u223c k for the equivalence generated by this preorder: w \u223c k w if and only if x w \u21d4 x w for every x \u2208 A * such that |x| \u2264 k. Clearly, \u223c k has finite index.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 19."
        },
        {
            "text": "Since K u and K v are PT-covers, there exists some number k \u2208 N every language K \u2208 K u \u222a K v is a finite Boolean combination of languages \u2191x for x \u2208 A * such that |x| \u2264 k. In other words, every such language K is a union of \u223c k -classes. Moreover, we may choose k so that |u| \u2264 k and |v| \u2264 k. We shall define the cover K as a set of \u223c h -classes for an appropriate number h that we choose using the following technical lemma.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 19."
        },
        {
            "text": "Let h \u2265 2|A| k+1 +1, a \u2208 A and u , v , w \u2208 A * such that u av h w. There exist u , v \u2208 A * such that w = u av , u k u and v k v .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 20."
        },
        {
            "text": "Proof. We claim that there exist y, z \u2208 A * with length at most |A| k+1 such that y u k y and z v k z. We first use this claim to prove the lemma. Clearly, |yaz| \u2264 2|A| k+1 + 1 \u2264 h and yaz u av . Therefore, since u av h w, it follows that yaz w. This yields a decomposition w = u av such that y u and z v . Since u k y and v k z, this implies u k u and v k v as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 20."
        },
        {
            "text": "It remains to prove the claim. We only construct a piece y \u2208 A * such that |y| \u2264 |A| k+1 and y u k y, as the construction of z is analogous. Let F be the set of all pieces of u of size at most k, that is,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 20."
        },
        {
            "text": "Clearly, |F | \u2264 |A| k+1 . For x \u2208 A * , let L F (x) be the set of words of F that are pieces of x. Let u = u 1 au 2 be some decomposition of u . Note that L F (u 1 ) \u2286 L F (u 1 a).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 20."
        },
        {
            "text": "We say that the occurrence of a given by the decomposition u = u 1 au 2 is bad if L F (u 1 ) = L F (u 1 a). Let y be the word obtained from u by deleting all bad letters (and keeping the other ones). By construction, y u and L F (y) = L F (u ). The latter property implies that u y for every u \u2208 F . By definition of F , this means that u k y. Furthermore, letters of y are not bad, and one may verify that there are at most |L F (u )| = |F | such letters. Therefore, |y| \u2264 |F | \u2264 |A| k+1 , which concludes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 20."
        },
        {
            "text": "We define h = 2|A| k+1 + 1. It is immediate that every \u223c h -class is a language of PT (it is a Boolean combination of languages \u2191x for x \u2208 A * such that |x| \u2264 h). Hence, the set K containing all \u223c h -classes which intersect \u2191(uav) is a PT-cover of \u2191(uav). It remains to show that for every K \u2208 K, there exist K u \u2208 K u and K v \u2208 K v such that K \u2286 K u aK v . We fix the language K \u2208 K for the proof. We need the following result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 20."
        },
        {
            "text": "Let H \u2286 K be a finite language. There exist K \u2208 K u and K \u2208 K v such that H \u2286 K aK .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "Proof. Let w 1 , . . . , w n \u2208 A * be the words in H, i.e., H = {w 1 , . . . , w n }. Our goal is to find K \u2208 K u and K \u2208 K v such that w i \u2208 K aK for all i = 1, . . . , n. Therefore, we first have to find a suitable decomposition of each word w i as u i av i , and then to show that all u i 's belong to some K \u2208 K u and all v i 's belong to some K \u2208 K v . By definition, K is a \u223c h -class and it intersects \u2191(uav). This yields a word x \u2208 \u2191(uav) such that x \u223c h w 1 \u223c h \u00b7 \u00b7 \u00b7 \u223c h w n . Since x \u2208 \u2191(uav), there exist u \u2208 \u2191u and v \u2208 \u2191v such that x = u av . Let = |w 1 | + 1. We may write the relations x \u223c h w 1 \u223c h \u00b7 \u00b7 \u00b7 \u223c h w n as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "Since h \u2265 2|A| k+1 + 1 by definition, may apply Lemma 20 n times to get u 1,1 , . . . , u n,1 , . . . , u 1, , . . . , u n, \u2208 A * and v 1,1 , . . . , v n,1 , . . . , v 1, , . . . , v n, \u2208 A * such that, -for every i \u2264 n and j \u2264 , we have w i = u i,j av i,j , and, -u k u 1,1 k \u00b7 \u00b7 \u00b7 k u n,1 k \u00b7 \u00b7 \u00b7 k u 1, k \u00b7 \u00b7 \u00b7 k u n, , and,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "Since = |w 1 |+1, the first property and the pigeonhole principle yield j 1 < j 2 \u2264 such that u 1,j1 = u 1,j2 and v 1,j1 = v 1,j2 . For every i \u2264 n, we let u i = u i,j1 and v i = v i,j1 . Therefore, for all i = 1, . . . , n, we have w i = u i av i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "The second and third properties now yield u k u 1 k \u00b7 \u00b7 \u00b7 k u n k u 1 and v k v 1 k \u00b7 \u00b7 \u00b7 k v n k v 1 , whence:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "Recall that |u| \u2264 k by definition of k. Since u \u2208 \u2191u and u k u 1 , it follows that u 1 \u2208 \u2191u. Since K u is a cover of \u2191u, this yields K \u2208 K u such that u 1 \u2208 K .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "Since K is a union of \u223c k -classes by choice of k and since u 1 \u223c k \u00b7 \u00b7 \u00b7 \u223c k u n , we deduce that u 1 , . . . , u n \u2208 K . Symmetrically, we obtain K \u2208 K v such that v 1 , . . . , v n \u2208 K . Finally, since w i = u i av i for every i \u2264 n, this yields H = {w 1 , . . . , w n } \u2286 K aK , as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "We may now finish the proof. For every n \u2208 N, we let H n \u2286 K be the (finite) language containing all words of length at most n in K. Clearly, K = n\u2208N H n and H n \u2286 H n+1 for every n \u2208 N. Moreover, Lemma 21 implies that for every n \u2208 N, we have K n \u2208 K u and K n \u2208 K v such that H n \u2286 K n aK n . Since K u and K v are finite sets, there exist K u \u2208 K u and K v \u2208 K v such that K n = K u and K n = K v for infinitely many n. Since H n \u2286 H n+1 for every n \u2208 N, it then follows that H n \u2286 K u aK v for every n \u2208 N. Finally, since K = n\u2208N H n , this implies K \u2286 K u aK v which concludes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 21."
        },
        {
            "text": "We may now present and prove Simon's theorem. It characterizes the star-free languages as those whose syntactic monoid is J-trivial. The original definition of this notion is based on the Green relation J defined on every finite monoid. Here, we do not consider this relation. Instead, we use an equational definition. A finite monoid M is J-trivial when it satisfies the following property:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "Theorem 22 (Simon [38] ). A regular language is piecewise testable if and only if its syntactic monoid is J-trivial.",
            "cite_spans": [
                {
                    "start": 18,
                    "end": 22,
                    "text": "[38]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "As expected, the main application of Simon's theorem is the decidability of PT-membership. Given a regular language L as input, one may compute its syntactic monoid and check whether it satisfies Eq. (3) by testing all possible combinations. By Theorem 22, this decides whether L is piecewise testable. Yet, as for the star-free languages in Sect. 4, this theorem is also important for the arguments that are required to prove it. We present such a proof now.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "Proof. We fix an alphabet A and a regular language L \u2286 A * for the proof. Let \u03b1 : A * \u2192 M be the syntactic morphism of L. We prove that L \u2208 PT(A) if and only if M is J-trivial. We start with the left to right implication which is essentially immediate from Lemma 18. As expected, the difficult and most interesting part of the proof is the converse implication.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "From piecewise testable languages to J-triviality. Assume that we have L \u2208 PT(A). We prove that M is J-trivial: (3) holds. Let s, t \u2208 M , we have to show that (st) \u03c9 s = (st) \u03c9 = t(st) \u03c9 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "Since \u03b1 is a syntactic morphism, it is surjective and there exists u, v \u2208 A * such that \u03b1(u) = s and \u03b1(v) = t. Moreover, since L \u2208 SF(A), Lemma 18 yields k \u2265 1 such that (uv) k\u03c9 u \u2261 L (uv) k\u03c9 \u2261 L v(uv) k\u03c9 . By definition of the syntactic morphism, this implies that \u03b1((uv) k\u03c9 u) = \u03b1((uv) k\u03c9 ) = \u03b1(v(uv) k\u03c9 ). Since \u03b1(u) = s and \u03b1(v) = t, this yields (st) \u03c9 s = (st) \u03c9 = t(st) \u03c9 as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "From J-triviality to piecewise testable languages. Assume that M is Jtrivial. We show that L is piecewise testable. We rely on the notions introduced in the Sect. 3 and directly prove that every language recognized by \u03b1 is piecewise testable. The argument is based on Proposition 7: we use induction to construct a PT-cover K of A * which is confined by \u03b1. By the proposition, this implies that every language recognized by \u03b1 belongs to PT(A). We start with a preliminary definition that we require to formulate the induction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "Given a finite set of languages K, and s, t \u2208 M , we say that K is (s, t)-safe if for every K \u2208 K and w, w \u2208 K, we have s\u03b1(w)t = s\u03b1(w )t. The argument is based on the following lemma. Lemma 23. Let s, t \u2208 M and w \u2208 A * . There exists a PT-cover of \u2191w which is (s, t)-safe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "We first use Lemma 23 to complete the main argument. We apply the lemma for s = t = 1 M and w = \u03b5. Since \u2191\u03b5 = A * , this yields a PT-cover K of A * which is (1 M , 1 M )-safe. Thus, for every K \u2208 K and w, w \u2208 A * , we have \u03b1(w) = \u03b1(w ). By Fact 6, this implies that K is confined by \u03b1, concluding the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "It remains to prove Lemma 23. Let s, t \u2208 M and w \u2208 A * . We construct a PT-cover K of \u2191w which is (s, t)-safe. We write P [s, w, t] \u2286 M \u00d7 M for the following set:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "We proceed by induction on the two following parameters, listed by order of importance:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "1. The size of P [s, w, t].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Simon's Theorem"
        },
        {
            "text": "We consider two cases depending on whether w is empty or not. We first assume that this property holds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The length of w."
        },
        {
            "text": "First case: w = \u03b5. We handle this case using induction on our first parameter. Let H \u2286 A * be the language of all words v \u2208 A * such that (s, t) \u2208 P [s, v, t]. We use induction to build a PT-cover of H (note that it may happen that H is empty in which case we do not need induction).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The length of w."
        },
        {
            "text": "There exists a PT-cover K H of H which is (s, t)-safe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "Proof. One may verify with a pumping argument that there exists a finite set F \u2286 H such that H \u2286 v\u2208F (\u2191v) (this is also an immediate consequence of Higman's lemma). Hence, it suffices to prove that for every v \u2208 H, there exists a PT-cover K v of \u2191v which is (s, t)-safe. Indeed, one may then choose K H to be the union of all covers K v for v \u2208 F . We fix v \u2208 H for the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "Since w = \u03b5, we have \u2191w = A * . P [s, w, t] ) yields a PT-cover K v of \u2191v which is (s, t)-safe, as desired.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 32,
                    "end": 43,
                    "text": "P [s, w, t]",
                    "ref_id": null
                }
            ],
            "section": "Fact 24."
        },
        {
            "text": "We let K H be the PT-cover K H of H given by Fact 24. We define,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "Finally, we let K = {K \u22a5 }\u222aK H . It is immediate that K is a PT-cover of A * = \u2191\u03b5 since PT is a Boolean algebra. It remains to verify that K is (s, t)-safe. Consider K \u2208 K and let u, u \u2208 K. We prove that s\u03b1(u)t = s\u03b1(u )t. If K \u2208 K H , this is immediate since K H is (s, t)-safe by construction. Hence, it suffices to show that K \u22a5 is (s, t)-safe. This is a direct consequence of the following fact. Note that this is the only place in the proof where we use the hypothesis that M satisfies (3). Proof. Let v \u2208 K \u22a5 . By definition of K \u22a5 , v \u2208 K for every K \u2208 K H . Since K H is a cover of H, it follows that v \u2208 H. By definition of H, it follows that (s, t) \u2208 P [s, v, t]. By definition, this yields x, y \u2208 A * such that s\u03b1(x) = s, t = \u03b1(y)t and xy \u2208 \u2191v. The latter property yields x , y \u2208 A * such that v = x y , x \u2208 \u2191x and y \u2208 \u2191y . We prove that s\u03b1(x ) = s and t = \u03b1(y )t, which yields as desired that s\u03b1(v)t = s\u03b1(x y )t = st. By symmetry, we only show that s = s\u03b1(x ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "Since s = s\u03b1(x), we have s = s(\u03b1(x)) \u03c9 . Moreover, since x \u2208 \u2191x , we have x 0 , . . . , x n \u2208 A * and a 1 , . . . , a n \u2208 A such that x = a 1 \u00b7 \u00b7 \u00b7 a n and x = x 0 a 1 x 1 \u00b7 \u00b7 \u00b7 a n x n . It follows from (3) that for every 1 \u2264 i \u2264 n, we have:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "(\u03b1(x)) \u03c9 = (\u03b1(x)) \u03c9 \u03b1(x 0 a 1 x 1 \u00b7 \u00b7 \u00b7 x i\u22121 ) = (\u03b1(x)) \u03c9 \u03b1(x 0 a 1 x 1 \u00b7 \u00b7 \u00b7 x i\u22121 a i ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "This yields (\u03b1(x)) \u03c9 = (\u03b1(x)) \u03c9 \u03b1(a i ). Therefore, since we know that s = s(\u03b1(x)) \u03c9 , we obtain s\u03b1(a i ) = s(\u03b1(x)) \u03c9 \u03b1(a i ) = s(\u03b1(x)) \u03c9 = s. Finally, this yields, s = s\u03b1(a n ) = s\u03b1(a n\u22121 a n ) = \u00b7 \u00b7 \u00b7 = s\u03b1(a 1 \u00b7 \u00b7 \u00b7 a n\u22121 a n ) = s\u03b1(x ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "This concludes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "Second case: w \u2208 A + . In that case, we have u, v \u2208 A * and a \u2208 A such that w = uav (the choice of u, v and a is arbitrary). Consider the two following subsets of M :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "Moreover, we say that a cover K of some language H is tight when K \u2286 H for every K \u2208 K. We use induction to prove the following fact.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 24."
        },
        {
            "text": "There exist tight PT-covers K u and K v of \u2191u and \u2191v which satisfy the following properties:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "-for every r \u2208 M u , the cover K v of \u2191v is (sr, t)-safe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "-for every r \u2208 M v , the cover K u of \u2191u is (s, rt)-safe.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "Proof. We construct K v (the construction of K u is symmetrical). Let M u = {r 1 , . . . , r n }. For every i \u2264 n, assume that we already have a PT-cover H i of \u2191v which is (sr i , t)-safe. We define,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "Since PT is a Boolean algebra, it is immediate that K v is a tight PT-cover of \u2191v which is (sr, t)-safe for every r \u2208 M u . Thus, it remains to build for every i \u2264 n such a PT-cover H i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "We fix i \u2264 n for the proof. By definition of M u , we have r i = \u03b1(u i a) for some word u i \u2208 \u2191u. Observe that since w = uav, we have P [sr i , v, t] \u2286 P [s, w, t] by definition: our first induction parameter (i.e., the size of P [s, w, t]) has not increased. Hence, since |v| < |w|, it follows by induction on our second parameter in Lemma 23 (the length of w) that there exists a PT-cover H i of \u2191v which is (sr i , t)-safe. This concludes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "We are ready to construct the desired PT-cover K of \u2191w. Consider the tight PT-covers K u and K v of \u2191u and \u2191v described in Fact 26. Since w = uav, Proposition 19 yields a PT-cover K of \u2191w such that for every K \u2208 K, there exist K u \u2208 K u and K v \u2208 K v satisfying K \u2286 K u aK v . It remains to prove that K is (s, t)-safe. Let K \u2208 K and x, x \u2208 K. We prove that s\u03b1(x)t = s\u03b1(x )t.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "By definition, K \u2286 K u aK v for K u \u2208 K u and K v \u2208 K v . Hence, there exist y, y \u2208 K u and z, z \u2208 K v such that x = yaz and x = y az . Since K u is a tight cover of \u2191u, we know that y \u2208 \u2191u, which implies that \u03b1(ya) \u2208 M u by definition. It follows that K v is (s\u03b1(ya), t)-safe by Fact 26. Therefore, since z, z \u2208 K v and K v \u2208 K v , we obtain s\u03b1(yaz)t = s\u03b1(yaz )t. Symmetrically, one may verify that s\u03b1(yaz )t = s\u03b1(y az )t. Altogether, it follows that s\u03b1(yaz)t = s\u03b1(y az )t, meaning that s\u03b1(x)t = s\u03b1(x )t. This concludes the proof of Lemma 23.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fact 26."
        },
        {
            "text": "We explained how covering provides a natural and convenient framework for handling membership questions. We illustrated this point by using covers to formulate new proofs for Sch\u00fctzenberger's theorem and Simon's theorem. We chose these two examples as they are arguably the two most famous characterization theorems of this kind. However, this approach is also relevant for other prominent characterization theorems. A first promising example is the class of unambiguous languages. It was also characterized by Sch\u00fctzenberger [37] and it also famous as the class of languages that can be define in two-variable first-order logic (this was shown by Th\u00e9rien and Wilke [40] ). Another interesting example is Knast's theorem [13] which characterizes the languages of dot-depth one. This class is natural generalization of the piecewise testable languages.",
            "cite_spans": [
                {
                    "start": 526,
                    "end": 530,
                    "text": "[37]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 666,
                    "end": 670,
                    "text": "[40]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 721,
                    "end": 725,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Implicit operations on finite j-trivial semigroups and a conjecture of I",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Almeida",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Simon. J. Pure Appl. Algebra",
            "volume": "69",
            "issn": "",
            "pages": "205--218",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Dot-depth of star-free events",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Brzozowski",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "S"
                    ],
                    "last": "Cohen",
                    "suffix": ""
                }
            ],
            "year": 1971,
            "venue": "J. Comput. Syst. Sci",
            "volume": "5",
            "issn": "1",
            "pages": "1--16",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "The dot-depth hierarchy of star-free languages is infinite",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Brzozowski",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Knast",
                    "suffix": ""
                }
            ],
            "year": 1978,
            "venue": "J. Comput. Syst. Sci",
            "volume": "16",
            "issn": "1",
            "pages": "37--55",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Characterizations of locally testable events",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "A"
                    ],
                    "last": "Brzozowski",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Simon",
                    "suffix": ""
                }
            ],
            "year": 1973,
            "venue": "Discrete Math",
            "volume": "4",
            "issn": "3",
            "pages": "243--271",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Green's relations and their use in automata theory",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Colcombet",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "LATA 2011",
            "volume": "6638",
            "issn": "",
            "pages": "1--21",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Efficient separability of regular languages by subsequences and suffixes",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Czerwi\u0144ski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Martens",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Masopust",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "V"
                    ],
                    "last": "Fomin",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Freivalds",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kwiatkowska",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ICALP 2013",
            "volume": "7966",
            "issn": "",
            "pages": "150--161",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-39212-2_16"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "First-order definable languages",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gastin",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Logic and Automata: History and Perspectives, Texts in Logic and Games",
            "volume": "2",
            "issn": "",
            "pages": "261--306",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Automata, Languages, and Machines",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Eilenberg",
                    "suffix": ""
                }
            ],
            "year": 1976,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "A proof of simon's theorem on piecewise testable languages",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Higgins",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Theor. Comput. Sci",
            "volume": "178",
            "issn": "1",
            "pages": "257--264",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "A new proof of Sch\u00fctzenberger's theorem",
            "authors": [
                {
                    "first": "P",
                    "middle": [
                        "M"
                    ],
                    "last": "Higgins",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Int. J. Algebra Comput",
            "volume": "10",
            "issn": "02",
            "pages": "217--220",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Tense logic and the theory of linear order",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "W"
                    ],
                    "last": "Kamp",
                    "suffix": ""
                }
            ],
            "year": 1968,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Piecewise testable languages via combinatorics on words",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Klima",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Discrete Math",
            "volume": "311",
            "issn": "20",
            "pages": "2124--2127",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "A semigroup characterization of dot-depth one languages. RAIRO -Theor",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Knast",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "Inform. Appl",
            "volume": "17",
            "issn": "4",
            "pages": "321--330",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Aspectos te\u00f3ricos da computa\u00e7\u00e3o",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "L"
                    ],
                    "last": "Lucchesi",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Simon",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Simon",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Simon",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        ";"
                    ],
                    "last": "Kowaltowski",
                    "suffix": ""
                },
                {
                    "first": "Sao",
                    "middle": [],
                    "last": "Impa",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Paulo",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Counter-Free Automata",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Mcnaughton",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "A"
                    ],
                    "last": "Papert",
                    "suffix": ""
                }
            ],
            "year": 1971,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A note on star-free events",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Meyer",
                    "suffix": ""
                }
            ],
            "year": 1969,
            "venue": "J. ACM",
            "volume": "16",
            "issn": "2",
            "pages": "220--225",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Finite automata",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Perrin",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Formal Models and Semantics",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Varieties of Formal Languages",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "E"
                    ],
                    "last": "Pin",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "A variety theorem without complementation",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "E"
                    ],
                    "last": "Pin",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Russ. Math. (Izvestija vuzov.Matematika)",
            "volume": "39",
            "issn": "",
            "pages": "80--90",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "The dot-depth hierarchy, 45 years later",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "E"
                    ],
                    "last": "Pin",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "177--202",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Mathematical foundations of automata theory",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "E"
                    ],
                    "last": "Pin",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Polynomial closure and unambiguous product",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "E"
                    ],
                    "last": "Pin",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Weil",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Theory Comput. Syst",
            "volume": "30",
            "issn": "4",
            "pages": "383--422",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Theories of Computability",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Pippenger",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Separating regular languages with two quantifier alternations",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Log. Methods Comput. Sci",
            "volume": "14",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Separating regular languages by piecewise testable and unambiguous languages",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Van Rooijen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "MFCS 2013",
            "volume": "8087",
            "issn": "",
            "pages": "729--740",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-40313-2_64"
                ]
            }
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Going higher in the first-order quantifier alternation hierarchy on words",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Esparza",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fraigniaud",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Husfeldt",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ICALP 2014",
            "volume": "8573",
            "issn": "",
            "pages": "342--353",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-43951-7_29"
                ]
            }
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Separating regular languages with first-order logic",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the Joint Meeting of the 23rd EACSL Annual Conference on Computer Science Logic (CSL 2014) and the 29th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS 2014)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "The tale of the quantifier alternation hierarchy of first-order logic over words",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "SIGLOG News",
            "volume": "2",
            "issn": "3",
            "pages": "4--17",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Separating regular languages with first-order logic",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Log. Methods Comput. Sci",
            "volume": "12",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Separation for dot-depth two",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 32th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS 2017)",
            "volume": "",
            "issn": "",
            "pages": "202--213",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "The covering problem",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Log. Methods Comput. Sci",
            "volume": "14",
            "issn": "3",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Generic results for concatenation hierarchies",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Theory Comput. Syst. (ToCS)",
            "volume": "63",
            "issn": "4",
            "pages": "849--901",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "Going higher in first-order quantifier alternation hierarchies on words",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "J. ACM",
            "volume": "66",
            "issn": "2",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "On all things star-free",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 46th International Colloquium on Automata, Languages, and Programming (ICALP 2019)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Separation and covering for group based concatenation hierarchies",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Place",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zeitoun",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS 2019)",
            "volume": "",
            "issn": "",
            "pages": "1--13",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "On finite monoids having only trivial subgroups",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "P"
                    ],
                    "last": "Sch\u00fctzenberger",
                    "suffix": ""
                }
            ],
            "year": 1965,
            "venue": "Inf. Control",
            "volume": "8",
            "issn": "2",
            "pages": "190--194",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Sur le produit de concat\u00e9nation non ambigu",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "P"
                    ],
                    "last": "Sch\u00fctzenberger",
                    "suffix": ""
                }
            ],
            "year": 1976,
            "venue": "Semigroup Forum",
            "volume": "13",
            "issn": "",
            "pages": "47--75",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "Piecewise testable events",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Simon",
                    "suffix": ""
                }
            ],
            "year": 1975,
            "venue": "GI-Fachtagung 1975",
            "volume": "33",
            "issn": "",
            "pages": "214--222",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-07407-4_23"
                ]
            }
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Partially ordered finite monoids and a theorem of I",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Straubing",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Simon. J. Algebra",
            "volume": "119",
            "issn": "2",
            "pages": "393--399",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Over words, two variables are as powerful as one quantifier alternation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wilke",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Proceedings of the 30th Annual ACM Symposium on Theory of Computing (STOC 1998)",
            "volume": "",
            "issn": "",
            "pages": "234--240",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "Classifying discrete temporal properties",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wilke",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "STACS 1999",
            "volume": "1563",
            "issn": "",
            "pages": "32--46",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-49116-3_3"
                ]
            }
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "Locally testable languages",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zalcstein",
                    "suffix": ""
                }
            ],
            "year": 1972,
            "venue": "J. Comput. Syst. Sci",
            "volume": "6",
            "issn": "2",
            "pages": "151--167",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "For every sub-alphabet B \u2286 A, we have B * \u2208 SF(A). Indeed, by closure under complement, A * = A * \\ \u2205 \u2208 SF(A). We then get A * aA * \u2208 SF(A) by closure under concatenation. Finally, this yields,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Let B be an alphabet. Consider a morphism \u03b2 : B * \u2192 M , C \u2286 B and s \u2208 M . There exists an SF-cover of C * which is (s, \u03b2)-safe.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "The size of \u03b2(C + ) \u2286 M . 2. The size of C. 3. The size of s\u03b2(C * ) \u2286 M .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "The aperiodic monoid M remains fixed throughout the whole proof. On the other hand, the alphabets B and C, the morphism \u03b2 : B * \u2192 M and s \u2208 M may change when applying induction.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "For every word v \u2208 K \u22a5 , we have s\u03b1(v)t = st.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Since \u03b1 is surjective (it is a syntactic morphism), it follows that P [s, w, t] = {(sq, rt) | q, r \u2208 M }. Therefore, we have P [s, v, t] \u2286 P [s, w, t] and (s, t) \u2208 P [s, w, t]. Since (s, t) \u2208 P [s, v, t] by definition of H, we get |P [s, v, t]| < |P [s, w, t]|. Hence, induction on the first parameter in Lemma 23 (the size of",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Proof. Since L \u2208 PT, there exists k \u2265 1 such that L is a Boolean combinations of language \u2191w with w \u2208 A * such that |w| \u2264 k (i.e. w has length at most k). We prove that the lemma holds for this number k. Let u, v \u2208 A * and \u2265 k. We show that (uv) u \u2261 L (uv) \u2261 L v(uv) . By symmetry, we concentrate on (uv) u \u2261 L (uv) : given x, y \u2208 A * , we show that x(uv) uy \u2208 L \u21d4 x(uv) y \u2208 L.Since \u2265 k, one may verify that for every w \u2208 A * such that |w| \u2264 k, we have w x(uv) uy \u21d4 w x(uv) y. In other words, x(uv) uy \u2208 \u2191w \u21d4 x(uv) y \u2208 \u2191w. Since L is a Boolean combination of such languages, this implies the equivalence x(uv) uy \u2208 L \u21d4 x(uv) y \u2208 L as desired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 18. Let A be an alphabet and L \u2208 PT(A). There exists"
        }
    ]
}