{
    "paper_id": "c38b814ee0dad02f02855ff7abdfc672bbf5cc1c",
    "metadata": {
        "title": "Intersection and Union Hierarchies of Deterministic Context-Free Languages and Pumping Lemmas 1 A Historical Account and an Overview of Contributions 1.1 Intersection and Union Hierarchies and Historical Background",
        "authors": [
            {
                "first": "Tomoyuki",
                "middle": [],
                "last": "Yamakami",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Fukui",
                    "location": {
                        "addrLine": "3-9-1 Bunkyo",
                        "postCode": "910-8507",
                        "settlement": "Fukui",
                        "country": "Japan"
                    }
                },
                "email": "tomoyukiyamakami@gmail.com"
            }
        ]
    },
    "abstract": [
        {
            "text": "We study the computational complexity of finite intersections and unions of deterministic context-free languages. Earlier, Wotschke (1978) demonstrated that intersections of (d + 1) deterministic context-free languages are in general more powerful than intersections of d deterministic context-free languages for any positive integer d based on the hierarchy separation of Liu and Weiner (1973) . The argument of Liu and Weiner, however, works only on bounded languages of particular forms, and therefore Wotschke's result cannot be extended to disprove any other language to be written in the form of an intersection of d deterministic context-free languages. To deal with the non-membership of a wide range of languages, we circumvent their proof argument and instead devise a new, practical technical tool: a pumping lemma for finite unions of deterministic context-free languages. Since the family of deterministic context-free languages is closed under complementation, this pumping lemma enables us to show a non-membership relation of languages made up with finite intersections of even non-bounded languages as well. We also refer to a relationship to Hibbard's limited automata.",
            "cite_spans": [
                {
                    "start": 373,
                    "end": 394,
                    "text": "Liu and Weiner (1973)",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "In formal language theory, context-free languages constitute a fundamental family CFL, which is situated in between the family REG of regular languages and that of context-sensitive languages. It has been well known that this family CFL is closed under an operation of union but not closed under intersection. As a quick example, the language L abc = {a n b n c n | n \u2265 0} is not context-free but it can be expressed as an intersection of two context-free languages. This non-closure property can be further generalized to any intersection of d (\u2265 1) context-free languages. For later notational convenience, we here write CFL(d) for the family of such languages, namely, the d intersection closure of CFL (see,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "e.g., [13] ). With this notation, the above language L abc belongs to CFL(2)\u2212CFL. Similarly, the language L d = {a n1 1 a n2 2 \u00b7 \u00b7 \u00b7 a n d d b n1 1 b n2 2 \u00b7 \u00b7 \u00b7 b n d d | n 1 , n 2 , . . . , n d \u2265 0} over an alphabet {a 1 , a 2 , . . . , a d , b 1 , b 2 , . . . , b d } falls into CFL(d) because L d can be expressed as an intersection of d context-free languages of the form {a n1 1 a n2 2 \u00b7 \u00b7 \u00b7 a n d d b m1 1 b m2 2 \u00b7 \u00b7 \u00b7 b m d d | n 1 , n 2 , . . . , n d , m 1 , m 2 , . . . , m d \u2265 0, n k = m k } (1 \u2264 k \u2264 d). In 1973, Liu and Weiner [8] gave a contrived proof to their key statement that (*) L d is outside of CFL(d \u2212 1) for any index d \u2265 2. Therefore, the collection {CFL(d) | d \u2265 1} truly forms an infinite hierarchy.",
            "cite_spans": [
                {
                    "start": 6,
                    "end": 10,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 115,
                    "end": 117,
                    "text": "n1",
                    "ref_id": null
                },
                {
                    "start": 379,
                    "end": 381,
                    "text": "n1",
                    "ref_id": null
                },
                {
                    "start": 539,
                    "end": 542,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Deterministic context-free (dcf) languages have been a focal point in CFL since a systematic study of Ginsburg and Greibach [1] . The importance of such languages can be exemplified by the facts that dcf languages are easy to parse and that every context-free language is simply the homomorphic image of a dcf language. Unlike CFL, the family DCFL of dcf languages is closed under neither union nor intersection. We use the terms of d-intersection deterministic contextfree (dcf ) languages and d-union deterministic context-free (dcf ) languages to express intersections of d dcf languages and unions of d dcf languages, respectively. For brevity, we write DCFL(d) and DCFL [d] respectively for the family of all d-intersection dcf languages and that of all d-union dcf languages, while Wotschke [11, 12] earlier referred DCFL(d) to the d-intersection closure of DCFL. In particular, we obtain DCFL(1) = DCFL [ Wotschke [11, 12] noted that the aforementioned result (*) of Liu and Weiner leads to the conclusion that {DCFL[d] | d \u2265 1} truly forms an infinite hierarchy.",
            "cite_spans": [
                {
                    "start": 124,
                    "end": 127,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 675,
                    "end": 678,
                    "text": "[d]",
                    "ref_id": null
                },
                {
                    "start": 797,
                    "end": 801,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 802,
                    "end": 805,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 910,
                    "end": 911,
                    "text": "[",
                    "ref_id": null
                },
                {
                    "start": 921,
                    "end": 925,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 926,
                    "end": 929,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "To be more precise, since the language L d belongs to DCFL(d), the statement (*) implies DCFL(d) CFL(d\u22121), which instantly yields DCFL(d\u22121) = DCFL(d). Wotschke's argument, nonetheless, heavily relies on the separation result of Liu and Weiner, who employed a notion of stratified semi-linear set to prove the statement (*). Notice that the proof technique of Liu and Weiner was developed only for a particular form of bounded languages 1 and it is therefore applicable to specific languages, such as L d . In fact, the key idea of the proof of Liu and Weiner for L d is to focus on the number of the occurrences of each base symbol in",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": ") in order to exploit the semi-linearity of \u03a8 (L d ), where # \u03c3 (w) expresses the total number of symbols \u03c3 in a string w.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Because of the aforementioned limitation of Liu and Weiner's proof technique, the scope of their proof cannot be extended to other forms of languages. Simple examples of such languages include L language expanding L d but its Parikh images do not have semi-linearity. As another example, let us take a look at a \"non-palindrome\" language NP al # d = and NP al # d to be outside of DCFL(d)? Moreover, given a language, how can we verify that it is not in DCFL(\u03c9)? We can ask similar questions for d-union dcf languages and the union hierarchy of dcf languages. Ginsburg and Greibach [1] remarked with no proof that the context-free language P al = {ww R | w \u2208 \u03a3 * } for any non-unary alphabet \u03a3 is not in DCFL[\u03c9]. It is natural to call for a formal proof of the remark of Ginsburg and Greibach. Using a quite different language L wot = {wcx | w, x \u2208 {a, b} * , w = x}, however, Wotschke [11, 12] actually proved that L wot does not belong to DCFL(\u03c9) (more strongly, the Boolean closure of DCFL) by employing the closure property of DCFL(d) under inverse gsm mappings as well as complementation and intersection with regular languages. Wotschke's proof relies on the following two facts. (i) The language L d+1 can be expressed as the inverse gsm map of the language",
            "cite_spans": [
                {
                    "start": 582,
                    "end": 585,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 886,
                    "end": 890,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 891,
                    "end": 894,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Dup c is expressed as the complement of L wot , restricted to a certain regular language. Together with these facts, the final conclusion comes from the aforementioned result (*) of Liu and Weiner because Dup c \u2208 DCFL(d) implies L d+1 \u2208 DCFL(d) by (i) and (ii). To our surprise, the fundamental results on DCFL(d) that we have discussed so far are merely \"corollaries\" of the main result (*) of Liu and Weiner! For further study on DCFL(d) and answering more general non-membership questions to DCFL(d), we need to divert from Liu and Weiner's contrived argument targeting the statement (*) and to develop a completely different, new, more practical technical tool. The sole purpose of this exposition is, therefore, set to (i) develop a new proof technique, which can be applicable to many other languages, (ii) present an alternative proof for the fact that the intersection and union hierarchies of DCFL are infinite hierarchies, and (iii) present other languages in CFL that do not belong to DCFL(\u03c9) (in part, verifying Ginsburg and Greibach's remark for the first time).",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "In relevance to the union hierarchy of dcf languages, there is another known extension of DCFL using a different machine model called limited automata, 2 which are originally invented by Hibbard [3] and later discussed extensively in, e.g., [9, 14] . Of all such machines, a d-limited deterministic automaton (or a dlda, for short) is a deterministic Turing machine that can rewrite each tape cell in between two endmarkers only during the first d visits (except that making a turn of a tape head counts as double visits). We can raise a question of whether there is any relationship between the union hierarchy and d-lda's.",
            "cite_spans": [
                {
                    "start": 195,
                    "end": 198,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 241,
                    "end": 244,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 245,
                    "end": 248,
                    "text": "14]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "In Sect. 1.1, we have noted that fundamental properties associated with DCFL(d) heavily rely on the single separation result (*) of Liu and Weiner. However, Liu and Weiner's technical tool that leads to their main result does not seem to withstand a wide variety of direct applications. It is thus desirable to develop a new, simple, and practical technical tool that can find numerous applications for a future study on DCFL(d) and DCFL [d] . Thus, our main contribution of this exposition is to present a simple but powerful, practical technical tool, called the pumping lemma of languages in DCFL[d] with d \u2265 1, which also enriches our understanding of DCFL[d] as well as DCFL(d). Notice that there have been numerous forms of so-called pumping lemmas (or iteration theorems) for variants of context-free languages in the past literature, e.g., [2, [4] [5] [6] [7] 10, 15] . Our pumping lemma is a crucial addition to the list of such lemmas.",
            "cite_spans": [
                {
                    "start": 438,
                    "end": 441,
                    "text": "[d]",
                    "ref_id": null
                },
                {
                    "start": 848,
                    "end": 851,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 852,
                    "end": 855,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 856,
                    "end": 859,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 860,
                    "end": 863,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 864,
                    "end": 867,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 868,
                    "end": 871,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 872,
                    "end": 875,
                    "text": "15]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Overview of Main Contributions"
        },
        {
            "text": "For a string x of length n and any number i \u2208 [n], x[i] stands for the ith symbol of x and x i for the i repetitions of x.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Overview of Main Contributions"
        },
        {
            "text": "As a special case of d = 1, we obtain Yu's pumping lemma [15, Lemma 1] from Lemma 1. Since there have been few machine-based analyses to prove various pumping lemmas in the past literature, one of the important aspects of this exposition is a clear demonstration of the first alternative proof to Yu's pumping lemma, which is solely founded on an analysis of behaviors of 1dpda's instead of derivation trees of LR(k) grammars as in [15] . The proof of Lemma 1, in fact, exploits early results of [14] on an ideal shape form (Sect. 2.3) together with a new approach of \u03b5-enhanced machines by analyzing transitions of crossing state-stack pairs (Sect. 2.4). These notions will be explained in Sect. 2 and their basic properties will be explored therein.",
            "cite_spans": [
                {
                    "start": 432,
                    "end": 436,
                    "text": "[15]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1 (Pumping Lemma for DCFL[d]). Let d be any positive integer and let L be any d-union dcf language over an alphabet \u03a3. There exist a constant"
        },
        {
            "text": "Using our pumping lemma (Lemma 1), we can expand the scope of the statement (*) of Liu and Weiner [8] targeting specific bounded languages to other types of languages, including L",
            "cite_spans": [
                {
                    "start": 98,
                    "end": 101,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1 (Pumping Lemma for DCFL[d]). Let d be any positive integer and let L be any d-union dcf language over an alphabet \u03a3. There exist a constant"
        },
        {
            "text": "Since Lemma 1 concerns with DCFL[d], in our proof of Theorem 1, we first take the complements of the above languages, restricted to suitable regular languages, and we then apply Lemma 1 appropriately to them. The proof sketch of this theorem will be given in Sect. 3. From Theorem 1, we instantly obtain the following consequences of Wotschke [11, 12] . Corollary 1. [11, 12] The intersection hierarchy of dcf languages and the union hierarchy of dcf languages are both infinite hierarchies.",
            "cite_spans": [
                {
                    "start": 343,
                    "end": 347,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 348,
                    "end": 351,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 367,
                    "end": 371,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 372,
                    "end": 375,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1 (Pumping Lemma for DCFL[d]). Let d be any positive integer and let L be any d-union dcf language over an alphabet \u03a3. There exist a constant"
        },
        {
            "text": "Concerning the limitation of DCFL(\u03c9) and DCFL[\u03c9] in recognition power, since all unary context-free languages are also regular languages and the family REG of regular languages is closed under intersection, all unary languages in DCFL(\u03c9) are regular as well. It is thus easy to find languages that are not in DCFL(\u03c9). Such languages, nevertheless, cannot serve themselves to separate CFL from DCFL(\u03c9) \u222a DCFL[\u03c9]. As noted in Sect. 1.1, Ginsburg and Greibach [1] remarked with no proof that the context-free language P al = {ww R | w \u2208 {0, 1} * } does not belong to DCFL(\u03c9) (as well as DCFL[\u03c9]). As another direct application of our pumping lemma, we give a formal written proof of their remark.",
            "cite_spans": [
                {
                    "start": 457,
                    "end": 460,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1 (Pumping Lemma for DCFL[d]). Let d be any positive integer and let L be any d-union dcf language over an alphabet \u03a3. There exist a constant"
        },
        {
            "text": "As an immediate consequence of the above theorem, we obtain Wotschke's separation of DCFL(\u03c9) from CFL. Here, we stress that, unlike the work of Wotschke [11, 12] , our proof does not depend on the main result (*) of Liu and Weiner. Corollary 2. [11, 12] CFL DCFL(\u03c9) and DCFL[\u03c9] CFL.",
            "cite_spans": [
                {
                    "start": 153,
                    "end": 157,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 158,
                    "end": 161,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 245,
                    "end": 249,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 250,
                    "end": 253,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 2. The context-free language P al is not in"
        },
        {
            "text": "We turn our interest to limited automata. Let us write d-LDA for the family of all languages recognized by d-limited deterministic automata, in which their tape heads are allowed to rewrite tape symbols only during the first d accesses (except that, in the case of tape heads making a turn, we treat each turn as double visits). Hibbard [3] demonstrated that d-LDA = (d \u2212 1)-LDA for any d \u2265 3. A slightly modified language of his, which separates d-LDA from (d \u2212 1)-LDA, also belongs to the 2 d\u22122 -th level of the union hierarchy of dcf languages but not in the (2 d\u22122 \u2212 1)-th level. We thus obtain the following separation.",
            "cite_spans": [
                {
                    "start": 337,
                    "end": 340,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 2. The context-free language P al is not in"
        },
        {
            "text": "The proofs of all the above assertions will be given after introducing necessary notions and notation in the subsequent section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 1. For any"
        },
        {
            "text": "The set of all natural numbers (including 0) is denoted by N. An integer interval [m, n] Z for two integers m, n with m \u2264 n is the set {m, m + 1, m + 2, . . . , n}. In particular, for any integer n \u2265 1, [1, n] Z is abbreviated as [n]. For any string x, |x| indicates the total number of symbols in x. The special symbol \u03b5 is used to denote the empty string of length 0. For a language L over alphabet \u03a3, L denotes \u03a3 * \u2212 L, the complement of L. Given a family F of languages, co-F expresses the complement family, which consists of languages L for any L \u2208 F.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fundamental Notions and Notation"
        },
        {
            "text": "A one-way deterministic pushdown automaton (or a 1dpda, for short) M is a tuple (Q, \u03a3, {| c, $}, \u0393, \u03b4, q 0 , Z 0 , Q acc , Q rej ), where Q is a finite set of inner states, \u03a3 is an input alphabet with\u03a3 = \u03a3 \u222a {\u03b5, | c, $}, \u0393 is a stack alphabet, \u03b4 is a deterministic transition function from Q \u00d7\u03a3 \u00d7 \u0393 to Q \u00d7 \u0393 * , q 0 is the initial state in Q, Z 0 is the bottom marker in \u0393 , and Q acc and Q rej are subsets of Q. The symbols | c and $ respectively express the left-endmarker and the right-endmarker. Let \u0393 (\u2212) = \u0393 \u2212 {Z 0 }. We assume that, if \u03b4(p, \u03b5, a) is defined, then \u03b4(p, \u03c3, a) is undefined for all symbols \u03c3 \u2208\u03a3 \u2212 {\u03b5}. Moreover, we require \u03b4(q, \u03c3, Z 0 ) = (p, \u03b5) for any p, q \u2208 Q and \u03c3 \u2208\u03a3. Each content of a stack is expressed as a 1 a 2 \u00b7 \u00b7 \u00b7 a k in which a 1 is the topmost stack symbol, a k is the bottom marker Z 0 , and all others are placed in order from the top to the bottom of the stack.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deterministic Pushdown Automata"
        },
        {
            "text": "Given d \u2208 N + , a d-intersection deterministic context-free (dcf ) language is an intersection of d deterministic context-free (dcf) languages. Let DCFL(d) denote the family of all d-intersection dcf languages. Similarly, we define d-union dcf languages and DCFL[d] by substituting \"union\" for \"intersection\" in the above definitions. Note that DCFL[d] = co-(DCFL(d)) because DCFL = co-DCFL.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Deterministic Pushdown Automata"
        },
        {
            "text": "For two language families F 1 and F 2 , the notation F 1 \u2227 F 2 (resp., F 1 \u2228 F 2 ) denotes the family of all languages L for which there are two languages L 1 \u2208 F 1 and L 2 \u2208 F 2 over the same alphabet satisfying L = L 1 \u2229 L 2 (resp., L = L 1 \u222a L 2 ). Lemma 2. [11, 12] From Lemma 3(1) follows Corollary 1, provided that Theorem 1 is true. Theorem 1 itself will be proven in Sect. 3.",
            "cite_spans": [
                {
                    "start": 261,
                    "end": 265,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 266,
                    "end": 269,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Deterministic Pushdown Automata"
        },
        {
            "text": "Let us recall from [14] a special \"pop-controlled form\" (called an ideal shape), in which the pop operations always take place by first reading an input symbol and then making a series (one or more) of the pop operations without reading any further input symbol. This notion was originally introduced for one-way probabilistic pushdown automata (or 1ppda's); however, in this exposition, we apply this notion only to 1dpda's. To be more formal, a 1dpda in an ideal shape is a 1dpda restricted to take only the following transitions. (1) Scanning \u03c3 \u2208 \u03a3, preserve the topmost stack symbol (called a stationary operation). It was shown in [14] that any 1ppda can be converted into its \"errorequivalent\" 1ppda in an ideal shape. In Lemma 4, we restate this result for 1dpda's. We say that two 1dpda's are (computationally) equivalent if, for any input x, their acceptance/rejection coincide. The push size of a 1ppda is the maximum length of any string pushed into a stack by any single move.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Ideal Shape"
        },
        {
            "text": "Let n \u2208 N + . Any n-state 1dpda M with stack alphabet size m and push size e can be converted into another (computationally) equivalent 1dpda N in an ideal shape with O(en 2 m 2 (2m) 2enm ) states and stack alphabet size O(enm(2m) 2enm ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 4 (Ideal Shape Lemma for 1dpda's). (cf. [14])"
        },
        {
            "text": "We want to define two basic notions of boundaries and crossing state-stacks. For this purpose, we visualize a single move of a 1dpda M as three consecutive actions: (i) firstly replacing the topmost stack symbol, (ii) updating an inner state, and (iii) thirdly either moving a tape head or staying still.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boundaries and Crossing State-Stack Pairs"
        },
        {
            "text": "A boundary is a borderline between two consecutive tape cells. We index all such boundaries from 0 to || cx$| as follows. The boundary 0 is located at the left of cell 0 and boundary i+1 is in between cell i and i+1 for every index i \u2265 0. When a string xy is written in |xy| consecutive cells, the (x, y)-boundary indicates the boundary |x| + 1, which separates between x and y. A boundary block between boundaries t 1 and t 2 with t 1 \u2264 t 2 is a consecutive series of boundaries between t 1 and t 2 (including t 1 and t 2 ). These t 1 and t 2 are called ends of this boundary block. For brevity, we write [t 1 , t 2 ] to denote a boundary block between t 1 and t 2 . For two boundaries t 1 , t 2 with t 1 < t 2 , the (t 1 , t 2 )-region refers to the consecutive cells located in the boundary block [t 1 , t 2 ]. When an input string x is written in the (t 1 , t 2 )-region, we conveniently call this region the x-region unless the region is unclear from the context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boundaries and Crossing State-Stack Pairs"
        },
        {
            "text": "The stack height of M at boundary t is the length of the stack content while passing the boundary t. E.g., a stack content a 1 a 2 \u00b7 \u00b7 \u00b7 a k has stack height k.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boundaries and Crossing State-Stack Pairs"
        },
        {
            "text": "A boundary block [t 1 , t 2 ] is called convex if there is a boundary s between t 1 and t 2 (namely, s \u2208 [t 1 , t 2 ]) such that there is no pop operation in the (t 1 , s)region and there is no push operation in the (s, t 2 )-region. A boundary block [t 1 , t 2 ] is flat if the stack height does not change in the (t 1 , t 2 )-region. A boundary block [t 1 , t 2 ] with t 1 < t 2 is pseudo-convex if the stack height at every boundary s \u2208 [t 1 , t 2 ] does not go below h 2 \u2212 h1\u2212h2 t2\u2212t1 (s \u2212 t 1 ), where h i is the stack height at boundary t i for any i \u2208 {1, 2}. By their definitions, either convex or flat boundary blocks are also pseudo-convex.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boundaries and Crossing State-Stack Pairs"
        },
        {
            "text": "A peak is a boundary t such that the stack heights at the boundaries t\u22121 and t+1 are smaller than the stack height at the boundary t. A plateau is a boundary block [t, t ] such that any stack height at a boundary i \u2208 [t, t ] is the same. A hill is a boundary block [t, t ] such that (i) the stack height at the boundary t and the stack height at the boundary t coincide, (ii) there is at least one peak at a certain boundary i \u2208 [t, t ], and (iii) both [t, i] and [i, t ] are convex. The height of a hill is the difference between the topmost stack height and the lowest stack height.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boundaries and Crossing State-Stack Pairs"
        },
        {
            "text": "Given strings over alphabet \u03a3, \u03b5-enhanced strings are strings over the extended alphabet \u03a3 \u03b5 = \u03a3 \u222a {\u03b5}, where \u03b5 is treated as a special input symbol expressing the absence of symbols in \u03a3. An \u03b5-enhanced 1dpda (or an \u03b5-1dpa, for short) is a 1dpda that takes \u03b5-enhanced strings and works as a standard 1dpda except that a tape head always moves to the right without stopping. This tape head movement is sometimes called \"real time\".",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Boundaries and Crossing State-Stack Pairs"
        },
        {
            "text": "For any 1dpda M , there exists an \u03b5-1dpda N such that, for any input string x, there is an appropriate \u03b5-enhanced stringx for which M accepts (resp., rejects) x iff N accepts (resp., rejects)x. Moreover,x is identical to x except for the \u03b5 symbol and is uniquely determined from x and M .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5."
        },
        {
            "text": "Let M be either a 1dpda or an \u03b5-1dpda, and assume that M is in an ideal shape. A crossing state-stack pair at boundary i is a pair (q, \u03b3) of inner state q and stack content \u03b3. In a computation of M on input x, a crossing state-stack pair (q, \u03b3) at boundary i refers to the machine's current status where (1) M is reading an input symbol, say, \u03c3 at cell i \u2212 1 in a certain state, say, p with the stack content a\u03b3 and then M changes its inner state to q, changing a by either pushing another symbol b satisfying \u03b3 = ba\u03b3 or popping a with \u03b3 = \u03b3 . Any computation of M on x can be expressed as a series of crossing state-stack pairs at every boundary in the | cx$-region. Two boundaries t 1 and t 2 with t 1 < t 2 are mutually correlated if there are two crossing state-stack pairs (q, \u03b3) and (p, \u03b3) at the boundaries t 1 and t 2 , respectively, for which the boundary block [t 1 , t 2 ] is pseudo-convex. Moreover, assume that t 1 < t 2 < t 3 < t 4 . Two boundary blocks [t 1 , t 2 ] and [t 3 , t 4 ] are mutually correlated if (i) [t 1 , t 2 ], [t 2 , t 3 ], and [t 3 , t 4 ] are all pseudo-convex, (ii) (q, \u03b3) and (p, \u03b1\u03b3) are crossing state-stack pairs at the boundaries t 1 and t 2 , respectively, and (iii) (s, \u03b1\u03b3) and (r, \u03b3) are also crossing state-stack pairs at the boundaries t 3 and t 4 , respectively, for certain p, q, r, s \u2208 Q, \u03b3 \u2208 (\u0393 (\u2212) ) * Z 0 , and \u03b1 \u2208 (\u0393 (\u2212) ) * .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5."
        },
        {
            "text": "If an \u03b5-1dpda is in an ideal shape, then it pops exactly one stack symbol whenever it reads a single symbol of a given \u03b5-enhanced input string. Lemma 6. Let w be any string.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5."
        },
        {
            "text": "such that t 1 is the (x 1 , x 2 )-boundary and t 2 is the (x 2 , x 3 )-boundary. If the boundaries t 1 and t 2 are mutually correlated and inner states at the boundaries t 1 and t 2 coincide, then it follows that w \u2208 L iff ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 5."
        },
        {
            "text": "We intend to present the proof sketches of three separation claims (Theorems 1 and 2 and Proposition 1) before verifying the pumping lemma. There is a constant c > 0 that satisfies the lemma. Let n = c + 1 and consider w i = a n b in for each index i \u2208 [d]. Since each w i belongs to L (d) , we can take an index pair j, k \u2208 [d] with j < k such that w j and w k satisfy the conditions of the lemma. Since Condition (1) of the lemma is immediate, we hereafter consider Condition (2) . Let x = a n b jn\u22121 , y = b, and\u0177 = b (k\u2212j)n+1 . Firstly, we consider Case (a) with a factorization x = x 1 x 2 x 3 x 4 x 5 with |x 2 x 4 | \u2265 1 and |x 2 x 3 x 4 | \u2264 c. Since x 1 x i 2 x 3 x i 4 x 5 y \u2208 L (d) for any number i \u2208 N, we conclude that x 2 \u2208 {a} * and x 4 \u2208 {b} * . Let x 2 = a m and x 4 = b r for certain numbers m, r \u2208 [c]. Note that x 1 x i 2 x 3 x i 4 x 5 y equals a n+(i\u22121)m b jn+(i\u22121)r . Hence, n + (i \u2212 1)m = g(jn + (i \u2212 1)r) for a certain g \u2208 [d]. This implies that (jg\u22121)n = (m\u2212gr)(i\u22121). We then obtain jg \u2212 1 = m \u2212 gr = 0, which further implies that j = g = 1 and m = r. Similarly, from x 1 x i 2 x 3 x i 4 x 5\u0177 \u2208 L (d) , it follows that n + (i \u2212 1)m = g (kn + (i \u2212 1)r). Thus, (kg \u2212 1)n = (m \u2212 g r)(i \u2212 1). This implies k = g = 1 and m = r. Since j = k, we obtain a contradiction.",
            "cite_spans": [
                {
                    "start": 478,
                    "end": 481,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Proof Sketches of Three Separation Claims"
        },
        {
            "text": "Next, we consider Case (b) with appropriate factorizations x = x 1 x 2 x 3 , y = y 1 y 2 y 3 , and\u0177 = z 1 z 2 z 3 with |x 2 | \u2265 1 and |x 2 x 3 | \u2264 c such that x 1 x i 2 x 3 y 1 y i 2 y 3 \u2208 L (d) and x 1 x i 2 x 3 z 1 z i 2 z 3 \u2208 L (d) for any number i \u2208 N. Since |x 2 x 3 | \u2264 c, we obtain x 2 \u2208 {b} * . Assume that x 2 = b m for a certain number m \u2208 [c]. This is impossible because x 1 x i 2 x 3 y 1 y i 2 y 3 has the form a n b jn+(i\u22121)m and the exponent of b is not of the form rn for any number r \u2208 [d].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof Sketches of Three Separation Claims"
        },
        {
            "text": "General Case of d \u2265 2: We begin with proving this case by considering d 1dpda's M 1 , M 2 , . . . , M d . The language recognized by each machine M i is denoted by L(M i ). Let us assume that L = d i=1 L(M i ). Take d + 1 strings w 1 , w 2 , . . . , w d+1 in L and assume that each w k has the form xy (k) with |x| > c. Since all w k 's are in L, define a function f as follows. Let f (k) denote the minimal index i k satisfying that w k \u2208 L(M i k ) but w k / \u2208 L(M j ) for all j = i k . Since there are at most d different languages, there are two distinct indices j 1 , j 2 \u2208 [d + 1] such that f (j 1 ) = f (j 2 ). In what follows, we fix such a pair (j 1 , j 2 ).",
            "cite_spans": [
                {
                    "start": 581,
                    "end": 585,
                    "text": "+ 1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Proof Sketches of Three Separation Claims"
        },
        {
            "text": "Consider the case of w = xy (j1) and w = xy (j2) . Take arbitrary factorizations w = x y and w = x \u0177. We apply the basis case of d = 1 again and obtain one of the following (a)-(b). (a) There is a factorization x = x 1 x 2 x 3 x 4 x 5 with |x 2 x 4 | \u2265 1 and |x 2 x 3 x 4 | \u2264 c such that x 1 x i 2 x 3 x i 4 x 5 y \u2208 L and x 1 x i 2 x 3 x i 4 x 5 y \u2208 L for any number i \u2208 N. (b) There are factorizations x = x 1 x 2 x 3 , y = y 1 y 2 y 3 , and y = z 1 z 2 z 3 such that |x 2 | \u2265 1, |x 2 x 3 | \u2264 c, x 1 x i 2 x 3 y 1 y i 2 y 3 \u2208 L, and x 1 x i 2 x 3 z 1 z i 2 z 3 \u2208 L for any number i \u2208 N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof Sketches of Three Separation Claims"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Deterministic context free languages",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ginsburg",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Greibach",
                    "suffix": ""
                }
            ],
            "year": 1966,
            "venue": "Inf. Control",
            "volume": "9",
            "issn": "",
            "pages": "620--648",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Iteration theorems for deterministic families of languages. Fundamenta Informaticae",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Harrison",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "",
            "volume": "9",
            "issn": "",
            "pages": "481--508",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A generalization of context-free determinism",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "N"
                    ],
                    "last": "Hibbard",
                    "suffix": ""
                }
            ],
            "year": 1967,
            "venue": "Inf. Control",
            "volume": "11",
            "issn": "",
            "pages": "196--238",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "A pumping lemma for real-time deterministic context-free languages",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Igarashi",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "Theor. Comput. Sci",
            "volume": "36",
            "issn": "",
            "pages": "89--97",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Iteration theorems for families of strict deterministic languages",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "N"
                    ],
                    "last": "King",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "Theor. Comput. Sci",
            "volume": "10",
            "issn": "",
            "pages": "317--333",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "The Boolean closure of linear context-free languages",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kutrib",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Malcher",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wotschke",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Acta Inform",
            "volume": "45",
            "issn": "",
            "pages": "177--191",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "An Introduction to Kolmogorov Complexity and Its Applications",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Vit\u00e1nyi",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "An infinite hierarchy of intersections of context-free languages",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "Y"
                    ],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Weiner",
                    "suffix": ""
                }
            ],
            "year": 1973,
            "venue": "Math. Syst. Theory",
            "volume": "7",
            "issn": "",
            "pages": "185--192",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Limited automata and regular languages",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Pighizzini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Pisoni",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Int. J. Found. Comput. Sci",
            "volume": "25",
            "issn": "",
            "pages": "897--916",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "A strong pumping lemma for context-free languages",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "S"
                    ],
                    "last": "Wise",
                    "suffix": ""
                }
            ],
            "year": 1976,
            "venue": "Theor. Comput. Sci",
            "volume": "3",
            "issn": "",
            "pages": "359--369",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "The Boolean closures of the deterministic and nondeterministic context-free languages",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wotschke",
                    "suffix": ""
                }
            ],
            "year": 1973,
            "venue": "GI Gesellschaft f\u00fcr Informatik e. V. LNCS",
            "volume": "",
            "issn": "",
            "pages": "113--121",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-41148-3_11"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Nondeterminism and Boolean operations in pda's",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wotschke",
                    "suffix": ""
                }
            ],
            "year": 1978,
            "venue": "J. Comput. Syst. Sci",
            "volume": "16",
            "issn": "",
            "pages": "456--461",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "under a slightly different title 14. Yamakami, T.: Behavioral Strengths and weaknesses of various models of limited automata",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Yamakami",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Geffert",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Preneel",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Rovan",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "\u0160tuller",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Oracle pushdown automata, nondeterministic reducibilities, and the hierarchy over the family of context-free languages",
            "volume": "8327",
            "issn": "",
            "pages": "519--530",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-10801-4_40"
                ],
                "arXiv": [
                    "arXiv:1303.1717"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "A pumping lemma for deterministic context-free languages",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Inf. Process. Lett",
            "volume": "31",
            "issn": "",
            "pages": "47--51",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Scanning \u03c3 \u2208 \u03a3, push a new symbol u (\u2208 \u0393 (\u2212) ) without changing any other symbol in the stack. (3) Scanning \u03c3 \u2208 \u03a3, pop the topmost stack symbol. (4) Without scanning an input symbol (i.e., \u03b5-move), pop the topmost stack symbol. (5) The stack operations (4) comes only after either (3) or (4).",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "1] = DCFL. Since DCFL is closed under complementation, it follows that the complement of DCFL(d) coincides with DCFL[d]. For our convenience, we call two hierarchies {DCFL(d) | d \u2265 1} and {DCFL[d] | d \u2265 1} the intersection and union hierarchies of dcf languages, respectively. Concerning these hierarchies, we set DCFL(\u03c9) to be the intersection closure of DCFL, which is d\u22651 DCFL(d). In a similar way, we write DCFL[\u03c9] for the union closure of DCFL, that is, d\u22651 DCFL[d].",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "where [d] denotes the set {1, 2, . . . , d}. This is a bounded",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "where w R i expresses the reversal of w i . This NP al # d is not even a bounded language. Therefore, Liu and Weiner's argument is not directly applicable to verify that neither L nor NP al # d belongs to CFL(d \u2212 1) unless we dextrously pick up its core strings that form a certain bounded language. With no such contrived argument, how can we prove L",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "DCFL(d) is closed under union, intersection with REG. In other words, DCFL(d) \u2227 REG \u2286 DCFL(d) and DCFL(d) \u2228 REG \u2286 DCFL(d). A similar statement holds for DCFL[d]. Lemma 3. Let d \u2265 1 be any natural number. 1. DCFL(d) = DCFL(d + 1) iff DCFL[d] = DCFL[d + 1]. 2. If L \u2208 DCFL(d), then it follows that A \u2229 L \u2208 DCFL[d] for any A \u2208 REG.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "boundary for each i \u2208[4]. If two boundary blocks [t 1 , t 2 ] and [t 3 , t 4 ] are mutually correlated, inner states at the boundaries t 1 and t 2 coincide, and inner states at the boundaries t 3 and t 4 coincide, then it follows that",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "To understand our proofs better, we demonstrate a simple and easy example of how to apply Lemma 1 to obtain a separation between DCFL[d] and DCFL[d \u2212 1].Proposition 2. Let d \u2265 2 and let L (d) = {a n b kn | k \u2208 [d], n \u2265 0}. It then follows that L (d) \u2208 DCFL[d] \u2212 DCFL[d \u2212 1]. Proof. Let d \u2265 2. Clearly, L (d) belongs to DCFL[d]. Assuming L (d) \u2208 DCFL[d \u2212 1], we apply the pumping lemma (Lemma 1) to L (d) .",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": ". Take a pumping-lemma constant c > 0 that satisfies Lemma 1. We set n = c+1 and consider the set. Lemma 1 guarantees the existence of a specific distinct pairBy Lemma 1, since |x | > c, there are two conditions to consider separately. Condition (1) is not difficult. Next, we consider Condition (2) .Note that x y = xy (j1) and x \u0177 = xy (j2) . There are three factorizations x = u 1 u 2 u 3 with |u 2 | \u2265 1 and |u 2 u 3 | \u2264 c, y = y 1 y 2 y 3 , and\u0177 = z 1 z 2 z 3 satisfying both u 1 u i 2 u 3 y 1 y i 2 y 3 \u2208 L and u 1 u ifor a certain e \u2265 1. In particular, take i = 2. Note that u 1 u 2 2 u 3 y 1 y 2 2 y 3 has factors a j1n. Thus, we obtain j 1 n = j 1 n + 2e \u2212 1, a clear contradiction.We omit from this exposition the proofs of Theorems 1(2), 2, and Proposition 1. These proofs will be included in its complete version.",
            "cite_spans": [
                {
                    "start": 296,
                    "end": 299,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "annex"
        },
        {
            "text": "We are now ready to provide the proof of the pumping lemma for DCFL[d] (Lemma 1). Our proof has two different parts depending on the value of d. The first part of the proof targets the basis case of d = 1. This special case directly corresponds to Yu's pumping lemma [15, Lemma 1] . To prove his lemma, Yu utilized a so-called left-part theorem of his for LR(k) grammars. We intend to re-prove Yu's lemma using only 1dpda's with no reference to LR(k) grammars. Our proof argument is easily extendable to one-way nondeterministic pushdown automata (or 1npda's) and thus to the pumping lemma for CFL. The second part of the proof deals with the general case of d \u2265 2. Hereafter, we give the sketches of these two parts.Basis Case of d = 1: Let \u03a3 be any alphabet and take any infinite dcf language L over \u03a3. Let us consider an appropriate \u03b5-1dpda M = (Q, \u03a3, {| c, $}, \u0393, \u03b4, q 0 , Z 0 , Q acc , Q rej ) in an ideal shape that recognizes L by Lemmas 4-5. For the desired constant c, we set c = 2 |Q| . Firstly, we take two arbitrary strings xy and x\u0177 over \u03a3 with y[1] =\u0177[1] = a and |x| > c.Our goal is to show that Condition (2) in the basis case of d = 1 holds. There are four distinct cases to deal with. Hereafter, we intend to discuss them separately. Note that, since M is one-way, every crossing state-stack pair at any boundary in the x-region does not depend on the choice of y and\u0177.Case 1: Consider the case where there are two boundaries t 1 , t 2 with 1 \u2264 t 1 < t 2 \u2264 |xa| and |t 2 \u2212 t 1 | \u2264 c such that (i) the boundaries t 1 and t 2 are mutually correlated and (ii) inner states at the boundaries t 1 and t 2 coincide. In this case, we factorize x into x 1 x 2 x 3 so that t 1 = |x 1 | and t 2 = |x 1 x 2 |. By Lemma 6(1), it then follows that, for any number i \u2208 N, x 1 x i 2 x 3 y \u2208 L and x 1 x i 2 x 3\u0177 \u2208 L. Case 2: Consider the case where there are four boundaries t 1 , t 2 , t 3 , t 4 with 1 \u2264 t 1 < t 2 < t 3 < t 4 \u2264 |xa| and |t 4 \u2212 t 1 | \u2264 c and there are p, q \u2208 Q, \u03b3 \u2208 (\u0393 (\u2212) ) * Z 0 , and \u03b1 \u2208 (\u0393 (\u2212) ) * for which (i) (q, \u03b3) and (q, \u03b1\u03b3) are the crossing state-stack pairs respectively at the boundaries t 1 and t 2 , (ii) (p, \u03b1\u03b3) and (p, \u03b3) are the crossing statestack pairs respectively at the boundaries t 3 and t 4 , and (iii) the boundary block [t i , t i+1 ] for each index i \u2208 [3] is pseudo-convex. We then take a factorization x = [4] . Note that |x 2 x 4 | \u2265 2 because of t 1 < t 2 and t 3 < t 4 . By an application of Lemma 6(2), we conclude that, for any z \u2208 {y,\u0177}, Clearly, m > |Q| 2 . We choose {t i } i\u2208 [m] and {r i } i\u2208 [m] so that (i) for each index i \u2208 [m], t i and r i are boundaries in the y-region and in the\u0177-region, respectively, satisfying that t 1 < t 2 < \u00b7 \u00b7 \u00b7 < t m and r 1 < r 2 < \u00b7 \u00b7 \u00b7 < r m , and (ii) for each index i \u2208 [m \u2212 1], [s i , s i+1 ] is mutually correlated to [t i , t i+1 ] in the y-region and also to [r i , r i+1 ] in the\u0177-region. Note that the boundary blocks [t 1 , t 2 ], . . . , [t m\u22121 , t m ], [r 1 , r 2 ], . . . , [r m\u22121 , r m ] are all pseudo-convex. Since m > |Q| 2 , it follows that there is a pair j 1 , j 2 \u2208 [m] with j 1 < j 2 such that inner states at the boundaries r j1 and r j2 coincide. Using Lemma 6(2), we can obtain the desired conclusion.Case 4: Assume that Cases 1-3 fail. In this case, we define a notion of \"true gain\" in the R-region and estimate its value. Choose s 1 and s 2 so that |xa| \u2212 c \u2264 s 1 , s 2 \u2264 |xa|, and the boundary block [s 1 , s 2 ] is pseudo-convex. Let G(s 1 , s 2 ) denote the set of boundary blocks [t 1 ,is pseudo-convex but cannot be flat, (ii) [t j , t j+1 ] is pseudo-convex (and could be flat), (iii) there are crossing state-stack pairs (q i , \u03b3), (q i , \u03b3) at the boundaries t i , t i for every i \u2208 [m], (iv) the stack height at the boundary t i is higher than the stack height at the boundary t i , (v) the boundary t i is a pit (i.e., the lowest point within its small vicinity). Define the true gain tg(s 1 , s 2 ) to be m i=1 |t i \u2212 t i |. It is possible to prove that tg(s 1 , s 2 ) > |Q| 3 . Using this inequality, we can employ an argument similar to Case 3 to obtain the lemma.",
            "cite_spans": [
                {
                    "start": 267,
                    "end": 271,
                    "text": "[15,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 272,
                    "end": 280,
                    "text": "Lemma 1]",
                    "ref_id": null
                },
                {
                    "start": 1120,
                    "end": 1123,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 2301,
                    "end": 2304,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 2356,
                    "end": 2359,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 2535,
                    "end": 2538,
                    "text": "[m]",
                    "ref_id": null
                },
                {
                    "start": 2553,
                    "end": 2556,
                    "text": "[m]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Proof Sketch of the Pumping Lemma for DCFL[d]"
        }
    ]
}