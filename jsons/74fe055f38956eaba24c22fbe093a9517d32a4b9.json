{
    "paper_id": "74fe055f38956eaba24c22fbe093a9517d32a4b9",
    "metadata": {
        "title": "Viral Genome Compression",
        "authors": [
            {
                "first": "Lucian",
                "middle": [],
                "last": "Ilie",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Western Ontario London",
                    "location": {
                        "postCode": "N6A 5B7",
                        "region": "Ontario",
                        "country": "Canada"
                    }
                },
                "email": "ilie@csd.uwo.ca"
            },
            {
                "first": "Liviu",
                "middle": [],
                "last": "Tinta",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Western Ontario London",
                    "location": {
                        "postCode": "N6A 5B7",
                        "region": "Ontario",
                        "country": "Canada"
                    }
                },
                "email": ""
            },
            {
                "first": "Cristian",
                "middle": [],
                "last": "Popescu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Western Ontario London",
                    "location": {
                        "postCode": "N6A 5B7",
                        "region": "Ontario",
                        "country": "Canada"
                    }
                },
                "email": ""
            },
            {
                "first": "Kathleen",
                "middle": [
                    "A"
                ],
                "last": "Hill",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Western Ontario",
                    "location": {
                        "postCode": "N6A 5B7",
                        "settlement": "London",
                        "region": "Ontario",
                        "country": "Canada"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Viruses compress their genome to reduce space. One of the main techniques is overlapping genes. We model this process by the shortest common superstring problem, that is, we look for the shortest genome which still contains all genes. We give an algorithm for computing optimal solutions which is slow in the number of strings but fast (linear) in their total length. This algorithm is used for a number of viruses with relatively few genes. When the number of genes is larger, we compute approximate solutions using the greedy algorithm which gives an upper bound for the optimal solution. We give also a lower bound for the shortest common superstring problem. The results obtained are then compared with what happens in nature. Remarkably, the compression obtained by viruses is quite high and also very close to the one achieved by modern computers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "According to [5] , all virus genomes experience pressure to minimize their size. For example, those with prokaryotic hosts must be able to replicate quickly to keep up with their host cells. In the case of viruses with eukaryotic hosts, the pressure on the genome size comes from the small size of the virus, that is, from the amount of nucleic acid that can be incorporated.",
            "cite_spans": [
                {
                    "start": 13,
                    "end": 16,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "One way to reduce the size of their genome is by overlapping genes. Some viruses show tremendous compression of genetic information when compared with the low density of information in the genomes of eukaryotic cells. As claimed in [5] , overlapping genes are common and \"the maximum genetic capacity is compressed into the minimum genome size.\" This property looks very interesting from mathematical point of view and we found it surprising that it was not much investigated. Daley and McQuillan [9] introduces and investigates a number of formal language theory operations motivated by the biological phenomenon. Krakauer [12] discusses genomic compression in general as achieved through reduced redundancy, overlapping genes, or translational coupling.",
            "cite_spans": [
                {
                    "start": 232,
                    "end": 235,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 497,
                    "end": 500,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 624,
                    "end": 628,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we investigate this property by naturally modelling it as the shortest common superstring problem (SCS). The genes are seen as strings and we look for the shortest superstring that contains them all. A variation is also considered due to the retrograde overlaps which may be present in some viruses.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The SCS problem is known to be NP-hard. We give an algorithm to compute optimal solutions which works well when the number of strings is not too high. The algorithm is conceptually very simple and also very fast with respect to the total length of all strings. We used this algorithm for those viral genomes whose number of genes is not very high.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "When the number of strings increases, we are no longer able to find optimal solutions and use a greedy algorithm for an approximation. This gives an upper bound for the length of a shortest superstring and, for a better estimate, we provide also a lower bound.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Finally, our results are compared with those obtained by viruses. The amount of compression using gene overlapping achieved by the viruses is remarkable; in all examples considered, it is the same or very close to the one obtained by modern computers. The biological significance of these results is to be investigated. Aside from the compression achieved in nature, any solution (or lower bound) for the corresponding SCS problem provides a limitation on the size of a viral genome which contains a given set of genes. Again, the biological relevance of such results remains to be clarified.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Let \u03a3 be an alphabet, that is, a finite non-empty set. Such an alphabet can be the set of four nucleotides {A, T, C, G}. We denote by \u03a3 * the set of all finite strings over \u03a3. The empty word is denoted \u03b5. Given a string w \u2208 \u03a3 * , w = a 1 a 2 \u00b7 \u00b7 \u00b7 a n , a i \u2208 \u03a3, the length of w is |w| = n; the length of \u03b5 is 0. We also denote w[i] = a i and w[i..j] = a i a i+1 \u00b7 \u00b7 \u00b7 a j , for all 1 \u2264 i \u2264 j \u2264 n. The reversal of w is a n a n\u22121 \u00b7 \u00b7 \u00b7 a 1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "If w = xyz, for some w, x, y, z \u2208 \u03a3 * , then x, y, and z are a prefix, factor (or substring), and suffix of w, resp. The prefix (suffix) of length n of w is denoted pref n (w) (suff n (w)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "For further notions and results on string combinatorics and algorithms we refer to [14] and [7] .",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 87,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 92,
                    "end": 95,
                    "text": "[7]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "The formal definition of the shortest common superstring problem (SCS) is: given k strings w 1 , w 2 , . . ., w k , find a shortest string w which contains all w i s as factors; such a w is usually called a shortest common superstring. Any superstring will be called a solution, whereas a shortest one is an optimal solution. Example 1. Consider the strings w 1 = baac, w 2 = aacc, and w 3 = acaa. A shortest superstring has length 8; it is baacaacc.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Shortest Common Superstring Problem"
        },
        {
            "text": "The SCS problem has many applications. Data compression is one of the fields where the SCS problem is very useful because data may be stored very efficiently as a superstring; see [10] , [15] . This superstring contains all the information in a compressed form. Computational biology is another field where SCS can be applied; see [13] .",
            "cite_spans": [
                {
                    "start": 180,
                    "end": 184,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 187,
                    "end": 191,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 331,
                    "end": 335,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "The Shortest Common Superstring Problem"
        },
        {
            "text": "The SCS problem was proved to be NP-hard in [10] and then MAX SNPhard in [3] . Therefore, it is unlikely to have polynomial time exact algorithms and research focussed mainly on approximation algorithms [17, 8, 11, 1, 2, 4] . The best approximation algorithm to date is due to Sweedyk [16] and can reach an approximation ratio of 2 1 2 . Still, in practice the very simple greedy algorithm is used with very good results. Blum et al. [3] proved that greedy is a 4-approximation algorithm. The still open conjecture is that the approximation factor is 2, which would be optimal as there are examples for which greedy produces no better approximations.",
            "cite_spans": [
                {
                    "start": 44,
                    "end": 48,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 73,
                    "end": 76,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 203,
                    "end": 207,
                    "text": "[17,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 208,
                    "end": 210,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 211,
                    "end": 214,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 215,
                    "end": 217,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 218,
                    "end": 220,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 221,
                    "end": 223,
                    "text": "4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 332,
                    "end": 333,
                    "text": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 434,
                    "end": 437,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "The Shortest Common Superstring Problem"
        },
        {
            "text": "As already mentioned in the introduction, viruses can overlap their genes. There are several types of overlaps. First we need to recall the DNA complementarity: the two strands of DNA are complementary and have opposite direction. The complementarity is such that whenever an A occurs on one strand, a T must appear on the other; we say that A and T are complementary. Similarly, C and G are complementary. We denote the complement of a nucleotide N by N . That is, we have A = T, C = G, and vice versa. Also, A = A. Complementarity is needed to understand retrograde overlapping.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Viral Genome Compression"
        },
        {
            "text": "For a string w = a 1 a 2 \u00b7 \u00b7 \u00b7 a |w| , we construct the complemented reversal of w, w = a |w| a |w|\u22121 \u00b7 \u00b7 \u00b7 a 1 . When w appears in one strand, w occurs opposite it in the other strand. Fig. 1 we have overlaps on the same strand, that is, direct overlaps; one is called suffix overlap and the other prefix overlap but such a difference is irrelevant for us.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 186,
                    "end": 192,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Viral Genome Compression"
        },
        {
            "text": "In ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Viral Genome Compression"
        },
        {
            "text": "correspond to an x in the lower strand. Again, one is called head-on overlap, the other end-on overlap, without relevance for our purpose.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. Retrograde overlaps (opposite strands)"
        },
        {
            "text": "In order to give some algorithms for optimal or approximate solutions for the SCS problem, we need to compute overlaps between strings. Also, we need to eliminate those strings which are factors of others.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "An overlap between two given strings u and v is any suffix of u that is also a prefix of v. We shall need only the longest overlaps but our algorithm computes them all in the same optimal time. The set overlaps(u, v) contains the lengths of all suffixes of u that are prefixes of v. We denote by overlap(u, v) the length of the longest overlap. Here is an example. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "To compute overlaps, we shall use a classical notion in pattern matching: a border of a string w is any string which is both a prefix and a suffix of w; the border of w, denoted border(w), is the longest non-trivial border of w, that is, different from w itself. Notice that all borders of w are: border(w), border 2 (w) = border(border(w)), border 3 (w), . . . , \u03b5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "Denote |w| = n and consider the array border w [0..n], where, for all We use borders to solve our problem. Assume we are given two strings u and v. Consider a new letters # (which does not appear in u or v) and construct the string w = v#u. It is clear that any border of w gives an overlap of u and v and vice versa. Therefore, using borders, we obtain an algorithm for computing overlaps which is linear in terms of |u| + |v|. Notice, however, that if one of the strings is much longer than the other, then we do not need the whole long string but just a short piece of it. An algorithm which works in linear time in the size of the shorter string would simply consider the string pref",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "We can also do it all at once. For the SCS problem, we always exclude from calculations the strings which are included as factors in others. This is pattern searching and there are many linear time algorithms for it. We can also use the borders as above to give a simple algorithm to both identify factors and compute overlaps. We consider w = v#u. Assuming |v| \u2264 |u|, v is a factor of u if and only if there is i such that border w (i) = |v|.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "if borderw[i] = |v| and |v| \u2264 |u| then 11.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "return",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "This algorithm is linear in |u| + |v|; this is optimal since it is the minimum required for searching. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Computing Overlaps"
        },
        {
            "text": "We may assume that none of the strings w i appears as factor of another one. (We check this in the algorithm.) Therefore, for any solution w of SCS, there is a permutation \u03c3 on k elements such that w contains each w i as a factor starting at position p i and p \u03c3(1) < p \u03c3(2) < \u00b7 \u00b7 \u00b7 < p \u03c3(k) .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "Example 5. For the strings in Example 1, the optimal solution is given by the permutation (1, 3, 2) . Therefore, our brute-force algorithm to compute an optimal solution of SCS will try all such permutations \u03c3; the set of all permutations on k elements is the symmetric group S k . For each permutation, we need the maximum overlap between w \u03c3(i) and w \u03c3(i+1) . No other overlaps are needed. Assuming that w \u03c3(i) and w \u03c3(i+1) overlap each other on a length less than their maximal overlap. Then we can simply overlap them more to obtain a shorter superstring.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 90,
                    "end": 99,
                    "text": "(1, 3, 2)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "We shall need one more definition. For two strings u and v which are not factors of each other, we denote by merge(u, v) the string obtained by overlapping them as much as possible, that is,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "Here is the algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "scs-optimal(w1, w2, . . . , w k ) 1. for i from 1 to k do 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "for j from 1 to k do 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "if i = j then 4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "overlap(wi, wj ) \u2190 overlaps-and-factors(wi, wj ) 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "if overlap(wi, wj ) = \u22121 then eliminate wi 6. scs \u2190 k i=0 |wi| [ we use the same k but it may be smaller ] 7. for all \u03c3 \u2208 S k do 8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "w \u2190 w \u03c3(1) 9.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "for i from 2 to k do 10.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "w \u2190 merge(w, w \u03c3(i) ) 11.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "if scs > |w| then 12.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "scs \u2190 |w| 13. return scs Proposition 1. The algorithm scs-optimal(w 1 , w 2 , . . . , w k ) computes an optimal solution for SCS and runs in time",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "Proof. The correctness follows from the fact that we try all permutations. As explained above, after eliminating strings which appear as factors of others, it it enough to consider only longest overlaps.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "The time complexity for the preprocessing steps 1-5 is O(k 2 ), because of Lemma 1. In the main processing part, steps 7-12, we repeat k! times something linear in . This is the dominant order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal Solutions of SCS"
        },
        {
            "text": "As the SCS problem is NP-hard, in practice approximation algorithms are often used to find a superstring which may not be shortest but hopefully close to optimal. The most common such algorithm for SCS is the greedy algorithm, which we describe below. It uses the natural idea of considering the longer overlaps first. It may not produce an optimal solution but it cannot be too far away. Here is an example when the greedy algorithm does not give an optimal solution. Example 7. Consider again the strings in Example 1, w 1 = baac, w 2 = aacc, and w 3 = acaa. The overlaps are shown below:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Approximate Solutions of SCS"
        },
        {
            "text": "The greedy algorithm chooses first the longest overlap, that is, overlap(w 1 , w 2 ), and obtains the string baaccacaa of length 9, since merge(w 1 , w 2 ) and w 3 have no overlap. But there is a shorter one, given by the permutation (1, 3, 2) , of length 8, that is baacaacc.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 234,
                    "end": 243,
                    "text": "(1, 3, 2)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Approximate Solutions of SCS"
        },
        {
            "text": "It is conjectured that the greedy solution is always at most twice longer than optimal; see [16] and the references therein for approximation algorithms for the SCS problem. In practice, the greedy algorithm works pretty well, as we shall see also in our experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Approximate Solutions of SCS"
        },
        {
            "text": "scs-greedy(w1, w2, . . . , w k ) 1. compute overlaps and eliminate factors as before 2. greedy scs \u2190 k i=0 |wi| 3. for all (i, j) with overlap(wi, wj) = max (s,t) overlap(ws, wt) do",
            "cite_spans": [
                {
                    "start": 157,
                    "end": 162,
                    "text": "(s,t)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Approximate Solutions of SCS"
        },
        {
            "text": "eliminate wi and wj from the list 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "add w = merge(wi, wj) to the list 6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "denote the new list w 1 , . . . , w k\u22121 7.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "the overlaps of w are given by wi for prefix and by wj for suffix 8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "\u2190 scs-greedy(w 1 , w 2 , . . . , w k\u22121 ) 9.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "if greedy scs > then 10.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "greedy scs \u2190 11. return greedy scs",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "The greedy algorithm gives an upper bound for the shortest length of a common superstring.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "4."
        },
        {
            "text": "We give in this section a lower bound for the length of the shortest superstring. It is computed using also a greedy approach but without checking if it is possible to actually find a superstring which uses the considered overlaps. (When this is possible, we have an optimal solution of SCS.)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "Any superstring w is defined by a permutation \u03c3 on k elements which gives k \u2212 1 overlaps. Also, the length of the superstring is the total length of all strings minus the total length of overlaps, that is, w \u03c3(i+1) ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 206,
                    "end": 214,
                    "text": "w \u03c3(i+1)",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Lower Bounds"
        },
        {
            "text": "For our estimate, we consider the matrix of overlaps, (overlap(w i , w j )) 1\u2264i =j\u2264k . A permutation \u03c3 as above gives k \u22121 overlaps such that no two are in the same row or column. We relax this condition by considering only rows or only columns. Choosing k \u2212 1 longest overlaps such that no two are on the same row gives a lower bound. Similarly for columns.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "The algorithm below computes the first one. The second is computed analogously. We assume the matrix of overlaps has already been computed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "lower- bound-row(w1, w2, . . . , w k ) 1. sort all elements of the matrix (overlap(wi, wj)) 1\u2264i =j\u2264k decreasingly 2.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 7,
                    "end": 38,
                    "text": "bound-row(w1, w2, . . . , w k )",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Lower Bounds"
        },
        {
            "text": "to obtain overlap(wi 1 , wj 1 ), . . . , overlap(wi n 2 \u2212n , wj n 2 \u2212n ) 3. lower bound row \u2190 0 4. rows used \u2190 0 5. t \u2190 1 6. while rows used < k \u2212 1 do 7.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "if row it not used then 8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "lower bound row \u2190 lower bound row + |wi t | \u2212 overlap(wi t , wj t ) 9.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "mark row it as used 10.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "rows used \u2190 rows used + 1 11.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "t \u2190 t + 1 12. lower bound row \u2190 lower bound row + |wj t\u22121 | 13. return lower bound row For correctness, it is enough to prove that the sum of the overlaps chosen by the algorithm is larger than the sum of overlaps corresponding to an optimal solution. In both cases, we have k \u2212 1 overlaps involved, no two in the same row. Assume that an optimal solution chooses all rows except for the ith whereas our algorithm for the lower bound misses only the jth row. In all rows chosen by both, the overlap included for the lower bound is at least as large. If i = j, this proves that we obtain indeed a lower bound. If i = j, then the overlap chosen for the lower bound from row i is larger than the one for the optimal solution in row j as the former appear first in the sorted list from step 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "As already mentioned, another lower bound is obtained similarly, by choosing k \u2212 1 elements from different columns in the overlap matrix; denote this lower bound by lower bound col. We have then the following lower bound:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "lower bound scs = max(lower bound row, lower bound col).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "The next result, which summarizes the above discussed bounds, is clear. lower bound row = 7, because of overlap(w 1 , w 2 ) and overlap(w 3 , w 2 ), lower bound col = 7, because of overlap(w 1 , w 2 ) and overlap(w 1 , w 3 ), lower bound scs = 7, scs = 8, greedy scs = 9.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "The lower bound cannot be achieved however, as it involves the beginning of w 2 (or the end of w 1 ) twice. Also, it happened that the lower bounds corresponding to rows and columns are the same; this is not true in general.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lower Bounds"
        },
        {
            "text": "The possibility of retrograde overlaps (see Fig. 2 ) further complicates the search for solutions, optimal or approximate. Each string may appear in a superstring as it is or as its complemented reversal.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 44,
                    "end": 50,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Retrograde Overlaps"
        },
        {
            "text": "Therefore, we need first to compute more overlaps. The following equalities help computing only half of all possible ones:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Retrograde Overlaps"
        },
        {
            "text": "For the exact algorithm, we need to consider, for each string w i , whether w i or w i appears at position p \u03c3(i) , which makes the algorithm even slower in the number of strings.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Retrograde Overlaps"
        },
        {
            "text": "The greedy algorithm works rather similarly. Only the overlaps for the merged strings need to be set a bit differently. For instance, if the overlap between w i and w j is chosen, then the string merge(w i , w j ) is added and its overlaps are taken from those given by prefixes of w i and w j .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Retrograde Overlaps"
        },
        {
            "text": "The lower bound is computed similarly. When choosing a certain overlap, the proper rows or columns need to be discarded for further consideration. For instance, in case of lower bound row, if the overlap between w i and w j is chosen, then all overlaps involving the suffix of of w i must be discarded, that is, all pairs (w i , w s ), (w i , w s ), (w s , w i ) and (w s , w i ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Retrograde Overlaps"
        },
        {
            "text": "We show in this section our computations for a number of viral genomes which were obtained from \"The National Center for Biotechnology Information,\" (web site www.ncbi.nlm.nih.gov). We start with a set of strings which are the genes and try to find a short superstring. Then we compare our result with the one achieved by the viruses. Notice that the time complexity of our exact algorithm grows very fast with the number of genes, but is linear in the total length. We managed to obtain exact solutions in Table 1 for a number of single stranded RNA viral genomes with relatively few genes. The columns give, in order, the family, the name of the virus, the total length of all genes, the compression achieved by the virus (total length of coding regions), and the shortest common superstring. All lengths are given in number of nucleotides. For genomes with more genes, we had to use the approximation algorithms. The results for a number of double stranded DNA viral genomes are shown in Table 2 . The columns have similar meaning, except that the one for the shortest common superstring is replaced by two: greedy and lower bound. All lengths are given in number of base pairs. The compression achieved by the viruses is, on average, 7.98%, that is, the (average) ratio between the reduction in size (total length of all genes minus viral coding) and the initial size (total length of genes). For the viruses in the first table, the ratio is higher, 11.95%, whereas for the second table it is 3.36%. The average compression ratio is remarkably high if we keep in mind that DNA molecules (seen as strings) are very difficult to compress in general. Commercial file-compression programs achieve usually no compression at all and the best especially designed algorithms, see [6] , can achieve something like 13.73% (that is the average for DNACompress from [6] , the best such algorithm to date).",
            "cite_spans": [
                {
                    "start": 1776,
                    "end": 1779,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1858,
                    "end": 1861,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 507,
                    "end": 514,
                    "text": "Table 1",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 991,
                    "end": 998,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Viral Compression Versus Computer Compression"
        },
        {
            "text": "Also, the compression achieved by viruses is very close to what we can do (using overlapping only) by computers. The above averages, for all viruses considered, single stranded RNA, and double stranded DNA viruses are 8.11% (only 0.13% better than viruses), 11.99%, and 3.59%, resp. For the second table we used the greedy compression; it should also be noticed that our lower bound behaves pretty well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Viral Compression Versus Computer Compression"
        },
        {
            "text": "To give a better idea of the overlaps, Figs. 3-14 at the end show all genomes considered above as they appear in nature with the non-coding regions removed (top) and then as computed by our programs (bottom). The overlaps and different strands are shown in different color. (The figures are most useful in the electronic version of the paper.)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Viral Compression Versus Computer Compression"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Improved length bounds for the shortest superstring problem",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Armen",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Stein",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Proc. 5th Internat. Workshop on Algorithms and Data Structures",
            "volume": "955",
            "issn": "",
            "pages": "494--505",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A 2 2 3 approximation algorithm for the shortest superstring problem",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Armen",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Stein",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Proc. Combinatorial Pattern Matching",
            "volume": "1075",
            "issn": "",
            "pages": "87--101",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Linear approximation of shortest superstrings",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Blum",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tromp",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yannakakis",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "J. Assoc. Comput. Mach",
            "volume": "41",
            "issn": "4",
            "pages": "630--647",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Rotations of periodic strings and short superstrings",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Breslauer",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "J. Algorithms",
            "volume": "24",
            "issn": "",
            "pages": "340--353",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Principles of Molecular Virology",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Cann",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "DNACompress: fast and effective DNA sequence compression",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Ma",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tromp",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Bioinformatics",
            "volume": "18",
            "issn": "",
            "pages": "2002--1696",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Parallel and sequential approximations of shortest superstrings",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Czumaj",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Gasieniec",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Piotrow",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Proc. First Scandinavian Workshop on Algorithm Theory",
            "volume": "824",
            "issn": "",
            "pages": "95--106",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Viral gene compression: complexity and verification",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Daley",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Mcquillan",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proc. of CIAA'04",
            "volume": "3317",
            "issn": "",
            "pages": "102--112",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "On finding minimal length superstrings",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gallant",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Maier",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Storer",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "Journal of Comput. and Syst. Sci",
            "volume": "20",
            "issn": "1",
            "pages": "50--58",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Long tours and short superstrings",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kosaraju",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Park",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Stein",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Proc. 35th Annual IEEE Symposium on Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "166--177",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Evolutionary principles of genomic compression",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "C"
                    ],
                    "last": "Krakauer",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Comments on Theor. Biol",
            "volume": "7",
            "issn": "",
            "pages": "215--236",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Introduction to Bioinformatics",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lesk",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Algebraic Combinatorics on Words",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lothaire",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "1 2 -approximation algorithms for shortest superstring",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Storer",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Data Compression: Methods and Theory",
            "volume": "16",
            "issn": "",
            "pages": "954--986",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Approximating shortest superstrings",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Teng",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Yao",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "Proc. 34th Annual IEEE Symposium on Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "158--165",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Let x = ACCGTGTAC and y = GTGTACCGTAC be two hypothetical genes. The complemented reversal of x is x = GTACACGGT. The possible overlaps between x and y are shown in Figs. 1 and 2. In",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "we have retrograde overlaps (as can appear, for instance, in double stranded DNA viral genomes). As seen in the figure, each x in the upper strand y GT GT ACCGT ACCGT GT AC Direct overlaps (same strand)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "For the strings u = abaababa and v = abababb we have",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "For the string w = abaababaaba we haveborder w = [borders of w are border w (|w|) = 6, border(w) = abaaba, border 2 w (|w|) = 3, border 2 (w) = aba, border 3 w (|w|) = 1, border 3 (w) = a.The array border w can be computed in time linear in |w| by a classical algorithm. The idea is to compute the elements from first to last. Then, when computing border w [i], all previous elements are known. The border of w[1..i]   is either an extension of a border of w[1..i \u2212 1]  or empty if this is not possible.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "The algorithm overlaps-and-factors(u, v) returns \u22121 iff v is a factor of u and otherwise computes the longest overlap of u and v. It runs in time O(|u| + |v|).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "The above algorithm computes a lower bound for the length of the shortest superstring in time O(k 2 log k). Proof. The time required by the algorithm is O(k 2 log k) because of sorting. The while cycle takes only O(k 2 ) time as it traverses the list of k 2 \u2212 k elements at most once and spends constant time for each element.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Human respiratory syncytial virus Bovine ephemeral fever virus",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Northern cereal mosaic virus Sleeping disease virus SARS coronavirus HIV-1 isolate 01IN565.11 from India HIV-2 isolate ALI from Guinea-Bissau Human Choristoneura fumiferana MNPV (left) and Vaccinia Virus strain Ankara (right)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Bovine Hemorrhagic enteritis virus",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Frog virus 3",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Proposition 3. We always have lower bound scs \u2264 scs \u2264 greedy scs. Example 8. For the strings in Example 1, we have:",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Viral genome compression -optimal solutionsTable 2. Viral genome compression -approximate solutions",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}