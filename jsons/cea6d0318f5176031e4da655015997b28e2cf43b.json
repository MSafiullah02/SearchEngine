{
    "paper_id": "cea6d0318f5176031e4da655015997b28e2cf43b",
    "metadata": {
        "title": "Complete Variable-Length Codes: An Excursion into Word Edit Operations",
        "authors": [
            {
                "first": "Jean",
                "middle": [],
                "last": "N\u00e9raud",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Laboratoire d'Informatique",
                    "institution": "Universit\u00e9 de Rouen",
                    "location": {
                        "addrLine": "Avenue de l'Universit\u00e9",
                        "postCode": "76800",
                        "settlement": "Saint-\u00c9tienne-du-Rouvray",
                        "country": "France"
                    }
                },
                "email": "jean.neraud@univ-rouen.fr"
            }
        ]
    },
    "abstract": [
        {
            "text": "The language X is complete if any word over A is a factor of some concatenation of words in X. Given a family of languages F containing X, X is maximal in F if no other set of F can strictly contain X. A language X \u2286 A * is a variable-length code if any equation among the words of X is necessarily trivial. The study discusses the relationship between maximality and completeness in the case of \u03c4 -independent or \u03c4 -closed variable-length codes. We focus to the binary relations by which the images of words are computed by deleting, inserting, or substituting some characters.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "In formal language theory, given a property F, the embedding problem with respect to F consists in examining whether a language X satisfying F can be included into some languageX that is maximal with respect to F, in the sense that no language satisfying F can strictly containX. In the literature, maximality is often connected to completeness: a language X over the alphabet A is complete if any string in the free monoid A * (the set of the words over A) is a factor of some word of X * (the submonoid of all concatenations of words in X). Such connection takes on special importance for codes: a language X over the alphabet A is a variable-length code (for short, a code) if every equation among the words (i.e. strings) of X is necessarily trivial.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A famous result due to M.P. Sch\u00fctzenberger states that, for the family of the so-called thin codes (which contains regular codes and therefore also finite ones), being maximal is equivalent to being complete. In connection with these two concepts lots of challenging theoretical questions have been stated. For instance, to this day the problem of the existence of a finite maximal code containing a given finite one is not known to be decidable. From this latter point of view, in [16] the author asked the question of the existence of a regular complete code containing a given finite one: a positive answer was brought in [4] , where was provided a now classical formula for embedding a given regular code into some complete regular one. Famous families of codes have also been concerned by those studies: we mention prefix and bifix codes [2, Theorem 3.3.8, Proposition 6.2.1], codes with a finite deciphering delay [3] , infix [10] , solid [11] , or circular [13] .",
            "cite_spans": [
                {
                    "start": 482,
                    "end": 486,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 625,
                    "end": 628,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 920,
                    "end": 923,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 932,
                    "end": 936,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 945,
                    "end": 949,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 964,
                    "end": 968,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Actually, with each of those families, a so-called dependence system can be associated. Formally, such a system is a family F of languages constituted by those sets X that contain a non-empty finite subset in F. Languages in F are F-dependent, the other ones being F-independent. A special case corresponds to binary words relations \u03c4 \u2286 A * \u00d7 A * , where a dependence systems is constituted by those sets X satisfying \u03c4 \u2229 (X \u00d7X) = \u2205: X is \u03c4 -independent if we have \u03c4 (X) \u2229 X = \u2205 (with \u03c4 (X) = {y : \u2203x \u2208 X, (x, y) \u2208 \u03c4 }). Prefix codes certainly constitute the best known example: they constitute those codes that are independent with respect to the relation obtained by removing each pair (x, x) from the famous prefix order. Bifix, infix or solid codes can be similarly characterized.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As regards to dependence, some extremal condition corresponds to the socalled closed sets: given a word relation \u03c4 \u2286 A * \u00d7 A * , a language X is closed under \u03c4 (\u03c4 -closed, for short) if we have \u03c4 (X) \u2286 X. Lots of topics are concerned by the notion. We mention the framework of prefix order where a one-to-one correspondence between independent and closed sets is provided in [2, Proposition 3.1.3] (cf. also [1, 18] ). Congruences in the free monoid are also concerned [15] , as well as their connections to DNA computing [7] . With respect to morphisms, involved topics are also provided by the famous L-systems [17] and, in the case of one-to-one (anti)-automorphisms, the so-called invariant sets [14] .",
            "cite_spans": [
                {
                    "start": 408,
                    "end": 411,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 412,
                    "end": 415,
                    "text": "18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 469,
                    "end": 473,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 522,
                    "end": 525,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 613,
                    "end": 617,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 700,
                    "end": 704,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As commented in [6] , maximality and completeness concern the economy of a code. If X is a complete code then every word occurs as part of a message, hence no part of X * is potentially useless. The present paper emphasizes the following questions: given a regular binary relation \u03c4 \u2286 A * \u00d7 A * , in the family of regular \u03c4 -independent (-closed) codes, are maximality and completeness equivalent notions? Given a non-complete regular \u03c4 -independent (-closed) code, is it embeddable into some complete one?",
            "cite_spans": [
                {
                    "start": 16,
                    "end": 19,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Independence has some peculiar importance in the framework of coding theory. Informally, given some concatenation of words in X, each codeword x \u2208 X is transmitted via a channel into a corresponding y \u2208 A * . According to the combinatorial structure of X, and the type of channel, one has to make use of codes with prescribed error-detecting constraints: some minimum-distance restraint is generally applied. In this paper, where we consider variable length codewords, we address to the Levenshtein metric [12] : given two different words x, y, their distance is the minimal total number of elementary edit operations that can transform x into y, such operation consisting in a one character deletion, insertion, or substitution. Formally, it is the smallest integer p such that we have y \u2208 \u039b p (x), with \u039b p = 1\u2264k\u2264p (\u03b4 1 \u222a \u03b9 1 \u222a \u03c3 1 ) k , where \u03b4 k , \u03b9 k , \u03c3 k are further defined below.",
            "cite_spans": [
                {
                    "start": 506,
                    "end": 510,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "From the point of view of error detection, X being \u039b p -independent guarantees that y \u2208 \u039b p (x) implies y = x. In addition, a code satisfies the property of error correction if its elements are such that \u039b p (x) \u2229 \u039b p (y) = \u2205 unless x = y: according to [9, chap. 6] , the existence of such codes is decidable. Denote by Subw(x) the set of the subsequences of x:",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 265,
                    "text": "[9, chap. 6]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "-\u03b4 k , the k-character deletion, associates with every word x \u2208 A * , all the words y \u2208 Subw(x) whose length is |x| \u2212 k. The at most p-character deletion is \u0394 p = 1\u2264k\u2264p \u03b4 k ; -\u03b9 k , the k-character insertion, is the converse relation of \u03b4 k and we set I p = 1\u2264k\u2264p \u03b9 k (at most p-character insertion); -\u03c3 k , the k-character substitution, associates with every x \u2208 A * , all y \u2208 A * with length |x| such that y i (the letter of position i in y), differs of x i in exactly k positions i \u2208 [1, |x|]; we set \u03a3 p = 1\u2264k\u2264p \u03c3 k ; -We denote by \u039b p the antireflexive relation obtained by removing all pairs",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "For short, we will refer the preceding relations to edit relations. For reasons of consistency, in the whole paper we assume |A| \u2265 2 and k \u2265 1. In what follows, we draw the main contributions of the study:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Firstly, we prove that, given a positive integer k, the two families of languages that are independent with respect to \u03b4 k or \u03b9 k are identical. In addition, for k \u2265 2, no set can be \u039b k -independent. We establish the following result:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Theorem A. Let A be a finite alphabet, k \u2265 1, and \u03c4 \u2208 \u03b4 k , \u03b9 k , \u03c3 k , \u0394 k , I k , \u03a3 k , \u039b k . Given a regular \u03c4 -independent code X \u2286 A * , X is complete if, and only if, it is maximal in the family of \u03c4 -independent codes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A code X is \u039b k -independent if the Levenshtein distance between two distinct words of X is always larger than k: from this point of view, Theorem A states some noticeable characterization of maximal k-error detecting codes in the framework of the Levenshtein metric.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Secondly, we explore the domain of closed codes. A noticeable fact is that for any k, there are only finitely many \u03b4 k -closed codes and they have finite cardinality. Furthermore, one can decide whether a given non-complete \u03b4 k -closed code can be embedded into some complete one. We also prove that no closed code can exist with respect to the relations \u03b9 k , \u0394 k , I k .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "As regard to substitutions, beforehand, we focus to the structure of the set \u03c3 * k (w) = i\u2208N \u03c3 i k . Actually, excepted for two special cases (that is, k = 1 [5, 19] , or k = 2 with |A| = 2 [8, ex. 8, p.77]), to our best knowledge, in the literature no general description is provided. In any event we provide such a description; furthermore we establish the following result:",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 161,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 162,
                    "end": 165,
                    "text": "19]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Theorem B. Let A be a finite alphabet and k \u2265 1. Given a complete \u03c3 k -closed code X \u2286 A * , either every word in X has length not greater than k, or a unique integer n \u2265 k + 1 exists such that X = A n . In addition for every \u03a3 k (\u039b k )-closed code X, some positive integer n exists such that X = A n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In other words, no \u03c3 k -closed code can simultaneously possess words in A \u2264k and words in A \u2265k+1 . As a consequence, one can decide whether a given noncomplete \u03c3 k -closed code X \u2286 A * is embeddable into some complete one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We adopt the notation of the free monoid theory. Given a word w, we denote by |w| its length; for a \u2208 A, |w| a denotes the number of occurrences of the letter a in w. The set of the words whose length is not greater (not smaller) than n is denoted by A \u2264n (A \u2265n ). Given x \u2208 A * and w \u2208 A + , we say that x is a factor of w if words u, v exist such that w = uxv; a subword of w consists in any (perhaps empty) subsequence w i1 \u00b7 \u00b7 \u00b7 w in of w = w 1 \u00b7 \u00b7 \u00b7 w |w| . We denote by F(X) (Subw(X)) the set of the words that are factor (subword) of some word in X",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "It is assumed that the reader has a fundamental understanding with the main concepts of the theory of variable-length codes: we suggest, if necessary, that he (she) report to [2] . A set X is a variable-length code (a code for short) if for any pair of sequences of words in X, say (x i ) 1\u2264i\u2264n , (y j ) 1\u2264j\u2264p , the equation x 1 \u00b7 \u00b7 \u00b7 x n = y 1 \u00b7 \u00b7 \u00b7 y p implies n = p, and x i = y i for each integer i (equivalently the submonoid X * is free). The two following results are famous ones from the variable-length codes theory: Theorem 1. Sch\u00fctzenberger [2, Theorem 2.5.16] Let X \u2286 A * be a regular code. Then the following properties are equivalent:",
            "cite_spans": [
                {
                    "start": 175,
                    "end": 178,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "(iii) a positive Bernoulli distribution \u03c0 exists such that \u03c0(X) = 1; (iv) for every positive Bernoulli distribution \u03c0 we have \u03c0(X) = 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Given a non-complete code X, let y \u2208 A * \\ F(X * ) be an overlapping-free word and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2. [4]"
        },
        {
            "text": "With regard to word relations, the following statement comes from the definitions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2. [4]"
        },
        {
            "text": "Each of the following properties holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 2. [4]"
        },
        {
            "text": "We start by providing a few examples:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Independent Codes"
        },
        {
            "text": "we have a n\u22121 b \u2208 \u03b4 k (a n b)), whereas the following codes are \u03b4 1 -independent:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Independent Codes"
        },
        {
            "text": "-the regular code:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Independent Codes"
        },
        {
            "text": "We have \u03b4 1 (T ) = A n \u222a A p , which is not a code, although it is complete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Independent Codes"
        },
        {
            "text": "In view of establishing the main result of Sect. 3, we will construct some peculiar word:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Independent Codes"
        },
        {
            "text": "Proof. Let X be a non-complete code, and let w \u2208 A * \\ F(X * ). Trivially, we have w k+1 / \u2208 F(X * ). Moreover, in a classical way a word u \u2208 A * exists such that y = w k+1 u is overlapping-free (e.g. [2, Proposition 1.3.6]). Since we assume i \u2208 [1, k] , each word in \u03c4 (y) is constructed by deleting (inserting, substituting) at most k letters from y, hence by construction it contains at least one occurrence of w as a factor. This implies \u03c4 (y) \u2229 F(X * ) = \u2205, thus \u03c4 (y) does not intersect X.",
            "cite_spans": [
                {
                    "start": 246,
                    "end": 252,
                    "text": "[1, k]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Complete Independent Codes"
        },
        {
            "text": "By contradiction, assume that a word x \u2208 X exists such that y \u2208 \u03c4 (x). It follows from \u03b4 \u22121 k = \u03b9 k and \u03c3 \u22121 k = \u03c3 k that y = w k+1 u is obtained by deleting (inserting, substituting) at most k letters from x: consequently at least one occurrence of w appears as a factor of x \u2208 X \u2286 F(X * ): this contradicts w / \u2208 F(X * ), therefore we obtain y / \u2208 \u03c4 (X) (cf. Fig. 1 ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 361,
                    "end": 367,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Complete Independent Codes"
        },
        {
            "text": "Proof of Lemma 5: y \u2208 \u03c4 (X) implies w \u2208 F(X); for i = k = 3 and y = w 4 u, the action of the substitution \u03c4 = \u03c33 is represented in some extremal condition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "As a consequence, we obtain the following result: Theorem 6. Let k \u2265 1 and \u03c4 \u2208 {\u03b4 k , \u03b9 k , \u03c3 k }. Given a regular \u03c4 -independent code X \u2286 A * , X is complete if, and only if, it is maximal as a \u03c4 -independent codes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "Proof. According to Theorem 1, every complete \u03c4 -independent code is a maximal code, hence it is maximal in the family of \u03c4 -independent codes. For proving the converse, we make use of the contrapositive. Let X be a non-complete \u03c4independent code, and let y \u2208 A * \\ F(X * ) satisfying the conditions of Lemma 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "With the notation of Theorem 2, necessarily X \u222a {y}, which is a subset of Y = X \u222a y(Uy) * , is a code. According to Lemma 5, we have \u03c4 (y) \u2229 X = \u03c4 (X) \u2229 {y} = \u2205. Since X is \u03c4 -independent and \u03c4 antireflexive, this implies \u03c4 (X \u222a {y}) \u2229 (X \u222a {y}) = \u2205, thus X non-maximal as a \u03c4 -independent code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "We notice that for k \u2265 2 no \u039b k -independent set can exist (indeed, we have",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "). However, the following result holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "Given a regular \u03c4 -independent code X \u2286 A * , X is complete if, and only if, it is maximal as a \u03c4 -independent code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "Proof. As indicated above, if X is complete, it is maximal as a \u03c4 -independent code. For the converse, once more we argue by contrapositive that is, with the notation of Lemma 5, we prove that X \u222a{y} remains independent. By definition,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "With regard to the relation \u039b k , Corollary 7 expresses some interesting property in term of error detection. Indeed, as indicated in Sect. 1, every code is \u039b kindependent if the Levenshtein distance between its (distinct) elements is always larger than k. From this point of view, Corollary 7 states some characterization of the maximality in the family of such codes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "It should remain to develop some method in view of embedding a given noncomplete \u039b k -code into a complete one. Since the construction from the proof Theorem 2 does not preserve independence, this question remains open.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 1."
        },
        {
            "text": "We start with the relation \u03b4 k . A noticeable fact is that corresponding closed codes are necessarily finite, as attested by the following result:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Closed Codes with Respect to Deletion or Insertion"
        },
        {
            "text": "Proof. It follows from \u03b5 / \u2208 X and X being \u03b4 k -closed that |x| = k. By contradiction, assume |x| \u2265 (k \u2212 1)k and let q, r be the unique pair of integers such that |x| = qk + r, with 0 \u2264 r \u2264 k \u2212 1. Since we have 0 \u2264 rk \u2264 (k \u2212 1)k \u2264 |x|, an integer s \u2265 0 exists such that |x| = rk + s, thus words x 1 , \u00b7 \u00b7 \u00b7 , x k , y exist such that x = x 1 \u00b7 \u00b7 \u00b7 x k y, with |x 1 | = \u00b7 \u00b7 \u00b7 = |x k | = r and |y| = s. By construction, every word t \u2208 Sub(x) with |t| \u2208 {r, s} belongs to \u03b4 * k (x) \u2286 X (indeed, we have r = |x| \u2212 qk and s = |x| \u2212 rk). This implies x 1 , \u00b7 \u00b7 \u00b7 , x k , y \u2208 X, thus x \u2208 X k+1 \u2229 X: a contradiction with X being a code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Complete Closed Codes with Respect to Deletion or Insertion"
        },
        {
            "text": "(1) According to Proposition 8, no code can be \u03b4 1 -closed. This can be also drawn from the fact that, for every set X \u2286 A + we have \u03b5 \u2208 \u03b4 * 1 (X). (2) Let A = {a, b} and k = 3. According to Proposition 8, every word in any \u03b4 k -closed code has length not greater than 5. It is straightforward to verify that X = {a 2 , ab, b 2 , a 4 b, ab 4 } is a \u03b4 k -closed code. In addition, a finite number of examinations lead to verify that X is maximal as a \u03b4 k -closed code. Taking for \u03c0 the uniform distribution we have \u03c0(X) = 3/4 + 1/16 < 1: thus X is non-complete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 9."
        },
        {
            "text": "According to Example 9(2), no result similar to Theorem 6 can be stated in the framework of \u03b4 k -closed codes. We also notice that, in Proposition 8 the bound does not depend of the size of the alphabet, but only depends of k. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 9."
        },
        {
            "text": "We close the section by considering the relations \u0394 k , \u03b9 k and I k :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 9."
        },
        {
            "text": "Proof. By contradiction assume that some \u03b9 k -closed code X \u2286 A * exists. Let x \u2208 X, n = |x| and u, v \u2208 A * such that x = uv. It follows from |(vu) k | = kn, that u(vu) k v \u2208 \u03b9 * k (x). According to Lemma 3(iii), we have \u03b9 * k (X) \u2286 X, thus u(vu) k v \u2208 X. Since u(vu) k v = (uv) k+1 = x k+1 \u2208 X k+1 , we have X k+1 \u2229 X = \u2205: a contradiction with X being a code. Consequently no I k -closed codes can exist. According to Example 9(1), given a code X \u2286 A * , we have \u03b4 1 (X) \u2286 X: this implies \u0394 k (X) \u2286 X, thus X not \u0394 k -closed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 9."
        },
        {
            "text": "Beforehand, given a word w \u2208 A + , we need a thorough description of the set \u03c3 * k (w). Actually, it is well known that, over a binary alphabet, all n-bit words can be computed by making use of some Gray sequence [5] . With our notation, we have A n = \u03c3 * 1 (w). Furthermore, for every finite alphabet A, the so-called |A|arity Gray sequences allow to generate A n [8, 19] : once more we have \u03c3 * 1 (w) = A n . In addition, in the special case where k = 2 and |A| = 2, it can be proved that we have |\u03c3 2 (w)| = 2 n\u22121 [8, Exercise 8, p. 28 ]. However, except in these special cases, to the best of our knowledge no general description of the structure of \u03c3 * k (w) appears in the literature. In any event, in the next paragraph we provide an exhaustive description of \u03c3 k (w). Strictly speaking, the proofs, that we have reported in Sect. 5.2, are not involved in \u03c3 k -closed codes: we suggest the reader that, in a first reading, after Sect. 5.1 he (she) directly jumps to Sect. 5.3.",
            "cite_spans": [
                {
                    "start": 213,
                    "end": 216,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 365,
                    "end": 368,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 369,
                    "end": 372,
                    "text": "19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 517,
                    "end": 520,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 521,
                    "end": 532,
                    "text": "Exercise 8,",
                    "ref_id": null
                },
                {
                    "start": 533,
                    "end": 538,
                    "text": "p. 28",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Complete Codes Closed Under Substitutions"
        },
        {
            "text": "In the case where A is a binary alphabet, we set A = {0, 1}: this allows a wellknown algebraic interpretation of \u03c3 k . Indeed, denote by \u2295 the addition in the group Z/2Z with identity 0, and fix a positive integer n; given w, w \u2208 A n , define w \u2295 w as the unique word of A n such that, for each i \u2208 [1, n] , the letter of position i in w \u2295 w is w i \u2295 w i . With this notation the sets A n and (Z/2Z) n are in one-to-one correspondence. Classically, we have w \u2208 \u03c3 1 (w) if, and only if, some u \u2208 A n exists such that w = w \u2295 u with |u| 1 = 1 (thus |u| 0 = n \u2212 1). From the fact that \u03c3 k (w) \u2286 \u03c3 k 1 (w), the following property holds:",
            "cite_spans": [
                {
                    "start": 299,
                    "end": 305,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Basic Results Concerning \u03c3 * k (w)"
        },
        {
            "text": "In",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Results Concerning \u03c3 * k (w)"
        },
        {
            "text": "The following property follows from",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Results Concerning \u03c3 * k (w)"
        },
        {
            "text": "Finally, for a \u2208 A we denote by a its complementary letter that is, a = a \u2295 1; for w \u2208 A n we set w = w 1 \u00b7 \u00b7 \u00b7 w n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Results Concerning \u03c3 * k (w)"
        },
        {
            "text": "Given w, w \u2208 A n the two following properties hold:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 13. Let"
        },
        {
            "text": "(i) If k is even and w \u2208 \u03c3 * k (w) then |w | 1 \u2212 |w| 1 is an even integer; (ii) If |w | 1 \u2212 |w| 1 is even then we have w \u2208 \u03c3 * k (w), for every k \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 13. Let"
        },
        {
            "text": "Given a positive integer n, we denote A n 0 (A n 1 ) the set of the words w \u2208 A n such that |w| 1 is even (odd).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 13. Let"
        },
        {
            "text": "Assume |A| = 2. Given w \u2208 A \u2265k exactly one of the following conditions holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 14."
        },
        {
            "text": "Actually, Proposition 12 is a consequence of the following property:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Proof. Let w \u2208 \u03c3 1 (w) and n = |w| = |w | \u2265 k. We prove that w \u2208 A * exists with w \u2208 \u03c3 k (w) and w \u2208 \u03c3 k (w ). By construction, i 0 \u2208 [1, n] exists such that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "(a) w i = w i if, and only if, i = i 0 . It follows from k \u2264 n that some (k \u2212 1)-element subset I \u2286 [1, n] \\ {i 0 } exists. Since we have |A| \u2265 3, some letter c \u2208 A \\ {w i0 , w i0 } exists. Let w \u2208 A n such that: (b) w i0 = c and, for each i = i 0 : w i = w i if, and only if, i \u2208 I.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "By construction we have w \u2208 \u03c3 k (w), moreover c = w i0 implies w i0 = w i0 . According to (a) and (b), we obtain:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Since we have |I \u222a {i 0 }| = k, this implies w \u2208 \u03c3 k (w ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Proof of Proposition 12. Let w \u2208 A n \\ {w}: we prove that w \u2208 \u03c3 * k (w). Let",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "if, and only if, = i j+1 . Since we have w (ij+1) \u2208 \u03c3 1 (w (ij ) ) (1 \u2264 j < p), by induction over j we obtain w \u2208 \u03c3 * 1 (w) thus, according to Lemma 15: w \u2208 \u03c3 * k (w).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "In view of proving Lemma 13 and Proposition 14, we need some new lemma:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Proof. Set A = {0, 1}. It follows from \u03c3 2 \u2286 \u03c3 2 1 that the result holds for k = 1. Assume k \u2265 2 and let n = |w|, w \u2208 \u03c3 2 (w). By construction, there are distinct integers i 0 , j 0 \u2208 [1, n] such that the following holds: By construction, we have w \u2208 \u03c3 k (w) and w \u2208 \u03c3 k (w ), thus w \u2208 \u03c3 2 k (w). Moreover, the fact that we have w = w is attested by the following equations:",
            "cite_spans": [
                {
                    "start": 184,
                    "end": 190,
                    "text": "[1, n]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Proof of Lemma 13. Assume k even. According to Property (1) we have w = w \u2295 u with |u| 1 = k. According to (2) , |w | 1 \u2212 |w| 1 is even: hence (i) follows. Conversely, assume |w | 1 \u2212 |w| 1 even and let u = w \u2295 w . According to (2) , |u| 1 is also even, moreover according to (1) we obtain w = \u03c3 |u|1 (w): this implies w \u2208 \u03c3 * 2 (w). According to Lemma 16, we have w \u2208 \u03c3 * k (w): this establishes (ii).",
            "cite_spans": [
                {
                    "start": 107,
                    "end": 110,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Proof of Proposition 14. Let w \u2208 A \u2265k and n = |w|. (iii) is trivial and (i) follows from Lemma 13(i): indeed, since k is even, \u03c3 * k (w) is the set of the words w \u2208 A n such that |w | 1 \u2212|w| 1 is even. Assume k odd, and let w \u2208 A n \\{w}; we will prove that w \u2208 \u03c3 * k (w). If |w | 1 \u2212 |w| 1 is even, the result comes from Lemma 13(ii). Assume |w | 1 \u2212 |w| 1 odd and let t \u2208 \u03c3 1 (w ), thus w \u2208 \u03c3 1 (t) \u2286 \u03c3 k \u2022 \u03c3 k\u22121 (t) that is, w \u2208 \u03c3 k (t ) for some t \u2208 \u03c3 k\u22121 (t). It follows from w \u2208 \u03c3 1 (t) that |t| 1 \u2212 |w | 1 is odd, whence |t| 1 \u2212 |w| 1 = (|t| 1 \u2212 |w | 1 ) + (|w | 1 \u2212 |w| 1 ) is even: according to Lemma 13(ii), this implies t \u2208 \u03c3 * k (w). But since k \u2212 1 is even, we have t \u2208 \u03c3 k\u22121 (t) \u2286 \u03c3 * 2 (t): according to Lemma 16,  ",
            "cite_spans": [
                {
                    "start": 718,
                    "end": 727,
                    "text": "Lemma 16,",
                    "ref_id": null
                },
                {
                    "start": 728,
                    "end": 728,
                    "text": "",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": ": this completes the proof.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs of the Statements 12, 13 and 14"
        },
        {
            "text": "Given a \u03c3 k -closed code X \u2286 A * , we say that the tuple (k, A, X) satisfies Condition (3) if each of the three following properties holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Consequences for \u03c3-Closed Codes"
        },
        {
            "text": "We start by proving the following technical result: Lemma 17. Assume |A| = 2 and k even. Given a pair of words v, w \u2208 A + , if |w| \u2265 max{|v| + 1, k + 1} then the set \u03c3 * k (w) \u222a {v} cannot be a code. Proof. Let v, w \u2208 A + , and n = |w| \u2265 max{|v| + 1, k + 1} (hence v / \u2208 \u03c3 * k (w) \u2286 A |w| ). By contradiction, we assume that \u03c3 * k (w) \u222a {v} is a code. We are in Condition (i) of Proposition 14 that is, we have \u03c3 * k (w) \u2208 {A n 0 , A n 1 }. On a first hand, since A n\u22121 is a right-complete prefix code [2, Theorem 3.3.8], it follows from |v| \u2264 n \u2212 1 that a (perhaps empty) word s exists such that vs \u2208 A n\u22121 . On another hand, it follows from A n\u22121 A = A n = A n 0 \u222a A n 1 that, for each u \u2208 A n\u22121 , a unique pair of letters a 0 , a 1 , exists such that ua 0 \u2208 A n 0 , ua 1 \u2208 A n 1 with a 1 = a 0 that is, a \u2208 A exists with vsa \u2208 \u03c3 * k (w). According to Lemma 13(i), |sav| 1 \u2212 |w| 1 = |vsa| 1 \u2212 |w| 1 is even; according to Lemma 13(ii), this implies sav \u2208 \u03c3 * k (w). Since we have (vsa)v = v(sav), the set \u03c3 * k (w) \u222a {v} cannot be a code.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Consequences for \u03c3-Closed Codes"
        },
        {
            "text": "As a consequence of Lemma 17, we obtain the following result:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Consequences for \u03c3-Closed Codes"
        },
        {
            "text": "Firstly, consider two words v, w \u2208 X \u2229 A \u2265k+1 and by contradiction, assume |v| = |w| that is, without loss of generality |v| + 1 \u2264 |w|. Since X is \u03c3 k -closed, we have \u03c3 * k (w) \u2286 X, whence the set \u03c3 * k (w) \u222a {v}, which a subset of X is a code: this contradicts the result of Lemma 17. Consequently, we have X \u2286 A \u2264k \u222a A n , with n = |v| = |w| \u2265 k + 1. Secondly, once more by contradiction assume that words v \u2208 X \u2229 A \u2264k , w \u2208 X \u2229 A \u2265k+1 exist. As indicated above, since X is \u03c3 k -closed, \u03c3 * k (w) \u222a {v} is a code: since we have |w| \u2265 k + 1 and |w| \u2265 |v| + 1, once more this contradicts the result of Lemma 17. As a consequence, necessarily we have X \u2286 A n , for some n \u2265 k +1. With such a condition, according to Proposition 14 for each pair of words v, w \u2208 X, we have \u03c3 * k (v), \u03c3 * k (w) \u2208 {A n 0 , A n 1 }: this implies X \u2208 {A n 0 , A n 1 , A n }.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Consequences for \u03c3-Closed Codes"
        },
        {
            "text": "According to Lemma 18, with Condition (3) no \u03c3 k -closed code can simultaneously possess words in A \u2264k and words in A \u2265k+1 .",
            "cite_spans": [
                {
                    "start": 13,
                    "end": 22,
                    "text": "Lemma 18,",
                    "ref_id": null
                },
                {
                    "start": 23,
                    "end": 41,
                    "text": "with Condition (3)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "The Consequences for \u03c3-Closed Codes"
        },
        {
            "text": "Given a \u03c3 k -closed code X \u2286 A * , if (k, A, X) does not satisfy Condition (3) then either we have X \u2286 A \u2264k , or we have X = A n , with n \u2265 k + 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "Proof. If Condition (3) doesn't hold then exactly one of the three following conditions holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "(a) X \u2286 A \u2264k ; (b) X \u2286 A k and |A| \u2265 3; (c) X \u2286 A \u2264k with |A| = 2 and k odd.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "With each of the two last conditions, let w \u2208 X \u2229 A \u2265k+1 . Since X is \u03c3 k -closed, according to the propositions 12 and 14(ii), we have A n = \u03c3 * k (w) \u2286 \u03c3 * k (X). Since A n is a maximal code, it follows from Lemma 3(iii) that X = A n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "As a consequence, every \u03c3 k -closed code is finite. In addition, we state:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "Theorem 20. Given a complete \u03c3 k (\u03a3 k , \u039b k )-closed code X, exactly one of the following conditions holds:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "(i) X is a subset of A \u2264k ; (ii) a unique integer n \u2265 k + 1 exists such that X = A n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "In addition, every \u03a3 k (\u039b k )-closed code is equal to A n , for some n \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "Proof. Let X be a complete \u03c3 k -closed code. If Condition (3) does not hold, the result is expressed by Lemma 19 . Assume that Condition (3) holds. According to Lemma 18, in any case some integer n \u2265 k+1 exists such that X \u2208 {A n 0 , A n 1 , A n }. Taking for \u03c0 the uniform distribution, we have \u03c0(A n 0 ) = \u03c0(A n 1 ) = 1/2 and \u03c0(A n ) = 1 thus, according to Theorem 1: X = A n . Recall that we have \u03c3 * 1 (w) = A |w| (e.g. [8] ). Assume X \u03a3 k -closed, and let w \u2208 X, n = |w|: we have A n = \u03c3 * 1 (X) \u2286 \u03a3 * k (X) \u2286 X thus X = A n (indeed, A n is a maximal code). Since \u03a3 k \u2286 \u039b k , if X is \u039b k -closed then it is \u03a3 k -closed, thus we have X = A n .",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 112,
                    "text": "Lemma 19",
                    "ref_id": null
                },
                {
                    "start": 424,
                    "end": 427,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "As a corollary, in the family of \u03a3 k (\u039b k )-closed codes, maximality and completeness are equivalent notions. With regard to \u03c3 k -closed codes, things are otherwise: indeed, as shown in [16] , there are finite codes that have no finite completion. Let X be one of them, and k = max{|x| : x \u2208 X}. By definition X is \u03c3 k -closed. Since every \u03c3 k -closed code is finite, no complete \u03c3 k -closed code can contain X.",
            "cite_spans": [
                {
                    "start": 186,
                    "end": 190,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "Proposition 21. Let X be a (finite) non-complete \u03c3 k -closed code. Then one can decide whether some complete \u03c3 k -closed code containing X exists. More precisely, there is only a finite number of such codes, each of them being computable, if any.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        },
        {
            "text": "Proof Sketch. We draw the scheme of an algorithm that allows to compute every complete \u03c3 k -closed codeX containing X. In a first step, we compute Y = X \u2229 A \u2264k . If Y = X, according to Theorem 20, we haveX \u2286 A \u2264k :X, if any, can be computed in a finite number of steps. Otherwise,X exists if, and only if, for some n \u2265 k + 1 we have X \u2286 A n : this can be straightforwardly checked.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 19."
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Bifix codes and Sturmian words",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Berstel",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "D"
                    ],
                    "last": "Felice",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Perrin",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Reutenauer",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Rindonne",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Algebra",
            "volume": "369",
            "issn": "",
            "pages": "146--202",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Codes and Automata",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Berstel",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Perrin",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Reutenauer",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "On completion of codes with finite deciphering delay",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bruy\u00e8re",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Eur. J. Comb",
            "volume": "11",
            "issn": "",
            "pages": "513--521",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Each regular code is included in a regular maximal one",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ehrenfeucht",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Rozenberg",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "RAIRO Theoret. Inf. Appl",
            "volume": "20",
            "issn": "",
            "pages": "89--96",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Loopless algorithms for generating permutations, combinations, and other combinatorial configurations",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ehrlich",
                    "suffix": ""
                }
            ],
            "year": 1973,
            "venue": "J. ACM",
            "volume": "20",
            "issn": "",
            "pages": "500--513",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Codes 1",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "J\u00fcrgensen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Konstantinidis",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Handbook of Formal Languages",
            "volume": "",
            "issn": "",
            "pages": "511--607",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-59136-5_8"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "At the crossroads of linguistic, DNA computing and formal languages: characterizing RE using insertion-deletion systems",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kari",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "P\u0203un",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Thierrin",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Proceedings of Third DIMACS Workshop on DNA Based Computing",
            "volume": "",
            "issn": "",
            "pages": "318--333",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Fascicule 2 : Generating All Tuples and Permutations",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Knuth",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "",
            "volume": "4",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Error correction and decodability",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Konstantinidis",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Finite maximal infix codes",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lam",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Semigroup Forum",
            "volume": "61",
            "issn": "",
            "pages": "346--356",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Finite maximal solid codes",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lam",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Theoret. Comput. Sci",
            "volume": "262",
            "issn": "",
            "pages": "333--347",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Binary codes capable of correcting deletions, insertion and reversals",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Levenshtein",
                    "suffix": ""
                }
            ],
            "year": 1965,
            "venue": "Engl. trans. in: Dokl. Acad. Nauk. SSSR)",
            "volume": "163",
            "issn": "",
            "pages": "845--848",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Completing circular codes in regular submonoids",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "N\u00e9raud",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Theoret. Comp. Sci",
            "volume": "391",
            "issn": "",
            "pages": "90--98",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Embedding a \u03b8-invariant code into a complete one",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "N\u00e9raud",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Selmi",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Theoret. Comput. Sci",
            "volume": "806",
            "issn": "",
            "pages": "28--41",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2018.08.022"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Congruences parfaites et semi-parfaites. S\u00e9minaire Dubreil. Alg\u00e8bre et th\u00e9orie des nombres",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nivat",
                    "suffix": ""
                }
            ],
            "year": 1971,
            "venue": "",
            "volume": "25",
            "issn": "",
            "pages": "1--9",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "On codes having no finite completion",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Restivo",
                    "suffix": ""
                }
            ],
            "year": 1977,
            "venue": "Discrete Math",
            "volume": "17",
            "issn": "",
            "pages": "309--316",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "The Mathematical Theory of L-Systems",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Rozenberg",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "The infimal prefix-closed and observable superlanguage of a given language",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Rudi",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [
                        "M"
                    ],
                    "last": "Wonham",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Syst. Control Lett",
            "volume": "15",
            "issn": "",
            "pages": "361--371",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "A survey of combinatorial gray codes",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Savage",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "SIAM Rev",
            "volume": "39",
            "issn": "4",
            "pages": "605--629",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "(a) w i = w i if, and only if, i \u2208 {i 0 , j 0 }. Since some (k \u2212 1)-element set I \u2286 [1, n] \\ {i 0 , j 0 } exists, w , w \u2208 A n exist with: (b) w i = w i if, and only if, i \u2208 {i 0 } \u222a I, and: (c) w i = w i if, and only if, i \u2208 {j 0 } \u222a I.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Proof. According to Proposition 8 only a finite number of \u03b4 k -closed codes over A can exist, each of them being a subset of A \u2264k 2",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We would like to thank the anonymous reviewers for their fruitful suggestions and comments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgment."
        }
    ]
}