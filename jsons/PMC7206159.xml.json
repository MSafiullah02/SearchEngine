{
    "paper_id": "PMC7206159",
    "metadata": {
        "title": "FlowRec: Prototyping Session-Based Recommender Systems in Streaming Mode",
        "authors": [
            {
                "first": "Hady",
                "middle": [
                    "W."
                ],
                "last": "Lauw",
                "suffix": "",
                "email": "hadywlauw@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Raymond",
                "middle": [
                    "Chi-Wing"
                ],
                "last": "Wong",
                "suffix": "",
                "email": "raywong@cse.ust.hk",
                "affiliation": {}
            },
            {
                "first": "Alexandros",
                "middle": [],
                "last": "Ntoulas",
                "suffix": "",
                "email": "antoulas@di.uoa.gr",
                "affiliation": {}
            },
            {
                "first": "Ee-Peng",
                "middle": [],
                "last": "Lim",
                "suffix": "",
                "email": "eplim@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "See-Kiong",
                "middle": [],
                "last": "Ng",
                "suffix": "",
                "email": "seekiong@nus.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Sinno",
                "middle": [
                    "Jialin"
                ],
                "last": "Pan",
                "suffix": "",
                "email": "sinnopan@ntu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Dimitris",
                "middle": [],
                "last": "Paraschakis",
                "suffix": "",
                "email": "dimitris.paraschakis@mau.se",
                "affiliation": {}
            },
            {
                "first": "Bengt",
                "middle": [
                    "J."
                ],
                "last": "Nilsson",
                "suffix": "",
                "email": "bengt.nilsson.TS@mau.se",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "In the past few years, the RecSys community has witnessed a paradigm shift from the traditional matrix completion problem to sequential session-based recommendations [9, 15]. The latter approach is dominated by neural methods that are often evaluated in an online manner, i.e. when the events of a session are sequentially revealed and predicted one-by-one. However, these systems are still trained in batches on large chunks of recorded data [7, 15, 19]. To better approximate real-world scenarios with severe cold-start and concept drifts, streaming recommender systems [3, 18, 20] have been designed for incremental online learning from continuous data streams in the context of limited memory/runtime, and anytime prediction [17]. However, most of them address the conventional rather than session-based recommendation problem [6]. Bridging the gap between session-based and streaming recommender systems has been recently attempted [6, 9], marking an emerging research direction of a high practical value.",
            "cite_spans": [
                {
                    "start": 167,
                    "end": 168,
                    "mention": "9",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 170,
                    "end": 172,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 444,
                    "end": 445,
                    "mention": "7",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 447,
                    "end": 449,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 451,
                    "end": 453,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 573,
                    "end": 574,
                    "mention": "3",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 576,
                    "end": 578,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 580,
                    "end": 582,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 730,
                    "end": 732,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 832,
                    "end": 833,
                    "mention": "6",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 938,
                    "end": 939,
                    "mention": "6",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 941,
                    "end": 942,
                    "mention": "9",
                    "ref_id": "BIBREF19"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Presently, only a few publicly available benchmarking frameworks for streaming recommendations exist. Some of them have been designed for a specific application domain [9, 16], while others lack native support for session data [5, 11]. Scikit-Multiflow [14] has recently been released as a general-purpose Python framework for stream mining, offering a variety of stream learners, change detectors, and evaluation methods. To facilitate the research on streaming session-based recommendations, we propose FlowRec1 \u2014 an extension of Scikit-Multiflow for rapid prototyping of recommender systems. The proposed framework currently contains several stream-oriented recommenders and metrics for prequential evaluation. Additionally, we demonstrate a principled way of exposing a recommendation interface to an underlying stream learner class of Scikit-Multiflow (namely, a Hoeffding Tree). We show that the resulting recommender system has remarkable performance against established baselines. FlowRec\u2019s functionality is detailed in the next section.",
            "cite_spans": [
                {
                    "start": 169,
                    "end": 170,
                    "mention": "9",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 172,
                    "end": 174,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 228,
                    "end": 229,
                    "mention": "5",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 231,
                    "end": 233,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 254,
                    "end": 256,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Consider a stream D of (overlapping) user sessions \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S=s_1, \\ldots , s_{|S|}$$\\end{document} (Fig. 1). A session represents an ordered sequence of events of the form (X, y), where X is a feature vector describing the context for item y. As a bare minimum, X contains the session identifier for the item. Other common features are timestamp and event type (e.g. click, purchase, etc.). The scope of our study is limited to the context of collaborative filtering, which relaxes the assumption of item metadata in feature vectors (technically, any feature can be encoded as a part of X).",
            "cite_spans": [],
            "section": "Problem Setting ::: FlowRec",
            "ref_spans": [
                {
                    "start": 366,
                    "end": 367,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "At each time step \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t=1,\\ldots ,T$$\\end{document}, the stream provides a sample (X, y). Based on the information in X, the model is asked to generate a list of N predictions \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{Y} = (\\hat{y}_1, \\ldots , \\hat{y}_N)$$\\end{document} in an attempt to correctly guess the hidden item y. This corresponds to the next-item prediction task in the RecSys literature [15]. In practice, only certain features of X are retained for the prediction part, such as the current session identifier, and possibly the timestamp of the event. After the prediction, the entire feature vector X together with the label y are revealed to the model, allowing it to make an incremental update. This iterative, supervised \u2018test-then-train\u2019 methodology is known as prequential evaluation [20] (Fig. 2).",
            "cite_spans": [
                {
                    "start": 896,
                    "end": 898,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1299,
                    "end": 1301,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Problem Setting ::: FlowRec",
            "ref_spans": [
                {
                    "start": 1309,
                    "end": 1310,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "In our framework, each processed sample (X, y) is added to the sliding window of the last n observations, which we refer to as observation window (depicted as the green box in Fig. 1). Although its use is not required in the ordinary stream learning, it can ease the development of session-based models by providing a snapshot of the recent session data on demand. The size of the window must be chosen in consideration of the system\u2019s memory and runtime constraints.\n\n",
            "cite_spans": [],
            "section": "Problem Setting ::: FlowRec",
            "ref_spans": [
                {
                    "start": 181,
                    "end": 182,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "FlowRec implements several evaluation metrics, two of which are commonly used for next-item prediction [6, 7, 13, 19], namely recall (a.k.a. hitrate) and mean reciprocal rank (MRR). Recall measures the average number of successful predictions, whereas MRR measures their average reciprocal ranking, i.e.:1\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\textit{Recall@}N = \\frac{1}{T}\\sum _{t=1}^{T} \\sum _{i=1}^{N} \\mathbb {1} (y_t = \\hat{y_i})\\qquad \\textit{MRR@}N = \\frac{1}{T}\\sum _{t=1}^{T} \\sum _{i=1}^{N} \\frac{1}{i} \\mathbb {1} (y_t = \\hat{y_i}) \\end{aligned}$$\\end{document}The framework keeps two sets of measurements: (a) global, where the running average of each metric is calculated from all the past data; and (b) sliding, where the average is taken over a sliding window of recent events that we call the evaluation window (purple box in Fig. 1). The sizes of evaluation and observation windows are user-adjustable, offering flexibility in simulation setups.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 105,
                    "mention": "6",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 107,
                    "end": 108,
                    "mention": "7",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 110,
                    "end": 112,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 114,
                    "end": 116,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Metrics ::: FlowRec",
            "ref_spans": [
                {
                    "start": 1095,
                    "end": 1096,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The basic workflow for measuring recall using prequential evaluation is presented in Algorithm 1. The complete functionality of Scikit-Multiflow\u2019s prequential evaluator is provided in its official documentation2.",
            "cite_spans": [],
            "section": "Prequential Evaluation ::: FlowRec",
            "ref_spans": []
        },
        {
            "text": "FlowRec introduces the following additional parameters3 for the evaluator:Indices of data columns holding session, timestamp, and event type identifiers. The last two columns are optional, and allow for time-aware and event-specific training and/or evaluation.Stream-related configurations, such as the size of the observation window, and the number of events to skip from the start of the stream.Recommendation-specific settings, such as the size of the recommendation list, and the event types that trigger recommendation requests. There are also flags for enabling/disabling reminders and repeated recommendations. Reminders are recommendations of items that were visited earlier by the user, whereas repeated recommendations are those that were already given earlier to the user.\n\n",
            "cite_spans": [],
            "section": "Prequential Evaluation ::: FlowRec",
            "ref_spans": []
        },
        {
            "text": "The size of the evaluation window (as well as other settings) are covered by the original parameter list of the EvaluatePrequential class in Scikit-Multiflow. Note that the stream provides samples in the order as they appear in the dataset. The last column of the dataset should always contain the item identifiers.",
            "cite_spans": [],
            "section": "Prequential Evaluation ::: FlowRec",
            "ref_spans": []
        },
        {
            "text": "Presently, FlowRec contains the following streaming models for session-based recommendations: Rule-Based Models. The first three models are rule-based recommenders that capture one-to-one relationships between items. These methods rely on the very last item of a session to make their predictions for the next item. Despite their simplicity, rule-based models have proven surprisingly effective in the domains of music and e-commerce [13], and have very low computational complexity. We briefly outline these methods below (refer to [13] for details).",
            "cite_spans": [
                {
                    "start": 435,
                    "end": 437,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 534,
                    "end": 536,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "\nAssociation Rules (AR). The rules are derived from co-occurrences of two items in a session (e.g. \u2018those-who-bought-also-bought\u2019). A co-occurrence forms rules in both directions, i.e. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_t \\leftrightarrow y_{t'}, t \\ne t'$$\\end{document}.Markov Chains (MC). The rules are derived from a first-order Markov Chain, describing the transition probability between items that appear in two contiguous events in a session, i.e. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_t \\rightarrow y_{t+1}$$\\end{document}.Sequential Rules (SR). The rules are derived from sequential patterns between two items in a session, but not necessarily in successive events, i.e. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_t \\rightarrow y_{t'}, t' > t$$\\end{document}. The sequential association is assigned the weight \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1/(t'-t)$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "In FlowRec, the above algorithms can be made event-specific by providing event_column_index. For instance, predictors of type \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$purchase \\leftrightarrow purchase$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$click \\rightarrow purchase$$\\end{document}, etc. can be useful in e-commerce applications as components of an ensemble recommender [2].",
            "cite_spans": [
                {
                    "start": 847,
                    "end": 848,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Session \nk\nNN. This is a specialized version of the k-Nearest Neighbors (kNN) algorithm that operates on session data. It is a strong baseline with performance comparable to that of certain deep neural methods [8, 13]. Being model-free, the algorithm is incremental by nature. S-kNN recommends items from other user sessions that are similar to the current session (a.k.a. neighbors). Given the active session S, the score of the candidate item \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{y}$$\\end{document} is calculated as follows:2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} score(\\hat{y} \\mid \\hat{y} \\notin S) = \\sum _{S' \\in \\mathcal {N}(S)} sim(S,S') \\cdot \\mathbb {1}(\\hat{y} \\in S') \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {N}(S)$$\\end{document} is the k-sized neighborhood of session S, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sim(S,S')$$\\end{document} is a measure of similarity between two sessions.",
            "cite_spans": [
                {
                    "start": 211,
                    "end": 212,
                    "mention": "8",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 214,
                    "end": 216,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "FlowRec implements Cosine, Jaccard, Dice, and Tanimoto similarity. In the future, we plan to implement other kNN variants described in [13].",
            "cite_spans": [
                {
                    "start": 136,
                    "end": 138,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "BEER[TS]. This is a bandit ensemble designed for streaming recommendations, which employs Thompson Sampling for the model selection. In [2], event-specific rule-based models were used as behavioral components of the ensemble. In FlowRec, any model implementing the predict_proba(X) method can be added as a component of BEER[TS]. For each recommendation slot, the ensemble picks a model m with the highest sample \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\theta _{m}\\sim Beta(\\alpha _m + 1,\\beta _m + 1)$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _m$$\\end{document} is the number of past successes, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta _m$$\\end{document} is the number of past failures. The method is adaptable to non-stationary data (e.g. occurring due to concept drift), which is achieved via exploration-exploitation. In addition, BEER[TS] supports component splitting into (relatively) stationary partitions (see [2] for details), which is achieved in FlowRec by setting the boundaries for probabilities returned by the predict_proba(X) method. Further, the components of the ensemble can complement each other in case of poor coverage, which helps to attack sparsity and cold-start issues.",
            "cite_spans": [
                {
                    "start": 137,
                    "end": 138,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1643,
                    "end": 1644,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Popularity Baseline. This is the traditional baseline that outputs the top-N most popular items in descending order.",
            "cite_spans": [],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "The above methods can be incrementally trained either on the global scale, or within the observation window. The latter option acts as a forgetting mechanism for older data, which aids model scalability and adaptability to recent trends.",
            "cite_spans": [],
            "section": "Session-Based Streaming Models ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Prototyping streaming session-based recommenders can be facilitated by employing the rich collection of incremental algorithms offered by Scikit-Multiflow, including Bayesian methods, lazy learners, ensembles, neural networks, tree-based methods, and more [14]. Utilizing any of these methods for recommendation tasks is achieved via a wrapper, which is a middle layer that handles the inputs and the outputs of an underlying learner. Some of the common tasks performed by wrappers include:transforming a sample to the desired input format accepted by a learner.calling the predict_proba(X) method of a learner, and manipulating its return values to generate top-N recommendations.\n",
            "cite_spans": [
                {
                    "start": 257,
                    "end": 259,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Using the above approach, we develop a recommender system by \u2018wrapping\u2019 the HoeffdingTree classifier provided by Scikit-Multiflow.",
            "cite_spans": [],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4], a HT is an incremental, anytime decision tree inducer designed for learning from data streams. Its key idea lies in the fact that only a small subset of samples passing through a node may be sufficient for deciding on the split attribute. For estimating the minimum number of samples needed, the method employs the Hoeffding bound, which offers sound theoretical guarantees of performance (see [4] for details), asymptotically comparable to that of a batch decision tree.",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 70,
                    "mention": "4",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 468,
                    "end": 469,
                    "mention": "4",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "HT Wrapper Architecture. The Scikit-Multiflow\u2019s implementation of a HT supports Naive Bayes prediction at the leaves of the tree, and the possibility of assigning a weight to each fitted sample. We take advantage of both capabilities in the proposed HT recommender. The core idea of our algorithm is to encode all item-to-item associations employed by rule-based methods (see above) in a unified learner. This allows HT to capture both sequential and co-occurrence patterns in a session. The idea is conceptually similar to the BEER[TS] framework [2], but instead of treating between-items associations as separate predictors explored by a bandit, we fit them to a single decision tree classifier using a specific weighting scheme, as explained below. We hence formulate the recommendation task as a multi-class classification problem. Due to the nature of the problem, HT is reduced to a decision stump, whose nodes represent input items, and the leaves contain item predictions obtained via Naive Bayes classification.",
            "cite_spans": [
                {
                    "start": 548,
                    "end": 549,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Training the Model. The incremental training of a HT in Scikit-Multiflow can be done by calling the method partial_fit(X, y, sample_weight). The first two parameters specify the input feature vector and the output label, respectively, with an associated (optional) sample weight. We use these parameters to encode the sequential relation between two items, by letting the feature vector contain the antecedent item and the label represent the consequent item. For the ease of notation, we use the item in place of a feature vector in Algorithm 2 (y or \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y'$$\\end{document}, lines 7 and 8). Internally, each antecedent is represented as a node of the tree.\n",
            "cite_spans": [],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "After fetching the current session vector S from the observation window, the wrapper learns all sequential patterns involving item y by fitting a series of samples \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(y'_i,y, w), \\forall i=1,\\ldots ,|S|$$\\end{document}, where the sample weight is inversely proportional to the distance between two items. Clearly, these fits utilize the same patterns as captured in Sequential Rules (SR) described above. Among these patterns, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_{|S|} \\rightarrow y$$\\end{document} pertains to the Markov Chain (MC). The corresponding sample, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(y'_{|S|},y, w_{MC})$$\\end{document}, uses a separate weight reflecting the perceived importance of the \u2018next-item\u2019 sequence. Finally, encoding co-occurrence patterns captured by Association Rules (AR) is achieved via a series of the so-called inverse fits, i.e. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(y, y'_i, w \\cdot w_{inv}), \\forall i=1,\\ldots ,|S|$$\\end{document}, which complete the bidirectional associations. The fixed weight \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w_{inv} \\in [0,1]$$\\end{document} is used to inform the influence of inverse (hence unobserved) sequential patterns on the classification.",
            "cite_spans": [],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "Making Predictions. Unlike rule-based methods, where the predictions are made solely on the basis of the latest item in a session, our HT wrapper makes predictions in an ensemble-like manner by combining the responses of all the relevant nodes of the tree. The prediction procedure is detailed in Algorithm 3.\n",
            "cite_spans": [],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "For each item \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y'_i$$\\end{document} in the current session vector, the wrapper calls the predict_proba(\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y'_i$$\\end{document}) method of a HT. This method returns a class probability vector that expresses the likelihood of each candidate item to follow item \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y'_i$$\\end{document}. The probability vectors \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_i$$\\end{document} are then weighted with the recency of item \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y'_i$$\\end{document}. Predictions obtained from the most recent item, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_{|S|}'$$\\end{document}, receive the highest weight specified by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w_{MC}$$\\end{document}. All weighted probability vectors are then added to produce the final scores for the candidate items, top-N of which are returned.",
            "cite_spans": [],
            "section": "Hoeffding Tree Wrapper ::: Prototyping",
            "ref_spans": []
        },
        {
            "text": "We use public datasets containing sessionized browsing logs. The datasets originate from three recommendation contests representing news, travel, and e-commerce domains. They are summarized in Table 1.\n",
            "cite_spans": [],
            "section": "Datasets ::: Simulation Results",
            "ref_spans": [
                {
                    "start": 199,
                    "end": 200,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "We consider the task of online next-item recommendation, where the goal is to suggest the list of most probable items to appear in the next session event. We track Recall@10 and MRR@10 during the entire run of the simulation using the real-time visualizer provided by the framework, which reports the global and the current (sliding) averages. Time horizon for each simulation is set to 1M events, with evaluation and observation window sizes of 10K and 50K events, respectively. The latter size was chosen in consideration of sufficient (sliding) session history and a reasonable memory/runtime overhead. We use a separate validation set of 100K events (preceding those of the simulation) for hyperparameter tuning. The evaluation itself is performed from pure cold-start, with no model pre-training involved. Sessions of size 1 are excluded from the evaluation. For our simulations, we use Intel Core i7 CPU @ 2.80 GHz and 16 Gb RAM.\n",
            "cite_spans": [],
            "section": "Prequential Evaluation Setup ::: Simulation Results",
            "ref_spans": []
        },
        {
            "text": "We evaluate the models presented in Sect. 3, with an addition of a Random classifier that sets the lower bound for performance. Below we briefly outline the optimal model configurations after the hyperparameter tuning step.",
            "cite_spans": [],
            "section": "Model Setup ::: Simulation Results",
            "ref_spans": []
        },
        {
            "text": "Rule-based (AR, MC, SR) models operate on a global scale, whereas the popularity-based one (POP) works within a sliding window. S-kNN uses Cosine similarity, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k=100$$\\end{document} (Trivago), \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k=200$$\\end{document} (Clef), \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k=300$$\\end{document} (Yoochoose). We also use recent session sub-sampling [8], with sub-sample sizes of 500 (Clef), 1000 (Trivago), and 1500 (Yoochoose). BEER[TS] includes AR, MC, SR, POP, and S-kNN as components of the ensemble. The HT wrapper uses weights \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w_{MC}=3$$\\end{document} (Yoochoose), \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w_{MC}=5$$\\end{document} (Clef, Trivago), and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w_{inv}=0.01$$\\end{document} (Clef), \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w_{inv}=0.9$$\\end{document} (Yoochoose, Trivago). The HoeffdingTree class of Scikit-Multiflow is instantiated with leaf_prediction=\u2018nb\u2019 to enable Naive Bayes prediction at the leaves. The pre-configured experiments are provided in FlowRec\u2019s code base for reproducibility.",
            "cite_spans": [
                {
                    "start": 1108,
                    "end": 1109,
                    "mention": "8",
                    "ref_id": "BIBREF18"
                }
            ],
            "section": "Model Setup ::: Simulation Results",
            "ref_spans": []
        },
        {
            "text": "The results of the simulation for the three datasets are presented in Fig. 3. The top performing model in each case is marked with an asterisk. Note that the column \u2018Sliding\u2019 contains the averages of the very last evaluation window.",
            "cite_spans": [],
            "section": "Results ::: Simulation Results",
            "ref_spans": [
                {
                    "start": 75,
                    "end": 76,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "The HT wrapper consistently achieves higher recall and MRR than the other baselines on all three datasets. This proves the effectiveness of combining item-to-item sequential patterns, and utilizing the entire user session at prediction time in an ensemble-like manner. The HT wrapper also happens to be noticeably faster than its main rival, BEER[TS] (in its current configuration). The total running times for each model are recorded by the framework. As a point of reference, we consider the upper limit of 100 ms per recommendation prescribed by the CLEF NewsReel challenge [10]. Table 2 reports average response times per recommendation request for each model. We observe that all runtimes fall within the recommended limit. The real-time visualization offers the possibility to diagnose potential issues at an early stage. For instance, the performance charts for Yoochoose and Trivago make it obvious that the inclusion of POP to BEER[TS] is not justified, and hence it can be dropped from the ensemble to gain speed. The live monitoring of model evolution helps to see how algorithms behave relative to each other on various segments of the dataset, as well as to better understand the peculiarities of the dataset itself. For example, the above two charts clearly show the stagnation of S-kNN after leaving the initial cold-start segment (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\approx $$\\end{document}0\u201350K), while other models continue to learn. We also see that Clef exhibits a more dynamic domain (news) with more profound concept drift, which makes learning more challenging. It is the only dataset where the popularity recommender has decent performance, surpassing other models on certain data segments. The Clef chart also reveals the \u2018easy\u2019 portion of the dataset (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\approx $$\\end{document}600K\u2013800K), where most algorithms (but not POP) boost their performance.\n",
            "cite_spans": [
                {
                    "start": 578,
                    "end": 580,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Results ::: Simulation Results",
            "ref_spans": [
                {
                    "start": 589,
                    "end": 590,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "We introduce FlowRec \u2014 a new recommendation framework for streaming session data developed on top of Scikit-Multiflow. It serves as a testbed for streaming recommendation models by offering prequential evaluation with real-time performance monitoring. One advantage of prototyping in FlowRec is the ability to \u2018wrap\u2019 various stream learners provided by Scikit-Multiflow, thus treating them as black boxes. We demonstrate how to develop such a wrapper for the HoeffdingTree class, capable of generating accurate session-based recommendations on evolving data streams. The framework will be further extended with additional evaluation protocols, metrics, and algorithms.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Datasets summary (1M events each)\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${}^a$$\\end{document}We use the subset of the dataset provided in [13].",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Average recommendation time (msec) per model\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Streaming sessions (Color figure online)",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Prequential protocol",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Performance charts for Clef (top), Yoochoose (middle), and Trivago (bottom)",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "Stream-based recommendations: online and offline evaluation as a service",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Kille",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Experimental IR Meets Multilinguality, Multimodality, and Interaction",
            "volume": "",
            "issn": "",
            "pages": "497-517",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Evaluation of session-based recommendation algorithms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ludewig",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jannach",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "User Model. User Adapt. Interact.",
            "volume": "28",
            "issn": "4\u20135",
            "pages": "331-390",
            "other_ids": {
                "DOI": [
                    "10.1007/s11257-018-9209-6"
                ]
            }
        },
        "BIBREF5": {
            "title": "Scikit-multiflow: a multi-output streaming framework",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Montiel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Read",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bifet",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Abdessalem",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "J. Mach. Learn. Res.",
            "volume": "19",
            "issn": "72",
            "pages": "1-5",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Performance analysis of hoeffding trees in data streams by using massive online analysis framework",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Srimani",
                    "suffix": ""
                },
                {
                    "first": "MM",
                    "middle": [],
                    "last": "Patil",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Int. J. Data Min. Model. Manage.",
            "volume": "7",
            "issn": "4",
            "pages": "293-313",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "A bandit-based ensemble framework for exploration/exploitation of diverse recommendation components: an experimental study within e-commerce",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Brod\u00e9n",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hammar",
                    "suffix": ""
                },
                {
                    "first": "BJ",
                    "middle": [],
                    "last": "Nilsson",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Paraschakis",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM Trans. Interact. Intell. Syst.",
            "volume": "10",
            "issn": "1",
            "pages": "4:1-4:32",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}