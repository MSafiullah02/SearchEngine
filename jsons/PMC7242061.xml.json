{
    "paper_id": "PMC7242061",
    "metadata": {
        "title": "Modelling and Validating an Automotive System in Classical B and Event-B",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Michael",
                "middle": [],
                "last": "Leuschel",
                "suffix": "",
                "email": "michael.leuschel@hhu.de",
                "affiliation": {}
            },
            {
                "first": "Mareike",
                "middle": [],
                "last": "Mutz",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Michelle",
                "middle": [],
                "last": "Werth",
                "suffix": "",
                "email": null,
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "In this work we have used both classical B and Event-B as modelling languages with ProB and rodin for tool support. The classical B-method [1] is a formal method rooted in predicate logic, set theory, arithmetic. B arose out of Z, with a focus on tool support and successive refinement to derive provably correct software out of high-level specifications. This initial version of B, supported by the tool Atelier-B, is now called classical B or also \u201cB for software\u201d.",
            "cite_spans": [
                {
                    "start": 140,
                    "end": 141,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Introduction and Background",
            "ref_spans": []
        },
        {
            "text": "Event-B was developed to enable systems modelling. It also tried to correct a few issues in classical B, simplifying the language (e.g., making it easier to parse and removing the complex inclusion mechanism) and trying to make refinement proofs easier and more scalable. The main addition though is a more flexible refinement concept targeted at systems modelling rather than software development. The foundations of Event-B are laid out in the book [2]. Event-B is supported by the rodin platform [3], which we have used for proving. In our development of the case study we made heavy use of the animator and model checker ProB [10] which supports both classical B and Event-B. ProB is also available as a plugin for rodin.",
            "cite_spans": [
                {
                    "start": 452,
                    "end": 453,
                    "mention": "2",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 500,
                    "end": 501,
                    "mention": "3",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 631,
                    "end": 633,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Introduction and Background",
            "ref_spans": []
        },
        {
            "text": "The goals we set ourselves were as follows:Validate the usability of the new visualization plugin VisB for ProB, in particular whether images from the case study description [7] can be reused with little effort.Examine whether systems modelling can be conducted in classical B.Examine whether a componend-based model in classical B can be converted to Event-B for use by the rodin for proof.\n",
            "cite_spans": [
                {
                    "start": 175,
                    "end": 176,
                    "mention": "7",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction and Background",
            "ref_spans": []
        },
        {
            "text": "Indeed, in earlier work we have often realised that classical B can also be used for systems modelling and may have some advantages. However, for proving systems, Event-B and rodin provide a nice platform and simpler1 proof obligations than classical B. We have modelled a subset of the lighting system, as well as a subset of the adaptive cruise control system. For the latter some insights found during modelling have led to improvements in the case study specification (see Sect. 6). In this article we only show details of the lighting system models, which we have developed using a development methodology described in Sect. 2, which consisted of using classical B during the exploration phase and Event-B for the proving phase.",
            "cite_spans": [],
            "section": "Introduction and Background",
            "ref_spans": []
        },
        {
            "text": "The contributions of this article thus consist in showing the usefulness of visualisation using a new lightweight SVG-based tool, comparing classical B and Event-B for systems modelling, and illustrating a development methodology. Together with the visualisation, our model provides an executable reference specification for a subset of the specification, which can be used by domain experts without formal methods training. We plan on extending this subset in future.",
            "cite_spans": [],
            "section": "Introduction and Background",
            "ref_spans": []
        },
        {
            "text": "The methodology we used was inspired by earlier experience on modeling and validating railway systems (e.g., [4, 5]). We divided the modelling into three phases (see Fig. 1): an exploratory modelling phase where one tries to understand the specification and domain and identifies important subcomponents.a synthesis phase, where the subcomponents are integrated to form ever larger subsystems and the integration is at least partially verified. We could have named this also the combination or structuring phase.an exhaustive verification phase, where the completed system is now formally proven to be safe and functionally correct.\n\n",
            "cite_spans": [
                {
                    "start": 110,
                    "end": 111,
                    "mention": "4",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 113,
                    "end": 114,
                    "mention": "5",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Modelling Methodology and Strategy",
            "ref_spans": [
                {
                    "start": 171,
                    "end": 172,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The exploratory phase 1 is dominated by editing and animation. Here it is important that one can quickly change the model, and one wants to use a maximally powerful language. Hence, in our case, we have used classical B with its rich substitution language for this phase. Also, the fact that we have a textual representation (which was versioned in Git) allows for easy editing and collaboration. Animation and graphical visualization are vital to check the presence of desired functionality, but also to check for unexpected behaviour and to gain a better understanding of the problem domain. To cite Bryan Cantrill:2\n\u201cThe visual cortex is unparalleled at detecting patterns.\u201d and \u201cThe value of visualization is not merely providing answers but especially provoking new questions.\u201d  The outcome of phase 1 is a first decomposition of the system into functional subcomponent models which can be animated.",
            "cite_spans": [],
            "section": "Modelling Methodology and Strategy",
            "ref_spans": []
        },
        {
            "text": "In phase 2 the model starts to stabilise, but we still experimented with various ways to integrate the components. In a refinement-based approach (e.g., Event-B) one has to decide upon a particular refinement order in which components are integrated, which can be sometimes difficult to find and tedious to change. Hence we again stayed in the classical B paradigm where the powerful machine inclusion features allowed us to experiment with various ways of assembling the entire system (see also Fig. 1). To ensure the proper functioning we start to write safety invariants in this phase. The verification in this phase was dominated by (safety) model checking and trace replay in the animator. The outcome of phase 2 is a functional composition into an overall system which can be animated and where various safety invariants can be checked using model checking.",
            "cite_spans": [],
            "section": "Modelling Methodology and Strategy",
            "ref_spans": [
                {
                    "start": 501,
                    "end": 502,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The last phase is dominated by proof. Here, the rodin platform\u2019s proof system is a key technology and the simplicity of Event-B\u2019s proof obligations can pay off. In this phase the decomposition of the system has stabilised and it was hence possible to transform the classical B model into a linear refinement hierarchy. This requires translating machine inclusion to machine refinement and operation calls to event extension (see Fig. 1 and Sect. 4). For functional aspects of the system we complemented proof with LTL model checking.",
            "cite_spans": [],
            "section": "Modelling Methodology and Strategy",
            "ref_spans": [
                {
                    "start": 434,
                    "end": 435,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "At the end of the exploratory phase (see Sect. 2) we had separated out the system into three components (see Fig. 2): A small component Sensors to manage the state of all sensors of the system and their updates.A component BlinkLamps for managing the blinking cycle and the actuators blinkLeft and blinkRight, based on a logical state variable stipulating which blinkers are active and how often blinking should be repeated.The PitmanController composed component which reacts to changes in the sensors and sets the logical state variable of the BlinkLamps components.A GenericTimer component which manages current time evolution and manages hard deadlines. There are actually two versions of this component, one for animation or simulation and one for finite state model checking.The main PitmanController_TIME system, which adds treatment of real time issues to the PitmanController model.\n\n",
            "cite_spans": [],
            "section": "Components ::: Classical B Modelling Details",
            "ref_spans": [
                {
                    "start": 114,
                    "end": 115,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "The purpose of the BlinkLamps component is to separate the management of the blink lamps from a logical state of the system. This logical state is modelled by a variable active_blinkers which is a subset of {left_blink,right_blink}, i.e., it has four possible logical states (from all blinkers off to all blinkers on). This model does not worry about real time and deadlines yet; it manages various lamp states using an internal state variable onCycle but, e.g., does not stipulate how long lamps should remain on or off and does not have a variable representing time at all. The model also manages a remaining_blinks variable, which stipulates how often the blinker still has to run independently (used later to implement tip blinking). A special value denotes unlimited continuous blinking. A small part of the model is shown in Listing 1.1. Safety invariants ensure the consistency between the logical variables active_blinkers and remaining_blinks with the blink lamp actuators. Early versions of our model had several errors in that respect, e.g., when events such that turning an engine on or off changed the system\u2019s state without consistently updating the actuators.\n",
            "cite_spans": [],
            "section": "Blink Lamps Controller ::: Classical B Modelling Details",
            "ref_spans": []
        },
        {
            "text": "The PitmanController reacts to changes in the sensors and sets the logical blinking state using the operations provided by the BlinkLamps machine. For example, Listing 1.2 shows how this is achieved using two parallel operation calls, one to to SET_EngineOn from the Sensors machine and one to SET_BlinkersOn from BlinkLamps shown above in Listing 1.1. It is also interesting to note that the second operation call is wrapped into a conditional.\n",
            "cite_spans": [],
            "section": "Integrating with Pitman Controller ::: Classical B Modelling Details",
            "ref_spans": []
        },
        {
            "text": "We have modelled time as a discrete integer variable representing elapsed time in milliseconds. The GenericTimers machine partially shown in Listing 1.3 manages a set of deadlines. The parameter TIMERS specifies a set of timers for which one can associate individual deadlines using the AddDeadline operation. Time can be advanced using the IncreaseTime operation, but it cannot proceed beyond a deadline, thus forcing events associated with the deadlines to be executed first. This is a typical scheme to model time in B, but variations and different approaches (e.g., using a controller event executed at fixed intervals).",
            "cite_spans": [],
            "section": "Modelling Time ::: Classical B Modelling Details",
            "ref_spans": []
        },
        {
            "text": "For our modelling we needed two timers: one for the blinking phases and one for the management of \u201ctip blinking\u201d. Future extensions of the model will probably require additional deadlines which can be easily added.\n",
            "cite_spans": [],
            "section": "Modelling Time ::: Classical B Modelling Details",
            "ref_spans": []
        },
        {
            "text": "The complete system model PitmanController_TIME then combines the untimed pitman controller with the GenericTimers. The Listing 1.4 shows how a deadline is set for the tip blinking event. When the deadline expires without the pitmanArmUpDown sensor changing the tip blinking is converted to a regular direction blinking.\n",
            "cite_spans": [],
            "section": "Modelling Time ::: Classical B Modelling Details",
            "ref_spans": []
        },
        {
            "text": "The above version of GenericTimers in Listing 1.3 is good for simulation or replaying traces with explicit timing information such as the ones accompanying [7] (see Appendix A). As curTime is unbounded, however, it leads to an infinite state space for model checking. Hence we also developed a second \u201cdrop-in-replacement\u201d of this machine, which has no curTime variable: the deadlines are always rescaled as if the current time was 0 (see Listing 1.5). In our case this was sufficient to produce a finite state model. Model checking the full system with ProB takes about 2.3 s, generating 2095 states and 16472 transitions. (See [12] or [9] for related ways of model checking timed systems in state-based formal methods.)\n",
            "cite_spans": [
                {
                    "start": 157,
                    "end": 158,
                    "mention": "7",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 630,
                    "end": 632,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 638,
                    "end": 639,
                    "mention": "9",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Modelling Time ::: Classical B Modelling Details",
            "ref_spans": []
        },
        {
            "text": "When translating a classical B composition such as the one in Fig. 2, one has to linearise the inclusion into a refinement chain. As you can see in Fig. 3, we have chosen the BlinkLamps as the top-level Event-B machine. In the translation, we had to split certain B operations into multiple events (as rodin does not provide an IF-THEN-ELSE). E.g., the operation SET_BlinkersOn from Listing 1.1 is translated into two events: SET_LeftBlinkersOn and SET_RightBlinkersOn.\n",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": [
                {
                    "start": 67,
                    "end": 68,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 153,
                    "end": 154,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "Let us now look at the PitmanController classical B machine, including Sensors and BlinkLamps. To translate this inclusion into refinement, we construct a superposition refinement of BlinkLamps, i.e., we add new variables and do not remove existing variables.3 Moreover, as Event-B does not allow operation calls, we need to encode them using event refinement, more precisely refinement using the rodin extends keyword which only adds actions and guards to an existing abstract event.",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": []
        },
        {
            "text": "Let us look again at the operation ENV_Turn_EngineOn in Listing 1.2 from Sect. 3.3 above. It calls SET_EngineOn from Sensors and conditionally calls SET_BlinkersOn from BlinkLamps. This operation is translated into three events refining either skip or extending SET_LeftBlinkersOn or SET_RightBlinkersOn:",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": []
        },
        {
            "text": "One can see that the translation has resulted in code duplication, making it more tedious to adapt the model. A similar issue occurs at the next refinement level, where we introduce timing. As again we cannot refine multiple components, the code for the timer logic gets interspersed and duplicated in multiple events. Here we show just two instances in the PitmanController_TIME_MC model, which show how the guards and actions are replicated in multiple events.",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": []
        },
        {
            "text": "If we want to modify the time management we need to edit multiple events in a consistent fashion, which is tedious and error-prone. The classical B model called the same operation in both cases; changing details about how time is handled just means changing or substituting the GenericTimers machine. Hence the conversion to Event-B in our methodology (Sect. 2) is delayed until the model has sufficiently stabilised.",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": []
        },
        {
            "text": "Proof Statistics and Insights. We checked the correctness of our translation by checking the state spaces generated by ProB is identical for those three models that can be compared. The results are summarised in Table 1.\n",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": [
                {
                    "start": 218,
                    "end": 219,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "In summary, the translation resulted in a model with many more events and more duplication, but was worth it in the end. The proving process was relatively painless, the rodin prover was easy to use. The proof statistics can be found in Table 2, and the proving process itself helped to uncover a few interesting invariant properties and some issues in our sub-components (which were not reachable by the model checking, but would have appeared if the subcomponents were used differently). Also, the generation and discharging of the well-definedness proof obligations provides another safety guarantee, which is not exhaustively covered by model checking with ProB.\n",
            "cite_spans": [],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": [
                {
                    "start": 243,
                    "end": 244,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "LTL Model Checking. As the rodin model contains a series of events for one particular action, like turning the engine on or off, we wanted to check that it is always possible to turn the engine on or off and that there is exactly one event which describes the system\u2019s evolution. For this we introduced the relative deadlock and controller state LTL properties in [8], which we used here. One particular property is the following one, which was violated by earlier versions of our translation:\n",
            "cite_spans": [
                {
                    "start": 365,
                    "end": 366,
                    "mention": "8",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Systems Modelling with Classical B and Translation to EventB",
            "ref_spans": []
        },
        {
            "text": "The core idea of our new ProB plugin called VisB is to have a lightweight visualization engine which can be easily maintained and which make use of graphics generated with off-the-shelf editors. More concretely, VisB makes use of a SVG (scalable vector graphics) file and a JSON markup file. The markup files contains formal model expressions which specify attributes of objects which should be updated according to the current state of a formal model.",
            "cite_spans": [],
            "section": "VisB Visualization of the Light System",
            "ref_spans": []
        },
        {
            "text": "The present case study description [7] contains several appealing images, which we kindly obtained from the coordinators of the case study. Luckily, some were already in the SVG format and as such relatively little effort was needed to obtain a first visualisation (after about one hour the first visualisation was working). The main work was to combine the images into a single one, iron out a few quirks in the SVG files, and change the relevant object identifiers to mnemonic names and then write a JSON glue file referring to these identifiers. The original, unmodified SVG file is shown in Fig. 4 and the start of the JSON glue file in Listing 1.7.\n\n",
            "cite_spans": [
                {
                    "start": 36,
                    "end": 37,
                    "mention": "7",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "VisB Visualization of the Light System",
            "ref_spans": [
                {
                    "start": 600,
                    "end": 601,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "As one can see, it specifies the original SVG file and provides instructions on how to update the attributes of objects (such as stroke-opacity) of particular objects (such as A-right corresponding to the front left light of the car). The value is given by a B expression which can reference the state of the formal model, in this case the active_blinkers variable. The glue file also specifies events which should be executed when certain objects are clicked upon.\n",
            "cite_spans": [],
            "section": "VisB Visualization of the Light System",
            "ref_spans": []
        },
        {
            "text": "The effect of applying the VisB glue file to the original SVG can be seen in Fig. 5. This visualization shows the state of the actuators blinkLeft and blinkRight, as well as the state of the sensors keyState, pitmanArmUpDown, hazardWarningSwitchOn and engineOn. It also shows the internal state of the controller, e.g., the active_blinkers variable by changing the stroke-opacity and using a light orange fill. This state is an actual error that was spotted thanks to the visualisation: the hazard warning switch is on, but only the right blinkers are on. We can also see that the pitman arm is pushed up, but the controller correctly considers both left and right blinkers to be active, but somehow the blink management component has not set blinkLeft to the expected value (100).",
            "cite_spans": [],
            "section": "VisB Visualization of the Light System",
            "ref_spans": [
                {
                    "start": 82,
                    "end": 83,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "VisB works for all of ProB\u2019s supported state-based formalisms (B, Event-B, Z, TLA+, Alloy), and as such we reused the same visualization for our classical B and Event-B models. A visualisation of the important states of the validation trace 7 from [7] can be found in Appendix A.",
            "cite_spans": [
                {
                    "start": 249,
                    "end": 250,
                    "mention": "7",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "VisB Visualization of the Light System",
            "ref_spans": []
        },
        {
            "text": "In conclusion, with relatively little effort it was possible to generate a visualisation from the graphics of the case study specification. In addition, the visualisation glue file was re-usable for a wide variety of models (several version of the classical B and Event-B models).",
            "cite_spans": [],
            "section": "VisB Visualization of the Light System",
            "ref_spans": []
        },
        {
            "text": "Some of the issues we found during implementing and especially during model checking the models are:Per specification, the system is not commutative. In ELS-13 it is stated that any tip-blinking is ignored or will be stopped by the hazard warning lights when hazard warning is active, respectively activated. So, we do have possible traces where at the same time hazard warning light is switched off and tip-blinking to either side is activated. Depending on which signal gets processed first, we either get three cycles of blinking or none at all. Same holds for switching on the engine and tip-blinking.In cruise control: while model checking we got shown errors in the activation of the cruise control as well as in the increasing and decreasing the desired speed, these errors seemed intended or at least directly caused by the specification. Depending on the version of the specification, there were different errors:The desired speed in an activated cruise control could be lowered arbitrarily in previous versions (up to 1.14). This led to invariant violations while model checking, as by pushing down the lever from a desired speed of 0, it was further decreased.The same invariant violation was caused by increasing the desired speed further than said maximum.In the current version (1.17), those are fixed, as some upper and lower thresholds are specified, as well as a minimum velocity when activating it. But as of now, when no previous desired speed is set, the scs is required to be activated at current speed (scs-2) as long as the current speed is above or at 20 km/h. Here an activation at a speed of above 200 km/h should be possible according to the specification, thus directly violating the invariant of being in the range of 1..2000.As we have a reverse gear specified (but our speed being in the range of 0..5000), obviously the speed is measured in absolutes. That means that activation of the speed control system is also possible when in reverse gear (as long as going over 20 km/h in reverse). With possible high previous desired speed, this should either wreck our motor or gearbox fast if it keeps going and accelerating in reverse.\nThere was a problem with the distance in adaptive cruise control, as the distance could be set to f.e. 3 s \u2013 with speeds of 240 km/h we would have had to measure distances that are outside our possible range. The latest specification solves this issue by setting a maximum target speed of 200 km/h.Ambient lights: els-19 states the low beam headlight should stay active for 30 more seconds with the interval being reset for example any time a door is opened or shut. We don\u2019t have sensors to measure that, as we only have a sensor to state if any door is open. So basically, this requirement has to be changed to either the 30 s cycle being reset continuously until the status of all doors is closed or to the cycle being reset only for the first door opened and respectively the last door shut.\n",
            "cite_spans": [],
            "section": "Description of Issues Uncovered",
            "ref_spans": []
        },
        {
            "text": "The importance of animation and visualization seems now accepted; see e.g. the applications [13] and earlier ABZ case studies [5, 6, 8]. The idea of exploratory phases has also been promoted elsewhere, e.g., in [11].",
            "cite_spans": [
                {
                    "start": 93,
                    "end": 95,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 127,
                    "end": 128,
                    "mention": "5",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 130,
                    "end": 131,
                    "mention": "6",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 133,
                    "end": 134,
                    "mention": "8",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 212,
                    "end": 214,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Related Work and Conclusion",
            "ref_spans": []
        },
        {
            "text": "The modelling approach described in Sect. 2 has been successful. Along the way we gained insights about the relationship between classical B machine inclusion and Event-B refinement. We were successful in re-using existing graphics to generate a custom graphical visualization, which helped us validate the model and allowed us to spot one error at least (cf. Fig. 5).",
            "cite_spans": [],
            "section": "Related Work and Conclusion",
            "ref_spans": [
                {
                    "start": 365,
                    "end": 366,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "A weak point of our approach is the manual translation from classical B to Event-B in phase 3. An automated translation of a subset of classical B to Event-B would reduce human effort and avoid errors in the translation. Another alternative would be to stay with Atelier-B and use its Event-B syntax, which does allow a more powerful substitution language. However, we were much more comfortable with the proving environment of rodin, hence the effort to translate the models was worth it for us here (and for an industrial system modeling project undertaken by the first author). Finally, why did we not simply do all of the modelling in Rodin to start with? The reasons are the limited tool support for structuring, editing and sharing of models. Future improvements to rodin could obviate the need to conduct the phases 1 and 2 of Sect. 2 in classical B. These improvements would require improved editing4 with git integration, improved model composition and decomposition features.",
            "cite_spans": [],
            "section": "Related Work and Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Size of classical B and Event-B model state spaces and model checking times\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Rodin proof statistics\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Machines and events in the three modelling phases",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Hierarchy of final classical B model with variables",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Hierarchy of final Rodin model, translated from classical B model in Fig. 2",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: SVG graphics used for VisB without modifications",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fig. 5.: Erroneous state uncovered via the visualisation",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [
                {
                    "first": "J-R",
                    "middle": [],
                    "last": "Abrial",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "The B-Book",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "ProB: an automated analysis toolset for the B method",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Leuschel",
                    "suffix": ""
                },
                {
                    "first": "MJ",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "STTT",
            "volume": "10",
            "issn": "2",
            "pages": "185-203",
            "other_ids": {
                "DOI": [
                    "10.1007/s10009-007-0063-9"
                ]
            }
        },
        "BIBREF2": {
            "title": "A formal modeling tool for exploratory modeling in software development",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Oda",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Araki",
                    "suffix": ""
                },
                {
                    "first": "PG",
                    "middle": [],
                    "last": "Larsen",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IEICE Trans.",
            "volume": "100\u2013D",
            "issn": "6",
            "pages": "1210-1217",
            "other_ids": {
                "DOI": [
                    "10.1587/transinf.2016FOP0003"
                ]
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [
                {
                    "first": "J-R",
                    "middle": [],
                    "last": "Abrial",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Modeling in Event-B: System and Software Engineering",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "An open extensible tool environment for Event-B",
            "authors": [
                {
                    "first": "J-R",
                    "middle": [],
                    "last": "Abrial",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hallerstede",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Voisin",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Formal Methods and Software Engineering",
            "volume": "",
            "issn": "",
            "pages": "588-605",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "Property-based modelling and validation of a CBTC zone controller in Event-B",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Comptier",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Leuschel",
                    "suffix": ""
                },
                {
                    "first": "L-F",
                    "middle": [],
                    "last": "Mejia",
                    "suffix": ""
                },
                {
                    "first": "JM",
                    "middle": [],
                    "last": "Perez",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mutz",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Reliability, Safety, and Security of Railway Systems. Modelling, Analysis, Verification, and Certification",
            "volume": "",
            "issn": "",
            "pages": "202-212",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Using a formal B model at runtime in a demonstration of the ETCS hybrid level 3 concept with Real Trains",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hansen",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Abstract State Machines, Alloy, B, TLA, VDM, and Z",
            "volume": "",
            "issn": "",
            "pages": "292-306",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Validating the requirements and design of a hemodialysis machine using iUML-B, BMotion studio, and co-simulation",
            "authors": [
                {
                    "first": "TS",
                    "middle": [],
                    "last": "Hoang",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Snook",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ladenberger",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Abstract State Machines, Alloy, B, TLA, VDM, and Z",
            "volume": "",
            "issn": "",
            "pages": "360-375",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "Validation of the ABZ landing gear system using proB",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ladenberger",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hansen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wiegard",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bendisposto",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Leuschel",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "STTT",
            "volume": "19",
            "issn": "2",
            "pages": "187-203",
            "other_ids": {
                "DOI": [
                    "10.1007/s10009-015-0395-9"
                ]
            }
        },
        "BIBREF12": {
            "title": "Real-time model checking is really simple",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Lamport",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Correct Hardware Design and Verification Methods",
            "volume": "",
            "issn": "",
            "pages": "162-175",
            "other_ids": {
                "DOI": []
            }
        }
    }
}