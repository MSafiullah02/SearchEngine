{
    "paper_id": "651b81d78d1ac01d71284617202df9537f360144",
    "metadata": {
        "title": "Parsing NCBI XML in Perl 5",
        "authors": []
    },
    "abstract": [],
    "body_text": [
        {
            "text": "For general questions about XML and Perl, check out the excellent Perl-XML FAQ [58] , available at: http://perl-xml.sourceforge.net/faq/.",
            "cite_spans": [
                {
                    "start": 79,
                    "end": 83,
                    "text": "[58]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "XML parser interfaces are broadly divided into two categories: tree-based and event-based. A tree-based interface, such as the DOM, will parse an XML document and build an in-memory tree of all its XML elements. For example, consider the XML document in Listing 5.1. This is a sample GBSeq XML document, retrieved from NCBI. If you send this document through a tree-based interface, the parser will create a tree like that displayed in Figure 5 .1. The root element is specified as the GBSet element and your application can navigate through the tree one node at a time. As your application traverses the tree, it can extract any and all data that it needs.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 436,
                    "end": 444,
                    "text": "Figure 5",
                    "ref_id": null
                }
            ],
            "section": "Tree-Based vs. Event-Based XML Parsers"
        },
        {
            "text": "Contrast this with an event-based parser, such as SAX. An event-based interface will read the document one line at a time. Each time the parser encounters an important piece of data, it will immediately fire off an event. For example, when the parser reaches the start <GBSeq -locus> tag, it fires off a start element event. When it sees the text, \"BC034957,\" it immediately fires off one or more character events. The same GBSeq example in Listing 5.1 will therefore trigger a very Listing 5.1 Excerpt of a sample GBSeq document from NCBI <?xml version=\"1.0\"?> <!DOCTYPE GBSet PUBLIC \"-//NCBI//NCBI GBSeq/EN\" \"http://www.ncbi.nlm.nih.gov/dtd/NCBI -GBSeq.dtd\"> <GBSet> <GBSeq> <GBSeq -locus>BC034957</GBSeq -locus> <GBSeq -length>2547</GBSeq -length> <GBSeq -strandedness value=\"not-set\">0</GBSeq -strandedness> <GBSeq -moltype value=\"mrna\">5</GBSeq -moltype> <GBSeq -topology value=\"linear\">1</GBSeq -topology> <GBSeq -division>PRI</GBSeq -division> <GBSeq -update-date>04-OCT-2003</GBSequpdate-date> <GBSeq -create-date>15-OCT-2002</GBSeqcreate-date> <GBSeq -definition>Homo sapiens a disintegrin and metalloproteinase domain 2 (fertilin beta), mRNA (cDNA clone MGC:26432 IMAGE:4826530), complete cds</GBSeq -definition> <GBSeq -primary-accession>BC034957</GBSeqprimary-accession> <GBSeq -accession-version>BC034957.2</GBSeqaccession-version> <GBSeq -other-seqids> <GBSeqid>gb|BC034957.2|</GBSeqid> <GBSeqid>gi|34783181</GBSeqid> </GBSeqother-seqids> ... </GBSeq> </GBSet> specific sequence of events (see Figure 5 .1). To extract the XML data, your application must be registered to receive parsing events and act upon them appropriately.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1508,
                    "end": 1516,
                    "text": "Figure 5",
                    "ref_id": null
                }
            ],
            "section": "Tree-Based vs. Event-Based XML Parsers"
        },
        {
            "text": "In event-based parsing, the XML parser is typically referred to as an event producer, and your application handler is referred to as an application consumer [61] . As the XML parser reads in an XML document, the parser will \"push\" events to the application consumer, and the consumer can choose to record these events or ignore them. Note that event-based parsers are always sequential, and therefore do not provide random access to the XML document content. using a Windows platform, you may be able to use the Active State Programmer's Package Module (PPM), to automatically install XML::LibXML. For up-to-date information about platform-specific installation issues, refer to the Perl-XML FAQ [58] .",
            "cite_spans": [
                {
                    "start": 157,
                    "end": 161,
                    "text": "[61]",
                    "ref_id": null
                },
                {
                    "start": 696,
                    "end": 700,
                    "text": "[58]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Tree-Based vs. Event-Based XML Parsers"
        },
        {
            "text": "The CPAN Shell can sometimes be a bit daunting, even to those with considerable Perl experience. If you find yourself having difficulties, check out the official CPAN documentation at: http: //www.perl.com/doc/manual/html/lib/CPAN.html. Alternatively, check out Section 2.4, \"Getting and Installing Modules,\" in Perl in a Nutshell, 2nd edition (O'Reilly, 2002) .",
            "cite_spans": [
                {
                    "start": 191,
                    "end": 360,
                    "text": "//www.perl.com/doc/manual/html/lib/CPAN.html. Alternatively, check out Section 2.4, \"Getting and Installing Modules,\" in Perl in a Nutshell, 2nd edition (O'Reilly, 2002)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Tree-Based vs. Event-Based XML Parsers"
        },
        {
            "text": "The Simple API for XML (SAX) is a standard event-based interface for parsing XML documents [71] . Unlike XML itself or the Document Object Model (DOM), SAX is not an official standard of any organization, such as the World Wide Web Consortium (W3C). Rather, SAX is a de facto standard, developed by a group of volunteers, freely available to the public, and widely implemented by dozens of XML parsers. SAX was originally designed for Java, but SAX and SAX-inspired implementations are now available for other languages, including Perl, Python, C++, Visual Basic, and Pascal (for a complete listing of SAX implementations see [71] ).",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 95,
                    "text": "[71]",
                    "ref_id": null
                },
                {
                    "start": 626,
                    "end": 630,
                    "text": "[71]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction to SAX"
        },
        {
            "text": "The official SAX web site is available at: http://www.saxproject.org. Continued SAX development is now hosted at SourceForge.net.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to SAX"
        },
        {
            "text": "Using an event-based XML parsing interface like SAX provides a number of advantages, particularly when used for bioinformatics applications. First, SAX is a de facto standard and has wide support within the industry. Second, you can learn the SAX interface in one language and immediately apply it to a second language; for example, you can learn the Perl XML::SAX interface and apply your knowledge to the Java SAX interface.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SAX and Bioinformatics Applications"
        },
        {
            "text": "Third, SAX is very fast and requires little memory. Unlike a tree-based interface, SAX will not store a complete representation of the XML document within memory. After an event has been reported to the application handler, the parser will immediately discard the event. This saves memory and is particularly important when parsing very large XML documents. For example, consider the implications of parsing the complete contents of UniProt [55], a comprehensive database of protein sequences and annotations. From the UniProt web site, you can download a complete snapshot of the database in UnitProt XML format. However, the complete snapshot consists of a single XML document, which is several hundreds of megabytes long. To parse this document via a tree-based interface, you need enough memory to hold the entire tree, and you always run the risk of receiving \"out of memory\" errors. In contrast, SAX requires very little overhead and is capable of parsing arbitrarily large documents.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SAX and Bioinformatics Applications"
        },
        {
            "text": "Although SAX itself is very memory efficient, keep in mind that your application handler can choose to store any and all XML events within its own internal data structures, and this will require its own set of memory requirements. You therefore need to carefully evaluate the specific requirements for your application. For example, if you want to parse the UnitProt XML file, and locate only a specific subset of proteins, your application handler can choose to record events specific to the target set, and discard the rest. Alternatively, if you want to import the UnitProt XML file into a set of relational database records, you only need to store one protein record at a time. After each record is committed to the database, you can purge your internal data structures, and move onto the next record.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SAX and Bioinformatics Applications"
        },
        {
            "text": "The main disadvantage of SAX is that it does not provide facilities for easily modifying existing XML documents, or easily creating new XML documents from scratch. Some programmers also find the capturing and processing of individual SAX events counterintuitive, and prefer the simplicity of a tree traversal API.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "SAX and Bioinformatics Applications"
        },
        {
            "text": "The SAX API was originally developed by a group of volunteers, coordinating over the xml-dev mailing list. SAX 1.0 was originally released in May 1998 [65] . SAX 2.0.1 was officially released in January 2002. Several major changes were introduced in SAX 2.0, including complete support for XML Namespaces, standard methods for configuring XML parser features and properties, and support for SAX filters, enabling you to chain XML applications together [57; 64] . This book focuses on SAX 2.0 only. For details regarding SAX 1.0, refer to the SAX web site at: http://www.saxproject.org/?selected=sax1.",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 155,
                    "text": "May 1998 [65]",
                    "ref_id": null
                },
                {
                    "start": 452,
                    "end": 460,
                    "text": "[57; 64]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "SAX 2.0"
        },
        {
            "text": "The Perl XML::SAX [70] module provides a complete implementation of the SAX 1.0 and 2.0 interfaces. The module is available for download from CPAN, and includes an XML parser written in Perl, called, XML::SAX::PurePerl [68]. PurePerl is considered quite slow, but it enables XML::SAX to work right out of the box on all platforms. XML::SAX also works with other faster SAXcompliant XML parsers, such as XML::LibXML [69], and provides a simple interface for selecting an XML parser at runtime.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "To get started with XML::SAX, follow these three steps:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "r Create a SAX event handler. As the XML parser reads a document, it will encounter specific XML constructs and notify your handler via callback methods. For example, when the XML parser encounters a new start element tag, it will call the event handler startelement() method, and pass information about the element. As a convenience, your event handler can extend XML::SAX::Base , and provide implementations of only those call-back methods that are of interest.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "r Obtain an XML parser and register your event handler with the parser. XML::SAX provides a factory class, called ParserFactory , which will locate, instantiate, and initialize an XML parser of your choosing. Later in this section, we will also explore options for selecting an XML parser at runtime.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "r Initiate parsing by calling one of the parsexxx() methods. For example, you can parse a local document by calling the parseuri() method and supplying an absolute or relative path to the file. Alternatively, you can use the parsefile() method and pass in a stream or file handle, such as an IO::File. You can also use the parsestring() method and pass in the complete XML document as one string. In all cases, the XML parser will immediately start parsing the document of your choosing, and report each XML event to the registered handler.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "To illustrate the basic concepts of XML::SAX, consider the sample Perl code in Listing 5.2. The source code in Listing 5.2 instantiates a parser object via the XML::SAX::ParserFactory class. By default, the ParserFactory will look for a package variable to determine which parser to instantiate. For example, the following package variable will load the PurePerl SAX parser: $XML::SAX::ParserPackage=\"XML::SAX::PurePerl\";",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Alternatively, the following package variable will load the LibXML SAX parser: $XML::SAX::ParserPackage=\"XML::LibXML::SAX::Parser\";",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "If no package variable is set, XML::SAX will automatically search all the directories in @INC in search of a SAX.ini file. The SAX.ini file uses a simple key=value format. For example, the following file specifies the LibXML SAX parser: ParserPackage = XML::LibXML::SAX::Parser If XML::SAX is unable to find a package variable or a SAX.ini file, it will automatically default to the PurePerl SAX parser. The Data::Dumper will display all information about the parser, including the package name of the selected parser, and a list of all features and properties.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "The bulk of the work in using XML::SAX goes into creating a custom SAX event handler. A sample event handler, called ContentReporter, is shown in Listing 5.3. Examine the code now, and we will survey its components below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "The ContentReporter in Listing 5.3 extends XML::SAX:Base , and selectively listens for four types of events: startdocument, enddocument, startelement, and endelement. The ContentReporter also keeps a running count of the number of elements encountered, and returns the total count to the main calling application. When we use this event handler on our sample GBSeq document in Listing 5.1, we get the following output: Depending on the call-back method, you may or may not receive additional information about the event. For example, when the parser encounters the beginning of an XML document, it will call the startdocument() method, but will not pass any additional event details. By contrast, when the parser encounters a new element, it will call the startelement() method, and pass along specific element details. Event details are specified as a hash reference with specific predefined keys. For example, the startelement() method receives a hash reference with several element specific keys, including \"Name,\" \"LocalName,\" and \"Prefix.\" You can then reference these keys to display additional information about the event. For example:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "sub startelement { my ($self, $element) = @ -; my $name = $element->{\"Name\"}; print \"Start Element: $name\\n\"; } The element hash reference also contains an optional \"Attributes\" key, which contains all attribute data associated with the element. For example, the following code will extract all attribute data and display it to the console: Table 5 .1 provides a listing of the main methods in XML::SAX::Base . Note in particular that the enddocument() method is the final method called, and that its return value is returned by the parsexxx() methods. This provides a convenient mechanism to propagate data from the event handler back to the main calling application. Indicates a character event. The $text parameter is a hash reference containing a single key:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 341,
                    "end": 348,
                    "text": "Table 5",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 Data: contains the character content. Given a string of XML text, each SAX parser is free to report character events as it sees fit. For example, one parser may report the entire text string via a single call to characters() ; a second parser may split the string and call characters() twice. Given this flexibility, it is important that your handler provide some type of character buffering",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates an XML comment. The $comment parameter is a hash reference containing a single key:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 Data: contains the comment text",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates a DTD Element Declaration. The $elementinfo parameter is a hash reference containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 Name: name of the element \u2022 Model: content model of the element endcdata ($self)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates the end of a CDATA section enddocument ($self)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates the end of an XML document. The return value of enddocument() is returned by the parsexxx() methods,andthereforeprovidesaconvenientmechanismforpropagating data from the event handler back to the main calling application endelement ($self, $element)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates the end of an XML element. The $element parameter is a hash reference containing the same keys as those defined in startelement(). See startelement() for details",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates the end scope of a namespace declaration. The $namespaceinfo parameter is a hash reference containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 Prefix: the namespace prefix, e.g., \"psi''",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 NamespaceURI: the namespace URI, e.g., \"net:sf:psidev:mi'' processinginstruction ($self, $pi)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "Indicates a processing instruction. The $pi parameter is a hash reference containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 Target: the target of the processing instruction \u2022 Data: the complete text of the processing instruction setdocumentlocator ($self, $doclocator) Sets a document locator object. This is usually the very first method called, directly before a call to startdocument(). If you want to determine the location of all subsequent SAX events, store the $doclocator object locally and reference it within other SAX call-back methods.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "The $doclocator parameter is a hash reference, containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 ColumnNumber: column number where the event occurred \u2022 LineNumber: line number where the event occurred ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction to XML::SAX"
        },
        {
            "text": "\u2022 SystemId: the system identifier of the current document or undef, if it is not defined \u2022 PublicId: the public identifier of the current document or undef, if it is not defined Note that SAX parsers are strongly encouraged to supply a document locator, but are not required to do so startcdata ($self)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "Indicates the start of a CDATA section. The actual content of the CDATA section is subsequently reported via the characters() method startdocument ($self)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "Indicates the start of an XML document startelement ($self, $element)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "Indicates the start of an XML element. The $element parameter is a hash reference containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "\u2022 Prefix: the namespace prefix of the element, e.g., \"psi''",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "\u2022 LocalName: the local name of the element. This is the name of the element, without its namespace prefix, e.g., \"interaction'' \u2022 Name: a fully qualified element name. This is the name of the element with its namespace prefix, e.g., \"psi:interaction'' \u2022 NamespaceURI: the namespace URI of this element \u2022 Attributes: a hash reference containing all the element's attributes If the element has attributes, the Attributes hash reference will contain one key for each attribute.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "The key is specified in the following form: \"{NamespaceURI}LocalName''. If the attribute is not associated with any namespace, it will have an empty NamespaceURI, e.g., \"{ }LocalName''. Each attribute will in turn contain the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "\u2022 Prefix: the namespace prefix of the attribute \u2022 LocalName: the local name of the attribute \u2022 Value: the attribute value \u2022 Name: a fully qualified attribute name \u2022 NamespaceURI: the namespace URI of the attribute startprefixmapping ($self, $namespaceinfo)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "Indicates the beginning scope of a namespace declaration. The $namespaceinfo parameter is a hash reference containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "\u2022 Prefix: the namespace prefix, e.g., \"psi''",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "\u2022 NamespaceURI: the namespace URI, e.g., \"net:sf:psidev:mi'' xmldecl ($self, $declaration)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "Indicates an XML declaration. The $declaration parameter is a hash reference containing the following keys:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "\u2022 Version: XML version, e.g., \"1.0'' \u2022 Encoding: character encoding, e.g., \"UTF-8''",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method Description"
        },
        {
            "text": "It is important to note that if your XML parser encounters an error in well-formedness, the parser will consider this a fatal error and stop program execution via a call to die(). (Recall from Chapter 2 that an XML document is considered well-formed if it follows the basic rules of document construction, e.g., all start tags must have matching end tags, elements must be properly nested, attributes must appear in quotes, etc.) If you want to prevent your program from dying, you can wrap your call to parsexxx() inside an eval block. For example: eval { $parser->parse -uri(\"sample/ncbi.xml\"); };",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Error Handling"
        },
        {
            "text": "if ($@) { my $message = $@->{\"Message\"}; my $linenumber = $@->{\"LineNumber\"}; print \"Error! --> $message\\n\"; print \"Error Occurred at line number: $line -number\\n\"; } Note that the $@ hash reference contains a number of predefined keys, such as \"Message,\" \"LineNumber,\" and \"ColumnNumber,\" allowing you to access specific details about the error.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Error Handling"
        },
        {
            "text": "Now that you understand the basics of XML::SAX , you can apply this knowledge to dynamically retrieve and parse sequence data from NCBI. Fortunately for us, NCBI provides a web service, called EFetch that simplifies the process of retrieving sequence records. EFetch is actually an example of a REST-based web service (for details on REST-based web services, refer to Chapter 9). In a nutshell, client applications connect to EFetch via HTTP and specify search criteria with a set of URL parameters. Based on the search criteria, the EFetch service will connect to the NCBI Entrez back-end database system, find a matching record, and return the requested record in the format of your choosing. EFetch currently provides access to several NCBI Entrez databases, including sequence, literature, and taxonomy databases; and can return data in several data formats, including text, HTML, ASN.1 and XML. If you are eager to try out a few sample EFetch requests, refer to To retrieve a specific nucleotide sequence record, you must append a database parameter and an ID parameter, which uniquely identifies the record. For example, the following URL retrieves the complete genome record for the SARS coronavirus, formatted in the GenBank flat file format: In the URL above, the db parameter specifies the NCBI nucleotide database, rettype specifies the GenBank flat file format, retmode specifies text content, and id specifies the NCBI GI number for the SARS virus. Conveniently, the id parameter accepts both NCBI GI numbers and NCBI accession numbers. For XML content, set the retmode parameter to \"xml.\" For example, to retrieve data in the NCBI TinySeq XML format, set rettype=fasta and retmode=xml. To retrieve data in the more comprehensive NCBI GBSeq XML, set rettype=gb and retmode=xml . For example, the following URL retrieves the same SARS virus record, but this time it is formatted in GBSeq XML: Source code for the Perl fetcher is shown in Listings 5.4 and 5.5. Examine the code now and we will describe its main components below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::SAX"
        },
        {
            "text": "As in our first SAX application, the fetch application consists of two parts: a main application, which initiates parsing (Listing 5.4), and a SAX event handler (Listing 5.5). The main application uses the World Wide Web library for Perl (LWP) [60] to connect to NCBI EFetch and retrieve the specified sequence record. It also obtains an XML parser via the SAX factory, and initiates parsing via the parsestring() method. The parsestring() method returns an associative array, which we then print to the console.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::SAX"
        },
        {
            "text": "The NcbiHandler.pm module listens for specific SAX events, and selectively stores specific GBSeq elements in an internal associative array. There are a few important items to note. First, the characters() method uses a character buffer. This is important because SAX parsers are free to perform character \"chunking\"-for example, one SAX parser may report a line of text via a single call to characters() , whereas a second SAX parser may break the line into two \"chunks\" and report it via two calls to characters() . Since there is no way to know ahead of time which chunking method the parser will use, it is always safest to assume multiple calls to characters() and to append to a character buffer each time. Second, the endelement() method is used to } # Selectively store element information.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::SAX"
        },
        {
            "text": "sub endelement { my ($self, $element) = @ -; my $name = $element->{\"Name\"}; if ($name eq \"GBSeqlocus\" | | $name eq \"GBSeqprimary-accession\" | | $name eq \"GBSeqdefinition\" | | $name eq \"GBSeqorganism\" selectively filter for specific GBSeq elements. For those specific elements of interest, we store the current character buffer into an associative array and use the element name as a hash key. We subsequently return the associative array to the main calling application by returning it from the enddocument() method.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::SAX"
        },
        {
            "text": "The Document Object Model (DOM) is a standard tree-based interface for reading, modifying, and creating XML documents. The DOM is an official recommendation of the W3C, and the DOM API is specified in the Object Management Group Interface Definition Language (OMG IDL). This enables the DOM API to be both platform and language independent. DOM implementations are available in numerous programming languages, including Perl, Java, JavaScript, VBScript, C/C++, and Python. In this section, we provide an introduction to the Perl XML::LibXML module, and illustrate its support for the DOM standard. We also revisit the NCBI EFetch service, and recreate the same functionality as our earlier SAX application. This enables you to directly compare and contrast the DOM approach with the SAX approach.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Document Object Model (DOM)"
        },
        {
            "text": "The XML::LibXML Perl module provides an interface to the very popular libxml parser, an XML parser written in C and developed for the Linux Gnome project. The libxml parser itself is packed with numerous features, including support for XML Namespaces, SAX, DOM, XPath, XPointer, and XInclude. For our purposes, we will be focusing exclusively on the DOM implementation provided by libxml. If you are interested in the other features of libxml, check out the main libxml web site at: http://xmlsoft.org.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DOM Traversal with XML::LibXML"
        },
        {
            "text": "Let us jump right in with our first DOM example. Listing 5.6 provides an example application, which will traverse through all the elements in our sample NCBI XML document. Examine the code now, and we will describe its main components below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DOM Traversal with XML::LibXML"
        },
        {
            "text": "There are several important elements to note about the code in Listing 5.6. First, we instantiate a new LibXML parser object and direct the parser to parse a local file: The parsefile() method returns a DOM Document object. This document object contains a complete tree representation of our XML document. To begin tree traversal, we request the root document element:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DOM Traversal with XML::LibXML"
        },
        {
            "text": "We then pass this root element to the recursive traversenode() method. In the DOM data model, all XML constructs, e.g., elements, attributes, text data, and processing instructions, are represented as DOM nodes, and all nodes provide a number of very useful attributes/methods. For example, you can retrieve the node name or node type: my $nodename = $node->nodeName; my $nodetype = $node->nodeType;",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DOM Traversal with XML::LibXML"
        },
        {
            "text": "Depending on the node type, our code takes different actions. For example, if we encounter a text node, we extract the embedded text content. If we encounter an element node, we retrieve a list of all its child nodes and pass these nodes recursively to the traversenode() method: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "DOM Traversal with XML::LibXML"
        },
        {
            "text": "The DOM API also supports several methods for finding specific subelements. For example, the getChildrenByTagName() method will find all direct children with the specified tag name. By contrast, the getElementsByTagName() method will recursively search all descendants of the current node, and return all descendants with the specified tag name. The LibXML module also provides support for XPath, a W3C specification that enables you to pinpoint specific elements or sets of elements within an XML document. For example, the code snippet below uses the XPath find feature to extract two specific GBSeq elements: my $doc = $parser->parse -file(\"sample/ncbi.xml\"); my $locus = $doc->find(\"/GBSet/GBSeq/GBSeqlocus\"); my $def = $doc->find(\"/GBSet/GBSeq/GBSeqdefinition\"); print \"Locus: $locus\\n\"; print \"Definition: $def\\n\";",
            "cite_spans": [],
            "ref_spans": [],
            "section": "} }"
        },
        {
            "text": "The complete LibXML DOM API is quite large, and we could not hope to cover it in its entirety in this chapter. For complete documentation on all relevant classes and methods, refer to the LibXML documentation, available online at: http://search.cpan.org/dist/XML-LibXML. If you are working extensively with LibXML, you may find it useful to print out the documented API for XML::LibXML::Node , the base class used to represent all DOM nodes, and XML::LibXML::Element , the class used to represent element nodes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "} }"
        },
        {
            "text": "The LibXML Perl module provides built-in support for validating XML documents against DTDs. To turn XML validation on, simply pass a true value to the parser validation() method, and then initiate parsing. If LibXML encounters an error in well-formedness or validity, it will immediately die() and report the error to the console. If you want to prevent your program from exiting, you can wrap the parse call in an eval block. For example: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Validating XML Documents with XML::LibXML"
        },
        {
            "text": "In addition to reading in XML documents, the Document Object Model also provides convenient mechanisms for modifying existing documents or creating new XML documents from scratch. For example, the code in Listing 5.7 uses the DOM API to create an entirely new document in the NCBI TinySeq XML format.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Creating New Documents with XML::LibXML"
        },
        {
            "text": "To create a new XML document, you must first instantiate a Document object: my $document = XML::LibXML::Document->new ();",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Creating New Documents with XML::LibXML"
        },
        {
            "text": "You then need to create root element, and add this to the document: my $root = $document->createElement (\"TSeq\"); $document->addChild ($root);",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Creating New Documents with XML::LibXML"
        },
        {
            "text": "You can then proceed to create new elements, and add these to the root element. Note that if you want to add text to an element, you must first create a text node, and then add this to the element node. This operation is automatically performed by the appendTextNode() method. In the same manner, to create an element with attributes, you must first create one or more attribute objects, and then add each attribute to the element node. The DOM API provides dozens of other methods for creating new nodes, removing nodes, and copying nodes. However, the scope of the complete API is beyond the scope of what we hope to cover here. For the complete API, refer to the LibXML API documentation, available online at: http://search.cpan.org/dist/XML-LibXML.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Creating New Documents with XML::LibXML"
        },
        {
            "text": "As our final topic, we revisit the NCBI EFetch service. Our goal is to retain the exact same functionality as our first EFetch application (see Section 5.2.5), but to replace the SAX code with # Add Sequence Type with Attribute my $seqtype = $document->createElement (\"TSeqseqtype\"); my $attribute = $document->createAttribute(\"value\", \"nucleotide\"); $seqtype->addChild ($attribute); $root->addChild ($seqtype);",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::LibXML"
        },
        {
            "text": "# Add Other Sub-elements addelement ($document, $root, \"TSeqgi\", \"11497606\"); addelement ($document, $root, \"TSeqsid\", \"ref| NM -001464.2| \"); addelement ($document, $root, \"TSeqtaxid\", \"9606\"); addelement ($document, $root, \"TSeqorgname\", \"Homo sapiens\"); addelement ($document, $root, \"TSeqdefline\", \"Homo sapiens a disintegrin and metalloproteinase domain 2 \" . \"(fertilin beta) (ADAM2), mRNA\"); addelement ($document, $root, \"TSeqlength\", \"2659\"); addelement ($document, $root, \"TSeqsequence\", \"CATCTCGCACTTC...\"); # Convert to XML String, with indentation my $xml = $document->toString(1); print \"XML Document:\\n$xml\"; # Adds New Element with Single Text Value sub addelement { my ($document, $parent, $elementname, $textstr) = @ -; my $child = $document->createElement ($elementname); $child->appendTextNode ($textstr); $parent->addChild ($child); } DOM code. By comparing the two examples, you can therefore directly compare the SAX and DOM interfaces and gain insight into both approaches.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::LibXML"
        },
        {
            "text": "The complete source code for our new fetch application is shown in Listing 5.8. As in our first DOM example, we parse an NCBI XML document and immediately extract its root element. However, instead of traversing the entire XML object tree, we now selectively traverse the tree in search of five specific GBSeq elements. To do so, we first obtain the GBSeq element: my @seq -children = $root->getElementsByTagName(\"GBSeq\"); my $seqnode = $seqchildren[0]; ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Using NCBI EFetch and XML::LibXML"
        },
        {
            "text": "We then selectively search for direct children with specific tag names. To do so, the local getelementtext() method uses the DOM getChildrenByTagName() method to find direct children with the specified tag name. If any matching children are found, we take the first matching child and immediately return its text content. We are therefore able to easily extract any piece of GBSeq data and immediately display it to the console.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "}"
        },
        {
            "text": "In conclusion, Perl provides excellent support for XML. In this chapter, we have discussed the fundamental differences between tree-based and event-based XML parsers, and have illustrated these differences by exploring the SAX and DOM interfaces. Event-based parsers, such as SAX, are generally faster and require less memory than comparable tree-based parsers. However, treebased parsers provide random access to any node or branch in the XML document and also provide facilities for modifying or creating new documents. If you have intense performance requirements, or are working with very large documents, you may have no choice but to use an event-based parser. However, for moderate-sized XML documents, you may find a tree-based interface easier to use. In either case, by sticking to well-defined public standards, such as SAX or DOM, you can more easily apply your XML knowledge to other programming languages, such as C++ or Java.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "}"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Parsing NCBI EFetch data via the DOM API # Fetches NCBI XML from the NCBI E-Fetch Utility. # Author",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "use LWP::Simple; use strict",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Tree-based vs. event-based XML parsing.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "$self, $doc) = @ -; print \"End Document\\n\"; return $elementcounter;",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "my $doc = $parser->parse -file(\"sample/ncbi.xml\");",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Listing 5.2 First XML::SAX application #!/usr/bin/perl # Basic SAX Example. # Obtain SAX Parser via ParserFactory my $parser = XML::SAX::ParserFactory->parser(Handler =>$handler); # Parse TinySeq XML Document my $elementcounter = $parser->parse -uri(\"sample/ncbi.xml\"); print \"Total Number of Elements: $element -counter\\n\";Tip: If you want to confirm which SAX parser is currently in use, you can use the very helpful Data::Dumper Perl module. Just obtain an XML parser via the ParserFactory and dump out its data. For example:",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Main methods of XML::SAX::Base Indicates a DTD Attribute Declaration. The $attributeinfo parameter is a hash reference containing the following keys:\u2022 Type: the attribute type, e.g. CDATA or ID\u2022 eName: the element name \u2022 aName: the attribute name \u2022 ValueDefault: attribute default flag, e.g. #REQUIRED or #IMPLIED \u2022 Value: default value, or undef if a default value is not supplied",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nucleotide&rettype=gb&retmode=  xml&id=30271926    Complete details regarding NCBI EFetch are available online at: http://eutils.ncbi.nlm.nih.gov/entrez/query/static/efetchseqhelp.html.Our goal is to write a Perl program capable of automatically retrieving sequence data from EFetch and extracting a small subset of the XML content for display to the console. The program expects a single command line argument, indicating an NCBI GI number or accession number. A sample run of the application is shown below:>fetch.pl NC -004718Downloading XML from NCBI E-Fetch Using URL: http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Listing 5.4 Parsing NCBI EFetch data via the SAX API #!/usr/bin/perl # Fetches NCBI XML from the NCBI E-Fetch Utility.Listing 5.5 NcbiHandler.pm #!/usr/bin/perl -w # Parses NCBI GBSeq XML Documents, and extracts only # selected elements.",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "By examining each element, and recursively exploring each of its child nodes, our sample application is capable of traversing through the entire XML document tree. An excerpt from this traversal is shown below:If you want to determine if an element has attributes, you can use the hasAttributes query method, and then retrieve those attributes via the attributes property. For example, the following code excerpt outputs all element attributes to the console: my $name = $attribute->nodeName; my $value = $attribute->value; print \"Attribute Name: $name --> Value: $value\\n\";",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "Listing 5.7 Creating a TinySeq XML document via the DOM API # Creates a new TinySeq XML Document via the DOM API. use XML::LibXML; use strict; # Instantiate New Document Object my $document = XML::LibXML::Document->new ();",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "Listing 5.8 (cont.) my @elements = $node->getChildrenByTagName($targetname); if (@elements) { my $element = $elements[0]; my $text = $element->textContent; } else { return \"Not Available\"; } } # Gets NCBI Identifier from user, and returns an absolute URL # to the NCBI E-Fetch Utility. sub getncbiurl { my $id = $ -[0]; # Set Base URL for NCBI E-Fetch my $baseurl = \"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/\" . \"efetch.fcgi?db=nucleotide&rettype=gb&retmode=xml&id=\"; return ($baseurl . $id);",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}