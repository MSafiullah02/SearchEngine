{
    "paper_id": "PMC7148240",
    "metadata": {
        "title": "VGCN-BERT: Augmenting BERT with Graph Embedding for Text Classification",
        "authors": [
            {
                "first": "Joemon",
                "middle": [
                    "M."
                ],
                "last": "Jose",
                "suffix": "",
                "email": "joemon.jose@glasgow.ac.uk",
                "affiliation": {}
            },
            {
                "first": "Emine",
                "middle": [],
                "last": "Yilmaz",
                "suffix": "",
                "email": "emine.yilmaz@ucl.ac.uk",
                "affiliation": {}
            },
            {
                "first": "Jo\u00e3o",
                "middle": [],
                "last": "Magalh\u00e3es",
                "suffix": "",
                "email": "jm.magalhaes@fct.unl.pt",
                "affiliation": {}
            },
            {
                "first": "Pablo",
                "middle": [],
                "last": "Castells",
                "suffix": "",
                "email": "pablo.castells@uam.es",
                "affiliation": {}
            },
            {
                "first": "Nicola",
                "middle": [],
                "last": "Ferro",
                "suffix": "",
                "email": "ferro@dei.unipd.it",
                "affiliation": {}
            },
            {
                "first": "M\u00e1rio",
                "middle": [
                    "J."
                ],
                "last": "Silva",
                "suffix": "",
                "email": "mjs@inesc-id.pt",
                "affiliation": {}
            },
            {
                "first": "Fl\u00e1vio",
                "middle": [],
                "last": "Martins",
                "suffix": "",
                "email": "flaviomartins@acm.org",
                "affiliation": {}
            },
            {
                "first": "Zhibin",
                "middle": [],
                "last": "Lu",
                "suffix": "",
                "email": "zhibin.lu@umontreal.ca",
                "affiliation": {}
            },
            {
                "first": "Pan",
                "middle": [],
                "last": "Du",
                "suffix": "",
                "email": "pan.du@umontreal.ca",
                "affiliation": {}
            },
            {
                "first": "Jian-Yun",
                "middle": [],
                "last": "Nie",
                "suffix": "",
                "email": "nie@iro.umontreal.ca",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Text classification is a fundamental problem in natural language processing (NLP) and has been extensively studied in many real applications. In recent years, we witnessed the emergence of text classification models based on neural networks such as convolutional neural networks (CNN) [15], recurrent neural networks (RNN) [13], and various models based on attention [27]. BERT [8] is one of the self-attention models that uses multi-task pre-training technique based on large corpora. It often achieves excellent performance, compared to CNN/RNN models and traditional models, in many tasks [8] such as Named-entity Recognition (NER), text classification and reading comprehension.",
            "cite_spans": [
                {
                    "start": 286,
                    "end": 288,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 324,
                    "end": 326,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 368,
                    "end": 370,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 379,
                    "end": 380,
                    "mention": "8",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 593,
                    "end": 594,
                    "mention": "8",
                    "ref_id": "BIBREF31"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The deep learning models excel by embedding both semantic and syntactic information in a learned representation. However, most of them are known to be limited in encoding long-range dependency information of the text [2]. The utilization of self-attention helps alleviate this problem, but the problem still remains. The problem stems from the fact that the representation is generated from a sentence or a document only, without taking into account explicitly the knowledge about the language (vocabulary). For example, in the movie review below:\u201cAlthough it\u2019s a bit smug and repetitive, this documentary engages your brain in\na way few current films do.\u201dboth negative and positive opinions appear in the sentence. Yet the positive attitude \u201ca way few current films do\u201d expresses a very strong opinion of the innovative nature of the movie in an implicit way. Without connecting this expression more explicitly to the meaning of \u201cinnovation\u201d in the context of movie review comments, the classifier may underweight this strong opinion and the sentence may be wrongly classified to be negative. On this example, self-attention that connects the expression to other tokens in the sentence may not help.",
            "cite_spans": [
                {
                    "start": 218,
                    "end": 219,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In recent studies, approaches have also been developed to take into account the global information between words and concepts. The most representative work is Graph Convolutional Networks (GCN) [16] and its variant Text GCN [32], in which words in a language are connected in a graph. By performing convolution operations on neighbor nodes in the graph, the representation of a word will incorporate those of the neighbors, allowing to integrate the global context of a domain-specific language to some extent. For example, the meaning of \u201cnew\u201d can be related to that of \u201cinnovation\u201d and \u201csurprised\u201d through the connections between them. However, GCNs that only take into account the global vocabulary information may fail to capture local information (such as word order), which is very important in understanding the meaning of a sentence. This is shown in the following examples, where the position of \u201cwork\u201d in the sentence will change the meaning depending on its context:\u201cskip\nwork\nto see it at the first opportunity.\u201d\u201cskip to see it,\nwork\nat the first opportunity.\u201d\n",
            "cite_spans": [
                {
                    "start": 195,
                    "end": 197,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 225,
                    "end": 227,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper, inspired by GCN [16, 32] and self-attention mechanism in BERT, we propose to combine the strengths of both mechanisms in the same model. We first construct a graph convolutional network on the vocabulary graph based on the word co-occurrence information, which aims at encoding the global information of the language, then feed the graph embedding and word embedding together to a self-attention encoder in BERT. The word embedding and graph embedding then interact with each other through the self-attention mechanism while learning the classifier. This way, the classifier can not only make use of both local information and global information, but also allow them to guide each other via the attention mechanism so that the final representation built up for classification will integrate gradually both local and global information. We also expect that the connections between words in the initial vocabulary graph can be spread to more complex expressions in the sentence through the layers of self-attention.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 34,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 36,
                    "end": 38,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We call the proposed model VGCN-BERT. Our source code is available at https://github.com/Louis-udm/VGCN-BERT.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We carry out experiments on 5 datasets of different text classification tasks (sentiment analysis, grammaticality detection, and hate speech detection). On all these datasets, our approach is shown to outperform BERT and GCN alone.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The contribution of this work is twofold:Combining global and local information: There has not been much work trying to combine local information captured by BERT and global information of a language. We demonstrate that their combination is beneficial.Interaction between local and global information through attention mechanism: We propose a tight integration of local information and global information, allowing them to interact through different layers of networks.\n",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "As aforementioned, attention mechanisms [28, 31] based on various deep neural networks, in particular the self-attention mechanism proposed by Vaswan et al. [27], have greatly improved the performance in text classification tasks. The representation of a word acquired through self-attention can incorporate the relationship between the word and all other words in a sentence by fusing the representations of the latter.",
            "cite_spans": [
                {
                    "start": 41,
                    "end": 43,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 45,
                    "end": 47,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 158,
                    "end": 160,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                }
            ],
            "section": "Self-attention and BERT ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "BERT (Bidirectional Encoder Representations from Transformers) [8], which leverages a multi-layer multi-head self-attention (called transformer) together with a positional word embedding, is one of the most successful deep neural network model for text classification in the past years. The attention mechanism in each layer of the encoder enhances the new representation of the input data with contextual information by paying multi-head attentions to different parts of the text. A pre-trained BERT model based on 800M words from BooksCorpus and 2,500M words from English Wikipedia is made available. It has also been widely used in many NLP tasks, and has proven effective. However, as most of other attention-based deep neural networks, BERT mainly focuses on local consecutive word sequences, which provides local context information. That is, a word is placed in its context, and this generates a contextualized representation. However, it may be difficult for BERT to account for the global information of a language.",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 65,
                    "mention": "8",
                    "ref_id": "BIBREF31"
                }
            ],
            "section": "Self-attention and BERT ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "Global relations between words in a language can be represented as a graph, in which words are nodes and edges are relations. Graph Neural Network (GNN) [2, 5] based on such a graph is good at capturing the general knowledge about the words in a language. A number of variants of GNN have been proposed and applied to text classification tasks [7, 12, 16, 21, 33], of which Kipf et al. [16] creatively presented Graph Convolutional networks (GCN) based on spectral graph theory. GCN first builds a symmetric adjacency matrix based on a given relationship graph (such as a paper citation relationship), and then the representation of each node is fused according to the neighbors and corresponding relationships in the graph during the convolution operation.",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 155,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 157,
                    "end": 158,
                    "mention": "5",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 345,
                    "end": 346,
                    "mention": "7",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 348,
                    "end": 350,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 352,
                    "end": 354,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 356,
                    "end": 358,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 360,
                    "end": 362,
                    "mention": "33",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 387,
                    "end": 389,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Graph Convolutional Networks (GCN) ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "Text GCN is a special case of GCN for text classification proposed by Yao et al. [32] recently. Different from general GCN, it is based on a heterogeneous graph where both words and documents are nodes. The relationships among nodes, however, are measured in three different ways, which are co-occurrence relations among words, tf-idf measure between documents and words, and self similarity among documents. In terms of convolution, Text GCN uses the same algorithm as GCN. GCN and its variants are good at convolving the global information in the graph into a sentence, but they do not take into account local information such as the order between words. When word order and other local information are important, GCN may be insufficient. Therefore, it is natural to combine GCN with a model capturing local information such as BERT.",
            "cite_spans": [
                {
                    "start": 82,
                    "end": 84,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                }
            ],
            "section": "Graph Convolutional Networks (GCN) ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "Some recent studies have combined GCN with BERT. Shang et al. [23] applied a combination to the medication recommendation task, which predict a medical code given the electronic health records (EHR), i.e., a sequence of historical medical codes, of a patient. They first embed the medical codes from a medical ontology using Graph Attention Networks (GAT), then feed the embedding sequence of the medical code in an EHR into BERT for code prediction. Nevertheless, the order in the code sequence is discarded in the transformer since it is not applicable in their scenario, making it incapable of capturing all the local information as in our text classification tasks.",
            "cite_spans": [
                {
                    "start": 63,
                    "end": 65,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "Existing Combinations of GCN and BERT ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "Jong et al. [14] proposed another combination to the citation recommendation task using paper citation graphs. This model simply concatenates the output of GCN and the output of BERT for downstream predictive tasks. We believe that interactions between the local and global information are important and can benefit the downstream prediction tasks. In fact, through layers of interactions, one could allow the information captured in GCN be applied to the input text, and the representation of the input text be spread over GCN. This will produce the effect we illustrated in the earlier example of movie review (a way few current films do vs. innovation). This is the approach we propose in this paper.",
            "cite_spans": [
                {
                    "start": 13,
                    "end": 15,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Existing Combinations of GCN and BERT ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "One may question about the necessity to explicitly use graph embedding to cope with global dependency information, as some studies [18, 25] have shown that word embedding trained on a corpus, such as Word2Vec [19], GloVe [22], FastText [10], can capture some global connections between words in a language. We believe that a vocabulary graph can still provide additional information given the fact that the connections between words observed in word embeddings are limited within a small text window (usually 5 words). Long-range connections are missing. In addition, by building a vocabulary graph on an application-specific document collection, one can capture application-dependent dependencies, in addition to the general dependencies in the pre-trained models.",
            "cite_spans": [
                {
                    "start": 132,
                    "end": 134,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 136,
                    "end": 138,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 210,
                    "end": 212,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 222,
                    "end": 224,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 237,
                    "end": 239,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Existing Combinations of GCN and BERT ::: Related Work",
            "ref_spans": []
        },
        {
            "text": "Our vocabulary graph is constructed using normalized point-wise mutual information (NPMI) [3], as shown in Eq. 1:1\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\text {NPMI}(i, j) = -\\frac{1}{\\log p(i,j)} \\log \\frac{p(i, j)}{p(i)p(j)} \\end{aligned}$$\\end{document}where i and j are words, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p(i, j) = \\frac{\\#W(i, j)}{\\#W}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p(i) = \\frac{\\#W(i)}{\\#W}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\#W(*)$$\\end{document} is the number of sliding windows containing a word or a pair of words, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\#W$$\\end{document} is the total number of sliding windows. To obtain long-range dependency, we set the window to the whole sentence. The range of value of NPMI is [-1,1]. A positive NPMI value implies a high semantic correlation between words, while a negative NPMI value indicates little or no semantic correlation. In our approach, we create an edge between two words if their NPMI is larger than a threshold. Our experiments show that the performance is better when the threshold is between 0.0 and 0.3.",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 92,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Vocabulary Graph ::: Proposed Method",
            "ref_spans": []
        },
        {
            "text": "A general GCN [16] is a multi-layer (usually 2 layers) neural network that convolves directly on a graph and induces embedding vectors of nodes based on properties of their neighborhoods. Formally, consider a graph \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G = (P, E)$$\\end{document}1, where P (with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|P| = n$$\\end{document}) and E are sets of nodes and edges, respectively. For a single convolutional layer of GCN, the new representation is calculated as follows:2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} H = \\tilde{A}XW, \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X \\in \\mathbb {R}^{n \\times m}$$\\end{document} is the input matrix with n nodes and m dimensions of the feature, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W \\in \\mathbb {R}^{m \\times h}$$\\end{document} is a weight matrix, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\tilde{A} = D^{-\\frac{1}{2}}A D^{-\\frac{1}{2}}$$\\end{document} is the normalized symmetric adjacency matrix, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$D_{ii} = \\sum _j A_{ij}$$\\end{document}. The normalization operation for A is to avoid numerical instabilities and exploding/vanishing gradients when used in a deep neural network model [16].",
            "cite_spans": [
                {
                    "start": 15,
                    "end": 17,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 2855,
                    "end": 2857,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Vocabulary GCN ::: Proposed Method",
            "ref_spans": []
        },
        {
            "text": "The graph nodes of GCN are \u201ctask entities\u201d such as documents that need to be classified. It requires all entities, including those from training set, validation set, and test set, to be presented in the graph, so that no node representation is missing in downstream tasks. This limits the application of GCN in many predictive tasks, where the test data is unseen during the training process.",
            "cite_spans": [],
            "section": "Vocabulary GCN ::: Proposed Method",
            "ref_spans": []
        },
        {
            "text": "In our case, we aim to convolve the related words instead of the documents in the corpus for classification. Therefore, the graph of our proposed GCN is constructed on the vocabulary instead of the documents. Thus, for a single document, assuming the document is a row vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{x}$$\\end{document} consisting of words in the vocabulary, a layer of convolution is defined in Eq. 3:3\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{h} = (\\tilde{A}\\varvec{x}^T)^TW=\\varvec{x}\\tilde{A}W, \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\tilde{A}^T=\\tilde{A}$$\\end{document} represent the vocabulary graph. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{x}\\tilde{A}$$\\end{document} extracts the part of vocabulary graph relevant to the input sentence \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{x}$$\\end{document}. W holds the weights of the hidden state vector for the single document, with dimension \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|V|\\times h$$\\end{document}. Then for m documents in a mini-batch, the one-layer graph convolution in Eq. 3 becomes:4\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} H = X\\tilde{A}W, \\end{aligned}$$\\end{document}and the corresponding 2-layer Vocabulary GCN with ReLU function is as follows:5\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathbf{VGCN} = \\text {ReLU}( X_{mv} \\tilde{A}_{vv} W_{vh}) W_{hc}, \\end{aligned}$$\\end{document}where m is the mini-batch size, v is the vocabulary size, h is the hidden layer size, c the class size or sentence embedding size. Every row of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X_{mv}$$\\end{document} is a vector containing document features, which can be a bag-of-words vector, or word embedding of BERT. The above equation aims to produce a layer of convolution of the graph, which captures the part of the graph relevant to the input (through \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X_{mv} \\tilde{A}_{vv}$$\\end{document}), then performs 2 layers of convolution, combining words from input sentence with their related words in vocabulary graph.",
            "cite_spans": [],
            "section": "Vocabulary GCN ::: Proposed Method",
            "ref_spans": []
        },
        {
            "text": "When BERT is applied to text classification, a typical solution contains three parts. The first part is the word embedding module with the position information of the word; the second part is the transformer module using multi-layer multi-head self-attention stacking; and the third part is the fully connected layer using the output sentence embedding for classification.",
            "cite_spans": [],
            "section": "Integrating VGCN into BERT ::: Proposed Method",
            "ref_spans": []
        },
        {
            "text": "Self-attention operates with a query Q against a key K and value V pair. The attention score is calculated as follows:6\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\text {Attention}(Q,K,V)=\\text {Softmax}\\left( \\frac{QK^T}{\\sqrt{d_k}}\\right) V, \\end{aligned}$$\\end{document}where the denominator is a scaling factor used to control the scale of the attention score, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$d_k$$\\end{document} is the dimension of the query and key vectors. Using these attention scores, every word can get a weighted vector representation encoding the contextual information.",
            "cite_spans": [],
            "section": "Integrating VGCN into BERT ::: Proposed Method",
            "ref_spans": []
        },
        {
            "text": "Instead of using only word embeddings of the input sentence in BERT, we feed both the vocabulary graph embedding obtained by Eq. 5 and the sequence of word embeddings to BERT transformer. This way, not only the order of the words in the sentence is retained, but also the background information obtained by VGCN is utilized. The overall VGCN-BERT model is schematically illustrated in Fig. 1. Through the attention score calculated by Eq. 6, local embedding and global embedding are fully integrated after layer-by-layer interaction in 12-layer and 12-heads self-attention encoder. The corresponding VGCN can then be formulated as:7\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathbf{G} _\\mathbf{embedding} = \\text { ReLU}( X_{mev} \\tilde{A}_{vv} W_{vh}) W_{hg}, \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W_{hg}$$\\end{document}, which was originally used for classification, becomes the output of size g of graph embedding (hyperparameter) whose dimension is the same as every word embedding; m is the size of the mini-batch; e is the dimension of word embedding, and v is the vocabulary size.",
            "cite_spans": [],
            "section": "Integrating VGCN into BERT ::: Proposed Method",
            "ref_spans": [
                {
                    "start": 390,
                    "end": 391,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "In addition to the original BERT model, we also use several other neural network models as baselines.",
            "cite_spans": [],
            "section": "Baselines ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "\nMLP: Multilayer perceptron with 2 hidden layers (512 and 100 nodes), and bag-of-words model with TF weighting.Bi-LSTM [11]: The BERT\u2019s pre-trained word embeddings are used as input to the Bi-LSTM model.Text GCN: The original Text GCN model uses the same input feature as MLP model, and we use the same training parameters as in [32].VGCN: This model only uses VGCN, corresponding to Eq. 7, but the output dimension becomes the class size. BERT\u2019s pre-trained word embeddings are used as input. The output of VGCN is relayed to a fully connected layer with Softmax function to produce the classification score. This model only uses the global information from vocabulary graph.BERT: We use the small version (Bert-base-uncased) pre-trained BERT [8].Vanilla-VGCN-BERT: Vanilla combination of BERT and VGCN is similar to [14], which produces two separate representations through BERT and GCN, and then concatenates them. ReLU and a fully connected layer are applied to the combined representation for classification. The main difference of this model with ours is that it does not allow interactions between the input text and the graph.\n",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 122,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 330,
                    "end": 332,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 745,
                    "end": 746,
                    "mention": "8",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 819,
                    "end": 821,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Baselines ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "We ran our experiments on the following five datasets:SST-2. The Stanford Sentiment Treebank is a binary single-sentence classification task consisting of sentences extracted from movie reviews with human annotations of their sentiment [24]. We use the public version2 which contains 6,920 examples in training set, 872 in validation set and 1,821 in test set, for a total of 4,963 positive reviews and 4,650 negative reviews. The average length of reviews is 19.3 words.MR is also a movie review dataset for binary sentiment classification, in which each review only contains one sentence [20]3. We used the public version in [26]4. It contains 5,331 positive and 5,331 negative reviews. The average length is 21.0 words.CoLA. The Corpus of Linguistic Acceptability is a binary single-sentence classification task. CoLA is manually annotated for acceptability (grammaticality) [29]. We use the public version which contains 8,551 training data and 1,043 ation data5, for a total of 6,744 positive and 2,850 negative cases. The average length is 7.7 words. Since we do not have the label for the test set, we split 5% of the training set as validation set and use the original validation set as the test set.ArangoHate [1] is a resampled dataset merging the datasets from [30] and [6]. It contains 2,920 hateful documents and 4,086 normal documents. The average length is 13.3 words. Since the dataset is not pre-divided into training, validation and test sets, we randomly split it into three sets at the ratio of 85:5:10.FountaHate is a large four-label dataset for hate speech and offensive language detection [9]. It contains 99,9966 tweets with cross-validated labels and is classified into 4 labels: normal (53,851), spam (14,030), hateful (27,150) and abusive (4,965). The average length is 15.7 words. Since the dataset is not pre-divided into training, validation and test sets, we split it into three sets at the ratio of 85:5:10 after shuffle.\n",
            "cite_spans": [
                {
                    "start": 237,
                    "end": 239,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 591,
                    "end": 593,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 628,
                    "end": 630,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 879,
                    "end": 881,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1220,
                    "end": 1221,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1273,
                    "end": 1275,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 1282,
                    "end": 1283,
                    "mention": "6",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 1614,
                    "end": 1615,
                    "mention": "9",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Datasets ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "We removed URL strings and @-mentions to retain the text content, then the text was lower-cased and tokenized using NLTK\u2019s TweetTokenizer7. We use BERTTokenizer function to split text, so that the vocabulary for GCN is always a subset of pre-trained BERT\u2019s vocabulary. When computing NPMI on a dataset, the whole sentence is used as the text window to build the vocabulary graph. The threshold of NPMI is set as 0.2 for all datasets to filter out non-meaningful relationships between words.",
            "cite_spans": [],
            "section": "Preprocessing and Setting ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "In the VGCN-BERT model, the graph embedding output size is set as 16, and the hidden dimension of graph embedding as 128. We use the Bert-base-uncased version of pre-trained BERT, and set the max sequence length as 200. The model is then trained in 9 epochs with a dropout rate of 0.2. The following are other parameter settings for different datasets.",
            "cite_spans": [],
            "section": "Preprocessing and Setting ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "\nSST-2: mini-batch = 16, learning rate = 1e\u22125, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_2$$\\end{document} loss weight decay = 0.01.CoLA and MR: mini-batch = 16, learn. rate = 8e\u22126, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_2$$\\end{document} loss decay = 0.01.ArangoHate: mini-batch = 16, learn. rate = 1e\u22125, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_2$$\\end{document} loss decay = 1e\u22123.FountaHate: mini-batch = 12, learn. rate = 4e\u22126, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_2$$\\end{document} loss decay = 2e\u22124.\n",
            "cite_spans": [],
            "section": "Preprocessing and Setting ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "These parameters are set based on our preliminary tests. We also use the default fine-tuning learning rate and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_2$$\\end{document} loss weight decay as in [8]. The baseline methods are set with the same parameters as in the original papers.",
            "cite_spans": [
                {
                    "start": 425,
                    "end": 426,
                    "mention": "8",
                    "ref_id": "BIBREF31"
                }
            ],
            "section": "Preprocessing and Setting ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "We use the cross-entropy as the loss function for all models, except for FountaHate dataset where we use the mean squared error as the loss function in order to leverage the annotators\u2019 voting information.",
            "cite_spans": [],
            "section": "Loss Function ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "We use Adam as training optimizer for all models. For cases where the label distributions are uneven (CoLA (2.4:1), ArangoHate (1.4:1) and FountaHate (10.9:5.5:2.8:1)), comput_class_weight function8 from scikit-learn [4] is used as the weighted loss function. The weight of each the classes (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W_c$$\\end{document}) is calculated by8\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} W_{classes}=\\frac{\\#dataset}{\\#classes\\cdot \\#every\\_class}, \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\#dataset$$\\end{document} is the total size of dataset and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\#classes$$\\end{document} is the number of classes and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\#every\\_class$$\\end{document} is the count of every class.",
            "cite_spans": [
                {
                    "start": 218,
                    "end": 219,
                    "mention": "4",
                    "ref_id": "BIBREF27"
                }
            ],
            "section": "Loss Function ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "We adopt the two most widely used metrics to evaluate the performance of the classifiers - the weighted average F1-score, and the macro F1-score [17].9\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathbf {Weighted \\ avg \\ F1} =\\sum _{i=1}^{C}F1_{c_i}*W_{c_i}, \\qquad \\mathbf {Macro \\ F1} =\\frac{1}{C}\\sum _{i=1}^{C}F1_{c_i} \\end{aligned}$$\\end{document}\n",
            "cite_spans": [
                {
                    "start": 146,
                    "end": 148,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Evaluation Metrics ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "The main results on weighted average F1-Score and macro F1-Score on test sets are presented in Table 1. The main observation is that VGCN-BERT outperforms all the baseline models (except against Vanilla-VGCN-BERT on MR dataset). In particular, it outperforms both VGCN and BERT alone, confirming the advantage to combine them.",
            "cite_spans": [],
            "section": "Experimental Result ::: Experiment",
            "ref_spans": [
                {
                    "start": 101,
                    "end": 102,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Among the models that only use local information, we see that BERT outperforms MLP, Bi-LSTM. Between the models that exploit a vocabulary graph - VGCN and Text-GCN, the performance is similar.",
            "cite_spans": [],
            "section": "Experimental Result ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "Vanilla-VGCN-BERT and VGCN-BERT are two models that combine local and global information. In general, these models perform better than the other baseline models. This result confirms the benefit of combining local information and global information.",
            "cite_spans": [],
            "section": "Experimental Result ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "Comparing VGCN-BERT with Vanilla-VGCN-BERT, we see that the former generally performs better. The difference is due to the interactions between local and global information. The superior performance of VGCN-BERT clearly shows the benefit of allowing interactions between the two types of information.",
            "cite_spans": [],
            "section": "Experimental Result ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "To better understand the behaviors of BERT, and its combination with VGCN, we visualize the attention distribution of the [CLS] token in the self-attention module of BERT, VGCN-BERT and Vanilla-VGCN-BERT models. As the vocabulary graph is embedded into vectors of 16 dimensions, it is not obvious to show what meaning corresponds to each dimension. To facilitate our understanding, we show the top two words from the sub-graph related to the input sentence, which are strongly connected to each of the 16 dimensions of graph embedding. More specifically, w each word embedding of a document is input to Eq. 7, we only need to broadcast the result of XA and element-multiply it by W to obtain the representation value of the words involved. The equation for obtain the involved words\u2019 id is as follow:10\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} Z&= (\\varvec{x}A)^T\\odot W, \\end{aligned}$$\\end{document}\n11\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\text {IDs involved}&=\\arg \\text {sort}(Z[:,g]), \\end{aligned}$$\\end{document}where x is a document in row vector, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g \\in [1,G]$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G=16$$\\end{document} is the size of graph embedding. For example, the first dimension of graph embedding shown in Fig. 2 corresponds roughly to the meaning of \u201c[boundary, innovations]\u201d.\n",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": [
                {
                    "start": 2233,
                    "end": 2234,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "In Fig. 2, we show the attention paid to each word (embedding) and each dimension of graph embedding (second part). As BERT does not use graph embedding, the attention paid to graph embedding is 0. In VGCN-BERT, we see that graph embedding draws an important part of attention.",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": [
                {
                    "start": 8,
                    "end": 9,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "For the movie review \u201cAlthough it\u2019s a bit smug and repetitive, this documentary engages your brain in a way few current films do.\u201d, the first half of the sentence is explicitly negative, while the remaining part expresses a positive attitude in an implicit way, which makes the sentence difficult to judge. For this example, BERT pays a very high attention to \u201cdo\u201d, and a quite high attention to \u201cthis\u201d. These words do not bear much meaning in sentiments. The final classification results by BERT is 0 (negative) while the true label is 1 (positive).",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "Vanilla-VGCN-BERT concatenates graph embedding with BERT without interaction between them. We can see that still no attention is paid to graph embedding, showing that such a simplistic combination cannot effectively leverage vocabulary information.",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "Finally, for VGCN-BERT, we see that a considerable part of attention is paid to graph embedding. The graph embedding is produced by integrating gradually the local information in the sentence with the global information in the graph. At the end, several dimensions of the graph embedding imply the meaning of \u201cinnovation\u201d, to which quite high attentions are paid. This results in classifying the sentence to the correct class (positive).",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "The meaning of \u201cinnovation\u201d is not produced immediately, but after a certain number of layers in BERT. In fact, through the layers of BERT, local information in the input sentence is combined to generate a higher level representation. In this example, at a certain layer, the expression \u201ca way few current films do\u201d is grouped and represented as an embedding similar to the meaning of \u201cinnovation\u201d. From then, the meaning related to \u201cinnovation\u201d in the graph embedding is capture through self-attention, and reinforced later on through interactions between the local and global information.",
            "cite_spans": [],
            "section": "Visualization ::: Experiment",
            "ref_spans": []
        },
        {
            "text": "In this study, we propose a new VGCN-BERT model to integrate a vocabulary graph embedding module with BERT. The goal is to complement the local information captured by BERT with the global information on the vocabulary, and allow both types of information to interact through the layers of attention mechanism. Our experiments on classification on 5 datasets show that the graph embedding does bring useful global information to BERT and this improves the performance. In comparison with BERT and VGCN alone, our model can clearly lead to better results, showing that VGCN-BERT can indeed take advantage of both mechanisms.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "As future work, we will consider using other types of vocabulary graph such as Wordnet, in addition to a graph created by co-occurrences. We believe that Wordnet contains useful connections between words that NPMI cannot cover. It is thus possible to combine several lexical resources into the vocabulary graph.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Weighted average F1-Score and (Macro F1-score) on the test sets. We run 5 times under the same preprocessing and random seed. Macro F1-score and Weighted F1-Score are the same on SST-2 and MR. Bold indicates the highest score and underline indicates the second highest score.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Illustration of VGCN-BERT. The embeddings of input sentence (Phase 1) are combined with the vocabulary graph (Phase 2) to produce a graph embedding, which is concatenated to the input sentence (Phase 3). Note that from the vocabulary graph, only the part relevant to the input is extracted and embedded. In Phase 4, several layers of self-attention are applied to the concatenated representation, allowing interactions between word embeddings and graph embedding. The final embedding at the last layer is fed in a fully connected layer (Phase 5) for classification.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Visualization of the attention that the token [CLS] (used as sentence embedding) pays to other tokens. The first part corresponds to word embeddings of the sentence. The second part is the graph embedding. [word1, word2] indicates the approximate meaning of a dimension in graph embedding.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Long short-term memory",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hochreiter",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schmidhuber",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Neural Comput.",
            "volume": "9",
            "issn": "8",
            "pages": "1735-1780",
            "other_ids": {
                "DOI": [
                    "10.1162/neco.1997.9.8.1735"
                ]
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Classification evaluation",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lever",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Krzywinski",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Altman",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Nat. Methods",
            "volume": "13",
            "issn": "8",
            "pages": "603-604",
            "other_ids": {
                "DOI": [
                    "10.1038/nmeth.3945"
                ]
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF27": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF28": {
            "title": "A comprehensive survey of graph embedding: problems, techniques and applications",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cai",
                    "suffix": ""
                },
                {
                    "first": "VW",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Chang",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE Trans. Knowl. Data Eng.",
            "volume": "30",
            "issn": "9",
            "pages": "1616-1637",
            "other_ids": {
                "DOI": [
                    "10.1109/TKDE.2018.2807452"
                ]
            }
        },
        "BIBREF29": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF30": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF31": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF32": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}