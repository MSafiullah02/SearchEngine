{
    "paper_id": "PMC7206258",
    "metadata": {
        "title": "Tree-Miner: Mining Sequential Patterns from SP-Tree",
        "authors": [
            {
                "first": "Hady",
                "middle": [
                    "W."
                ],
                "last": "Lauw",
                "suffix": "",
                "email": "hadywlauw@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Raymond",
                "middle": [
                    "Chi-Wing"
                ],
                "last": "Wong",
                "suffix": "",
                "email": "raywong@cse.ust.hk",
                "affiliation": {}
            },
            {
                "first": "Alexandros",
                "middle": [],
                "last": "Ntoulas",
                "suffix": "",
                "email": "antoulas@di.uoa.gr",
                "affiliation": {}
            },
            {
                "first": "Ee-Peng",
                "middle": [],
                "last": "Lim",
                "suffix": "",
                "email": "eplim@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "See-Kiong",
                "middle": [],
                "last": "Ng",
                "suffix": "",
                "email": "seekiong@nus.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Sinno",
                "middle": [
                    "Jialin"
                ],
                "last": "Pan",
                "suffix": "",
                "email": "sinnopan@ntu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Redwan",
                "middle": [
                    "Ahmed"
                ],
                "last": "Rizvee",
                "suffix": "",
                "email": "rizveeredwan.csedu@gmail.com",
                "affiliation": {}
            },
            {
                "first": "Mohammad",
                "middle": [
                    "Fahim"
                ],
                "last": "Arefin",
                "suffix": "",
                "email": "f.arefin8@gmail.com",
                "affiliation": {}
            },
            {
                "first": "Chowdhury",
                "middle": [
                    "Farhan"
                ],
                "last": "Ahmed",
                "suffix": "",
                "email": "farhan@du.ac.bd",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Pattern mining is a branch of data mining which encloses the tasks of discovering inherent, useful and interesting patterns in databases. Sequential pattern mining was proposed [1] to apply the pattern mining techniques on sequential or ordered data, where the interestingness of a pattern can be measured in terms of various criteria such as its occurrence frequency, length, profit etc. An example of a sequential pattern is \u201cCustomers who buy a digital camera are likely to buy a color printer within a month.\u201d If a data-sequence is comprised of a set of events, the problem is to find all sequential patterns with a user-specified minimum support, where the support of a sequential pattern is the percentage of data-sequences that contain the pattern [9]. For example, in the database of a retail superstore, each data sequence may correspond to the purchase history of a customer and each event represents the items bought in one purchase. A sequential pattern may be 10% customers bought \u2018Smartphone\u2019, followed by \u2018Screen Protector\u2019 and \u2018Powerbank\u2019. Hence, sequential pattern mining methods are popularly used to identify patterns which are generally used in making recommendation systems, text predictions, improving system usability or making informative product choice decisions.",
            "cite_spans": [
                {
                    "start": 178,
                    "end": 179,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 756,
                    "end": 757,
                    "mention": "9",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Due to its wide range of applications, numerous algorithms have been proposed to mine sequential patterns efficiently; most notably of two major classes- apriori based and pattern growth based. A typical apriori-like sequential pattern mining method, such as GSP [9], adopts a multiple-pass, candidate generation-and-test approach. But it is computationally expensive due to generation of huge set of candidates and multiple scan of the database which significantly reduces the performance in large and dense databases, specially in lower minimum support thresholds. On the other hand, pattern-growth based algorithms, which follow a divide and conquer approach are several times faster than the apriori algorithms. But there is still room for major improvement as these algorithms work by generating projected databases. Moreover, an efficient tree-based structure to store complete sequential databases is yet to be proposed, which could be useful in numerous cases like interactive pattern mining, sequential pattern mining in dynamic databases and applications with sliding window. Due to its numerous applications, mining sequential patterns in a parallel or distributed computing environment has also emerged as an important issue with many applications where tree alike structure could be useful.",
            "cite_spans": [
                {
                    "start": 264,
                    "end": 265,
                    "mention": "9",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Being motivated by this, we propose a tree based data structure SP-Tree and an algorithm, Tree-Miner to mine sequential patterns from it. Consequently, we demonstrate our algorithm\u2019s superiority compared to existing algorithms and highlight its versatility. Our main contributions in this paper are: A tree-structure, SP-Tree to store the database in an efficient manner with build once, mine many property.An efficient mining algorithm Tree-Miner to mine sequential patterns from SP-Tree.Multiple Pruning techniques and optimizations to reduce runtime along with the scope of extensibility and scalability.\n",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper, we provide a brief discussion regarding the existing literature in Sect. 2. In Sect. 3, we propose our SP-Tree data structure and our mining algorithm, Tree-Miner along with pruning mechanisms and optimization techniques. In Sect. 4 we demonstrate our algorithm\u2019s performance across various real life datasets and we draw conclusions in Sect. 5.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this section, we explore the preliminary terminologies and concepts related to our problem domain and a brief discussion regarding the existing literature.",
            "cite_spans": [],
            "section": "Terminologies and Background Study",
            "ref_spans": []
        },
        {
            "text": "Let there be a set of items\nI = \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i_1, i_2, . . . i_m$$\\end{document}. An itemset or event X is a set of items such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X \\subseteq I$$\\end{document}. A sequence\nS is a collection or list of itemsets with a certain order [1] and can be written as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${<}e_1$$\\end{document}\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_2$$\\end{document}\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_3$$\\end{document} ... \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_l{>}$$\\end{document}, where each event \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document} happens before event \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_j$$\\end{document} if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i \\,<\\,j$$\\end{document} and each event \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document} is a set of items. A sequence database\nSDB is a list of sequences. The support of a sequence \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s_a$$\\end{document} in SDB is defined as the number of sequences that contain \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s_a$$\\end{document} and is denoted by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf{sup} $$\\end{document}(\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s_a$$\\end{document}). A sequence s is said to be a frequent sequence or a sequential pattern if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sup(s) \\ge minsup$$\\end{document}, for a threshold minsup set by the user. So, given a SDB and a minsup, the problem of mining sequential patterns is, to generate all subsequences where each subsequence \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s_a$$\\end{document} has \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sup(s_a) \\ge minsup$$\\end{document}. If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} = <(ab)b> and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} = <(abc)(be)(de)c>, where a, b, c, d and e are items, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} is a subsequence of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document}.",
            "cite_spans": [
                {
                    "start": 759,
                    "end": 760,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Terminologies and Background Study",
            "ref_spans": []
        },
        {
            "text": "As mining sequential patterns is a very popular problem, numerous research works have addressed this. Different algorithms follow different strategies and data structures to search for sequential patterns efficiently. As a result, some algorithms are more efficient than others. GSP [9] and SPADE [11] are two prominent works which have addressed this problem. Both solutions are based on candidate generation and testing paradigm. Their main bottleneck is that they generate a huge amount of redundant candidates while performing multiple database scans.",
            "cite_spans": [
                {
                    "start": 284,
                    "end": 285,
                    "mention": "9",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 298,
                    "end": 300,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Terminologies and Background Study",
            "ref_spans": []
        },
        {
            "text": "PrefixSpan [7] is one of the benchmark algorithms for frequent sequence mining which adopts a divide and conquer technique. It expands a pattern by recursively creating smaller projected databases on each iteration. Main computation cost of prefixspan is basically the generation of projected databases. Another renowned algorithm to solve the problem of frequent sequential pattern mining is SPAM [2] which introduced the idea of depth first search based technique to generate patterns in the search space along with efficient pruning mechanisms. These four literature were the benchmark works which provided completely new techniques to address the problem. After these, several novel techniques were introduced which provided some tweaking over them to improve the basic algorithm\u2019s performance. FAST [8] improved the support count technique of SPAM [2] using sparse id list which was a modification of SPADE\u2019s [11] idea. Lapin [10] was another improvement over SPAM [2] which showed the importance of last event\u2019s items that how it can reduce the search space and improve performance. A very efficient structure co-occurrence map was proposed in [5] which provided new technique to prune search space in both SPADE [11] and SPAM [2]. In this paper, we propose a complete tree-based structure to represent the sequential database and a mining algorithm along with efficient pruning mechanisms and improvisations to efficiently mine sequential patterns. Main motivation behind this work is, a complete and compact structure provides huge assistance to handle both dynamic and stream database along with interactive mining. Our technique also provides a new dimension to approach the problem.",
            "cite_spans": [
                {
                    "start": 12,
                    "end": 13,
                    "mention": "7",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 399,
                    "end": 400,
                    "mention": "2",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 805,
                    "end": 806,
                    "mention": "8",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 854,
                    "end": 855,
                    "mention": "2",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 915,
                    "end": 917,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 932,
                    "end": 934,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 971,
                    "end": 972,
                    "mention": "2",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1151,
                    "end": 1152,
                    "mention": "5",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1220,
                    "end": 1222,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1234,
                    "end": 1235,
                    "mention": "2",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Terminologies and Background Study",
            "ref_spans": []
        },
        {
            "text": "Our proposed Sequential Pattern Tree or SP-Tree is a tree which will represent the sequential database(SDB) in an efficient manner. We will consider the SDB of Table 1 in this section for discussion. In each row of the Table 1 we have sequences with their IDs. Here, item set domain \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$I = \\{ \\text {a}, \\text {b}, \\text {c}, \\text {d}, \\text {e}, \\text {f}, \\text {g}\\}$$\\end{document} and for each sequence, items within curly braces form events. Now, we will explain the node structure of SP-Tree and the representative SP-tree of Table 1.\n",
            "cite_spans": [],
            "section": "SP-Tree ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 166,
                    "end": 167,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 225,
                    "end": 226,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 806,
                    "end": 807,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "SP-Tree ::: Proposed Approach",
            "ref_spans": []
        },
        {
            "text": "Node Structure of SP-Tree: Before diving into discussion we want to point out some important points. Each sequence\u2019s each event(set of items) should be lexicographically sorted and each item of each sequence have an event number which denotes the number of event in which this item appeared in the sequence. For example, in the first sequence of Table 1, first a\u2019s event number is 1, because it belongs to event number 1 of that sequence. Similarly, second a\u2019s event number is 2 because it appeared in event 2. So, embedded with event number first sequence can be seen as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a:1\\}\\{a:2,b:2,c:2\\}\\{a:3,c:3\\}\\{d:4\\}\\{c:5,f:5\\}\\rangle $$\\end{document}.\n\n",
            "cite_spans": [],
            "section": "SP-Tree ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 352,
                    "end": 353,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "\nLabel: Each node will represent an item and that item is the node\u2019s label.Event Number: Each node will also have an event number which represents the node\u2019s label/item\u2019s event number.Count: This number denotes how many times this node had been traversed during construction of the tree from sequences. This also denotes how many times this path(root up to this node) or prefix has been shared among the sequences. This attribute\u2019s value is important to calculate generated pattern\u2019s support.We have shown the complete SP-Tree of sample database of Table 1 in Fig. 2. In each node we have provided its label, count and event number. Red color values in each node is node number which we have used here for discussion purpose. At first we will have only root node. Then we will insert each sequence into the tree. For each sequence we put each item of the sequence of each event in the tree sequentially with their event number and label. We always start from the root and recursively put the items in the tree and traverse the tree. For each node, we check if we have child node from the current node for the item (with corresponding event number) we want to put. if we do not have that, then we create a node with item\u2019s label and event with count 1 and if we already have a child node then we just increase that node\u2019s count attribute\u2019s value. After creating or increasing the count value of the child node we go there and perform recursive process to put the next item of the transaction/sequence into the tree. The intermediate processes of inserting first three sequences/transactions are shown in Fig. 3 and the complete tree after inserting last sequence is shown in Fig. 2.Besides these three attributes we have two additional attributes.Next Link: Next links are essential to traverse in the tree faster and efficiently. For a node v, next links for an item it denotes the first node occurrences (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n_1,n_2,...n_k$$\\end{document}) in v\u2019s subtree in different branches for it. By moving through next links we can reach different nodes faster (Fig. 1) and generate patterns by connecting the node\u2019s labels. An example of next links for different items of node 1 is given in Fig. 4. Here to show next links for item a, b, c, d we used different colors for better visualization.Parent Info: Each node will store its parent nodes labels which are in the same event as it in the path from root to this node. This information is useful during mining to efficiently reduce search space. Now the best and compact way to store this information is using bitset. If we have domain knowledge, then we can number the items as 0,1,2,.. etc and make a bitset to store parent items. Like, in the SP-Tree of Fig. 4, node 4 needs to store label \u2018a\u2019(node 2\u2019s label) and \u2018b\u2019 (node 3\u2019s label), because they are in the same event as it(event 2), so if we number \u2018a\u2019 as 0, \u2018b\u2019 as 1, \u2018c\u2019 as 2 and \u2018d\u2019,\u2018e\u2019,\u2018f\u2019,\u2018g\u2019 respectively then node 4 will store \u201c11\u201d as its parent information (setting the bits of position 0 and 1 only). This bit based representation will give ease to perform bitwise operations which will improve runtime. The respective parent info for each node is shown in Fig. 2. \u201cnull\u201d means it does not have any parent item in same event. But our mining algorithm is also capable of handling other representations as well.\n\n",
            "cite_spans": [],
            "section": "SP-Tree ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 565,
                    "end": 566,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1608,
                    "end": 1609,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 1679,
                    "end": 1680,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 2323,
                    "end": 2324,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2453,
                    "end": 2454,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 2971,
                    "end": 2972,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 3437,
                    "end": 3438,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 555,
                    "end": 556,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Suppose we have a pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P= \\langle \\{\\alpha \\}\\{\\beta \\} \\rangle $$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} can be a single item or a set of items. During mining we extend a pattern in two ways, Sequence Extension (SE) and Itemset Extension (IE). SE is if we add an item A at the end of P as new event resulting in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{\\alpha \\}\\{\\beta \\}\\{A\\}\\rangle $$\\end{document} and IE is if we add an item A in the last event of P resulting in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{\\alpha \\}\\{\\beta A\\}\\rangle $$\\end{document}. Co-Existing Item Table is helpful to understand which items co-exist in the database either in different event or in same event. By definition of pattern extension items existing in different event perform SE and items existing in same event perform IE. This table is helpful to reduce search space by giving idea regarding the actual possible symbols to extend a sequence. We provide the Co-Existing Item Table of our database in Table 2. In Table 2 we have shown the co-existing items for our database Table 1 along with their frequency. Each transaction contributes only once for each combination (SE or IE). For SE part this table can be efficiently calculated using \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$next-links$$\\end{document} and for IE part this table can be calculated during insertion of the sequences in the tree. This idea was adopted in our methodology from [3, 5].\n",
            "cite_spans": [
                {
                    "start": 2980,
                    "end": 2981,
                    "mention": "3",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 2983,
                    "end": 2984,
                    "mention": "5",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Co-existing Item Table ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 2311,
                    "end": 2312,
                    "mention": "2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 2323,
                    "end": 2324,
                    "mention": "2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 2384,
                    "end": 2385,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "In this paper, we propose an efficient mining algorithm, Tree-Miner to generate patterns from SP-Tree. Tree-Miner is a recursive algorithm which concatenates the nodes of the SP-Tree and generates the sequential patterns by adding the node\u2019s labels using next links. This algorithm follows pattern expanding approach which means it starts with an empty sequence and gradually by traversing in the tree using next links it adds new symbols/items at the end of the sequence as SE or IE. The node\u2019s count attribute resolves the issue of pattern\u2019s support calculation. Now, we will talk about the important concepts of Tree-Miner about how patterns are explored.",
            "cite_spans": [],
            "section": "Tree-Miner: Mining Sequential Patterns from SP-Tree ::: Proposed Approach",
            "ref_spans": []
        },
        {
            "text": "Patterns Formation Rules: Node combinations from SP-Tree makes a pattern and from different subtrees the first node combinations are always chosen. For example from our SP-Tree of Fig. 2 pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\} \\rangle $$\\end{document} can be found in node 1, 18 and 25. These three nodes make pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\} \\rangle $$\\end{document} in 3 different subtrees. Node combination \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{1,3\\}$$\\end{document} forms pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\rangle $$\\end{document} in leftmost subtree, similarly node combination \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{1,12\\}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{18,23\\}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{25,28\\}$$\\end{document} forms pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\rangle $$\\end{document} in other three different subtrees and always the count attribute value of last node in each combination( here 3, 12, 23, 28) contributes to the pattern\u2019s frequency and here is 4. As, the first combination in different subtrees are always chosen it can be said that pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\rangle $$\\end{document} can be found by reaching node 3, 12, 23 and 28 and this will make the nodeList of pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\rangle $$\\end{document} from where next iteration of pattern expansion will begin for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\rangle $$\\end{document}.",
            "cite_spans": [],
            "section": "Tree-Miner: Mining Sequential Patterns from SP-Tree ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 185,
                    "end": 186,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Node Concatenation by Sequential Extension: Suppose, we have a pattern P and the nodeList of P is \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N=\\{n_i, n_j, n_k\\}$$\\end{document} which denotes where P ends in different subtrees(first occurrence). Suppose, we want to sequentially extend P as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P\\{\\alpha \\}$$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha \\in I$$\\end{document}, then for each node n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\in $$\\end{document}\nN we need to search in its subtree, the first nodes which have different event number with n(SE-Rule). That node will sequentially extend node n and for each n, the resultant nodes will make nodelist for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P\\{\\alpha \\}$$\\end{document}. Using next links we can perform recursive moves to find the desired nodes in the subtree. Like, in Fig. 2, for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\rangle $$\\end{document}\nnodeList = (3, 12, 23, 28). We want to make \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\{c\\}\\rangle $$\\end{document}. Node 3 using next link for c will reach first node 4 but it has same event number, so it will again move from node 4 using next link for c and will eventually reach node 6. Node 6 is the valid extension for node 3. The resultant nodeList for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\{b\\}\\{c\\}\\rangle $$\\end{document} is (6, 29) and support is 2.",
            "cite_spans": [],
            "section": "Tree-Miner: Mining Sequential Patterns from SP-Tree ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 2037,
                    "end": 2038,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Node Concatenation by Itemset Extension: Suppose we have a pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle P\\{Q\\}\\rangle $$\\end{document} where P can be a set of events or empty and Q a lexicographically sorted set of items and here the nodeList for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle P\\{Q\\}\\rangle $$\\end{document} is N=\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{n_i,n_j,n_k\\}$$\\end{document}. Now if we want to extend the pattern as IE to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle P\\{Q\\beta \\}\\rangle $$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} is an item and for any item q\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\in $$\\end{document}\nQ lexicographically \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} then for each node n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\in $$\\end{document}\nN we need to find the nodes in the subtree of n which will extend n as IE and will comprise nodeList of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{P\\}\\{Q\\beta \\}\\rangle $$\\end{document}. A node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} is extended by node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{j}$$\\end{document} as IE if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{j}$$\\end{document} in subtree of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} and both have same event number. There can be two cases for each n to find such node.",
            "cite_spans": [],
            "section": "Tree-Miner: Mining Sequential Patterns from SP-Tree ::: Proposed Approach",
            "ref_spans": []
        },
        {
            "text": "\nDirect Node: Using next link of n for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} we reach a node which have same event number as n. This node will directly expand n as IE. For example in Fig. 2, from node 18 (belonging to nodeList of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\}\\rangle $$\\end{document}) using next link for b we can directly reach node 19 which have same event number as 18. So it will extend node 18 as IE.Indirect Node: Using next link of n for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} if we reach a node which does not have same event number as n. In this case, we have to find the node k in the subtree of n which have all the items of Q as ancestor in the same event. For example, in Fig. 2, from node 1 (which belongs to nodeList of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{a\\} \\rangle $$\\end{document}) suppose we want to extend it as IE with b making a pattern \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{ab\\} \\rangle $$\\end{document}. Then first using next link b from 1, we will reach node 3, but node 3\u2019s event number is different from node 1. So, Direct Node connection is not possible meaning \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{1,3\\}$$\\end{document} does not make \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{ab\\} \\rangle $$\\end{document}. So, we search in the subtree of node 1 using recursive next link for b so that we can find such a node with label b which have a in same itemset. Interestingly in our case node 3 does the work having node 2 as same itemset with label a. So, ultimately node 3 belongs to the nodeList of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\langle \\{ab\\} \\rangle $$\\end{document}. In this purpose bitmask representation really becomes handy. By bitmasking with parent attribute value we will be able to get if this node has desired parent labels in same event.\n",
            "cite_spans": [],
            "section": "Tree-Miner: Mining Sequential Patterns from SP-Tree ::: Proposed Approach",
            "ref_spans": [
                {
                    "start": 442,
                    "end": 443,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1450,
                    "end": 1451,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "For each pattern P we always have a nodeList which denotes where the pattern ends and we always search for nodes in each subtree of each n in nodeList to extend a pattern through recursive next link moves. Besides nodeList for each pattern P there exists two lists sList and iList which says regarding the valid symbols which can perform SE and IE on P respectively. Initially this will be made from Co-Existing Item Table with symbols which will satisfy minsup. In each iteration this two lists will get pruned. There can be three types of pruning during pattern extension. They are - Co-existing Item Table Based Pruning: Suppose, we have a pattern P. Then we can add a symbol \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} with P as SE iff \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} occurs with each and every item of the last event of P\u2019s at least minsup times as sequence extending item. Similarly to extend P by adding \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} as IE, it must occur with each and every item of the last event of P as itemset extending symbols at least minsup times. If this condition satisfies then and only then we will perform node concatenation and measure actual candidacy by support counting.sList and iList Pruning: Suppose during pattern extension we have a pattern P and the corresponding nodeList, sList and iList. Suppose after node concatenation and measuring support we found that only \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sList'$$\\end{document}(\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\subseteq sList$$\\end{document}) and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$iList'(\\subseteq iList)$$\\end{document} can extend P as SE and IE respectively based on minsup. Then during recursive pattern expansion for each item A in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sList'$$\\end{document} we can extend P as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P\\{A\\}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sList'$$\\end{document} as new sList and new iList as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sList'$$\\end{document}-the items in the last event of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p\\{A\\}$$\\end{document}. Now for each item A in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$iList'$$\\end{document} we can extend P as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{PA\\}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$sList'$$\\end{document} as new sList and with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$iList'$$\\end{document}-A as new iList. This is a very popular pruning mechanism which we have adopted in our system.Heuristic iList Pruning: Suppose for a pattern P we have a nodeList, sList and iList and an item A where A is in both sList and iList. After node concatenation and support counting we found that A does not extend P as SE. Now during node concatenation the nodes which were first visited through next link for A from each node n in nodeList, if their count attribute\u2019s summation does not satisfy minsup then A can be pruned from iList. It works because count attribute value of any parent node is always \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\ge $$\\end{document} child node\u2019s count attribute. Due to having a tree like structure we could introduce this heuristic pruning technique.\n\n",
            "cite_spans": [],
            "section": "Tree-Miner: Mining Sequential Patterns from SP-Tree ::: Proposed Approach",
            "ref_spans": []
        },
        {
            "text": "To evaluate the performance of Tree-Miner based on SP-Tree, we conducted several experiments on a 64 bit machine having intel Core i7-3770 CPU @ 3.40 GHz \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\times $$\\end{document} 8, 8 GB RAM and Linux 16.04 Operating System. We analyze the performance with respect to runtime, memory consumption and structure construction time. To compare in run time and memory we will evaluate our performance against three state-of-the-art algorithms PrefixSpan, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$CM\\text {-}SPADE$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$CM\\text {-}SPAM$$\\end{document}. We have conducted our performance on various real life and synthetic datasets and among them we will show the results in the datasets of Table 3. In other datasets our performance were quite similar. We have conducted our approach\u2019s performance in both sparse and dense datasets and observed comparatively better results. If for a dataset \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\frac{\\text {avg seq. length}}{\\text {number of unique items}} \\ge 19\\%$$\\end{document}, we considered it as dense.\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": [
                {
                    "start": 1469,
                    "end": 1470,
                    "mention": "3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "From the runtime analysis of Fig. 5, we can see that, our approach performs comparatively better than other state-of-the-art algorithms while it outperforms Prefixspan to a huge extent while CM-SPADE and CM-SPAM with comparatively closer but significant amount. Main superiority of our approach is, through next link it reduces the search space faster and efficiently and it does not need to generate any projected database and it also does not need any other structure to calculate the support of a pattern rather than only SP-Tree nodes. Our SP-Tree has two important characteristics, one is prefix sharing and another one is next link which we have already mentioned. Through prefix sharing it improves the performance in dense datasets specially while through next link it can move in the tree efficiently specially improving performance in sparse datasets. Besides bit based representation during itemset extension as parent item info also improves performance. In lower thresholds, performance gap is better compared to higher thresholds. Because in lower thresholds we have a significant search space and our approach can traverse in them with better efficiency while in higher thresholds search space gets reduced for each algorithm and so, though ours better but no so differentiable due to time reduction.\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": [
                {
                    "start": 34,
                    "end": 35,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "As, we provide a structure SP-Tree to represent the sequential database, definitely it will need a memory for that. Besides we use a Co-Existing Item Table to prune search space. These two are the most vital factors which consume the memory usage in our approach. From experiments, we found that our approach takes slightly more memory compared to CM-SPADE and CM-SPAM but less memory compared to Prefixspan, mainly because we do not need to generate any projected databases and pattern\u2019s support count measure also does not need any other structure except SP-Tree nodes. But considering runtime improvement this should be considerable. We have shown the comparison of memory usage in FIFA dataset in Fig. 6, in other datasets performance were quite similar. Another important point to note that these structures can be built only once on the complete database and can be used for mining at various minsup. So, our solution can be very useful for interactive mining. For the sake of comparison, in Fig. 5 we constructed the tree and table each time from scratch considering the minsup and then compared with other algorithms (because they were not interactive algorithms) and found comparatively better results. So, if we had saved the complete structure and mined then definitely performance improvements would have been even more significant. Besides from Table 4 we can see that construction time(tree and table) is insignificant compared to mining time. So, if we need to mine the same database in various thresholds or in lower thresholds our solution is quite impressive. Main challenges behind a tree based structure was how to represent the items within same event in an efficient manner and distinguish during mining. Our SP-Tree and Tree-Miner algorithm provides a novel solution in this regard.",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": [
                {
                    "start": 706,
                    "end": 707,
                    "mention": "6",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 1003,
                    "end": 1004,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1364,
                    "end": 1365,
                    "mention": "4",
                    "ref_id": "TABREF3"
                }
            ]
        },
        {
            "text": "In this paper, we presented a tree based data structure, SP-Tree to store sequential databases and a new mining algorithm Tree-Miner to mine sequential patterns efficiently from the tree. We have also utilized the idea of Co-Existing Item Table to reduce search space and various pruning mechanisms for pattern expansion phase to improve runtime along with improvisations. We have also demonstrated our mining algorithm\u2019s superior performance against various state-of-the-art approaches along with other important metrics performance in experimental analysis section. As our solution is a tree based approach and maintains the build once mine many property, it has significant advantage to approach problems regarding interactive mining along with dynamic databases and sliding window based problems. In this paper, we proposed the tree structure and basic mining technique to discover sequential patterns and we plan to extend this solution to solve challenges of dynamic sequential databases and problems regarding sliding window. Besides, another advantage of tree based solution is having a structured way to handle all the data by its branches, subtrees etc. which can be used in numerous branches of pattern mining including multilevel, multidimensional and parallel or distributed sequential pattern mining.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Sequential database\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Co-existing item table of sample database\n",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3.: Dataset description\n",
            "type": "table"
        },
        "TABREF3": {
            "text": "Table 4.: Construction time vs mining time\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Recursive next link move",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: SP-Tree of Table 1",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Intermediate processes of constructing SP-Tree",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: Next links for node 1",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fig. 5.: Runtime comparison with various minsup",
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Fig. 6.: Memory comparison",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "LAPIN: effective sequential pattern mining algorithms by last position induction for dense databases",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kitsuregawa",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Advances in Databases: Concepts, Systems and Applications",
            "volume": "",
            "issn": "",
            "pages": "1020-1023",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "Spade: an efficient algorithm for mining frequent sequences",
            "authors": [
                {
                    "first": "MJ",
                    "middle": [],
                    "last": "Zaki",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Mach. Learn.",
            "volume": "42",
            "issn": "1\u20132",
            "pages": "31-60",
            "other_ids": {
                "DOI": [
                    "10.1023/A:1007652502315"
                ]
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Fast vertical mining of sequential patterns using co-occurrence information",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fournier-Viger",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gomariz",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Campos",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thomas",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Advances in Knowledge Discovery and Data Mining",
            "volume": "",
            "issn": "",
            "pages": "40-52",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "The SPMF open-source data mining library version 2",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fournier-Viger",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Machine Learning and Knowledge Discovery in Databases",
            "volume": "",
            "issn": "",
            "pages": "36-40",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "A survey of sequential pattern mining",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fournier-Viger",
                    "suffix": ""
                },
                {
                    "first": "JCW",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "RU",
                    "middle": [],
                    "last": "Kiran",
                    "suffix": ""
                },
                {
                    "first": "YS",
                    "middle": [],
                    "last": "Koh",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Thomas",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Data Sci. Pattern Recognit.",
            "volume": "1",
            "issn": "1",
            "pages": "54-77",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "Finding flexible patterns in unaligned protein sequences",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Jonassen",
                    "suffix": ""
                },
                {
                    "first": "JF",
                    "middle": [],
                    "last": "Collins",
                    "suffix": ""
                },
                {
                    "first": "DG",
                    "middle": [],
                    "last": "Higgins",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Protein Sci.",
            "volume": "4",
            "issn": "8",
            "pages": "1587-1595",
            "other_ids": {
                "DOI": [
                    "10.1002/pro.5560040817"
                ]
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "FAST sequence mining based on sparse id-lists",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Salvemini",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Fumarola",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Malerba",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Han",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Foundations of Intelligent Systems",
            "volume": "",
            "issn": "",
            "pages": "316-325",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Mining sequential patterns: generalizations and performance improvements",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Srikant",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Agrawal",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Advances in Database Technology \u2014 EDBT \u201996",
            "volume": "",
            "issn": "",
            "pages": "1-17",
            "other_ids": {
                "DOI": []
            }
        }
    }
}