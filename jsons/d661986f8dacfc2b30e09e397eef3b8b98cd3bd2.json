{
    "paper_id": "d661986f8dacfc2b30e09e397eef3b8b98cd3bd2",
    "metadata": {
        "title": "Code Action Network for Binary Function Scope Identification",
        "authors": [
            {
                "first": "Van",
                "middle": [],
                "last": "Nguyen",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Monash University",
                    "location": {
                        "settlement": "Clayton",
                        "country": "Australia"
                    }
                },
                "email": "van.nk@monash.edu"
            },
            {
                "first": "Trung",
                "middle": [],
                "last": "Le",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Monash University",
                    "location": {
                        "settlement": "Clayton",
                        "country": "Australia"
                    }
                },
                "email": "trunglm@monash.edu"
            },
            {
                "first": "Tue",
                "middle": [],
                "last": "Le",
                "suffix": "",
                "affiliation": {
                    "laboratory": "AI Research Lab, Trusting Social",
                    "institution": "",
                    "location": {
                        "settlement": "Melbourne",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Khanh",
                "middle": [],
                "last": "Nguyen",
                "suffix": "",
                "affiliation": {
                    "laboratory": "AI Research Lab, Trusting Social",
                    "institution": "",
                    "location": {
                        "settlement": "Melbourne",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Olivier",
                "middle": [],
                "last": "De Vel",
                "suffix": "",
                "affiliation": {},
                "email": "olivier.devel@dst.defence.gov.au"
            },
            {
                "first": "Paul",
                "middle": [],
                "last": "Montague",
                "suffix": "",
                "affiliation": {},
                "email": "paul.montague@dst.defence.gov.au"
            },
            {
                "first": "John",
                "middle": [],
                "last": "Grundy",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Monash University",
                    "location": {
                        "settlement": "Clayton",
                        "country": "Australia"
                    }
                },
                "email": "john.grundy@monash.edu"
            },
            {
                "first": "Dinh",
                "middle": [],
                "last": "Phung",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Monash University",
                    "location": {
                        "settlement": "Clayton",
                        "country": "Australia"
                    }
                },
                "email": "dinh.phung@monash.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "Function identification is a preliminary step in binary analysis for many applications from malware detection, common vulnerability detection and binary instrumentation to name a few. In this paper, we propose the Code Action Network (CAN) whose key idea is to encode the task of function scope identification to a sequence of three action states NI (i.e., next inclusion), NE (i.e., next exclusion), and FE (i.e., function end) to efficiently and effectively tackle function scope identification, the hardest and most crucial task in function identification. A bidirectional Recurrent Neural Network is trained to match binary programs with their sequence of action states. To work out function scopes in a binary, this binary is first fed to a trained CAN to output its sequence of action states which can be further decoded to know the function scopes in the binary. We undertake extensive experiments to compare our proposed method with other state-of-the-art baselines. Experimental results demonstrate that our proposed method outperforms the state-of-the-art baselines in terms of predictive performance on real-world datasets which include binaries from well-known libraries.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "In computer security, we often encounter situations where source code is not available or impossible to access and only binaries are accessible. In these situations, binary analysis is an essential tool enabling many applications such as malware detection, common vulnerability detection [9] , and etc. Function identification is usually the first step in many binary analysis methods. This aims to specify function scopes in a binary and is a building block to a diverse range of application domains including binary instrumentation [5] , vulnerability research [10] and binary protection structures with Control-Flow Integrity. In both binary analysis and function identification, tackling the loss of high-level semantic structures in binaries which results from compilers during the process of compilation is likely the most challenging problem.",
            "cite_spans": [
                {
                    "start": 288,
                    "end": 291,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 534,
                    "end": 537,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 563,
                    "end": 567,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "There have been many effective methods for dealing with the function identification problem from heuristic solutions (statistical methods for binary analysis) to complicated approaches employing machine learning or deep learning techniques. In an early work, Kruegel et al. [4] through his research which leveraged statistical methods with control flow graphs concluded that the task of function start identification can be trivially solved for regular binaries. However, later research in [14] argued that this task is non-trivial and complex in some specific cases wherein it is too challenging for heuristics-based methods to discover all function boundaries. Other influential works and tools that rely on signature database and structural graphs include IDA Pro, Dyninst, (Binary Analysis Platform) BAP, and Nucleus [1] . Andriesse et al. [1] has recently proposed a new signature-less approach to function detection for stripped binaries named Nucleus which is based on structural Control Flow Graph analysis. More specifically, Nucleus identifies functions in the intraprocedural control flow graph (ICFG) by analyzing the control flow between basic blocks, based on the observation that intraprocedural control flow tends to use different types and patterns of control flow instructions than inter-procedural control flow.",
            "cite_spans": [
                {
                    "start": 274,
                    "end": 277,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 490,
                    "end": 494,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 821,
                    "end": 824,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 844,
                    "end": 847,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Machine learning has been applied to binary analysis and function identification in particular. The seminal work of [11] modeled function start identification as a Conditional Random Field (CRF) in which binary offsets and a number of selected patterns appear in the CRF. Since the inference on a CRF is very expensive, though feature selection and approximate inference were adopted to speed up this model, its computational complexity is still very high. ByteWeight [2] is another successful machine learning based method for function identification aiming to learn signatures for function starts using a weighted prefix tree, and recognizes function starts by matching binary fragments with the signatures. Each node in the tree corresponds to either a byte or an instruction, with the path from the root node to any given node representing a possible sequence of bytes or instructions. Although ByteWeight significantly outperformed disassembler approaches such as IDA Pro, Dyninst and Binary Analysis Platform (BAP), it is not scalable enough for even medium-sized datasets [12] .",
            "cite_spans": [
                {
                    "start": 116,
                    "end": 120,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 468,
                    "end": 471,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1079,
                    "end": 1083,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Deep learning has undergone a renaissance in the past few years, achieving breakthrough results in multiple application domains such as visual object recognition [3] , language modeling [13] , and software vulnerability detection [6] [7] [8] . The study in [12] is the first work which applied a deep learning technique for the function identification problem. In particular, a bidirectional Recurrent Neural Network (Bidirectional RNN) was used to identify whether a byte is a start point (or end point) of a function or not. This method was proven to outperform ByteWeight [2] while requiring much less training time. However, to address the boundary identification problem with [12] , a simple heuristic to pair adjacent function starts and function ends was used (see Section 5.3 in that paper). Consequently, this approach is not able to efficiently utilize the context information of consecutive bytes and machine instructions in a function and the pairing procedure might lead to inconsistency since the networks for function start and end were trained independently. Furthermore, this method cannot address the function scope identification problem, the hardest and most essential sub problem in function identification, wherein the scope (i.e., the addresses of all machine instructions in a function) of each function must be specified.",
            "cite_spans": [
                {
                    "start": 162,
                    "end": 165,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 186,
                    "end": 190,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 230,
                    "end": 233,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 234,
                    "end": 237,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 238,
                    "end": 241,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 257,
                    "end": 261,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 575,
                    "end": 578,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 681,
                    "end": 685,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Inspired from the idea of a Turing machine, we imagine a memory tape consisting of many cells on which machine instructions of a binary are stored. The head is first pointed to the first machine instruction located in the first cell. Each machine instruction is assigned to an action state in the action state set {NI, NE, FE} depending on its nature. After reading the current machine instruction and assigning the corresponding action state to it, the head is moved to the next cell and this procedure is halted as we reach the last cell in the tape (see Sect. 3.1). Eventually, the sequence of machine instructions in a given binary is translated to the corresponding sequence of action states. Based on this incentive, in this paper, we propose a novel method named the Code Action Network (CAN) whose underlying idea is to equivalently transform the task of function scope identification to learning a sequence of action states. A bidirectional Recurrent Neural Network is trained to match binary programs with their corresponding sequences of action states. To predict function scopes in any binary, the binary is first fed to a trained CAN to output its corresponding sequence of action states on which we can then work out function scopes in the binary. The proposed CAN can tackle binaries for which there exist external gaps between functions and internal gaps inside functions wherein each internal gap in a function does not contain instructions from other functions. By default, our CAN named as CAN-B operates at the byte level and can cope with all binaries that satisfy the aforementioned condition. However, for the binaries that can be further disassembled into machine instructions, another variant named as CAN-M is able to operate at the machine instruction level. CAN-M can efficiently exploit the semantic relationship among bytes in an instruction and instructions in a function as well as requiring much shorter sequence length compared with the Bidirectional RNN in [12] which also works at the byte level. In addition, our proposed CAN-B and CAN-M can directly address the function scope identification task, hence inherently offering the solution for other simpler tasks including the function start/end/boundary identifications.",
            "cite_spans": [
                {
                    "start": 1992,
                    "end": 1996,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We undertake extensive experiments to compare our proposed CAN-B and CAN-M with state-of-the-art methods including IDA, the Bidirectional RNN, ByteWeight no-RFCR and ByteWeight on the dataset used in [2, 12] . The experimental results show that our proposed CAN-B and CAN-M outperform the baselines on function start, function end and function boundary identification tasks as well as achieving very good performance on function scope identification and also surpass the Nucleus [1] on this task. Our proposed methods slightly outperform the Bidirectional RNN proposed in [12] on the function start and end identification tasks, but significantly surpass this method on the function boundary identification task -the more important task. This demonstrates the capacity of our methods in efficiently utilizing the contextual relationship carried in consecutive machine instructions or bytes to properly match the function start and end entries for this task. As expected, our CAN-M obtains the best predictive performances on most experiments and is much faster than the Bidirectional RNN proposed in [12] . Particularly, CAN-M takes about 1 hour for training with 20,000 iterations which is nearly 4 times faster than the Bidirectional RNN proposed in [12] using the same number of iterations for training and the same number of bytes for handling input. This is due to the fact that CAN-M operates at the machine instruction level, while the Bidirectional RNN proposed in [12] operates at the byte level.",
            "cite_spans": [
                {
                    "start": 200,
                    "end": 203,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 204,
                    "end": 207,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 572,
                    "end": 576,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1100,
                    "end": 1104,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1252,
                    "end": 1256,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1473,
                    "end": 1477,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We also do error analysis to qualitatively compare our CAN-M and CAN-B with the baselines. We observe that there are a variety of instruction styles for the function start and function end (e.g., in the experimental dataset, there are a thousand different function start styles and function end styles). In their error analyses, Shin et al. [12] and Bao et al. [2] mentioned that for functions which encompass several function start styles or function end styles, their proposed methods tend to make mistakes in predicting the function start or end bytes with many false positives and negatives. However, it is not the case for our proposed methods, since we further observe that for the functions which contain more than one function start style or function end style which account for 98.38% and 28% of the testing set respectively, our proposed CAN-M has 0.24% and 1.09% false positive rates respectively.",
            "cite_spans": [
                {
                    "start": 341,
                    "end": 345,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 361,
                    "end": 364,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This section discusses the function identification problem. We begin with definitions of the sub problems in the function identification problem, followed by an example of source code in the C language and its binaries compiled with optimization levels O1 using gcc on the Linux platform for the x86-64 architecture.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Function Identification Problem"
        },
        {
            "text": "Given a binary program P , our task is to identify the necessary information (e.g., function starts, function ends) in its n functions {f 1 , ..., f n } which is initially unknown. Depending on the nature of information we need from {f 1 , ..., f n }, we can categorize the task of function identification into the following such problems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Definitions"
        },
        {
            "text": "In the first problem, we need to specify the set S = {s 1 , ..., s n } which contains the start instruction byte for each of the corresponding functions in {f 1 , ..., f n }. If a function (e.g. f i ) has multiple start points, s i will be the first start instruction byte for f i . In the second problem, we need to identify the set E = {e 1 , ..., e n } which contains the end instruction byte for each of the corresponding functions in {f 1 , ..., f n }. If a function (e.g. f i ) has multiple exit points, e i will be the last end instruction byte for f i . In the last problem, we have to point out the set of (start, end) pairs SE = {(s 1 , e 1 ) , ..., (s n , e n )} which contains the pairs of the function start and the function end for each of the corresponding functions in {f 1 , ..., f n }.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Function Start/End/boundary Identification."
        },
        {
            "text": "Function Scope Identification. This is the hardest problem in the function identification task. In this problem, we need to find out the set {(f 1,s1 , ..., f 1,e1 ) , ..., (f n,sn , ..., f n,en )} which specifies the instruction bytes in each function f 1 , ..., f n in the given binary program P . Here we note that because functions may be not contiguous, the instruction bytes (f i,si , ..., f i,ei ) may also be not contiguous. It is apparent that the solution of this problem covers the three aforementioned problems. Since our proposed CAN addresses this problem, it inherently offers solutions for the other problems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Function Start/End/boundary Identification."
        },
        {
            "text": "In Fig. 1 , we show an example of a short source code fragment for a function in the C programming language, the corresponding assembly code in the machine instruction and corresponding hexadecimal mode of the binary code respectively, which was compiled using gcc with the optimization level O1 for the x86-64 architecture on the Linux platform. We further observe that in real binary code, the patterns for the entry point vary over a wide range and can start with push, mov, movsx, inc, cmp, or, and, etc. In the example, the assembly code corresponding with the optimization level O1 on Linux has three ret statements. Furthermore, in real binary code, the ending point of a function can vary in pattern beside the ret pattern. These make the task of function identification very challenging. For the challenges of the function scope identification task, we refer the readers to [2, 12] and the discussions therein. ",
            "cite_spans": [
                {
                    "start": 883,
                    "end": 886,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 887,
                    "end": 890,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 9,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Running Example"
        },
        {
            "text": "In what follows, we present the key idea of our CAN. In a binary, there are external gaps between functions as well as internal gaps inside a non-contiguous function. The external gaps might contain data, jump tables or padding-instruction bytes which do not belong to any function (e.g., additional instructions generated by a compiler such as nop, int3). The internal gaps in general might contain data, jump tables or instructions from other functions (e.g., nested functions). We further assume that the internal gaps do not contain any instruction from other functions. It means that if there exist functions nested in a function, our CAN ignores these internal functions. However, we believe that the nested functions are extremely rare in real-world binaries. For example, in the experimental dataset, we observe that there are only 506 nested functions over the total of 757,125 functions (i.e., the occurrence rate is 0.067%).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Key Idea"
        },
        {
            "text": "The key idea of CAN is to encode the task of function scope identification to a sequence of three action states NI (i.e., next inclusion), NE (i.e., next exclusion), and FE (i.e., function end). With the aforementioned assumption, the binaries of interest consist of several functions and the functions in a binary do not intermingle, that is, each function only contains its machine instructions, data, or jump-tables and do not contain any machine instruction of other functions. Each function can be therefore viewed as a collection of bytes where each byte is from a machine instruction of this function (i.e., instruction byte) or data/jumptables inside this function (i.e., non-instruction byte). To clarify how to proceed over a binary function given a sequence of action states, let us imagine this Each output value takes one of three action states NI, NE, or FE. The Code Action Network will learn to map the input sequences of items (i1, i2, ..., i l ) to the target output sequence (y1, y2, ..., y l ) with the loss Li at each time step t. The h represents for the forward-propagated hidden state (toward the right) while the g stands for the backward-propagated hidden state (toward the left). At each time step t, the predicted output ot can benefit from the relevant information of the past from its h and the future from its g.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Key Idea"
        },
        {
            "text": "binary program including many instruction and non-instruction bytes as a tape of many cells wherein each cell contains a instruction or non-instruction byte and a pointer firstly points to the first cell in the tape. The action state NI includes the current instruction or non-instruction byte in the current cell to the current function and moves the pointer to the next cell (i.e., the next instruction or non-instruction byte). The action state NE excludes the current instruction or non-instruction byte in the current cell from the current function and moves the pointer to the next cell. The action state FE counts the current instruction or non-instruction byte in the current cell, ends the current function, starts reading a new function, and moves the pointer to the next cell.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Key Idea"
        },
        {
            "text": "To further explain how to transform a binary program to a sequence of action states, we consider an example binary code depicted in Fig. 2 (the left-hand  figure) . Assume that we have a sequence of instruction and non-instruction bytes, which belong to Function 1, Function 2 and Function 3, respectively where the functions may be not contiguous and there exist gaps between the functions (e.g., the gap between Function 1 and Function 2 includes the padding-instruction byte (pad-ins-byte) G2 and the non-instruction (non-ins-byte) byte G3). The pointer of CAN firstly points to G1, labels this padding-instruction byte (padins-byte) as NE since G1 does not belong to any function, and moves to the instruction byte F11. The instruction byte F11 is labeled as NI since it belongs to the function Function 1. The pointer then moves to the non-instruction byte F12 which can come from a jump-table or data and labels it as NE because F12 does not belong to any function. After that, the pointer moves to the instruction byte F13 and the non-instruction byte F14 subsequently. F13 and F14 are then labeled as NI and NE respectively since F13 belong to the function Function 1 while F14 does not belong to any function, and the pointer moves to the instruction byte F15 and labels it as FE since it is the end of the function Function 1 and we need to start reading the new function (i.e., the function Function 2 ). The pointer subsequently moves to the instruction byte G2 and the non-instruction G3 which can come from a jump-table or data and labels them as NE since they do not belong to any function. The pointer then traverses across the instruction bytes F21, F22, F23 and labels them as NI, NI, FE. The pointer now starts reading the new function (i.e., the function Function 3 ). This process is repeated until the pointer reaches the last instruction or non-instruction byte and we eventually identify all functions.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 132,
                    "end": 162,
                    "text": "Fig. 2 (the left-hand  figure)",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Key Idea"
        },
        {
            "text": "It is worth noting that if binaries can be disassembled and a function in these binaries can be thus viewed as a collection of instructions and non-instructions, we can perform the aforementioned idea at the machine instruction level wherein each cell in the tape represents an instruction or non-instruction of a binary. The advantages of performing the task of function identification at the machine instruction level include: i) the sequence length of the bidirectional RNN is significantly reduced and ii) the semantic relationship among bytes in a machine instruction and machine instructions can be further exploited. As a consequence, the gradient exploding and vanishing which often occur with long RNNs can be avoided and the model is easier to train while obtaining higher predictive performance and much shorter training times as shown in our experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Key Idea"
        },
        {
            "text": "Byte Level and Machine Instruction Level. To process data for the byte level, we simply take the raw bytes in the text segment of the given binary and input them to CAN-B. To process data for the machine instruction level, we first use Capstone 1 to disassemble the binaries and preprocess the machine instructions obtained from the text segment of a binary before inputting them to CAN-M. This preprocessing step aims to work out fixed length inputs from machine instructions. For each machine instruction, we employ Capstone to detect entire machine instructions, then eliminate redundant prefixes to obtain core parts that contain the opcode and other significant information (see our Supplementary Material for details, available at https://app.box.com/s/iq9u8r).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preprocess Input Statement"
        },
        {
            "text": "Training Procedure. The Code Action Network (CAN) is a multicell bidirectional RNN whose architecture is depicted in Fig. 2 (the right-hand figure) where we assume the number of cells over the input is 2. Our CAN takes a binary program B = (i 1 , i 2 , . . . , i l ) including l instructions (non-instructions) for CAN-M or instruction bytes (non-instruction bytes) for CAN-B and learns to output the corresponding sequence of action states Y = (y 1 , y 2 , ..., y l ) where each y k takes one of three action states NI (i.e., y k = 1), NE (i.e., y k = 2), or FE (i.e., y k = 3). The computational process of CAN is as follows:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 117,
                    "end": 147,
                    "text": "Fig. 2 (the right-hand figure)",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Code Action Network Architecture"
        },
        {
            "text": "where k = 1, ...l, h 1 0 , h 2 0 , g 1 l+1 = g 1 0 , g 2 l+1 = g 2 0 are initial hidden states and \u03b8 = (U, V, W, H, G, R, S) is the model. We further note that p k , k = 1, . . . , l is a discrete distribution over the three labels NI, NE, and FE.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Code Action Network Architecture"
        },
        {
            "text": "To find the best model \u03b8 * , we need to solve the following optimization problem: max where p(y k | o k ) is the y k -th element of the discrete distribution p k or in other words, we have p(y k | o k ) = p k,y k .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Code Action Network Architecture"
        },
        {
            "text": "In what follows, we present how to work out the function scopes in a binary using a trained CAN. The machine instructions/noninstructions for CAN-M or instruction/non-instruction bytes for CAN-B in the testing binary are fed to the trained model to work out the predicted sequence of action states. This predicted sequence of action states is then decoded to the function scopes inside the binary. As shown in Fig. 3 , the binary in Fig. 2 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 410,
                    "end": 416,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 433,
                    "end": 439,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Testing Procedure."
        },
        {
            "text": "In this section, firstly, we present the experimental results of our proposed Code Action Network for the machine instruction level (CAN-M) and the byte level (CAN-B) compared with other baselines including IDA, ByteWeight (BW) no-RFCR, ByteWeight (BW) [2] , the Bidirectional RNN (BRNN) [12] and Nucleus [1] . Secondly, we perform error analysis to qualitatively investigate our proposed methods. We also investigate the model behaviour of our CAN-M with various RNN cells and with different size for hidden states (see in our Supplementary Material, available at https://app.box.com/s/iq9u8r).",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 256,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 288,
                    "end": 292,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 305,
                    "end": 308,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Experiments"
        },
        {
            "text": "We used the dataset from [2, 12] , which consists of 2,200 different binaries including 2,064 binaries obtained from the findutils, binutils, and coreutils packages and compiled with both icc and gcc for Linux at four optimization levels O0, O1, O2, and O3. The remaining binaries for Windows are from various well-known open-source projects which were compiled with Microsoft Visual Studio for the x86 (32 bit) and the x86-64 (64 bit) architectures at four optimization levels Od, O1, O2, and Ox.",
            "cite_spans": [
                {
                    "start": 25,
                    "end": 28,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 29,
                    "end": 32,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Dataset"
        },
        {
            "text": "We divided the binaries into three random parts; the first part contains 80% of the binaries used for training, the second part contains 10% of the binaries used for testing, and the third part contains 10% of the binaries for validation. For CAN-M, we used a sequence of 250 hidden states for the x86 architecture and 125 hidden states for the x86-64 architecture where the size of hidden states is 256. For CAN-B, akin to the Bidirectional RNN in [12] , we used a sequence length of 1,000 hidden states for the x86 and x86-64 architectures. We employed the Adam optimizer with the default learning rate 0.001 and the mini-batch size of 32. In addition, we applied gradient clipping regularization to prevent the over-fitting problem when training the model. We implemented the Code Action Networks in Python using Tensorflow, an open-source software library for Machine Intelligence developed by the Google Brain Team.",
            "cite_spans": [
                {
                    "start": 449,
                    "end": 453,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Setting"
        },
        {
            "text": "Code Action Network Versus Baselines. We compared our CAN-M and CAN-B using the Long Short Term Memory (LSTM) cell and the hidden size of 256 with IDA, the Bidirectional RNN (BRNN), ByteWeight (BW) no-RFCR and ByteWeight (BW) in the task of function start, function end, function boundary and function scope identification. For the well-known tool IDA as well as the Bidirectional RNN, ByteWeight no-RFCR, and ByteWeight methods, we reported the experimental results presented in [2] and [12] . Obviously, the task of function scope identification wherein we need to specify addresses of machine instructions in each function is harder than that of function boundary identification. To compute the function scope results, given a predicted function by CAN variants, we considered their start and end instructions for CAN-M and start and end bytes for CAN-B, and then evaluated measures (e.g., Precision, Recall, and F1 score) based on this pair. In addition, in the function scope identification task, a pair is counted as a correct pair if all predicted bytes or machine instructions accompanied with this pair forms a function that exactly matches to a valid function in the ground truth. In contrast, in the function boundary identification task, we only require the start and end positions of this pair to be correct.",
            "cite_spans": [
                {
                    "start": 480,
                    "end": 483,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 488,
                    "end": 492,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "The experimental results in Table 1 show that our proposed CAN-M and CAN-B achieved better predictive performances (i.e., Recall, Precision, and F1 score) compared with the baselines in most cases (PE x86, PE x86-64, ELF x86 and ELF x86-64). For the function boundary identification task, our CAN-B and CAN-M significantly outperformed the baselines in all measures, especially for CAN-M. Interestingly, the predictive performance of our proposed methods on the harder task of function scope identification was higher or comparable with that of the baselines on the easier task of function boundary identification. In comparison with the Bidirectional RNN proposed in [12] , our proposed methods slightly outperform it on the function start and function end identification tasks, but significantly surpass this method on the function boundary identification task -the more important task. This result demonstrates the capacity of our methods in efficiently utilizing the contextual relationship carried in consecutive machine instructions or bytes to properly match the function start and end entries for this task. Regarding the amount of time taken for training, our CAN-M took approximately 3,490 s for training in 20,000 iterations, while our CAN-B and the Bidirectional RNN using the same number of iterations with the sequence length 1,000 took about 12,030 seconds (i.e., roughly four times slower). This is due to a much smaller sequence length of CAN-M compared with CAN-B and the Bidirectional RNN.",
            "cite_spans": [
                {
                    "start": 668,
                    "end": 672,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [
                {
                    "start": 28,
                    "end": 35,
                    "text": "Table 1",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Experimental Results"
        },
        {
            "text": "We also compared the average predictive performance for case by case including the function start, function bound and function scope identifications of our CAN-M and CAN-B using the hidden size of 256 and LSTM cell with the Bidirectional RNN, ByteWeight, and Nucleus in both Linux and Windows platforms. For Nucleus [1] , we reported the experimental results reported in that paper. The experimental results in Table 2 indicate that our CAN-M and CAN-B again outperformed the baselines, while CAN-M obtained the highest predictive performances in all measures (Recall, Precision and F1 score).",
            "cite_spans": [
                {
                    "start": 316,
                    "end": 319,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 411,
                    "end": 418,
                    "text": "Table 2",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Code Action Network Versus Bidirectional RNN, ByteWeight and Nucleus."
        },
        {
            "text": "For a qualitative assessment, we performed error analysis of our CAN-M and CAN-B for all cases including PEx86, PEx64, ELFx86 and ELFx64.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Error Analysis"
        },
        {
            "text": "At the machine instruction level, we observed that there are 4,714, 4,464, 3,320 and 8,147 different types of machine instructions for function start while there are 1,926, 5,523, 9,082 and 11,421 different types of machine instructions for function end in the PEx86, PEx64, ELFx86 and ELFx64 datasets respectively. At byte level, we found that there are 91, 49, 41 and 53 different types of instruction bytes for function start while there are 166, 125, 133 and 126 different types of bytes for function end in the PEx86, PEx64, ELFx86 and ELFx64 datasets respectively. Obviously, these diverse ranges in the function start and function styles make the task of function identification really challenging. In all four cases (PEx86, PEx64, ELFx86 and ELFx64), the compilers in use often add padding between functions such as nop, int3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Error Analysis"
        },
        {
            "text": "We summarize some observations for our methods performance as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Error Analysis"
        },
        {
            "text": "-Shin et al. [12] and Bao et al. [2] commonly mentioned that for the functions that contain either several function start or function end styles inside, their models tend to confuse in determining the true start or end points, hence offering many false positives. This is due to a high level of ambiguity in the start or end entries for these functions. However, it is not the case for our proposed CAN-M and CAN-B. For example, at the machine instruction level with PE x86, we found that the functions which contain more than one function start style or function end style account for 98.38% and 28.00% of the testing set and when predicting these functions, our proposed CAN-M has 0.28% false negative rate and 0.24% false positive rate as well as 1.56% false negative rate and 1.09% false positive rate. -Our proposed methods also share the same behavior as the method in [12] in predicting some first and last items in an input sequence, that is, the CAN-M and CAN-B sometimes offer false positives and negatives when predicting some first and last instructions or bytes in an input sequence. More specifically, if an input sequence involves several functions, the start of the first function and the end of the last function are more likely to be predicted incorrectly. This is possibly due to the scarcity of context before or after them. For example, at the machine instruction level with PE x86, we record that there is about 2.39% of input sequences which contain function ends at some first and last input items. When predicting these function end entries, our proposed CAN-M obtains 21.21% false positive rate and 27.27% false negative rate. ",
            "cite_spans": [
                {
                    "start": 13,
                    "end": 17,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 33,
                    "end": 36,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 875,
                    "end": 879,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Error Analysis"
        },
        {
            "text": "In this paper, we have proposed the novel Code Action Network (CAN) for dealing with the function identification problem, a preliminary and significant step in binary analysis for many security applications such as malware detection, common vulnerability detection and binary instrumentation. Specifically, the CAN leverages the underlying idea of a multicell bidirectional recurrent neural network with the idea of encoding the task of function scope identification to a sequence of three action states NI (i.e., next inclusion), NE (i.e., next exclusion), and FE (i.e., function end) in order to tackle function scope identification, the hardest and most crucial task in function identification. The experimental results show that the CAN can achieve state-of-the-art performance in terms of efficiency and efficacy.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Compiler-agnostic function detection in binaries",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Andriesse",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Slowinska",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Bos",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IEEE European Symposium on Security and Privacy",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Byteweight: learning to recognize functions in binary code",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bao",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Burket",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Woo",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "23rd USENIX Security Symposium",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Imagenet classification with deep convolutional neural networks",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Krizhevsky",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sutskever",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "E"
                    ],
                    "last": "Hinton",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Advances in Neural Information Processing Systems",
            "volume": "25",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Static disassembly of obfuscated binaries",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kruegel",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Robertson",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Valeur",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Vigna",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Proceedings of Conference on USENIX Security Symposium",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "PEBIL: efficient static binary instrumentation for Linux",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Laurenzano",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "M"
                    ],
                    "last": "Tikir",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Carrington",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Snavely",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "International Symposium on Performance Analysis of Systems and Software (ISPASS)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Maximal divergence sequential autoencoder for binary software vulnerability detection",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Le",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "International Conference on Learning Representations",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Deep cost-sensitive kernel machine for binary software vulnerability detection",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Nguyen",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Pacific-Asia Conference on Knowledge Discovery and Data Mining",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Deep domain adaptation for vulnerable code function identification",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Nguyen",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "International Joint Conference on Neural Networks",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Automatically patching errors in deployed software",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "H"
                    ],
                    "last": "Perkins",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Cross-architecture bug search in binary executables",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pewny",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Garmany",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gawlik",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Rossow",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Holz",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of IEEE Symposium on Security and Privacy",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Learning to analyze binary computer code",
            "authors": [
                {
                    "first": "N",
                    "middle": [
                        "E"
                    ],
                    "last": "Rosenblum",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhu",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "P"
                    ],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Hunt",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "798--804",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Recognizing functions in binaries with neural networks. In: 24th USENIX Security Symposium",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "C R"
                    ],
                    "last": "Shin",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Song",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Moazzezi",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Sequence to sequence learning with neural networks",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sutskever",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Vinyals",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [
                        "V"
                    ],
                    "last": "Le",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the 27th International Conference on Neural Information Processing Systems",
            "volume": "2",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Control flow integrity for COTS binaries",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Sekar",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Proceedings of the 22nd USENIX Conference on Security",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Example source code of a function in the C language programming (Left), the corresponding assembly code (Middle) with some parts omitted for brevity and the corresponding hexadecimal mode of the binary code (Right).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "(The left-handfigure)The key idea of Code Action Network. Assume that we have a sequence of instruction bytes in three functions where the functions may not be contiguous and there exist gaps between the functions. The Code Action Network transforms this sequence of instruction bytes to those of action states (i.e., NI, NE, and FE).(The right-hand figure)The architecture of the Code Action Network.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "where D is the training set including pairs (B, Y) of the binaries and their corresponding sequence of action states.Because o k is a function (lossy summary) of i 1:l , we further derive logp(Y | B) as:log p (Y | B) =l k=1 log p (y k | y 1:k\u22121 , i 1:l ) = l k=1 log p (y k | o k ) Substituting back to the optimization problem in Eq. p (y k | o k )",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "The testing procedure of our Code Action Network. The sequence of machine instructions/non-instructions or instruction bytes/non-instruction bytes in a binary program is fed to the trained Code Action Network to work out the sequence of action states. Subsequently, the sequence of action states is decoded to the set of functions in this binary.",
            "latex": null,
            "type": "figure"
        },
        "TABREF1": {
            "text": "Comparison of our Code Action Network and baselines (Best in bold, second best in underline). Noting that f.s, f.e, f.b and f.sc stand for func. start, func. end, func. boundary and func. scope while R, P, and F1 represent Recall, Precision and F1 score respectively. CAN-M 99.30% 99.56% 99.43% 97.97% 99.29% 98.63% 99.56% 99.71% 99.64% 99.12% 99.31% 99.21% 40% 98.65% 98.52% 95.94% 97.21% 96.57% 98.97% 99.12% 99.05% 97.52% 98.28% 97.90%",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Comparison with the baselines (the Bidirectional RNN, ByteWeight and Nucleus) using average scores for all architectures (x86 and x86-64) for both Linux and Windows of our Code Action Network. The experimental results for Nucleus are from the original paper using the same dataset (Best performance in bold, second best in underline).",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "This research was supported under the Defence Science and Technology Group's Next Generation Technologies Program.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgement."
        }
    ]
}