{
    "paper_id": "77980f9370fa3b15dda026a641a28eb31265f9bc",
    "metadata": {
        "title": "Memetic Algorithms with Partial Lamarckism for the Shortest Common Supersequence Problem",
        "authors": [
            {
                "first": "Carlos",
                "middle": [],
                "last": "Cotta",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of M\u00e1laga",
                    "location": {
                        "addrLine": "Campus de Teatinos",
                        "postCode": "29071",
                        "settlement": "M\u00e1laga",
                        "country": "Spain"
                    }
                },
                "email": "ccottap@lcc.uma.es"
            }
        ]
    },
    "abstract": [
        {
            "text": "The Shortest Common Supersequence problem is a hard combinatorial optimization problem with numerous practical applications. We consider the use of memetic algorithms (MAs) for solving this problem. A specialized local-improvement operator based on character removal and heuristic repairing plays a central role in the MA. The tradeoff between the improvement achieved by this operator and its computational cost is analyzed. Empirical results indicate that strategies based on partial lamarckism (i.e., moderate use of the improvement operator) are slightly superior to full-lamarckism and no-lamarckism.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The Shortest Common Supersequence Problem (SCSP) is a classical problem from the realm of string analysis. In essence, the SCSP consists of finding a minimal-length sequence S of symbols such that all strings in a certain set L are embedded in S (a more detailed description of the problem and the notion of embedding will be provided in next section). The SCSP provides a \"clean\" combinatorial optimization problem of great interest from the point of view of Theoretical Computer Science. In this sense, the SCSP has been studied in depth, and we now have accurate characterizations of its computational complexity. These characterizations range from the classical complexity paradigm (i.e., unidimensional complexity) to the more recent parameterized complexity paradigm (i.e., multidimensional complexity). We will survey some of these results in next section as well, but it can be anticipated that the SCSP is intrinsically hard [1, 2, 3] under many formulations and/or restrictions.",
            "cite_spans": [
                {
                    "start": 934,
                    "end": 937,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 938,
                    "end": 940,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 941,
                    "end": 943,
                    "text": "3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "These hardness results would not be critical were the SCSP a mere academic problem. However, the SCSP turns out to be also a very important problem from an applied standpoint: it has applications in planning, data compression, and bioinformatics among other fields [4, 5, 6] . Thus, the practical impossibility of utilizing exact approaches for tackling this problem in general motivates attention be re-directed to heuristic approaches. Such heuristic approaches are aimed to producing probably-(yet not provably-) optimal solutions to the SCSP. Examples of such heuristics are the Majority Merge (MM) algorithm, and related variants [7] , or the Alphabet-Leftmost (AL) algorithm [8] . More sophisticated heuristics have been also proposed, for instance, evolutionary algorithms (EAs) [7, 9] . This work will follow the way paved by previous EA approaches to this problem. To be precise, the use of memetic algorithms (MAs) will be considered. The main feature of this MA is the utilization of a twofold local-improvement strategy: on one hand, a repair mechanism is used to restore feasibility of solutions, shortening them if possible; on the other hand, an iterated local-search strategy is used to further improve solution quality. The computational impact of this latter component will be here analyzed, and confronted with the quality improvement attainable.",
            "cite_spans": [
                {
                    "start": 265,
                    "end": 268,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 269,
                    "end": 271,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 272,
                    "end": 274,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 635,
                    "end": 638,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 681,
                    "end": 684,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 786,
                    "end": 789,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 790,
                    "end": 792,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "First of all, let us define the notion of supersequence. Let s and r be two strings of symbols taken from an alphabet \u03a3. String s can be said to be a supersequence of r (denoted as s r) using the following recursive definition: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "Plainly, the definition above implies that r can be embedded in s, meaning that all symbols in r are present in s in the very same order (although not necessarily consecutive). We can now formally define the decisional version of the SCSP:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "Shortest Common Supersequence Problem Instance: A set L of m strings {s 1 , \u00b7 \u00b7 \u00b7 , s m }, s i \u2208 \u03a3 * (where \u03a3 is a certain alphabet), and a positive integer k. Question: Does there exist a string s \u2208 \u03a3 * , |s| k, such that s s i for all s i \u2208 L?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "Obviously, associated with this decisional problem, we have its optimization version in which the smallest k is sought such that the corresponding instance is a yes-instance. Let us now consider the computational complexity of the SCSP.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "The SCS problem can be shown to be NP-hard, even if strong constraints are posed on L, or on \u03a3. For example, it is NP-hard in general when all s i have length two [5] , or when the alphabet size |\u03a3| is two [2] . At any rate, it must be noted that NP-hard results are usually over-stressed; in fact, the NPcharacterization is a worst-case scenario, and such worst cases may be unlikely (for example, 3-SAT is NP-hard, yet most instances are easily solvable; only those located at the phase transition between satisfiability and non-satisfiability are hard to solve). A more sensible characterization of hardness is required in order to deal with these issues, and parameterized complexity is the key.",
            "cite_spans": [
                {
                    "start": 163,
                    "end": 166,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 206,
                    "end": 209,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "Parameterized complexity [10] approaches problems from a multidimensional perspective, realizing its internal structure, and isolating some parameters. If hardness (that is, non-polynomial behavior) can be isolated within these parameters, the problem can be efficiently solved for fixed values of them. Here, efficiently means in time O(f (k)n c ), where k is the parameter value, n is the problem size, f is an arbitrary function of k only, and c is a constant independent of k and n. A paradigmatic example of this situation is provided by Vertex Cover: it is NP-hard in general, but it can be solved in time O(1.271 k +n), where n is the number of vertices, and k is the maximum size of the vertex cover sought [11, 12] . Problems such as Vertex Cover for which this hardness-isolation is possible are termed fixed-parameter tractable (FPT). Non-FPT problem will fall under some class in the W \u2212hierarchy. Hardness for class W [1] is the current measure of intractability.",
            "cite_spans": [
                {
                    "start": 25,
                    "end": 29,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 715,
                    "end": 719,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 720,
                    "end": 723,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 931,
                    "end": 934,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "Several parameterizations are possible for the SCSP. Firstly, the maximum length k of the supersequence sought can be taken as a parameter. If the alphabet size is constant, or another parameter, then the problem turns in this case to be FPT, since there are at most |\u03a3| k supersequences, and these can be exhaustively checked. However, this is not very useful in practice because k max |s i |. If the number of strings m is used as a parameter, then SCS is W [1]\u2212hard, and remains so even if |\u03a3| is taken as another parameter [6] , or is constant [3] . Failure of finding FPT results in this latter scenario is particularly relevant since the alphabet size in biological problems is fixed (e.g., there are just four nucleotides in DNA). Furthermore, the absence of FPT algorithms implies the absence of fully polynomial time approximation schemes (FPTAS) for the corresponding problem, that is, there does not exist an algorithm returning solutions within factor 1 + from the optimum in time which is polynomial in n and 1/ .",
            "cite_spans": [
                {
                    "start": 527,
                    "end": 530,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 548,
                    "end": 551,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "The Shortest Common Supersequence Problem"
        },
        {
            "text": "The hardness results mentioned in the previous subsection motivate the utilization of heuristic approaches for tackling the SCSP. One of the most popular algorithms for this purpose is Majority Merge (MM). This is a greedy algorithm that constructs a supersequence incrementally by adding the symbol most frequently found at the front of the strings in L, and removing these symbols from the corresponding strings. More precisely:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "for s i \u2208 L, s i = \u03b2s i do let s i \u2190 s i 6:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "let s \u2190 s\u03b2 7:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "until si\u2208L |s i | = 0 8: return s",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "The myopic functioning of MM makes it incapable of grasping the global structure of strings in L. In particular, MM misses the fact that the strings can have different lengths [7] . This implies that symbols at the front of short strings will have more chances to be removed, since the algorithm has still to scan the longer strings. For this reason, it is less urgent to remove those symbols. In other words, it is better to concentrate in shortening longer strings first. This can be done by assigning a weight to each symbol, depending of the length of the string in whose front is located. Branke et al. [7] propose to use precisely this string length as weight, i.e., step 3 in the previous pseudocode would be modified to have \u03bd(\u03b1) \u2190 si=\u03b1s i |s i |. Another heuristic has been proposed by Rahmann [8] in the context of the application of the SCSP to a microarray production setting. This algorithm is termed Alphabet-Leftmost (AL), and its functioning can be described as follows:",
            "cite_spans": [
                {
                    "start": 176,
                    "end": 179,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 608,
                    "end": 611,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 803,
                    "end": 806,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "if \u2203s j \u2208 L : s j = \u03c0 i s j then 5:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "for s j \u2208 L, s j = \u03c0 i s j do let s j \u2190 s j 6:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "let s \u2190 s\u03c0 i 7: end if 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "let i \u2190 (i MOD |\u03a3|) + 1 9:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "until si\u2208L |s i | = 0 10: return s",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "As it can be seen, AL takes as input the list of strings whose supersequence is sought, and a permutation of symbols in the alphabet. The algorithm then proceeds with successive repetitions of this pattern until the all strings in L are embedded. Obviously, unproductive steps (i.e., when the next symbol in row does not appear at the front of any string in L) are ignored. Such a simple algorithm can provide very good results for some SCSP instances.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristics for the SCSP"
        },
        {
            "text": "One of the difficulties faced by an EA (or by a MA) when applied to the SCSP is the existence of feasibility constraints, i.e., an arbitrary string s \u2208 \u03a3 * , no matter its length, is not necessarily a supersequence of strings in L. Typically, these situations can be solved in three ways: (i) allowing the generation of infeasible solutions and penalizing accordingly, (ii) using a repairing mechanism for mapping infeasible solutions to feasible solutions, and (iii) defining appropriate operators and/or problem representation to avoid the generation of infeasible solutions. We have analyzed these three approaches elsewhere, and we have found that option (ii) provided better results than option (i) and (iii) (in this latter case, we considered an EA that used ideas from GRASP [13] as suggested in [14] ). We will thus elaborate on this option.",
            "cite_spans": [
                {
                    "start": 783,
                    "end": 787,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 804,
                    "end": 808,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "Our MA evolves sequences in |\u03a3| \u03bb , where \u03bb = si\u2208L |s i |. Before being submitted for evaluation, these sequences are repaired using a function \u03c1 : \u03a3 * \u00d7 (\u03a3 * ) m \u2192 \u03a3 * whose behavior can be described as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "if where L| \u03b1 = {s 1 | \u03b1 , \u00b7 \u00b7 \u00b7 , s m | \u03b1 }, and s| \u03b1 equals s when s = \u03b1s , being s otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "As it can be seen, this repairing function not only completes s in order to have a valid supersequence, but also removes unproductive steps, as it is done in AL. Thus, it also serves the purpose of local improver to some extent. After this repairing, raw fitness (to be minimized) is simply computed as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "As mentioned in Sect. 1, an additional local-improvement level is considered. To do so, we have considered the neighborhood define by the Delete k : \u03a3 * \u00d7 (\u03a3 * ) m \u2192 \u03a3 * operation [8] . The functioning of this operation is as follows:",
            "cite_spans": [
                {
                    "start": 180,
                    "end": 183,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "Delete k (s, L) = \u03c1(s , L) i fk = 1 and s = \u03b1s \u03b1Delete k\u22121 (s , L| \u03b1 ) if k > 1 and s = \u03b1s (4) This operation thus removes the k-th symbol from s, and then submits it to the repair function so that all all strings in L can be embedded. Notice that the repairing function can actually find that the sequence is feasible, hence resulting in a reduction of length by 1 symbol. A full local-search scheme is defined by iterating this operation until no single deletion results in length reduction:",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 94,
                    "text": "(4)",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "if f itness(r) < f itness(s) then 5:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "let s \u2190 r 6:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "let k \u2190 0 7: else 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "let k \u2190 k + 1 9: end if 10: end while 11:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "return s",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "The application of this LS operator has a computational cost that we measure as the number of partial evaluations in step 3 above. More precisely, since the application of the repairing function starts at position k, we compute each application of Delete k to s as (|r| \u2212 k)/|r| fitness evaluations. This is accumulated during the run of the MA to have a more sensible estimation of the search cost.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Memetic Algorithms for the SCSP"
        },
        {
            "text": "The experiments have been done with a steady-state MA (popsize = 100, p X = .9, p m = 1/n, maxevals = 100, 000), using binary tournament selection, uniform crossover, and random-substitution mutation. In order to analyze the impact of local search, the LS operation is not always applied, but randomly with probability p. The values p \u2208 {0, 0.01, 0.1, 0.5, 1} have been considered. We denote by MA x% the use of p = x/100. Notice that MA 0% would then be a plain repair-based EA. Two different sets of problem instances have been used in the experimentation. The first one is composed of random strings with different lengths. To be precise, each instance is composed of eight strings, four of them with 40 symbols, and the remaining four with 80 symbols. Each of these strings is randomly built, using an alphabet \u03a3. Four subsets of instances have been defined using different alphabet sizes, namely |\u03a3| =2, 4, 8, and 16. For each alphabet size, five different instances have been generated.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "Secondly, a more realistic benchmark consisting of strings with a common source has been considered. A DNA sequence from a SARS coronavirus strain has been retrieved from a genomic database 1 , and has been taken as supersequence; then, different sequences are obtained from this supersequence by scanning it from left to right, and skipping nucleotides with a certain fixed probability. In these experiments, the length of the supersequence is 158, the gap probability is 10%, 15%, or 20% and the number of so-generated sequences is 10.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "First of all, the results for the random strings are shown in Table 1 . All MAs perform notably better than AL. The results for MM (not shown) are similar to those of AL (more precisely, they are between 2.5% and 10% better, still far worse than the MAs). Regarding the different MAs, performance differences tend to be higher for increasing alphabet sizes. In general, MAs with p > 0 are better than MA 0% (the differences are statistically significant according to a Wilcoxon ranksum test [15] in above 90% of the problem instances). MA 1% provides somewhat better results, although the improvement with respect to the other MAs (p > 0) is only significant in less than 20% of the problem instances.",
            "cite_spans": [
                {
                    "start": 491,
                    "end": 495,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [
                {
                    "start": 62,
                    "end": 69,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Experimental Results"
        },
        {
            "text": "The results for the strings from the SARS DNA sequence are shown in Table 2 . Again, AL performs quite poorly here. Unlike the previous set of instances, MM (not shown) does perform notably better than AL. Actually, it matches the performance of MA 0% for low gap probability (10% and 15%), and yields an average 227.8 for the larger gap probability. In this latter problem instance, the MAs with p > 0 seem to perform marginally better. MA 100% and MA 1% provide local search). Using partial lamarckism (0 < p < 1) provides in some problem instances better results, and does not seem to be harmful on any of the remaining instances. Hence, it can offer the best tradeoff between quality improvement and computational cost. Future work will be directed to confirm these results on other neighborhood structures for local search. In this sense, alternatives based on symbol insertions or symbol swaps can be considered [8] .",
            "cite_spans": [
                {
                    "start": 918,
                    "end": 921,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [
                {
                    "start": 68,
                    "end": 75,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Experimental Results"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "The parameterized complexity of sequence alignment and consensus",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Bodlaender",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Downey",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Fellows",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wareham",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Theoretical Computer Science",
            "volume": "147",
            "issn": "",
            "pages": "31--54",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "More on the complexity of common superstring and supersequence problems",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Middendorf",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Theoretical Computer Science",
            "volume": "125",
            "issn": "",
            "pages": "205--228",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "On the parameterized complexity of the fixed alphabet shortest common supersequence and longest common subsequence problems",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Pietrzak",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Journal of Computer and System Sciences",
            "volume": "67",
            "issn": "",
            "pages": "757--771",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Theory and algorithms for plan merging",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Foulser",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Artificial Intelligence",
            "volume": "57",
            "issn": "",
            "pages": "143--181",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Complexity of common subsequence and supersequence problems and related problems",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Timkovsky",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Cybernetics",
            "volume": "25",
            "issn": "",
            "pages": "565--580",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "An integrated complexity analysis of problems from computational biology",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hallet",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Improved heuristics and a genetic algorithm for finding short supersequences",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Branke",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Middendorf",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Schneider",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "OR-Spektrum",
            "volume": "20",
            "issn": "",
            "pages": "39--45",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "The shortest common supersequence problem in a microarray production setting",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Rahmann",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Bioinformatics",
            "volume": "19",
            "issn": "",
            "pages": "156--161",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Searching for shortest common supersequences by means of a heuristic based genetic algorithm",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Branke",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Middendorf",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Proceedings of the Second Nordic Workshop on Genetic Algorithms and their Applications",
            "volume": "",
            "issn": "",
            "pages": "105--114",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Parameterized Complexity",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Downey",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Fellows",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Vertex cover: further observations and further improvements",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Kanj",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Jia",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Proceedings of the 25th International Workshop on Graph-Theoretic Concepts in Computer Science. Number 1665 in Lecture Notes in Computer Science",
            "volume": "",
            "issn": "",
            "pages": "313--324",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A general method to speed up fixed-parametertractable algorithms",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Niedermeier",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Rossmanith",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Information Processing Letters",
            "volume": "73",
            "issn": "",
            "pages": "125--129",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Greedy randomized adaptive search procedures",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Feo",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Resende",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Journal of Global Optimization",
            "volume": "6",
            "issn": "",
            "pages": "109--133",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "A hybrid GRASP-evolutionary algorithm approach to golomb ruler search",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Cotta",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Fern\u00e1ndez",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Lecture Notes in Computer Science",
            "volume": "3242",
            "issn": "",
            "pages": "481--490",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Nonparametric Statistical Methods Based on Ranks",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Lehmann",
                    "suffix": ""
                }
            ],
            "year": 1975,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "and s = s r if r = \u03b1r and s = \u03b1s , \u03b1 \u2208 \u03a3 s r if r = \u03b1r and s = \u03b2s and \u03b1 = \u03b2, \u03b1, \u03b2 \u2208 \u03a3",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "\u2203i : s i = and i : s i = \u03b1s i and s = \u03b1s \u03b1\u03c1(s , L| \u03b1 ) if \u2203i : s i = \u03b1s i and s = \u03b1s MM(L) if \u2203i : s i = and s = (2)",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Results of the different heuristics on 8 random strings (4 of length 40, and 4 of length 80), for different alphabet sizes |\u03a3|. The results of AL are averaged over all permutations of the alphabet (or a maximum 100,000 permutations for |\u03a3| = 16), and the results of the EAs are averaged over 30 runs. In all cases, the results are further averaged over five different problem instances AL MA 0% MA 1% |\u03a3| best mean \u00b1 std.dev. best mean \u00b1 std.dev. best mean \u00b1 std.dev.Table 2. Results of the different heuristics on the strings from the SARS DNA sequence. The results of AL are averaged over all permutations of the alphabet (or a maximum 100,000 permutations for |\u03a3| = 16), and the results of the EAs are averaged over 30 runs",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgements. This work is partially supported by Spanish MCyT and FEDER under contract TIC2002-04498-C05-02.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        },
        {
            "text": "the best and second best mean results (no statistical difference between them). A Wilcoxon ranksum test indicates that the difference with respect to MA 0% is significant (at the standard 5% significance).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "annex"
        },
        {
            "text": "We have studied the deployment of MAs on the SCSP. The main goal has been to determine the way that local search affects the global performance of the algorithm. The experimental results seem to indicate that performance differences are small but significant with respect to a plain repair-based EA (i.e., no",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ]
}