{
    "paper_id": "PMC7206278",
    "metadata": {
        "title": "Inferring Restricted Regular Expressions with Interleaving from Positive and Negative Samples",
        "authors": [
            {
                "first": "Hady",
                "middle": [
                    "W."
                ],
                "last": "Lauw",
                "suffix": "",
                "email": "hadywlauw@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Raymond",
                "middle": [
                    "Chi-Wing"
                ],
                "last": "Wong",
                "suffix": "",
                "email": "raywong@cse.ust.hk",
                "affiliation": {}
            },
            {
                "first": "Alexandros",
                "middle": [],
                "last": "Ntoulas",
                "suffix": "",
                "email": "antoulas@di.uoa.gr",
                "affiliation": {}
            },
            {
                "first": "Ee-Peng",
                "middle": [],
                "last": "Lim",
                "suffix": "",
                "email": "eplim@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "See-Kiong",
                "middle": [],
                "last": "Ng",
                "suffix": "",
                "email": "seekiong@nus.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Sinno",
                "middle": [
                    "Jialin"
                ],
                "last": "Pan",
                "suffix": "",
                "email": "sinnopan@ntu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Yeting",
                "middle": [],
                "last": "Li",
                "suffix": "",
                "email": "liyt@ios.ac.cn",
                "affiliation": {}
            },
            {
                "first": "Haiming",
                "middle": [],
                "last": "Chen",
                "suffix": "",
                "email": "chm@ios.ac.cn",
                "affiliation": {}
            },
            {
                "first": "Lingqi",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "email": "zhanglingqisteve@gmail.com",
                "affiliation": {}
            },
            {
                "first": "Bo",
                "middle": [],
                "last": "Huang",
                "suffix": "",
                "email": "HBruomeng@outlook.com",
                "affiliation": {}
            },
            {
                "first": "Jianzhao",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "email": "zhagjz@ios.ac.cn",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "A classical problem in grammatical inference is to identify a language from positive examples and negative examples. We study learning regular expressions (REs) with interleaving (shuffle), denoted by RE(&). Since RE(&) are widely used in various areas of computer science [1], including XML database systems [5, 12, 26], complex event processing [24], system verification [4, 13, 15], plan recognition [18] and natural language processing [21, 28].",
            "cite_spans": [
                {
                    "start": 274,
                    "end": 275,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 310,
                    "end": 311,
                    "mention": "5",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 313,
                    "end": 315,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 317,
                    "end": 319,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 348,
                    "end": 350,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 374,
                    "end": 375,
                    "mention": "4",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 377,
                    "end": 379,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 381,
                    "end": 383,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 404,
                    "end": 406,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 441,
                    "end": 443,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 445,
                    "end": 447,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Studying the inference of RE(&) has several practical motivations, such as schema inference. The presence of a schema for XML documents has many advantages, such as for query processing and optimization, data integration and exchange [11, 30]. However, many XML documents in practice are not accompanied by a valid schema [16], making schema inference an attractive research topic [2, 3, 10, 14, 31]. Learning Relax NG schemas is an important research problem for schema inference, since it is more powerful than other XML schema languages, such as DTD or XSD [5] and has unrestricted supports for the interleaving operator. It is known that the essential task in Relax NG schema inference is learning RE(&) from a set of given sample [23, 31].",
            "cite_spans": [
                {
                    "start": 235,
                    "end": 237,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 239,
                    "end": 241,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 323,
                    "end": 325,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 382,
                    "end": 383,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 385,
                    "end": 386,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 388,
                    "end": 390,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 392,
                    "end": 394,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 396,
                    "end": 398,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 561,
                    "end": 562,
                    "mention": "5",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 736,
                    "end": 738,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 740,
                    "end": 742,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Previously, RE(&) learning has been studied from positive examples only [23, 29, 31]. However, negative examples might be useful in some applications. For instance, the schema evolution [8, 9] can be done incrementally, with little feedback needed from the user, when we also allow negative examples. Learning RE(&) from positive and negative examples may have other crucial applications, such as mining scientific workflows. REs have already been used in the literature as a well-suited mechanism for inter-workflow coordination [17]. The user labeled some sequences of modules from a set of available workflows as positive or negative examples. So such algorithms can be thus applied to infer the workflow pattern that the user has in mind.",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 75,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 77,
                    "end": 79,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 81,
                    "end": 83,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 187,
                    "end": 188,
                    "mention": "8",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 190,
                    "end": 191,
                    "mention": "9",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 531,
                    "end": 533,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Such kinds of applications motivate us to investigate the problem of learning RE(&) from positive and negative examples. Most researchers have studied subclasses of REs, which are expressive enough to cover the vast majority of real-world applications [6, 7, 22] and perform better on several decision problems than general ones [6, 7, 19, 20, 25, 27]. Bex et al. [3] proposed learning algorithms for two subclasses of REs: SOREs and CHAREs, which capture many practical DTDs/XSDs and are both single occurrence REs. Bex et al. [2] also studied learning algorithms, based on the Hidden Markov Model, for the subclass of REs in which each alphabet symbol occurs at most k times (k-OREs). More recently, Freydenberger and K\u00f6tzing [10] proposed more efficient algorithms for the above-mentioned SOREs and CHAREs. Existing work on RE(&) learning mentioned above [23, 29, 31] are all working on specific subclasses of REs. The aim of these approaches is to infer restricted subclasses of single occurrence REs with interleaving starting from a positive set of words representing XML documents based on maximum clique or maximum independent set.",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 254,
                    "mention": "6",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 256,
                    "end": 257,
                    "mention": "7",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 259,
                    "end": 261,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 330,
                    "end": 331,
                    "mention": "6",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 333,
                    "end": 334,
                    "mention": "7",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 336,
                    "end": 338,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 340,
                    "end": 342,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 344,
                    "end": 346,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 348,
                    "end": 350,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 365,
                    "end": 366,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 529,
                    "end": 530,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 729,
                    "end": 731,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 859,
                    "end": 861,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 863,
                    "end": 865,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 867,
                    "end": 869,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper, we focus on learning the subclass of RE(&), called SIREs (see Definition 1) [29]. It has been proved that the problem of learning SIREs is NP-hard [29]. Here, we solve this problem by using genetic algorithms and parallel techniques. Genetic algorithms have been used to solve NP problems, and parallel techniques can make programs more efficient. As a result, when given both positive and negative examples, we can effectively learn a SIRE.",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 94,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 163,
                    "end": 165,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The main contributions of this paper are listed as follows.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "\nWe design algorithm iSIRE based on genetic algorithm, which can learn SIREs from both positive and negative examples. To the best of our knowledge, our work is the first one to infer the subclass of RE(&) from positive and negative examples. We hope our work may shed some light on further research.Our algorithm has better expansibility. Algorithm iSIRE not only supports learning with positive and negative examples, but also supports learning with positive or negative examples only.We conduct a series of experiments with alphabets of different sizes. The results reveal the effectiveness of iSIRE, show the high accuracy and preciseness of our work.\n",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The subclass of REs with interleaving (SIREs) are SOIREs over \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma $$\\end{document} defined by the following grammar:\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "For instance, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ a^*b^? \\& cd^+$$\\end{document} is a SIRE, but \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ a^+b \\& c^+a$$\\end{document} is not because a appears twice.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Candidate Region (CR). We use candidate region to define the skeleton structure of a SIRE. Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {N}$$\\end{document} ={0,1,2,...}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {N}_0 = \\mathbb {N} \\backslash \\{0\\}$$\\end{document} (0 is excluded). For a SIRE \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ r:=D_1 \\& \\cdots \\& D_n$$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$D_i\\in \\varSigma ^*$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1\\le i \\le n$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1\\le n\\le \\mathbb {N}_0$$\\end{document}, it belongs to the candidate region \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ |D_1| \\& \\cdots \\& |D_n|$$\\end{document}. The size of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$D_i$$\\end{document}, denoted by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|D_i|$$\\end{document}, is the total number of alphabet symbols occurred in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$D_i$$\\end{document}.",
            "cite_spans": [],
            "section": "Definition 2 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "For a given alphabet \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=n$$\\end{document}, it is easy to see there are \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{n-1}$$\\end{document} CRs. For example, consider \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma $$\\end{document}=\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{a,b,c,d,e\\}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |$$\\end{document}=5. As is shown in Fig. 1, we can get 16 CRs. The number of squares with the same color represents the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|D_i|$$\\end{document}, e.g., the 6th CR denotes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 1 \\& 1 \\& 3$$\\end{document} and the 12th CR denotes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$  1 \\& 1 \\& 1 \\& 2$$\\end{document}. So, the SIRE \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ r_1 = a^{+} \\& b \\& c^{*}d^+e^{?}$$\\end{document} belongs to the 6th CR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 1 \\& 1 \\& 3$$\\end{document} and the SIRE \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$  r_2 = a^{+} \\& b \\& c^{*} \\& d^+e^{?}$$\\end{document} belongs to the 12th CR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$  1 \\& 1 \\& 1 \\& 2$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Definition 2 ::: Preliminaries",
            "ref_spans": [
                {
                    "start": 1590,
                    "end": 1591,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The algorithm iSIRE first figures out the SCRs of the expression to be learned, then for each SCR, employs genetic algorithms to learn character sequence and multiplicity sequence in parallel, and decodes each learned sequence to a SIRE according to its SCR. After multi-generation evolution and iteration, the best SIRE is selected by function bestRE(). The main procedures of the algorithm are presented in Algorithm 1, and are illustrated as follows.",
            "cite_spans": [],
            "section": "The Main Algorithm ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "\nScan positive examples \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_+$$\\end{document} and negative examples \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_\\_$$\\end{document} to get the alphabet \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma $$\\end{document}, then call function getSCRs() to initialize all the SCRs based on \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |$$\\end{document}.In parallel, call algorithm candSIRE to select the best SIRE from each SCR, and put them in the candidate set C.Call function bestRE() to select the best SIRE from C and output it.\n",
            "cite_spans": [],
            "section": "The Main Algorithm ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "Function bestRE() is designed to select the best SIRE. It measures two metrics of SIREs: K(r) for accuracy and CC(r) [23] for preciseness. For a SIRE r, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$K(r) = \\frac{|T_{P}|+|T_{N}|-|F_{P}|-|F_{N}|}{|S_+|+|S_\\_|}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{P} =\\{w\\in S_+|w\\in L(r)\\}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{N} =\\{w\\in S_\\_|w \\notin L(r)\\}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$F_{P} =\\{w\\in S_+|w \\notin L(r)\\}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$F_{N} =\\{w\\in S_\\_|w \\in L(r)\\}$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_+$$\\end{document} is the set of positive examples and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_\\_$$\\end{document} is the set of negative examples. The Combinatorial Cardinality (CC(r), introduced in [23]) of r can be computed as follows: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$CC(r) = \\prod \\limits _{i=1}^{n-1} \\left( {\\begin{array}{c}\\sum _{j=1}^{i+1} |D_j|\\\\ |D_{i+1}|\\end{array}}\\right) $$\\end{document}. Note that K(r) has a higher priority than CC(r) when selecting the best SIRE. If the value of K(r) is larger, then it means r can accept more positive examples and reject more negative examples. Smaller the CC(r) is, the more precise the SIRE will be. In the rest of this section, we will discuss the implementations of lines 3, 4 and 5 in detail. \n",
            "cite_spans": [
                {
                    "start": 118,
                    "end": 120,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 2475,
                    "end": 2477,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "The Main Algorithm ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "Next, we will give a detailed explanation of Line 3 of Algorithm 1 (initializing all the SCRs) in this section.",
            "cite_spans": [],
            "section": "Initializing All the Simplified Candidate Regions (SCRs) ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "From Definition 2, when \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=n$$\\end{document}, there are \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{n-1}$$\\end{document} CRs. Because of the unorder features of SIREs, we can easily find that for a SIRE \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ r = D_1 \\& \\cdots \\& D_n$$\\end{document}, the order of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$D_i$$\\end{document} can be arbitrary, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1\\le i \\le n$$\\end{document}. Hence, we can merge some equivalent CRs and get the SCRs. For instance, in Fig. 1, we can merge the 6th CR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 1 \\& 1 \\& 3$$\\end{document}, the 8th CR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 1 \\& 3 \\& 1$$\\end{document} and the 11th CR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 3 \\& 1 \\& 1$$\\end{document} together. After the merger of some equivalent CRs, we get the SCRs shown in Fig. 2.",
            "cite_spans": [],
            "section": "Initializing All the Simplified Candidate Regions (SCRs) ::: Learning Algorithm",
            "ref_spans": [
                {
                    "start": 1727,
                    "end": 1728,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2757,
                    "end": 2758,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "When the\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=n$$\\end{document}, how many SCRs are there? This problem is equivalent to Integer Partition, e.g., when \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=5$$\\end{document}, there are 7 SCRs, including 5, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 4 \\& 1$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 3 \\& 2$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 3 \\& 1 \\& 1$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 2 \\& 2 \\& 1$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$  2 \\& 1 \\& 1 \\& 1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$  1 \\& 1 \\& 1 \\& 1 \\& 1$$\\end{document}. Meanwhile, the 7 partitions of 5 are: 5 = 5, 5 = 4 + 1, 5 = 3 + 2, 5 = 3 + 1 + 1, 5 = 2 + 2 + 1, 5 = 2 + 1 + 1 + 1 and 5 = 1 + 1 + 1 + 1 + 1. In general, approximation formulas exist that can calculate the number of partitions. For \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n \\in \\mathbb {N}$$\\end{document}, the number of partitions of n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p(n) \\approx \\frac{1}{4n\\sqrt{3}}\\mathrm {e}^{\\pi \\sqrt{\\frac{2n}{3}}}$$\\end{document} as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n\\rightarrow \\infty $$\\end{document}. As n increases, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\frac{1}{4n\\sqrt{3}}\\mathrm {e}^{\\pi \\sqrt{\\frac{2n}{3}}}$$\\end{document} is far less than \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{n-1}$$\\end{document}. It can be seen from Table 1 intuitively that the number of SCRs is far less than CRs. So we use function getSCRs() to get SCRs instead of CRs in our algorithm iSIRE.\n\n",
            "cite_spans": [],
            "section": "Initializing All the Simplified Candidate Regions (SCRs) ::: Learning Algorithm",
            "ref_spans": [
                {
                    "start": 4459,
                    "end": 4460,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "For each SCR obtained in first step, we employ the algorithm candSIRE (shown in Algorithm 2) to find the best candidate SIRE. Because each SCR is independent of each other and does not interfere with each other, we use multi-thread on our multi-core processor to run the candSIRE algorithm in parallel. By using parallel processing, we can infer the best candidate SIRE for each SCR with numerous SIREs simultaneously, which makes a huge difference when there are often hundreds of SIREs to evaluate per SCR. \n",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "The algorithm candSIRE uses a number of genetic operators. Using the alphabet \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma = \\{a,b,c,d,e\\}$$\\end{document} as an example, we introduce some of them as follows.",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "\ncharacter crossover: in the character population, we randomly select two character sequences \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_1 = ebdac$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2 = eabdc$$\\end{document} as parents (in Fig. 3). First, we select the genetic information (bd) and (ab) of the parent \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document} at the same position, and put them into the children \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_2$$\\end{document} at the corresponding position respectively. Then we explain how to add the genetic information of the parent \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document} into the child \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}. Our method starts from the ending position of genetic information of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document}, and then passes each gene of parent \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document}, which has not appeared in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}, to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}. In this example, we start with the gene d of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document}, because d is already in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}, we skip it and move to c. Since c is not in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}, we can put c to the first available location of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}. As we arrived at the end of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document}, we moved to the first gene e. This time, e is not in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}, so we can add e to the next available location of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1$$\\end{document}. Continue the process we get \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1 = cbdea$$\\end{document}. In the same way, we generate \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_2 = cabed$$\\end{document}, and they are shown in Fig. 3.character mutation: the principle of character mutation is to traverse each gene and determine the mutation according to the mutation rate. If the selected gene mutates, the method randomly selects another gene and exchange their positions. For example, for a character sequence \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_1 = abcde$$\\end{document}, we assume the selected gene a mutates, then we select gene c and exchange the position of a and c, thus finally get \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_{1}^{'} = ebcda$$\\end{document} shown in Fig. 4.chromosome encoding: as is shown in Fig. 5, when we encode SIRE \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ r= d^{?}b^{+}c^{*} \\& e^{+} \\& a$$\\end{document}, we can extract a SCR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 3 \\& 1 \\& 1$$\\end{document}, a multiplicity sequence \u201c\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$?+*+1$$\\end{document}\u201d and a character sequence dbcea.chromosome decoding: we decode a SCR \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ 2 \\& 2 \\& 1$$\\end{document}, a multiplicity sequence \u201c\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$*??+*$$\\end{document}\u201d and a character sequence abcde to get a SIRE \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ r= a^{*}b^{?} \\& c^{?}d^{+} \\& e^{*}$$\\end{document}. The example is shown in Fig. 6.\n\n\n\n\n",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": [
                {
                    "start": 712,
                    "end": 713,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 7001,
                    "end": 7002,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 8013,
                    "end": 8014,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 8056,
                    "end": 8057,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 10118,
                    "end": 10119,
                    "mention": "6",
                    "ref_id": "FIGREF5"
                }
            ]
        },
        {
            "text": "In the algorithm candSIRE, for a given SCR, positive examples \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_+$$\\end{document} and negative examples \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_\\_$$\\end{document}, we select the best candidate SIRE that accepts as many positive samples as possible, rejects as many negative samples as possible, and as precise as possible. The main procedures are as follows.",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "\nInitialize the population of candidate character sequences. Here we set the population size to 500.Select the best multiplicity sequence for each character sequence using algorithm selectMuls in parallel. The pseudocode of selectMuls is presented in Algorithm 3, we will explain its details later.Decode each pair of character sequences, corresponding best multiplicity sequences and the given SCR to get the population of candidate SIREs by calling function decode().Call function calcValues(), calculate fitness value f(r) for each SIRE r. The fitness value f(r) of r is defined as follows. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$f(r) = (K(r), CC(r)),$$\\end{document} For the detailed definitions of K(r) and CC(r), see Sect. 3.1. Our fitness function gives priority to K(r), and then compare the CC(r), that is, on the basis of selecting the SIRE that can accept more positive examples and reject more negative examples, then consider the more precise ones.Call function select() to generate the next generation SIREs. The method first retains the best 20% of SIREs by the fitness f(r) in the current population unchanged, and then applies roulette-wheel selection to the remaining 80% to get the next generation SIREs. Meanwhile, it is also important to note that K(r) is the top priority when choosing SIREs. When the values of K(r) are the same, we choose the SIRE which CC(r) is minimum.Call function charCrossover(), select some pairs of character sequences according to the crossover rate (0.8), and construct new pairs of character sequences by applying the character crossover.Call function charMutate(), select some character sequences according to the mutation rate (0.03), and modify the selected sequences by applying the character mutation.Iterate \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2-8$$\\end{document} steps until the number of generations reaches the given threshold \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$C\\underline{\\ \\ }G_{max}$$\\end{document}. Here we set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$C\\underline{\\ \\ }G_{max}$$\\end{document}=300. Finally, we call function bestRE() (see Sect. 3.1) to select the best SIRE from the last generation of SIREs.\n",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "In order to improve the efficiency of evolution, we adopt two tricks to optimize algorithm candSIRE. In the second step of candSIRE, it needs to select the best multiplicity sequence for each character sequence. Obviously, this process can be executed in parallel because these character sequences are independent of each other when finding the best multiplicity sequence. Besides, as is well known, the fitness function is usually the most computationally expensive component of the genetic algorithm. Thus, we use value hashing to reduce the amount of time spent on calculating fitness values by storing previously computed fitness values in a hash table. During execution, solutions found previously will be revisited due to the random mutations and recombinations of SIREs, then we just revisit its fitness value directly from the hash table instead of recalculation. Inevitably, the storage of the hash table consumes memory usage.",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "Now we introduce the algorithm selectMuls used in the second step of algorithm candSIRE (shown in Algorithm 3), it aims to select best multiplicity sequence for each character sequence. Before introducing the details of selectMuls, we illustrate its genetic operators as follows.",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "\nmultiplicity crossover: randomly select crossover points of two parents, and then exchange the selected genes to get children. In the multiplicity population, e.g., we randomly select two multiplicity sequences \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_1 = ``*+1?+$$\\end{document}\u201d and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2 = ``*??++$$\\end{document}\u201d as parents. Then we exchange \u201c+1\u201d of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_1$$\\end{document} and \u201c??\u201d of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_2$$\\end{document} to get children \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_1 = ``*???+$$\\end{document}\u201d and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_2 = ``*+1++$$\\end{document}\u201d in Fig. 7.multiplicity mutation: replacing the mutated gene with an element of the set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{*,+,?,1\\}$$\\end{document}. The principle of character mutation is to traverse each gene of the chromosome and determine the mutation according to the mutation rate. The example is shown in Fig. 8.\n\n\n",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": [
                {
                    "start": 2071,
                    "end": 2072,
                    "mention": "7",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 2615,
                    "end": 2616,
                    "mention": "8",
                    "ref_id": "FIGREF7"
                }
            ]
        },
        {
            "text": "The main procedures of selectMuls are illustrated as follows.",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "\nInitialize the population of candidate multiplicity sequences. Here we set the population size to 200.Call function decode(), decode each group of multiplicity sequences, the character sequences and the SCR to get the population of candidate SIREs.Call function calcValues(), calculate fitness value f(r) for each SIRE r.Call function select(), use roulette-wheel selection to generate a next generation from the current population according to fitness values.Call function mulCrossover(), select some pairs of multiplicity sequences according to the crossover rate (0.8), and construct new pairs of multiplicity sequences by multiplicity crossover.Call function mulMutate(), select some multiplicity sequences according to the mutation rate (0.03), and modify the sequences by applying the multiplicity mutation.Iterate 2\u20138 steps until the number of generations reaches the given threshold \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$M\\underline{\\ \\ }G_{max}$$\\end{document}. Here we set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$M\\underline{\\ \\ }G_{max}$$\\end{document}=100. Then, we call function bestRE() to select the best SIRE r from the last generation of SIREs in the given SCR. Finally, we call function encode(r).muls to get a multiplicity sequence.\n\n",
            "cite_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR ::: Learning Algorithm",
            "ref_spans": []
        },
        {
            "text": "To compare the algorithms Exact Minimal [29], conMiner [29], conDAG [29] and iSIRE, we generate 9 datasets of positive examples with alphabet size \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |$$\\end{document} = \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{5,10,15\\}$$\\end{document} and example size |S| = \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{100,500,1000\\}$$\\end{document}. Table 2 presents the K(r) values and CC(r) values of the learned SIREs. From Table 2 we can see that for all the 9 datasets, the K(r) values of learned SIREs with both algorithms are all 100%, which means both algorithms can guarantee the learned SIREs to cover all positive examples1. According to the CC(r) values of SIREs learned by the four algorithms in Table 2, we observe that when the alphabet size \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |$$\\end{document} is smaller (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=5$$\\end{document}), the learned SIREs by Exact Minimal, conMiner, conDAG and iSIRE have the same smaller CC(r) values. However, as the alphabet size \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |$$\\end{document} grows larger (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=15$$\\end{document}), the CC(r) values of learned SIREs by Exact Minimal, conMiner or conDAG is much larger than that of iSIRE, that means the results learned by iSIRE is more precise than the other 3 algorithms.\n",
            "cite_spans": [
                {
                    "start": 41,
                    "end": 43,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 56,
                    "end": 58,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 69,
                    "end": 71,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Learning SIREs from Positive Examples ::: Experiments",
            "ref_spans": [
                {
                    "start": 1076,
                    "end": 1077,
                    "mention": "2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 1153,
                    "end": 1154,
                    "mention": "2",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 1435,
                    "end": 1436,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "In order to evaluate the effectiveness of our learning algorithm on learning examples of both positive and negative cases, we would have liked to compare iSIRE with other approaches, but this was impossible, since we found no other tools or algorithms supporting learning SIREs from both positive and negative examples. Thus we only conducted experiment with our own algorithm. According to the alphabet size, example size, and the proportion of positive and negative examples, we made 27 datasets of examples and conducted experiment on these examples (shown in Table 3). As Table 3 shows, more than 74% K(r) values of inferred SIREs are above 75%, that is, majority of SIREs learned by iSIRE accept most of positive examples and reject most of negative examples, which demonstrates the high effectiveness of our algorithms.\n",
            "cite_spans": [],
            "section": "Learning SIREs from Positive and Negative Examples ::: Experiments",
            "ref_spans": [
                {
                    "start": 569,
                    "end": 570,
                    "mention": "3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 582,
                    "end": 583,
                    "mention": "3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "In this paper, we provided algorithm iSIRE to learn a SIRE from positive and negative examples based on genetic algorithms and parallel techniques. Then we conducted experiments with alphabets of different sizes, and results showed that with only positive examples, our learning results are more precise compared with the state-of-the-art algorithms, and when given both positive and negative examples, we can learn SIREs with high accuracy.",
            "cite_spans": [],
            "section": "Conclusions",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: The number of CRs and SCRs of varying alphabet size.\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Result of learning SIREs from positive examples.\n",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3.: Results of learning SIREs from positive and negative examples.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: All the candidate regions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=5$$\\end{document}",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: All the simplified candidate regions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\varSigma |=5$$\\end{document}",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Character crossover",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: Character mutation",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fig. 5.: Chromosome encoding",
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Fig. 6.: Chromosome decoding",
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Fig. 7.: Multiplicity crossover",
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Fig. 8.: Multiplicity mutation",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Shuffled languages - representation and recognition",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Berglund",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Bj\u00f6rklund",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bj\u00f6rklund",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theor. Comput. Sci.",
            "volume": "489\u2013490",
            "issn": "",
            "pages": "1-20",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2013.04.022"
                ]
            }
        },
        "BIBREF1": {
            "title": "Fast learning of restricted regular expressions and DTDs",
            "authors": [
                {
                    "first": "DD",
                    "middle": [],
                    "last": "Freydenberger",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "K\u00f6tzing",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Theory Comput. Syst.",
            "volume": "57",
            "issn": "4",
            "pages": "1114-1158",
            "other_ids": {
                "DOI": [
                    "10.1007/s00224-014-9559-3"
                ]
            }
        },
        "BIBREF2": {
            "title": "Schema profiling of document-oriented databases",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Gallinucci",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Golfarelli",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Rizzi",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Inf. Syst.",
            "volume": "75",
            "issn": "",
            "pages": "13-25",
            "other_ids": {
                "DOI": [
                    "10.1016/j.is.2018.02.007"
                ]
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Concurrent regular expressions and their relationship to petri nets",
            "authors": [
                {
                    "first": "VK",
                    "middle": [],
                    "last": "Garg",
                    "suffix": ""
                },
                {
                    "first": "MT",
                    "middle": [],
                    "last": "Ragunath",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Theor. Comput. Sci.",
            "volume": "96",
            "issn": "2",
            "pages": "285-304",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(92)90339-H"
                ]
            }
        },
        "BIBREF5": {
            "title": "XTRACT: learning document type descriptors from XML document collections",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Garofalakis",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gionis",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shim",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shim",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shim",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Data Min. Knowl. Disc.",
            "volume": "7",
            "issn": "1",
            "pages": "23-56",
            "other_ids": {
                "DOI": [
                    "10.1023/A:1021560618289"
                ]
            }
        },
        "BIBREF6": {
            "title": "Shuffle languages, petri nets, and context-sensitive grammars",
            "authors": [
                {
                    "first": "JL",
                    "middle": [],
                    "last": "Gischer",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Commun. ACM",
            "volume": "24",
            "issn": "9",
            "pages": "597-605",
            "other_ids": {
                "DOI": [
                    "10.1145/358746.358767"
                ]
            }
        },
        "BIBREF7": {
            "title": "The quality of the XML Web",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Grijzenhout",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Marx",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "J. Web Semant.",
            "volume": "19",
            "issn": "",
            "pages": "59-68",
            "other_ids": {
                "DOI": [
                    "10.1016/j.websem.2012.12.001"
                ]
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "The inclusion problem for regular expressions",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hovland",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Comput. Syst. Sci.",
            "volume": "78",
            "issn": "6",
            "pages": "1795-1813",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jcss.2011.12.003"
                ]
            }
        },
        "BIBREF11": {
            "title": "Learning deterministic regular expressions for the inference of schemas from XML data",
            "authors": [
                {
                    "first": "GJ",
                    "middle": [],
                    "last": "Bex",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Gelade",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Vansummeren",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "TWEB",
            "volume": "4",
            "issn": "4",
            "pages": "14:1-14:32",
            "other_ids": {
                "DOI": [
                    "10.1145/1841909.1841911"
                ]
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "Closure properties and descriptional complexity of deterministic regular expressions",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Losemann",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Martens",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Niewerth",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci.",
            "volume": "627",
            "issn": "",
            "pages": "54-70",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2016.02.027"
                ]
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "Complexity of decision problems for XML Schemas and chain regular expressions",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Martens",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schwentick",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "SIAM J. Comput.",
            "volume": "39",
            "issn": "4",
            "pages": "1486-1530",
            "other_ids": {
                "DOI": [
                    "10.1137/080743457"
                ]
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "Discovering restricted regular expressions with interleaving",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Peng",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Web Technologies and Applications",
            "volume": "",
            "issn": "",
            "pages": "104-115",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "Schema management for document stores",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "PVLDB",
            "volume": "8",
            "issn": "9",
            "pages": "922-933",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF27": {
            "title": "Efficient asymmetric inclusion of regular expressions with interleaving and counting for XML type-checking",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Colazzo",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ghelli",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pardini",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sartiani",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theor. Comput. Sci.",
            "volume": "492",
            "issn": "",
            "pages": "88-116",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2013.04.023"
                ]
            }
        },
        "BIBREF28": {
            "title": "Linear time membership in a class of regular expressions with counting, interleaving, and unordered concatenation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Colazzo",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ghelli",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sartiani",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Trans. Database Syst.",
            "volume": "42",
            "issn": "4",
            "pages": "24:1-24:44",
            "other_ids": {
                "DOI": [
                    "10.1145/3132701"
                ]
            }
        },
        "BIBREF29": {
            "title": "Update rewriting and integrity constraint maintenance in a schema evolution support system: PRISM++",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Curino",
                    "suffix": ""
                },
                {
                    "first": "HJ",
                    "middle": [],
                    "last": "Moon",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Deutsch",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zaniolo",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "PVLDB",
            "volume": "4",
            "issn": "2",
            "pages": "117-128",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF30": {
            "title": "Managing semi-structured data",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Florescu",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "ACM Queue",
            "volume": "3",
            "issn": "8",
            "pages": "18-24",
            "other_ids": {
                "DOI": [
                    "10.1145/1103822.1103832"
                ]
            }
        }
    }
}