{
    "paper_id": "PMC7198254",
    "metadata": {
        "title": "An XQuery Specification for Requests with Preferences on XML Databases",
        "authors": [
            {
                "first": "Vladimir",
                "middle": [],
                "last": "Ivanov",
                "suffix": "",
                "email": "v.ivanov@innopolis.ru",
                "affiliation": {}
            },
            {
                "first": "Artem",
                "middle": [],
                "last": "Kruglov",
                "suffix": "",
                "email": "a.kruglov@innopolis.ru",
                "affiliation": {}
            },
            {
                "first": "Sergey",
                "middle": [],
                "last": "Masyagin",
                "suffix": "",
                "email": "s.masiagin@innopolis.ru",
                "affiliation": {}
            },
            {
                "first": "Alberto",
                "middle": [],
                "last": "Sillitti",
                "suffix": "",
                "email": "a.sillitti@innopolis.ru",
                "affiliation": {}
            },
            {
                "first": "Giancarlo",
                "middle": [],
                "last": "Succi",
                "suffix": "",
                "email": "g.succi@innopolis.ru",
                "affiliation": {}
            },
            {
                "first": "Maurice",
                "middle": [],
                "last": "Tchoup\u00e9 Tchendji",
                "suffix": "",
                "email": "maurice.tchoupe@univ-dschang.org",
                "affiliation": {}
            },
            {
                "first": "Patrik",
                "middle": [
                    "Joslin"
                ],
                "last": "Kenfack",
                "suffix": "",
                "email": "kenfackjoslin@gmail.com",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "One of the consequences of the proliferation of online information today is data diversity. XML is widely used as a core technology for knowledge management within companies and the dissemination of data on the Web (such as product catalogues), as it allows semi-structured data to be organized and manipulated. A collection of XML documents is considered to be a forest of trees with labelled nodes. To manipulate the data stored in XML and extract the relevant information in terms of structure and/or content, many query languages have been proposed such as XPath [6] and XQuery [7]. Indeed, these query languages take into account both the content and the structure of underlying documents, as it can completely change their relevance and adequacy with regard to the needs expressed by the user. However, it is important to note that in order to query a document using these languages, the user must a priori know its structure. This requirement is difficult to meet in an open environment such as the Web, where document structures are not always available. Thus, due to the non-existence or lack of knowledge of the model of the document being queried, the documents are queried almost blindly. Query writers in this context do so according to an imaginary document structure they believe to be that of the document. Such queries would generally return either no results (cases of too specific queries having little or no match with the content or structure of the document in question) or, in the extreme, too many results (case of too general queries intensively using wildcards).",
            "cite_spans": [
                {
                    "start": 568,
                    "end": 569,
                    "mention": "6",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 583,
                    "end": 584,
                    "mention": "7",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The problems of absence or very large number of results of a query have also emerged within the classical database community. Requests with preference aims to be a solution to this problem. Intuitively, a request with preferences specifies the user\u2019s wishes and consists of two parts specifying on the first one, the mandatory requirements called constraints and on the second part, the optional requirements called wishes or preferences. However, a result of a request with preferences must necessarily satisfy the first part and possibly the second; if there is at least one answer satisfying the first and second part of the query, only the answers satisfying both parts must be returned as a result.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Some specific languages (generally extensions of SQL or XPath) have been proposed for the formulation of queries with preferences: SQLf [2], Preference SQL [10], Preferences Queries [5], ... for relational databases (RBD), XPref [1], Preference XPATH [9], PrefSXPath [13], ... for XML databases (XML BDs). Generally, proposed extensions of XPath language for importing the concept of preferences are only interested in either value based preferences [1, 9] or structure based preferences [13]. Our approach takes into account these two types of preferences in order to better satisfy user requirements.",
            "cite_spans": [
                {
                    "start": 137,
                    "end": 138,
                    "mention": "2",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 157,
                    "end": 159,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 183,
                    "end": 184,
                    "mention": "5",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 230,
                    "end": 231,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 252,
                    "end": 253,
                    "mention": "9",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 268,
                    "end": 270,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 451,
                    "end": 452,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 454,
                    "end": 455,
                    "mention": "9",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 489,
                    "end": 491,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The rest of this paper is organized as follows: Sect. 2 presents some concepts related to XML documents, queries languages and open source implementations, we detail our specifications by presenting in Sect. 3, a grammar for the language XQuery preference and the representation model. And we finally end with a conclusion and future work.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "XPath allows to designate one or more nodes in an XML document, using path expressions. Thus, an XPath expression is a sequence of steps. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ [/]step_{1}/step_{2}/.../step_{n}$$\\end{document}[/]step1/step2/.../stepn. An XPath step consists of an axis, a filter and a predicate (optional): axe :  : filtre[predicat] The axis indicates a search direction. The most used axes are parent-child (represented by A/B) and descendant axis (A//B). The filter selects a node type. For example the expression A/B returns all elements B children of an element A. Predicates select content.",
            "cite_spans": [],
            "section": "XPath ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "XQuery [7] is the query language recommended by the W3C to extract information from many types of XML data sources. XQuery is the XML equivalent of SQL language, for retrieving data contained in relational databases and inherits the properties of several other languages. From XPath it uses the path expression syntax for addressing elements in XML documents. From SQL it takes up the idea of a series of clauses based on keywords that provide a model for data restructuring (the SQL SELECT-FROM-WHERE model). XQuery queries have several expression forms, the most famous is the FLWOR form. The acronym FLWOR comes from the reserved words of the language which make help to define the main clauses of this type of expression: For - Let - Where - Order By - Return.",
            "cite_spans": [
                {
                    "start": 8,
                    "end": 9,
                    "mention": "7",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "XQuery ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "Each clause in a FLWOR expression plays a particular role in the query and some of these clauses are optional. Thus, a FLWOR instruction consists of the following parts:For: iteration on an XML document part listLet: allows the assignment of values to a variableOrder by: sorting resultsWhere: restriction clause (constraints)Return: form of the expression to be returned\n",
            "cite_spans": [],
            "section": "XQuery ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "An example of this type of request is given in Fig. 3. This query select the email addresses and skills of people who have a Java skill level above 3 and have more than two years of experience.\n",
            "cite_spans": [],
            "section": "XQuery ::: XML Document and Queries Languages",
            "ref_spans": [
                {
                    "start": 52,
                    "end": 53,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "There are many open source implementations of XQuery. We present here a non-exhaustive list of them:BaseX is a very light-weight, high-performance and scalable XML Database engine and XPath/XQuery 3.0 Processor, including full support for the W3C Update and Full Text extensions all developed in Java. It comes with interactive user interfaces (desktop, web-based) that give users great insight into their data [8].eXist-db is a high-performance open source native XML database - a NoSQL document database and application platform built entirely around XML technologies. A Browser-based IDE allows managing and editing all artifacts belonging to an application. Syntax-coloring, code-completion and error-checking help to get it right. Being a complete solution, eXist-db tightly integrates with XForms for complex form development [12].Galax is an open-source implementation of XQuery, the W3C XML Query Language. It includes several advanced extensions for XML updates, scripting, and distributed programming. Implemented in O\u2019Caml, Galax comes with a state of the art compiler and optimizer. Most of Galax\u2019s architecture is formally documented, making it ideal for users interested in teaching XQuery, in building new language extensions, or developing new optimizations [11].Oracle Berkeley DB XML is an open source, embeddable XML database with XQuery-based access to documents stored in containers and indexed based on their content. Implemented in C, Oracle Berkeley DB XML is built on top of Oracle Berkeley DB and inherits its rich features and attributes.\n",
            "cite_spans": [
                {
                    "start": 412,
                    "end": 413,
                    "mention": "8",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 833,
                    "end": 835,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1275,
                    "end": 1277,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Open Source Implementations of XQuery ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "XML queries (XPath or XQuery) to be evaluated on XML documents (trees), need to be represented in a model (a tree representation) in order to facilitate their evaluation. Therefore, evaluating the query is equivalent to apply the corresponding model to the XML tree trough a tree pattern matching process.",
            "cite_spans": [],
            "section": "Open Source Implementations of XQuery ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "A generalized tree pattern is a couple \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ G=(T,F) $$\\end{document}G=(T,F) where T is a tree and F a Boolean formula such as.",
            "cite_spans": [],
            "section": "Definition 1 ::: Generalized Tree Pattern (GTP) ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "\nEach node in the tree T is labeled with different variables and has a group number.To each arc of T is associated a pair of labels \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$<x, m>$$\\end{document}<x,m>, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ x \\in \\{PC, AD\\} $$\\end{document}x\u2208{PC,AD} specifies the axis (parent-child and ancestor-descendant, respectively) and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ m \\in \\{mandatory, optional \\} $$\\end{document}m\u2208{mandatory,optional} specifies the arc\u2019s status.F is a Boolean combination of predicates applicable to nodes.\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Generalized Tree Pattern (GTP) ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "Zhimin Chen et al. [4] also propose an algrithm for translating an XQuery expression1 in GTP. The request is put in a canonical form and is then parsed clause by clause while the GTP is progressively built up to the last clause, we invite you to read [4] for more details. The GTP is intended to be mapped (Pattern matching) to the XML tree.",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 21,
                    "mention": "4",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 252,
                    "end": 253,
                    "mention": "4",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Definition 1 ::: Generalized Tree Pattern (GTP) ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "A Pattern Match of a GTP \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ G=(G,F) $$\\end{document}G=(G,F) in a tree collection C is a subtree h partial: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ h : G \\rightarrow C $$\\end{document}h:G\u2192C such that:h contains at least group 0 of G.h preserves the relational structure of G. This means that whenever h is defined on two nodes u, v and there is a PC arc (respectively AD) (u, v) in G, then h(v) is a son (respectively a descendant) of h(u).h satisfies the Boolean formula F of G (Fig. 4).\n",
            "cite_spans": [],
            "section": "Definition 2 ::: Generalized Tree Pattern (GTP) ::: XML Document and Queries Languages",
            "ref_spans": [
                {
                    "start": 981,
                    "end": 982,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "\n\n\n",
            "cite_spans": [],
            "section": "Definition 2 ::: Generalized Tree Pattern (GTP) ::: XML Document and Queries Languages",
            "ref_spans": []
        },
        {
            "text": "Based on the grammar given in [4] to describe a significant subset of the XQuery language, we consider the following grammar for XQuery preference expressions (Fig. 5).",
            "cite_spans": [
                {
                    "start": 31,
                    "end": 32,
                    "mention": "4",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Grammar of the Language XQuery Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": [
                {
                    "start": 165,
                    "end": 166,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "For simplicity, we make other assumptions about our grammar as follows.",
            "cite_spans": [],
            "section": "Grammar of the Language XQuery Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "\nThe atomic predicates allowed in the boolean formula \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi $$\\end{document}\u03c6 are the integrated relop predicates (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$<,\\, \\le ,\\,>,\\, \\ge ,\\, =,\\, \\ne $$\\end{document}<,\u2264,>,\u2265,=,\u2260) or the integrated predicate empty(FLWR) . The operand of a relop predicate can be one of the following: constant c, XPath expression XPE, or agg(XPE) , where agg is one of the integrated aggregate functions, namely, avg, count, min, max, or sum [4].The XPath expressions used are expressions extended by the operator \u201c!\u201d except for the Pref clause.\n",
            "cite_spans": [
                {
                    "start": 964,
                    "end": 965,
                    "mention": "4",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Grammar of the Language XQuery Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "XQuery query with preference on values and structure: Let\u2019s consider a query in witch, a user is looking for a candidate with Java skills and at least a diploma level above 3. But would like this person to have at least two years of experience, and skills with the framework Sping-boot would be a plus. The user also wants the returnees to have filled in the information on their profiles.",
            "cite_spans": [],
            "section": "Example 1 ::: Expression of Preferences on Values and Structure ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "In this example, the condition on Java skills and diploma level above 3 is a constraint while the condition on the number of years of experience and Spring-Boot skills is a wish whose satisfaction increase relevance of the associated result. The Fig. 6 illustrates how this request can be expressed in the language XQuery preference.",
            "cite_spans": [],
            "section": "Example 1 ::: Expression of Preferences on Values and Structure ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": [
                {
                    "start": 251,
                    "end": 252,
                    "mention": "6",
                    "ref_id": "FIGREF5"
                }
            ]
        },
        {
            "text": "For this request, people with only Java skills and a diploma level above 3 represent potential responses but are dominated by candidates who have in addition, an experience of more than 2 years and Spring-Boot skills. However, if no answer respects all the constraints of the Pref clause, only those that best integrate the user\u2019s preferences are returned: They are called  undominated solutions. The operator \u201c!\u201d present in the XPath expression \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\$p/profile!//name$$\\end{document}$p/profile!//name specifies that the person elements with a profile sub-element are preferred. For now, we have imposed certain restrictions on XQuery preference expressions. For example, we require that XPath paths defined in the clause Pref do not include a preference element for the simple reason that all these paths are already preferential since they appear in the pref clause.\n",
            "cite_spans": [],
            "section": "Example 1 ::: Expression of Preferences on Values and Structure ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "In the Sect. 2.4 we presented a model for XPath and XQuery queries. Indeed, these model considerably reduce the complexity of evaluating requests. In the following section, in the same vein we propose a query model for XQuery preference requests based on the GTP model of Chen Zhimin et al.",
            "cite_spans": [],
            "section": "Example 1 ::: Expression of Preferences on Values and Structure ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "A generalized tree pattern with preference is a couple \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ G=(T,F) $$\\end{document}G=(T,F) where T is a tree and F a Boolean formula such as:Each node in the tree T is labeled with a different variable and has a group number.to each arc of T is associated a tag e, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ e \\in \\{PC, AD, OP, PN, APN, PP\\} $$\\end{document}e\u2208{PC,AD,OP,PN,APN,PP}PC, AD: specify the parent-child and ancestor-descendant axisPN, APN: specify respectively the parent-child preference and ancestor-descendant preference axes.OP, PP: specify the optional axes and preference path respectively.\nF is a group of formula S and P specifying respectively a Boolean combination of predicates applicable to non-preferential nodes and to preferential nodes.\n",
            "cite_spans": [],
            "section": "Definition 3 ::: GTP Request with Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "A node is said to be a preference if it is located at target of a preference arc.",
            "cite_spans": [],
            "section": "Definition 4 ::: GTP Request with Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Definition 4 ::: GTP Request with Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "The model thus presented integrates the different elements for the representation of preferences in the GTPs. The GTP with preference is obtained by a parsing of the query XQuery preference as in [4]. The process for parsing a request is as follows: We have a global analysis environment ENV to manage information collected from the request analysis i.e The association variable name-nodes. The query is parsed clause by clause. We also use a help function buildTPQ(xp) where xp is an extended XPath expression2, which constructs part of GTP with preference from xp. This function is described as follows:Each time that xp starts with the built-in document function, a new GTP is added to ENV.If xp begins with a variable, the node associated with this variable is searched for in the tree and the new part resulting from xp starts from it.When xp contains the operator \u201c!\u201d, The arcs associated with the nodes considered are of PN or APN type, depending on the axis (/ or // respectively) and the constraints linked to these nodes are placed in group P of the GTP formula.\n",
            "cite_spans": [
                {
                    "start": 197,
                    "end": 198,
                    "mention": "4",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Definition 4 ::: GTP Request with Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "During the analysis of a Pref clause, the arcs created are of type PP and the constraints linked to these nodes are placed in group P.",
            "cite_spans": [],
            "section": "Definition 4 ::: GTP Request with Preference ::: XQuery Preference: A Language for Expressing XQuery Requests with Preference",
            "ref_spans": []
        },
        {
            "text": "In this paper, we have made two major proposals: XQuery preference an extension of the XQuery language for the expression of requests with preferences which can relate to both the structure and the content; the GTP model with preference an extended version of the GTP model for the representation of XQuery preference queries; The examples given show that the proposed language is quite expressive and thus makes it possible to meet a variety of needs. We have carried out a study for the evaluation of GTPs requests with preference by an adaptation of the algorithm \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Twig^{2}Stack $$\\end{document}Twig2Stack [3] for the evaluation of exact GTPs requests. Due to the limitation of the number of pages in this paper, we could not describe it here, but it is accessible via the open repository on Github3. The results obtained are very interesting and show that we can extend the existing algorithms with a very small loss in performance but an improvement in terms of quality of the results delivered to users.",
            "cite_spans": [
                {
                    "start": 879,
                    "end": 880,
                    "mention": "3",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Conclusion",
            "ref_spans": []
        },
        {
            "text": "Furthermore, this work serves as the foundation for a much larger body of work, which could be the subject of further study. Among which, integration and experimentation of XQuery preference in the presented open source sources implementations, an in-depth study of the nested XQuery preference queries and the search for the best algorithms for evaluating queries with preferences.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "Fig. 1.: XML document.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Tree representation of an XML document.",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Example of an XQuery query",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: Example of an XQuery expression and corresponding GTP query.",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fig. 5.: Syntax of XQuery preference expressions",
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Fig. 6.: An example of XQuery request with preference on structure and values",
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Fig. 7.: Example of representation of a GTP request with preference",
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Fig. 8.: XQuery preference request corresponding to the GTP with preference of the Fig. 7",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "XPref: a preference language for P3P",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Agrawal",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kiernan",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Srikant",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Comput. Netw.",
            "volume": "48",
            "issn": "",
            "pages": "809-827",
            "other_ids": {
                "DOI": [
                    "10.1016/j.comnet.2005.01.004"
                ]
            }
        },
        "BIBREF1": {
            "title": "The preference SQL system - an overview",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Kie\u00dfling",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Endres",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Wenzel",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "IEEE Data Eng. Bull.",
            "volume": "34",
            "issn": "",
            "pages": "11-18",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "SQLf query functionality on top of a regular relational database management system",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bosc",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Pivert",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Knowledge Management in Fuzzy Databases",
            "volume": "",
            "issn": "",
            "pages": "171-190",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Preference formulas in relational queries",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Chomicki",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "ACM Trans. Database Syst.",
            "volume": "28",
            "issn": "4",
            "pages": "427-466",
            "other_ids": {
                "DOI": [
                    "10.1145/958942.958946"
                ]
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Preference XPATH: a query language for e-commerce",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Kie\u00dfling",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Hafenrichter",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Fischer",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Holland",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Information Age Economy",
            "volume": "",
            "issn": "",
            "pages": "427-440",
            "other_ids": {
                "DOI": []
            }
        }
    }
}