{
    "paper_id": "6131478dbe113de2398eadaafda2d964917e488f",
    "metadata": {
        "title": "Graph Databases for Information Retrieval",
        "authors": [
            {
                "first": "Chris",
                "middle": [],
                "last": "Kamphuis",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Radboud University",
                    "location": {
                        "settlement": "Nijmegen",
                        "country": "The Netherlands"
                    }
                },
                "email": "chris@cs.ru.nl"
            }
        ]
    },
    "abstract": [
        {
            "text": "Graph models have been deployed in the context of information retrieval for many years. Computations involving the graph structure are often separated from computations related to the base ranking. In recent years, graph data management has been a topic of interest in database research. We propose to deploy graph database management systems to implement existing and novel graph-based models for information retrieval. For this a unifying mapping from a graph query language to graph based retrieval models needs to be developed; extending standard graph database operations with functionality for keyword search. We also investigate how data structures and algorithms for ranking should change in presence of continuous database updates. We want to investigate how temporal decay can affect ranking when data is continuously updated. Finally, can databases be deployed for efficient two-stage retrieval approaches?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "There has been a long history of IR research in combination with relational databases. Recently, M\u00fchleisen et al.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "[10] implemented such a system, where",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Many IR systems make use of graph-based models. For social media Clements et al. [5] show this by using random walks over typed social media. In the context of websearch, Metzler et al. [9] and Craswell et al. [6] show the usefulness of using anchor text. Vuurens et al. [12] presented a news tracker for ad-hoc information needs. They used a temporal graph model; implemented as a standalone application over streaming graphs. Entity oriented search has been another topic of interest in the IR community [1, 2] , where researchers make extensive use of knowledge bases to improve ranking. It would be a natural choice to use graph databases to represent these models, especially if the system allows for data to be updated continuously. The goal of this PhD research is to represent graph-based models in a graph database that also supports keyword search. This would allow graph based methods to be combined with traditional keyword search, without using different system components.",
            "cite_spans": [
                {
                    "start": 81,
                    "end": 84,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 186,
                    "end": 189,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 210,
                    "end": 213,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 271,
                    "end": 275,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 506,
                    "end": 509,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 510,
                    "end": 512,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Motivation"
        },
        {
            "text": "they achieved efficiency and effectiveness on par with custom made inverted index systems. They argue that using relational databases instead of custommade inverted indexes has the following advantages for IR.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivation"
        },
        {
            "text": "Firstly, viewing IR as a database application offers a formal framework for complex query operators. This forces IR researchers to be precise on how to deal with more complex query operators and their edge cases. By expressing the ranking logic in query languages, it is not possible to resort to heuristics or shortcuts. This helps explaining the resulting rankings of documents. Secondly, a relational database offers a clean system architecture. Storage management is taken care of by the database engine, separating low level components shared in any data application from IR components. Thirdly, advances in database research offer benefits on systems build using databases. All performance gains in database engines will directly trickle down to the IR system. Fourthly, databases offer additional tools for error analysis. E.g., join together relevance judgement, document representations and the result set to generate scatter plots. Finally, it offers opportunities for rapid prototyping. Many IR researchers might not be interested in data management and query evaluation. This can be taken care of by the database engine, researches can focus on methods for ranking.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Motivation"
        },
        {
            "text": "In previous work [7] we argued how a graph query languages for IR also yield benefits for reproducible IR research.",
            "cite_spans": [
                {
                    "start": 17,
                    "end": 20,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Motivation"
        },
        {
            "text": "Industry has also shown an interest in graph databases in combination with full text IR. Neo4J, the most popular database 1 , supports graph analysis in combination with full text analysis using Lucene 2 . Lucene is however embedded in their graph query language, while we envision retrieval to be carried out by the same system that does the graph processing. Busch et al. [4] presented Earlybird, a system that allows continuous updates to be searched real-time. They show how updates can be processed in the context of inverted indexes. A similar approach could be taken in the context of graph databases. B\u00f6ttcher et al. [3] presented an approach how updates for compressed databases can be implemented efficiently by updating the data without decompressing all data.",
            "cite_spans": [
                {
                    "start": 374,
                    "end": 377,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 625,
                    "end": 628,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Motivation"
        },
        {
            "text": "How can keyword search be integrated with a graph query language? Many retrieval models make use of graph information, often graph-based models support traditional keyword search. When implementing graph-based models in a graph database, it should be able to integrate graph-based results with keyword search seamlessly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Research and Methodology"
        },
        {
            "text": "As shown by M\u00fchleisen et al. [10] , keyword search can be expressed as SQL queries over relational databases and executed efficiently. The goal of the proposed research is to extend this idea, and express keyword search in graph databases. This could be approached in two ways. One way would be to try to express the keyword ranking functions as structured queries in a graph query language. This could for example be achieved by representing documents and terms as properties in the graph e.g. vertices themselves, and translate classic keyword search algorithms to functions over the graph. Especially in the context of entity ranking, where entities are part of a knowledge base, this would make sense. Another approach would be to follow M\u00fchleisen et al., and represent the graph database as an extension on top of the relational database. Using the relational database as the core for a graph database would be a natural fit, as graph traversal algorithms can be expressed using recursive join operations. As keyword search can already be expressed in the relational database, combining keyword search with the additional graph information will computationally be cheap.",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 33,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Proposed Research and Methodology"
        },
        {
            "text": "What data structures and algorithms should be used when data is continuously updated? Often when IR systems are being developed, they are evaluated on static data. When deploying such a system to production, it might not be as effective or efficient when data is constantly changing. For example, index compression algorithms might assign document identifiers to documents according to their contents; delta gaps should be as small as possible. When data is constantly updated, many of these algorithms will not work. Graph data does tend to appear in the context when data constantly is changing. Ideally the data does not have to be re-indexed all the time, the underlying index can just be updated when changes to the data are being presented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Research and Methodology"
        },
        {
            "text": "In order for a graph database system to be useful in an IR context, it needs to be efficient in both handling updates to data and when it is used for ranking. In our research we want to investigate which algorithms and data structures can be used to efficiently handle both database transactions and retrieval.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposed Research and Methodology"
        },
        {
            "text": "When graph databases do support continuous updates, temporal graphs could be represented in the graph database. One could add timestamps to vertices to store useful temporal information of the graph (e.g. when the is vertex added). The question then arises how the temporal evolution of the graph should affect the ranking scores of the edges and/or vertices. Examples of usecases where this would be especially interesting include tweets and comments on videos, where not only their content but also their recency are relevant. Using a temporal graph database would also be an ideal setup to establish a connection between temporal decay and ranking in models for temporal summarizing as described in the Real-Time Summarization track [8] .",
            "cite_spans": [
                {
                    "start": 736,
                    "end": 739,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "How should edges/vertices be ranked in the presence of continuous updates?"
        },
        {
            "text": "Can a database be used in order to unify different stages in the ranking process? IR systems often consist of multiple parts that carry out different stages in the retrieval process. An initial ranker calculates an initial ranking score, e.g. BM25, over inverted indexes. After the initial ranking stage, a more effective, but computationally more expensive method re-ranks the top-k retrieved documents. This second stage re-ranker is often completely detached from the initial ranker, e.g. neural approaches and learning-to-rank methods are often implemented in different programming languages than the initial ranker. Data from the inverted index and results from the initial retrieval step, need to be copied in order for the re-ranking algorithm to work. Often re-ranking algorithms work with different data structures than inverted indexes do, so it might be necessary to restructure the data also. These mismatches between retrieval stages can introduce latency in the full retrieval pipeline. In order to avoid this latency, ideally the initial ranking stage and the re-ranking stage can be expressed in the same programming language using the same data structures such that latency introduced by re-ranking is only an effect of the re-ranking algorithm itself.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "How should edges/vertices be ranked in the presence of continuous updates?"
        },
        {
            "text": "Recently Raasveldt and M\u00fchleisen [11] presented DuckDB, an analytical embeddable database system. It has been specifically designed for executing analytical queries fast in an embedded environment. This research proposes to use DuckDB as a database backend for fast top-k retrieval by implementing methods as described by M\u00fchleisen et al. [10] . DuckDB has bindings for Python, the de facto language used for experiments with neural methods. DuckDB supports extracting the results of the issued queries directly to NumPy arrays, allowing for (neural) re-rankers to quickly start the re-ranking without first having to move the data. We want to investigate whether the results of M\u00fchleisen et al. [10] also hold for DuckDB. If so, latency introduced by moving data might be minimized, and re-ranking systems might be able to re-rank the top-k faster. Allowing more re-ranking methods to be deployed in production.",
            "cite_spans": [
                {
                    "start": 33,
                    "end": 37,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 339,
                    "end": 343,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 696,
                    "end": 700,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "How should edges/vertices be ranked in the presence of continuous updates?"
        },
        {
            "text": "Are graphs to correct abstraction level in the context for IR? One could argue that graphs are not the correct abstraction level in the context of IR. Specifically expressing keyword queries as graph database queries might make things more complex. We would argue that although this might be seen as a disadvantage, it would allow for more complex (graph inherent) structures to be integrated with keyword search more easily.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discussion"
        },
        {
            "text": "How should graphs be constructed for text documents? It would be possible to construct graphs from text documents in different ways. What would be the right granularity of the graph? Edges could represent terms in a document and link terms together when they appear in the same document. Maybe it would make more sense to express sentences or even documents as edges in the graph. For example in the context of the web, a document level graph could make sense. It would also make sense to change the granularity depending on the search task. When processing the text documents, should preprocessing (stopping, stemming) be integrated in the graph query language or should the graph query language only be used for querying the database retrieval time?",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discussion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Entity-Oriented Search",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Balog",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-93935-3"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Overview of the trec 2010 entity track",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Balog",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Serdyukov",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "P"
                    ],
                    "last": "De Vries",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Implementing efficient updates in compressed big text databases",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "B\u00f6ttcher",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "B\u00fcltmann",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Hartel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schl\u00fc\u00dfler",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Decker",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Lhotsk\u00e1",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Link",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Basl",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "DEXA 2013",
            "volume": "8056",
            "issn": "",
            "pages": "189--202",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-40173-2_17"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Earlybird: real-time search at twitter",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Busch",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Gade",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Larson",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Lok",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Luckenbill",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "J"
                    ],
                    "last": "Lin",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "2012 IEEE 28th International Conference on Data Engineering",
            "volume": "",
            "issn": "",
            "pages": "1360--1369",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "The task-dependent effect of tags and ratings on social media access",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Clements",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "P"
                    ],
                    "last": "De Vries",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J T"
                    ],
                    "last": "Reinders",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ACM Trans. Inf. Syst",
            "volume": "28",
            "issn": "4",
            "pages": "1--42",
            "other_ids": {
                "DOI": [
                    "10.1145/1852102.1852107"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Effective site finding using link anchor information",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Craswell",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hawking",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Robertson",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Proceedings of the 24th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval",
            "volume": "",
            "issn": "",
            "pages": "250--257",
            "other_ids": {
                "DOI": [
                    "10.1145/383952.383999"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Reproducible IR needs an (IR) (graph) query language",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Kamphuis",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "P"
                    ],
                    "last": "De Vries",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the Open-Source IR Replicability Challenge Co-Located with 42nd International ACM SIGIR Conference on Research and Development in Information Retrieval",
            "volume": "",
            "issn": "",
            "pages": "17--20",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Overview of the TREC 2017 real-time summarization track",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Building enriched document representations using aggregated anchor text",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Metzler",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Novak",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cui",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Reddy",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the 32nd International ACM SIGIR Conference on Research and Development in Information Retrieval",
            "volume": "",
            "issn": "",
            "pages": "219--226",
            "other_ids": {
                "DOI": [
                    "10.1145/1571941.1571981"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Old dogs are great at new tricks: column stores for IR prototyping",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "M\u00fchleisen",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Samar",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "De Vries",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Proceedings of the 37th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval, SIGIR 2014",
            "volume": "",
            "issn": "",
            "pages": "863--866",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "DuckDB: an embeddable analytical database",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Raasveldt",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "M\u00fchleisen",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the ACM SIGMOD International Conference on Management of Data",
            "volume": "",
            "issn": "",
            "pages": "1981--1984",
            "other_ids": {
                "DOI": [
                    "10.1145/3299869.3320212"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Online news tracking for adhoc information needs",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "B"
                    ],
                    "last": "Vuurens",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "P"
                    ],
                    "last": "De Vries",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Blanco",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Mika",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 2015 International Conference on The Theory of Information Retrieval",
            "volume": "",
            "issn": "",
            "pages": "221--230",
            "other_ids": {
                "DOI": [
                    "10.1145/2808194.2809474"
                ]
            }
        }
    },
    "ref_entries": {},
    "back_matter": [
        {
            "text": "Acknowledgements. This work is part of the research program Commit2Data with project number 628.011.001 (SQIREL-GRAPHS), which is (partly) financed by the Netherlands Organisation for Scientific Research (NWO).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}