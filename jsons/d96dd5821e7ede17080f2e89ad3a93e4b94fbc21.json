{
    "paper_id": "d96dd5821e7ede17080f2e89ad3a93e4b94fbc21",
    "metadata": {
        "title": "A Logic for Reflective ASMs",
        "authors": [
            {
                "first": "Klaus-Dieter",
                "middle": [],
                "last": "Schewe",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "UIUC Institute",
                    "location": {
                        "settlement": "Haining",
                        "country": "China"
                    }
                },
                "email": "kd.schewe@intl.zju.edu.cn"
            },
            {
                "first": "Flavio",
                "middle": [],
                "last": "Ferrarotti",
                "suffix": "",
                "affiliation": {},
                "email": "flavio.ferrarotti@scch.at"
            }
        ]
    },
    "abstract": [
        {
            "text": "Reflective algorithms are algorithms that can modify their own behaviour. Recently a behavioural theory of reflective algorithms has been developed, which shows that they are captured by reflective abstract state machines (rASMs). Reflective ASMs exploit extended states that include an updatable representation of the ASM signature and rules to be executed by the machine in that state. Updates to the representation of ASM signatures and rules are realised by means of a sophisticated tree algebra defined in the background of the rASM. In this paper the theory is taken further by an extension of the logic of ASMs to capture inferences on rASMs. The key is the introduction of terms that are interpreted by ASM rules stored in some location. We show that fragments of the logic with a fixed bound on the number of steps preserve completeness, whereas the full run-logic for rASMs becomes incomplete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Reflection refers to the ability of an algorithm or program to modify its own behaviour. The concept is as old as computer science; it already appears in LISP [16] , where programs and data are both represented uniformly as lists. General run-time and compile-time linguistic reflection in programming and database research have been investigated in general by Stemple, Van den Bussche and others in [18, 19] . Recently, adaptivity and thus reflection has become a key aspect of (cyber-physical) systems [7] . Nonetheless, it is still not well understood and contains great challenges and risks. As it is hard to oversee how a system behaves after many adaptations, any uncontrolled application of reflection bears the risk of unpredictable and undesired outcomes. Thus, the challenge for rigorous methods is to enable static reasoning and verification of desired properties of reflective algorithms and systems, which requires to control an unbounded family of specifications.",
            "cite_spans": [
                {
                    "start": 159,
                    "end": 163,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 400,
                    "end": 404,
                    "text": "[18,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 405,
                    "end": 408,
                    "text": "19]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 504,
                    "end": 507,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Concerning the foundations of reflection we developed a behavioural theory of reflective sequential algorithms (RSAs) in [12] (see arXiv version in [9] ), which extends and cleanses our previous sketch in [2] . The theory provides an axiomatic, language-independent definition of RSAs, defines an extension of sequential ASMs to reflective sequential ASMs (rsASMs), by means of which RSAs can be specified, and provides a proof that RSAs are captured by rsASMs. That is, rsASMs satisfy the postulates of the axiomatisation, and any RSA as stipulated by the axiomatisation can be defined by a behaviourally equivalent rsASM. The notion of behavioural equivalence is slightly weaker than the corresponding notion for sequential or parallel algorithms, as there is no need to require that changes to the represented algorithm are exactly the same, as long as the application of the algorithm to the core part of the structure yields the same results.",
            "cite_spans": [
                {
                    "start": 121,
                    "end": 125,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 148,
                    "end": 151,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 205,
                    "end": 208,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In [13] we sketched how to generalise the theory to reflective parallel algorithms [11] , which requires an integration of the behavioural theory of synchronous parallel algorithms [3] . Leaving this general aspect aside the generalisation of just the reflective sequential ASMs to reflective ASMs is rather straightforward. For deterministic ASMs this was done in [10] . In a nutshell, in each step of a reflective ASM (rASM) the rule is taken from a dedicated location self , which uses a tree structure to represent the signature and rule, and a sophisticated tree algebra to manipulate tree values [14] . We also exploit partial updates in the form of [15] to minimise clashes that may otherwise result from simultaneously updating self by several parallel branches.",
            "cite_spans": [
                {
                    "start": 3,
                    "end": 7,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 83,
                    "end": 87,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 181,
                    "end": 184,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 365,
                    "end": 369,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 602,
                    "end": 606,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 656,
                    "end": 660,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper we address the fundamental question how desired properties of a reflective algorithm can be verified. As rASMs capture reflective algorithms, this requires extending the logic of ASMs [4, 5, 17] . We observe that in these logics the rules defining an ASM only enter as extra-logical constants r that are expanded in atomic formulae [r]\u03d5 (the application of r to the current state leads to a state satisfying the formula \u03d5), upd(r, X) (the rule r yields an update set X in the current state), and upm(r,\u1e8c) (the rule r yields an update multiset\u1e8c in the current state). In an rASM, however, the rule to be applied in the current state is stored itself in the state in a sublocation of a location self . We therefore explore the idea to treat r in formulae as variables that are interpreted by a rule stored in the current state. Furthermore, as reasoning about reflective algorithms only makes sense for multiple steps, we also extend the one-step ASM logic to a multiple-step logic. The precise definition of such a logic and the completeness proof for a fragment of the logic are the key contributions of this paper.",
            "cite_spans": [
                {
                    "start": 198,
                    "end": 201,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 202,
                    "end": 204,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 205,
                    "end": 208,
                    "text": "17]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In Sect. 2 we present rASMs as extensions of ASMs. Section 3 is dedicated to the introduction of the logic of ASMs, which follows our previous work in [4] . The core of the paper is Sect. 4, where we formally develop the extension of the logic dealing with reflection and investigate completeness. We conclude with a brief summary and outlook in Sect. 5.",
            "cite_spans": [
                {
                    "start": 151,
                    "end": 154,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We assume general familiarity with ASMs as defined in [1] . The extension to reflective ASMs requires to define a background structure that covers trees and operations on them, a dedicated variable self that takes as its value a tree representation of an ASM signature and rule, and the extension of rules by partial updates. Due to space limitations our presentation must be terse-nevertheless the details are given in [9, 10, 12] . Note that the omitted details include the sophisticated tree algebra defined for the representation of rules and the access to them. We use some of its operators, but they can be correctly understood from the context.",
            "cite_spans": [
                {
                    "start": 54,
                    "end": 57,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 420,
                    "end": 423,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 424,
                    "end": 427,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 428,
                    "end": 431,
                    "text": "12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "Let \u03a3 be an ASM signature, i.e. a set of function symbols. Partial assignments are defined as follows: Whenever f \u2208 \u03a3 has arity n and op is an operator of arity m + 1, t i (i = 1, . . . , n) and t i (i = 1, . . . , m) are terms over \u03a3, then f (t 1 , . . . , t n ) \u21d4 op t 1 , . . . , t m is a rule. The informal meaning is that we evaluate the terms as well as f (t 1 , . . . , t n ) in the current state S, then apply op to val S (f (t 1 , . . . , t n )), val S (t 1 ), . . . , val S (t m ) and assign the resulting value v to the location (f, (val S (t 1 ), . . . , val S (t n ))). Conditions for compatibility and the collapse of an update multiset into an update set have been elaborated in detail in [15] .",
            "cite_spans": [
                {
                    "start": 704,
                    "end": 708,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "For the dedicated location storing the self-representation of an ASM it is sufficient to use a single function symbol self of arity 0. Then in every state S the value val S (self ) is a complex tree comprising two subtrees for the representation of the signature and the rule, respectively. That is, in the tree structure we have a root node o labelled by self with exactly two successor nodes, The inductive definition of trees representing rules is rather straightforward. For instance, an assignment rule f (t 1 , . . . , t n ) := t 0 is represented by a tree of the form update func f term t 1 . . . t n term t 0 , and a partial assignment rule f (t 1 , . . . , t n ) \u21d4 op t 1 , . . . , t m is represented by a tree of the form",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "The background of an rASM is defined by a background class K over a background signature V K . It must contain an infinite set reserve of reserve values and an infinite set \u03a3 res of reserve function symbols, the equality predicate, the undefinedness value undef, and a set L of labels self, signature, rule, func, name, arity, update, term, if, bool, par, let, partial. The background class must further define truth values and their connectives, tuples and projection operations on them, natural numbers and operations on them, trees in T L and tree operations, and the function I, where Ix.\u03d5 denotes the unique x satisfying condition \u03d5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "If B is a base set, then an extended base set is the smallest set B ext containing B that is closed under adding function symbols in the reserve \u03a3 res , natural numbers, the terms T with respect to B and \u03a3 res , and terms of the tree algebra defined over \u03a3 res with labels in L as defined above. Furthermore, we useT ext to denote the union of the set T ext of terms with \u03a3 ext and the set of rules.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "The background must further provide functions: drop :T ext \u2192 B ext and raise : B ext \u2192T ext for each base set B and extended base set B ext , and a derived extraction function \u03b2 : T ext \u2192 n\u2208N T n , which assigns to each term defined over the extended signature \u03a3 ext and the extended base set B ext a tuple of terms in T defined over \u03a3 and B.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "A reflective ASM (rASM) M comprises an (initial) signature \u03a3 containing a 0-ary function symbol self , a background as defined above, and a set I of initial states over \u03a3 closed under isomorphisms such that any two states I 1 , I 2 \u2208 I coincide on self . Furthermore, M comprises a state transition function \u03c4 on states over extended signature \u03a3 S with \u03c4 (S) = S +\u0394 rS (S), where the rule r S is defined as raise(rule(val S (self ))) over the signature \u03a3 S = raise(signature(val S (self ))).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "In this definition we use extraction functions rule and signature defined on the tree representation of a sequential ASM in self . These are simply defined as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reflective Abstract State Machines"
        },
        {
            "text": "We now look briefly into a simplified version of the logic of non-deterministic ASMs as defined in [4] . The simplification concerns the distinction between dbterms and algorithmic terms that is necessary, if explicit meta-finite states are considered. Here we just consider a single uniform signature \u03a3, so terms are defined in the usual way. However, we have to keep in mind that rASMs have a rich set of operators in their background that are used to build terms. Furthermore, as we are dealing with non-determinism there is a need to consider also \u03c1-terms of the form \u03c1 v (t | \u03d5), where \u03c1 is a multiset operator defined in the background, \u03d5 is a formula, t is a term, and v is a variable. A pure term is defined as a term that does not contain any sub-term which is a \u03c1-term.",
            "cite_spans": [
                {
                    "start": 99,
                    "end": 102,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "In order to define formulae inductively we extend the set of first-order variables with a countable set of second-order (relation) variables of arity r for each r \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "1. If s and t are terms, then s = t is a formula. 2. If t 1 , . . . , t r are terms and X is a second-order variable of arity r, then X(t 1 , . . . , t r ) is a formula. 3. If r is a rule and X is a second-order variable of arity 3, then upd(r, X) is a formula. 4. If r is a rule and\u1e8c is a second-order variable of arity 4, then upm(r,\u1e8c) is a formula. 5. If \u03d5 and \u03c8 are formulae and x is a first-order variable, then \u00ac\u03d5, \u03d5 \u2228 \u03c8 and \u2200x(\u03d5) are formulae.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "6. If \u03d5 is a formula and X is a second-order variable, then \u2200X(\u03d5) is a formula. 7. If \u03d5 is a formula and X is a second-order variable of arity 3, then [X]\u03d5 is a formula.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "Note that we use second-order variables of arity 3 and 4 to capture update sets and update multisets, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "The semantics of the logic is defined by Henkin structures. A Henkin prestructure S is a state of signature \u03a3 with base set B extended with a new universe D n of n-ary relations for each n \u2265 1, where D n \u2286 P(B n ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "Variable assignments \u03b6 into a Henkin prestructure S are defined as usual: \u03b6(x) \u2208 B for each first-order variable x, and \u03b6(X) \u2208 D n for each second-order variable X of arity n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "Then the interpretation of a term in a Henkin prestructure S with a variable assignment \u03b6 is defined as usual; for \u03c1-",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "We extend this interpretation to formulae. For a second-order variable X of arity 3 we abuse the notation by writing val S,\u03b6 ",
            "cite_spans": [
                {
                    "start": 121,
                    "end": 124,
                    "text": "S,\u03b6",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "-If \u03d5 is of the form X(t 1 , . . . , t r ), then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "-If \u03d5 is of the form upd(r, X), then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "-If \u03d5 is of the form upm(r,\u1e8c), then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "-If \u03d5 is of the form \u2200x(\u03c8), then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "-If \u03d5 is of the form \u2200X(\u03c8), where X is a second-order variable of arity n, then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "For a sentence \u03d5 to be valid in the given Henkin semantics, it must be true in all Henkin prestructures. This is a stronger requirement than saying that \u03d5 is valid in the standard Tarski semantics. A sentence that is valid in Tarski semantics is true in those Henkin prestructures, for which each universe D n is the set of all relations of arity n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "The universes D n of the Henkin prestructures should not be arbitrary collections of n-ary relations. Thus, it is reasonable to restrict our attention to some collections of n-ary relations that we can define, i.e. we restrict our attention to Henkin structures.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "A Henkin structure is a Henkin prestructure S that is closed under definability, i.e. for every formula \u03d5, variable assignment \u03b6 and arity n \u2265 1, we have that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "The main result in [4] states that the logic for ASMs defined here is complete with respect to Henkin semantics.",
            "cite_spans": [
                {
                    "start": 19,
                    "end": 22,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "The Logic of Abstract State Machines"
        },
        {
            "text": "Let us now investigate the extension of the logic above to handle reflection. The main difference of rASMs to ordinary ASMs is that in each step a different rule r is applied, and this rule is part of the current state. In the one-step logic of ASMs described in the previous section a rule is treated as a fixed extra-logical constant appearing only in formulae of the form upd(r, X) and upm(r,\u1e8c), and the meaning of these formulae depends on the actual rule r.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Reasoning About Reflection"
        },
        {
            "text": "In an rASM val S (self ) is a tree value t and rule(t) (defined at the end of Sect. 2) is the subtree representing the actual rule of the rASM in state S. Then raise(rule(val S (self ))) is the rule r S of the rASM in state S, or phrased differently, we obtain this rule by interpretation of the term",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "That is, the only extension to the logic required to capture reflection is the treatment of the first argument of upd(r, X) and upm(r,\u1e8c) as a term that is then evaluated in the state S. If the result is not a rule, these formulae remain undefined.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "However, for a single machine step this extension is rather irrelevant, as in an rASM the main rule does not change within a single step. Thus, we have to take multiple steps into account. For these we introduce two additional predicates r-upd and r-upm with the following informal meaning:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "-r-upd(n, X) means that n steps of the reflective ASM yield the update set X, where in each step the actual value of self is used. -r-upm(n,\u1e8c) means that n steps of the reflective ASM yield the update mul-tiset\u1e8c.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "To be more precise, X and\u1e8c in predicates r-upd(n, X) and r-upd(n,\u1e8c) are the union of the n update sets and n updates multisets, respectively, yielded by the reflective ASM in n steps. Clearly, we have r-upd(1, X) \u2194 upd(therule, X), and analogously, r-upm(1, X) \u2194 upm(therule,\u1e8c). For the generalisation to arbitrary values of n we exploit the definition of upd(r, X) and upm(r,\u1e8c) for sequence rules to inductively define axioms for r-upd and r-upm. We further need the definition of consistent update sets in the logic:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "for the set F dyn of constants representing the dynamic function symbols in \u03a3. Then we can use con(r, X) to expresses that X represents one of the possible update sets generated by a rule r and that X is consistent: con(r, X) \u2261 upd(r, X) \u2227 conUSet(X).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "We further define r-upd(n + 1, X) \u2194 r-upd(1, X) \u2227 \u00acconUSet(X) \u2228 x, y) ))) as well as",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 64,
                    "end": 69,
                    "text": "x, y)",
                    "ref_id": null
                }
            ],
            "section": "Extension of the Logic of ASMs"
        },
        {
            "text": "Let L (r) asm denote the logic of rASMs resulting from these extensions using therule and predicates r-upd(n, X) and r-upm(n, X) for arbitrary n. Let L r asm denote the further extended logic of rASMs, in which in addition quantification over n is permitted. Let us call L (r) asm the multi-step logic of rASMs, and L r asm the run logic of rASMs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness"
        },
        {
            "text": "Even without updating the rule in every step it is obvious that the run logic L r asm subsumes a full dynamic logic over runs of ASMs. As such it is impossible to achieve completeness.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Completeness"
        },
        {
            "text": "Concerning the multi-step logic L (r) asm of rASMs the situation is not so obvious. We may continue a sublogic L (r,n) asm using a fixed value of n and formulae of the form r-upd(m, X) and r-upm(m, X) with fixed m \u2264 n. For such a sublogic we can extend the completeness result of the logic of ASMs using similar arguments. The remaining part of this section is dedicated to prove this key result. First note that every subformulae of the form r-upd(m, X) and of the form r-upm(m, X) that occurs in a L (r,n) asm -formulae can be replaced by their corresponding definitions above. This is possible, because we have only bounded finite values for m = 1 . . . n to consider.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "Thus, the axioms and rules of the derivation system remain the same as for the logic of ASMs [4, 5] . Starting point is the natural formalism L 2 as defined in [6] for the relational variant of second-order logic on which the logic is based. L 2 uses the usual axioms and rules for first-order logic, with quantifier rules applying to second-order variables as well as first-order variables, and with the stipulation that the range of the second-order variables includes at least all the relations definable by the formulae of the language. A deductive calculus for L 2 is obtained by augmenting the axioms and inference rules of first-order logic as follows:",
            "cite_spans": [
                {
                    "start": 93,
                    "end": 96,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 97,
                    "end": 99,
                    "text": "5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 160,
                    "end": 163,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "-\u2203X\u2200v 1 , . . . , v k (X(v 1 , . . . , v k ) \u2194 \u03d5), where k \u2265 1, v 1 , . . . , v k are first-order variables, and X is a k-ary second-order variable that does not occur freely in the formula \u03d5.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 22,
                    "end": 71,
                    "text": "(X(v 1 , . . . , v k ) \u2194 \u03d5), where k \u2265 1, v 1 , .",
                    "ref_id": null
                }
            ],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "provided the arity of X and Y coincides.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "-",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "In addition to these axioms and rules and standard axioms and rules for first-order logic with equality, the logic L (r,n) asm comprises the following: -The axioms for upd(r, X) and upm(r, X). Since here we do not need to consider explicit meta-finite states, these axioms are a simplified version of Axioms U1-U7 and Axioms\u00dc1-\u00dc7 in Section 7.2 and 7.3 in [4] , respectively. For instance, Axiom U1 which states that X represents an update set yielded by the assignment rule f (t) := s iff it contains exactly one update and this update is ((f, t) , s), can be written as:",
            "cite_spans": [
                {
                    "start": 356,
                    "end": 359,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [
                {
                    "start": 540,
                    "end": 547,
                    "text": "((f, t)",
                    "ref_id": null
                }
            ],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "-The distribution axiom and the necessitation rule from the axiom system K of modal logic, and modus ponens, which allow us to derive all modal properties that are valid in Kripke frames. -The axiom \u00acconUSet(X) \u2192 [X]\u03d5 asserting that if an update set X is not consistent, then there is no successor state obtained from applying X to the current state-thus [X]\u03d5 is interpreted as true for any formula \u03d5. -The rule of universal generalisation",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "if v is not free in \u03c8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "-The axiom",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "from dynamic logic asserting that executing a sequence rule is equivalent to executing its sub-rules sequentially.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "-The extensionality axiom",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "For the proof of completeness we proceed in the same way as for the corresponding completeness proof for the logic of ASMs in [4] . First for operators defined in the background, in particular the multiset functions used in \u03c1-terms, are treated as standard non-axiomatised functions. This allows us to assume without loss of generality that formulae do not contain \u03c1-terms.",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 129,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "Then we turn formulae into variants of formulae of first-order logic with types. For this we create a modified signature \u03a3 T , which contains the function symbols from \u03a3, a unary relation symbol T n for each n \u2265 1, an (n + 1)-ary relation symbol E n for each n \u2265 1, and unary relation symbols T 0 and T r . With these we proceed as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "1. Turn formulae upd(r, X) and upm(r, X) into formulae of the form T r (x) \u2192 upd(x, X) and T r (x) \u2192 upm(x, X), where T r (x) asserts that x is a tree term representing a rule. 2. Bring all remaining atomic formulae into the form v 1 = v 2 , f (v 2 ) = v 1 or X(v 1 , . . . , v n ). 3. Eliminate all modal operators expressing them by means of the formula conUSet(X). 4. Replace each atomic (second-order) formula of the form X(t 1 , . . . , t n ) by E n (t 1 , . . . , t n , X), and relativise quantifiers over individuals using T , and quantifiers over n-ary relations in D n for some n \u2265 1 to T n .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "The main difference to the similar reduction applied in [4] is that subformulae upd(r, X) and upm(r, X) cannot be completely eliminated. However, by using T r and tree terms we turn these formulae into first-order formulae with types. Then the axioms for upd(r, X) and upm(r, X) have to be adapted to this modification as well. In the case of upd, we define a new axiom that replaces Axioms U1-U7 and has the form",
            "cite_spans": [
                {
                    "start": 56,
                    "end": 59,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "where \u03d5 U 1 , . . . , \u03d5 U 7 are modified versions of the formulae in the right-hand side of Axioms U1-U7, respectively. In particular, \u03d5 U 1 can be defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "Note that for simplicity we have assumed, w.l.o.g. (see [4] among others), that the arity of the functions in the update rules is 1.",
            "cite_spans": [
                {
                    "start": 56,
                    "end": 59,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "Due to space limitations, we leave the definition of the remaining formulae \u03d5 U 2 , . . . , \u03d5 U 7 as a simple exercise to the reader. Likewise the definition of a new axiom that replaces Axioms\u00dc1-\u00dc7 is also left as an easy exercise to the reader.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "asm is true in a Henkin prestructure S iff the transformed formula \u03d5 * is true in a first-order structure S * over \u03a3 T that is uniquely determined by S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "The first direction of Lemma 1, i.e., if an L (r,n) asm -formula \u03d5 is true in S, then \u03d5 * is true in S * , can be proven by structural induction. We only need to apply the transformation described above to each of the cases in the definition of the set of L (r,n) asm -formulae and then check that the resulting first-order formulae is satisfied by the corresponding state S * . Likewise, the second direction of Lemma 1 can be proven by structural induction on the definition of first-order formulae, in this case using the inverse of the transformation described above. We omit these proofs since both are quite long, but technically straightforward.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "Thus, if \u03d5 * is valid, then \u03d5 is true in all Henkin structures. Note that the converse does not always hold. For instance \u2203x(x = x) is true in all Henkin structures (since by definition the domain of S is not empty), but \u2203x(T 0 (x)\u2227(x = x)) is not valid. In general, not every \u03a3 T -structure is an S * structure for some Henkin \u03a3-structure S. However, if a \u03a3 T -structure S * satisfies the following properties, then it corresponds to a Henkin structure S (cf. [6] ):",
            "cite_spans": [
                {
                    "start": 461,
                    "end": 464,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. The run logic L r asm of rASMs is incomplete."
        },
        {
            "text": "-T r (c) for nullary function symbols self \u2208 \u03a3,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u03a3-correctness:"
        },
        {
            "text": "-T 0 (c) for all nullary function symbols c \u2208 \u03a3 other than self , and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u03a3-correctness:"
        },
        {
            "text": "2. Non-emptiness: \u2203x(T 0 (x) \u2228 T r (x)). 3. Disjointness:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u03a3-correctness:"
        },
        {
            "text": "4. Elementhood: E n (x 1 , . . . , x n , y) \u2192 T n (y) \u2227 (T 0 (x 1 ) \u2228 T r (x 1 )) \u2227 \u00b7 \u00b7 \u00b7 \u2227 (T 0 (x n ) \u2228 T r (x n )) for n \u2265 1. 5. Extensionality: T n (x) \u2227 T n (y) \u2227 \u2200z(E n (z, x) \u2194 E n (z, y)) \u2192 x = y for n \u2265 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u03a3-correctness:"
        },
        {
            "text": "6. Comprehension: \u2203y\u2200x(E n (x, y) \u2194 \u03c8) for n \u2265 1 and y non-free in \u03c8.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "\u03a3-correctness:"
        },
        {
            "text": "A is a first-order structure of signature \u03a3 T which satisfies properties 1-6 above and sub(A) is the sub-structure of A induced by the elements of n\u22650 (T n ) A \u222a (T r ) A , then for some Henkin structure S of signature \u03a3, sub(A) is the structure S * determined by S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "Proof. Given A with domain dom(A), we define S as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "-For each n \u2265 1, the universe D n of n-ary relations consists of the sets {\u0101 \u2208 (dom(S)) n | (E n ) A (\u0101, s)} for all s \u2208 (T n ) A . -The interpretation of function symbols f \u2208 \u03a3 is the same as in A but restricted to arguments from dom(S).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "By the \u03a3-correctness, non-emptiness and comprehension properties of A, we get that S is a Henkin structure. We claim that sub(A) is isomorphic to S * via function g :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "First, we note that g is well defined by the disjointness property and by the fact that, by definition of S and S * , every element x in dom(S * ) is in n\u22650 (T n ) S * \u222a (T r ) S * . That g is surjective follows from the definition of S * from A and the fact that dom(sub(A)) is the restriction of dom(A) to dom(S * ). By the extensionality property, we get that g is injective. By definition we get that g preserves the function symbols in \u03a3 as well as the relation symbols T n for every n \u2265 0. Finally, for every n \u2265 1, we get that g preserves E n by the elementhood property.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "Let \u03a8 be the set of formulae listed under properties 1-6 above, we obtain the following Henkin style completeness theorem:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "asm -formula \u03d5 is true in all Henkin structures iff \u03d5 * is derivable in first-order logic from \u03a8 (i.e., iff \u03a8 \u03d5 * ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "Proof. Assume that \u03a8 \u03d5 * , and let S be a Henkin structure. Then S * |= \u03a8 and therefore S * |= \u03d5 * . By Lemma 1, we get that S |= \u03d5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "Conversely, assume that \u03d5 is true in all Henkin structures. Towards showing \u03a8 |= \u03d5 * , let us assume that A |= \u03a8 , and let sub(A) be its substructure generated by the elements of n\u22650 (T n ) A \u222a (T r ) A . Then by Lemma 2, sub(A) = S * for some first-order structure S * determined by a Henkin structure S. Since by assumption we have that S |= \u03d5, it follows from Lemma 1 that S * |= \u03d5 * and therefore sub(A) |= \u03d5 * . But each quantifier in \u03d5 * is relativised to (T n ) A for some n \u2265 1, and then we also have that A |= \u03d5 * . We have shown that \u03a8 |= \u03d5 * , and then, by the completeness theorem of first-order logic, we get that \u03a8 \u03d5 * .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "It is easy to see that the proof system that we have described earlier in this section is sound. Thus, if \u03d5 is a formula derivable in L (r,n) asm , then \u03d5 is true in all Henkin structures. It is then immediate from Theorem 3 that \u03d5 * is derivable in first-order logic from \u03a8 . On the other hand, via an easy but lengthy induction on the length of the derivations, we get the following. Lemma 3. \u03d5 * is derivable in first-order from \u03a8 iff \u03d5 is derivable in L (r,n) asm .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "Theorem 3 and Lemma 3 immediately imply that L (r,n) asm is complete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. If"
        },
        {
            "text": "We have shown before that reflective algorithms are captured by reflective abstract state machines (rASMs), which exploit extended states that include an updatable representation of the main ASM rule to be executed by the machine in that state. Updates to the representation of ASM signatures and rules are realised by means of a sophisticated tree algebra. This enables the rigorous specification of reflective algorithms and thus adaptive systems and is one step in the direction of controlling the risk associated with systems that can change their own behaviour.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "In this paper we made another step in this direction by providing an extension of the logic of ASMs to rASMs. For this we replaced extra-logical constants representing rules by terms that are subject to interpretation in the current state. As reasoning about reflective algorithms only makes sense for multiple steps, we also extend the one-step ASM logic to a multiple-step logic, and prove that for a sublogic with the number of steps bound to a fixed constant we preserve the completeness of the logic, whereas the logic in general will be incomplete.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "By providing such a logic we show that it is possible to reason statically over specifications that are highly dynamic and even unbounded in the sense that the behaviour of the system after a sequence of adaptations is not known at all at the time the system is specified. This is of tremendous importance for the application of rigorous methods to truly adaptive systems. Even more, by showing that fragments of the logic that deal with bounded sequences of steps are still complete we even enable tool support for such reasoning.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "The use of the logic in an extension of proof obligations for the refinement of rASMs in the line of [8] will be the next step in our research.",
            "cite_spans": [
                {
                    "start": 101,
                    "end": 104,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Abstract State Machines",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "B\u00f6rger",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "St\u00e4rk",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-36498-6"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A behavioural theory for reflective sequential algorithms",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                },
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Tec",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "PSI 2017",
            "volume": "10742",
            "issn": "",
            "pages": "117--131",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-74313-4_10"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A new thesis concerning synchronised parallel computing -simplified parallel ASM thesis",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                },
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Tec",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci",
            "volume": "649",
            "issn": "",
            "pages": "25--53",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "A complete logic for Database Abstract State Machines",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                },
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Tec",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Logic J. IGPL",
            "volume": "25",
            "issn": "5",
            "pages": "700--740",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A unifying logic for nondeterministic, parallel and concurrent Abstract State Machines",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                },
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Tec",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Ann. Math. Artif. Intell",
            "volume": "83",
            "issn": "3-4",
            "pages": "321--349",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Higher order logic",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Leivant",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Handbook of Logic in Artificial Intelligence and Logic Programming",
            "volume": "2",
            "issn": "",
            "pages": "229--322",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Towards ASM-based formal specification of selfadaptive systems",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ABZ 2014",
            "volume": "8477",
            "issn": "",
            "pages": "204--209",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-43652-3_17"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Verification of ASM refinements using generalized forward simulation",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "J. UCS",
            "volume": "7",
            "issn": "11",
            "pages": "952--979",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Behavioural theory of reflective algorithms I: reflective sequential algorithms",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Concurrent reflective Abstract State Machines. In: 19th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing",
            "authors": [
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "30--35",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Behavioural theory of reflective algorithms II: reflective parallel algorithms",
            "authors": [
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Behavioural theory of reflective algorithms I: reflective sequential algorithms",
            "authors": [
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Evolving concurrent systems: behavioural theory and logic",
            "authors": [
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ferrarotti",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Tec",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "An",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the Australasian Computer Science Week Multiconference",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "XML database transformations",
            "authors": [
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. UCS",
            "volume": "16",
            "issn": "20",
            "pages": "3043--3072",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Partial updates in complex-value databases",
            "authors": [
                {
                    "first": "K.-D",
                    "middle": [],
                    "last": "Schewe",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Information and Knowledge Bases XXII",
            "volume": "225",
            "issn": "",
            "pages": "37--56",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Reflection and semantics in LISP",
            "authors": [
                {
                    "first": "B",
                    "middle": [
                        "C"
                    ],
                    "last": "Smith",
                    "suffix": ""
                }
            ],
            "year": 1984,
            "venue": "Proceedings of the 11th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages",
            "volume": "",
            "issn": "",
            "pages": "23--35",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A logic for abstract state machines",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "St\u00e4rk",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Nanchen",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "J. Univ. Comput. Sci",
            "volume": "7",
            "issn": "11",
            "pages": "952--979",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Type-safe linguistic reflection: a generator technology",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Stemple",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Fully Integrated Data Environments",
            "volume": "",
            "issn": "",
            "pages": "158--188",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Reflective programming in the relational algebra",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Van Den Bussche",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Van Gucht",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Vossen",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "J. Comput. Syst. Sci",
            "volume": "52",
            "issn": "3",
            "pages": "537--549",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "say o 0 and o 1 , labelled by signature and rule, respectively. So we have o \u227a c o 0 , o 0 \u227a s o 1 and o \u227a c o 1 , where \u227a c and \u227a s denote, respectively, the child and sibling relationships. The subtree rooted at o 0 has as many children o 00 , . . . , o 0k as there are function symbols in the signature, each labelled by func. Each of the subtrees rooted at o oi takes the form func name f arity n with a function name f and a natural number n. The subtree rooted at o 1 represents the rule of a sequential ASM as a tree.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "For each n \u2208 N the bounded fraction L (r,n) asm of the multi-step logic L (r) asm of rASMs is complete.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "-The axiom \u00ac[X]\u03d5 \u2192 [X]\u00ac\u03d5 describing the deterministic accessibility relation in terms of [X]. -The Barcan axiom \u2200v([X]\u03d5) \u2192 [X]\u2200v(\u03d5), where v is a first-order or secondorder variable. -Axioms \u03d5 \u2227 upd(r, X) \u2192 [X]\u03d5 and con(r, X) \u2227 [X]\u03d5 \u2192 \u03d5 for static and pure \u03d5 asserting that the interpretation of static and pure formulae is the same in all states. -The frame axiom conUSet(X) \u2227 \u2200z(\u00acX(c f , x, z)) \u2227 f (x) = y \u2192 [X]f (x) = y and the update axiom conUSet(X) \u2227 X(c f , x, y) \u2192 [X]f (x) = y asserting the effect of applying an update set. -The axiom upm(r, X) \u2192 \u2203Y (upd(r, Y )) stating that if a rule r yields an update multiset, then it also yields an update set. -The restricted axiom of universal instantiation \u2200v(\u03d5(v)) \u2192 \u03d5[t/v], if \u03d5 is pure or t is static, t is a term free for v in \u03d5(v).",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}