{
    "paper_id": "eec6907f57648072bf02622a2e13dea97fd012eb",
    "metadata": {
        "title": "Formal Verification of Interoperability Between Future Network Architectures Using Alloy",
        "authors": [
            {
                "first": "Mohammad",
                "middle": [],
                "last": "Jahanian",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Riverside",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Jiachen",
                "middle": [],
                "last": "Chen",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Rutgers University",
                    "location": {
                        "addrLine": "North Brunswick",
                        "region": "NJ",
                        "country": "USA"
                    }
                },
                "email": "jiachen@winlab.rutgers.edu"
            },
            {
                "first": "K",
                "middle": [
                    "K"
                ],
                "last": "Ramakrishnan",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Riverside",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "The Internet is composed of many interconnected, interoperating networks. With the recent advances in Future Internet design, multiple new network architectures, especially Information-Centric Networks (ICN) have emerged. Given the ubiquity of networks based on the Internet Protocol (IP), it is likely that we will have a number of different interconnecting network domains with different architectures, including ICNs. Their interoperability is important, but at the same time difficult to prove. A formal tool can be helpful for such analysis. ICNs have a number of unique characteristics, warranting formal analysis, establishing properties that go beyond, and are different from, what have been used in the state-of-the-art because ICN operates at the level of content names rather than node addresses. We need to focus on node-to-content reachability, rather than node-to-node reachability. In this paper, we present a formal approach to model and analyze information-centric interoperability (ICI). We use Alloy Analyzer's model finding approach to verify properties expressed as invariants for information-centric services (both pull and push-based models) including content reachability and returnability. We extend our use of Alloy to model counting, to quantitatively analyze failure and mobility properties. We present a formally-verified ICI framework that allows for seamless interoperation among a multitude of network architectures. We also report on the impact of domain types, routing policies, and binding techniques on the probability of content reachability and returnability, under failures and mobility.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Today's computer networks, the Internet being a dominant example, are heavily used to fulfill users' information-centric needs: users primarily seek information over the network without necessarily wanting to focus on its location or the underlying mechanisms used to retrieve it [9] . However, the current way of using \"location-based\" access in IP networks results in a less convenient and less efficient means for information retrieval and dissemination. Information-Centric Networks (ICNs) address this content-oriented networking paradigm by separating content identity from its location [9] . ICN enables access to content based on its name, from wherever it resides, supporting mobility as well as accessing the named content from the best, any, or all source(s). It also allows for network-wide caching to reduce access latency. There are a variety of ICN architectures which have been proposed in the past decade. Two of the most notable ones, which we primarily focus on in this paper, are Named Data Networks (NDN) [20] , and MobilityFirst [16] , which have been considered for Future Internet designs [3] .",
            "cite_spans": [
                {
                    "start": 280,
                    "end": 283,
                    "text": "[9]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 593,
                    "end": 596,
                    "text": "[9]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1026,
                    "end": 1030,
                    "text": "[20]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1051,
                    "end": 1055,
                    "text": "[16]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1113,
                    "end": 1116,
                    "text": "[3]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Currently, there are two main factors that make the discussion of network interoperability important: 1) Today, IP is ubiquitous and used on a majority of network devices, despite the legacy of end-point address-oriented communication, especially considering new services and demands on today's networks [15] . 2) Research on designing new network architectures radically different from IP, is ongoing, and in many cases has already led to implemented systems; our focus in this paper is on an important class of such architectures, namely ICN. It is anticipated that we may have a number of interconnected networks (domains) using different architectures [15] . To go beyond the interconnection (i.e., physical connections between different domains) towards interoperation between them (i.e., being able to use a service, or content, provided by one domain in another domain), we need network interoperability. In the past decade, several designs have been proposed for interoperation between an ICN architecture (either NDN or MF) with IP [3] . However, such designs and their requirements were presented informally, describing the primitives and operations. It has been observed that network interoperability is complex [19] ; thus, a formal structure for analysis of information-centric interoperability (ICI) can be very helpful, as it can provide proofs or expose errors early on, before the universal deployment of ICI frameworks for Future Internet.",
            "cite_spans": [
                {
                    "start": 304,
                    "end": 308,
                    "text": "[15]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 656,
                    "end": 660,
                    "text": "[15]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1041,
                    "end": 1044,
                    "text": "[3]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1223,
                    "end": 1227,
                    "text": "[19]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Formal methods have been extensively used for designing and analyzing computer networks and protocols (surveyed in [14] ). As for interoperability, work in [19] proposed a formal model to analyze interoperation of legacy networks. However, it only deals with host-centric interoperability (HCI), and only uses classic model finding [17] reasoning techniques. We extend that to support ICI as well as modeling failure and mobility with model counting [7] techniques. Network verification tools have also been proposed to analyze network data and control planes. Recently, work in [10] proposed a tool to verify ICN data planes, analyzing properties such as reachability. However, it only deals with a single domain, while our goal here is to cover multiple domains with different architectures coexisting with each other. Also, the symbolic execution nature of works such as [10] is computationally too expensive when expanded across multiple domains, each having its own data plane.",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 119,
                    "text": "[14]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 156,
                    "end": 160,
                    "text": "[19]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 332,
                    "end": 336,
                    "text": "[17]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 450,
                    "end": 453,
                    "text": "[7]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 579,
                    "end": 583,
                    "text": "[10]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 874,
                    "end": 878,
                    "text": "[10]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We present an Alloy [8] -based formalization of ICI, to analyze interoperability correctness. We cover both pull-based (request/response) and push-based (publish/subscribe) [6] content retrieval services, and their most essential properties such as content reachability and returnability. To analyze content-oriented services, we distinguish between static and dynamic content, justifying their differences, and specifying no-conflict properties, especially for dynamic content retrieval. For verification of these properties, we use Alloy Analyzer's built-in SAT solver-based model finding engine [2] . We also consider failure and mobility; to analyze them, mere model finding is not sufficient, as failure and mobility, when severe, can cause any network protocol to become \"incorrect\" (and raise counterexamples). Thus, for such analysis, we resort to model counting (to count and compare the number of satisfying instances and counterexamples) to assess \"how well\" a particular domain or architecture is doing under failure and mobility.",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 23,
                    "text": "[8]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 173,
                    "end": 176,
                    "text": "[6]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 598,
                    "end": 601,
                    "text": "[2]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The major contributions of this paper are: 1) a model finding method to analyze basic properties (mainly reachability and returnability) of informationcentric interoperability (ICI); 2) a formally-verified ICI framework; and 3) a model counting method to analyze gateway failure and mobility.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "ICN enables access to content independent of its location, focusing on the fact that what matters to users is what the content is rather than where that content is located [9] . An ICN network layer recognizes and makes its forwarding decisions based on content names (or IDs) instead of addresses (unlike host-centric networks, as in today's IP networks), achieving efficiency and scalability.",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 175,
                    "text": "[9]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Information-Centric Networking (ICN) and Interoperability"
        },
        {
            "text": "Among many different ICN architectures proposed recently, we focus on the two most popular ones, namely Named Data Networks (NDN) [20] and Mobil-ityFirst (MF) [16] . Both allow users to retrieve content using content names, through pull-based request/response or push-based publish/subscribe methods [6] . In-network content caching in routers is an important feature of ICN, allowing for requests to be satisfied from an intermediate cache on the path to the server/repository [9] . An in-network namespace is generally a graphical structure that captures the content names and their relationships in an ICN's content space [12] . Despite both being ICNs, NDN and MF have important differences [16, 20] : NDN uses human-readable hierarchically-structured names, with Longest Prefix Matching-based forwarding. NDN content requests (called Interests) leave \"breadcrumb\" state in the routers on their path, which the associated response (called Data packets) then follow back, via Reverse Path Forwarding (RPF). MF, on the other hand, uses flat IDs (called GUIDs) to identify content. Response packets contain the consumer's ID and do not need to follow the same path as the request. Also, MF inherently supports mobility by late binding, which re-directs in-flight packets towards a mobile content repository. Early binding assigns names to locations strictly at the original client, while late binding allows such assignment to be updated on its way in the network [16] .",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 134,
                    "text": "[20]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 159,
                    "end": 163,
                    "text": "[16]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 300,
                    "end": 303,
                    "text": "[6]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 478,
                    "end": 481,
                    "text": "[9]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 625,
                    "end": 629,
                    "text": "[12]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 695,
                    "end": 699,
                    "text": "[16,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 700,
                    "end": 703,
                    "text": "20]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1465,
                    "end": 1469,
                    "text": "[16]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Information-Centric Networking (ICN) and Interoperability"
        },
        {
            "text": "There have been several proposals for interoperability frameworks for ICNs (surveyed in [3] ). These frameworks typically consist of interoperation gateways between domains of different network architectures, performing translations between them. All of these proposals allow interoperation of just two domains, IP and one ICN (either NDN or MF), and often require addition of new protocols or modification of existing ones. We generalize these solutions in our model to an interoperability framework of multiple (\u22652) domain types (we allow IP, NDN and MF to coexist simultaneously), and do not change any domain-specific protocols.",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 91,
                    "text": "[3]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Information-Centric Networking (ICN) and Interoperability"
        },
        {
            "text": "Alloy is a declarative language based on relations and first order logic [8] . Alloy models a system, M , through the declaration of signatures (objects and their relations) and facts (constraints and axioms). A predicate is defined as a logical formula. An Assertion is a logical formula (which can be a combination of predicates) that are required to be always true (i.e., as invariants) in the system. Alloy Analyzer [2] allows the automatic analysis of models and their properties through utilizing off-the-shelf SAT solvers. The tool translates Alloy descriptions into Conjunctive Normal Form (CNF) expressions. It uses an enumeration of instances, also called model finding, within a bound (scope), to prove whether or not a predicate P ever holds (by SAT-solving M \u2227P ), or an assertion A always holds as an invariant (by SAT-solving M \u2227 \u00acA, to look for counterexamples).",
            "cite_spans": [
                {
                    "start": 73,
                    "end": 76,
                    "text": "[8]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Alloy"
        },
        {
            "text": "Alloy has been used in modeling and analysis of many systems, including network protocols and architectures [8] . In the particular case of network interoperability, Zave [19] used Alloy to formally analyze host-centric interoperability for legacy networks, with domains of the Public Switched Telephone Network (PSTN), BoxOS and the Session Initiation Protocol (SIP). We extend the approach to model and analyze interoperability of information-centric services and architectures, since we are dealing with radically different network designs (name-based networking vs. address-based [9] ) and required properties (node-tocontent reachability vs. node-to-node reachability [10] ). Additionally, we extend the classic Alloy-based model finding approach, such as in [19] , to a model counting one, to quantitatively analyze the impacts of failure and mobility. An important feature of Alloy is its strength in efficiently handling graph structures and properties [18] , a feature that we benefit from, in two ways: 1) the composite network topology, and 2) a graph-based information namespace. Further, Alloy helps provide proofs for properties with a reasonably large scope [18] .",
            "cite_spans": [
                {
                    "start": 108,
                    "end": 111,
                    "text": "[8]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 171,
                    "end": 175,
                    "text": "[19]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 584,
                    "end": 587,
                    "text": "[9]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 673,
                    "end": 677,
                    "text": "[10]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 764,
                    "end": 768,
                    "text": "[19]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 961,
                    "end": 965,
                    "text": "[18]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1173,
                    "end": 1177,
                    "text": "[18]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Alloy"
        },
        {
            "text": "We now describe the basics of our formal model 1 . First and foremost, let us define information-centric interoperability (ICI):",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Modeling Information-Centric Interoperability"
        },
        {
            "text": "Throughout this paper, we use the term \"network\" to mean \"a composition of multiple network domains\", each domain being a different type of standalone architecture (e.g., IP, NDN, or MF). An interoperability framework (such as [3] ) is a set of protocols and architectural components that allow interconnected networks of different types to interoperate. Information-centric services are broadly sub-categorized as: 1) requesting for and retrieving content (pull-based), and 2) subscribing to and receiving content (push-based). Both of these may be based on namespaces defined by content producers. An example 3-domain ICI scenario is depicted in Fig. 1 . As shown, ICI accesses content by name, rather than an address. Also, requests can be satisfied at any cache node, not just the original server. As for formal analysis, in ICI, the main property we care about is node-tocontent reachability [10] , while in traditional host-centric interoperability (HCI) analysis [19] , the focus is on node-to-node reachability. We model our networked environment using Alloy's relational and logical atoms. We have Domains (as abstract signatures), each of which can be an IP, NDN, or MF type (extended signatures) (Listing 3.1). A Node is at least in one Domain and has at least one NodeID. A Node can be either a Client, Repos (repository/server), or GW (gateway). A gateway is associated with exactly two Domains (constrained using facts), that it is stitching together (Listing 3.2.) Our declarations specify a network meta-model [8] , which maps to a number of instances (models) each being a network configuration (i.e., with their own topology, content, namespace, etc.). An example 2-domain instance is depicted in Fig. 2 , as a high-level schematic, showing objects and their inter-relations. The Client here wishes to retrieve some Content using its ContentID or a (set of) Keyword (s). Objects of type Route and RevRoute (reverse route) couple the notion of \"a series of links\" and \"packets carried over them\", the packet carrying content request and response, respectively. A Route has attributes such as initiator, acceptor, and a request for ContentID. We also extend signatures to add more fine-grained, domain-specific characteristics. One of Route's extended object types, namely IPRoute, inherits its attributes and constraints, and also has additional attributes such as srcIPaddress and destIPaddress, and constraints saying that source and destination IP addresses must correctly correspond to initiator and acceptor nodes. Gateways perform translation for forwarding requests (over a composition of Routes), and retain state information which they use to forward the content back to the client (over composition of RevRoutes). We also add a number of additional facts, such as uniqueness of node ID, absence of selflooping routes, and the existence of one-to-one mapping between NDN's forward and reverse routes (to reflect NDN's RPF policy [20] ).",
            "cite_spans": [
                {
                    "start": 227,
                    "end": 230,
                    "text": "[3]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 897,
                    "end": 901,
                    "text": "[10]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 970,
                    "end": 974,
                    "text": "[19]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1526,
                    "end": 1529,
                    "text": "[8]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 2955,
                    "end": 2959,
                    "text": "[20]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [
                {
                    "start": 648,
                    "end": 654,
                    "text": "Fig. 1",
                    "ref_id": null
                },
                {
                    "start": 1715,
                    "end": 1721,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "Definition 1. A sequence of interconnected domains in a network are information-centrically interoperable if and only if any client in any of the domains can access information-centric services provided in any other domain."
        },
        {
            "text": "We define a global-state relation C that captures routes to/from gateways. To model connectivity, we use the transitive closure of the route-connections relation C where (r1, r2) \u2208 C if and only if there exists a gateway between two domains that connects routes r1 and r2. E.g., if we have C = {(r1, r2), (r2, r3)}, then its transitive closure C + = {(r1, r2), (r2, r3), (r1, r3)} will represent existing paths of any length (i.e., number of routes). We define object type Connections (as a singleton) to capture these connections (i.e., relation C); it has attributes being relations themselves, primarily connected and revconnected, to capture connection relations of Routes and RevRoutes respectively. Relation revconnected has an additional constraint, which says that for two reverse routes rr1 and rr2 connected at gateway gw, corresponding state information (associated with the ContentID or other multiplexing/demultiplexing values in rr1 and rr2) must be stored on gw, so that the content can be carried over this cascade of reverse routes towards the consumer (Listing 3.3). Additionally, we define a fact (path exists, Listing 3.4) that ensures any two nodes are connected (through one or multiple Routes or RevRoutes), to reduce our instance space to only the ones with strongly connected topology. While Routes represent unicast exchange paths, we define Groups to denote multicast groups (one-to-many communication), enabling push-based notification models. Following the principles of ICN, each group is associated with a content name Prefix [6] and can be used for publish/subscribe exchanges regarding that prefix. Each group belongs to one domain. To model a connection of groups across multiple domains, we add relation attributes chain and revchain to Connections (Listing 3.3), to capture connectivity of groups (as a chain) for subscription and publication respectively. To ensure strong connectivity, we add a fact that says any two groups serving the same prefix are chained (Listing 3.5). NDN) or ContentGUID (in MF) (Listing 3.6). Each ContentID is a leaf node under a Prefix in the prefix tree (PTree). An example prefix tree is shown in Fig. 3 , which represents the network's content namespace. PTree may contain a number of fragmented sub-trees (i.e., as a forest), each sub-tree representing the namespace of a different (set of) content provider(s) in different domains. To represent the structure of hierarchical prefixes, we use binary relations to model the immediate parent-child relationship between prefixes in PTree. In Fig. 3 , the relation P = {(P 1, P 2), (P 1, P 3), (P 2, P 4), (P 2, P 5)} represents such relationships, and is captured in the prefix-to-prefix relation map in PTree (Listing 3.6). We also use its transitive closure to model the ancestordescendant relationships. We add additional facts to ensure basic constraints on the tree, such as the non-existence of loops. ",
            "cite_spans": [
                {
                    "start": 1557,
                    "end": 1560,
                    "text": "[6]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 2014,
                    "end": 2018,
                    "text": "NDN)",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 2165,
                    "end": 2171,
                    "text": "Fig. 3",
                    "ref_id": null
                },
                {
                    "start": 2559,
                    "end": 2565,
                    "text": "Fig. 3",
                    "ref_id": null
                }
            ],
            "section": "Definition 1. A sequence of interconnected domains in a network are information-centrically interoperable if and only if any client in any of the domains can access information-centric services provided in any other domain."
        },
        {
            "text": "There are a number of important properties that are required from the framework, to ensure interoperability as defined in Definition 1. We consider properties of two classes of information-centric services here: pull-based (for unicast request/response), and push-based (for multicast publish/subscribe) content retrieval. We further divide the pull-based services into two categories: static content retrieval (SCR) and dynamic content retrieval (DCR). This distinction is important as the nature, protocol for retrieval, and thus formal properties of the two are different: static content is one that does not change in a long time (e.g., a movie) and can be retrieved from its original producer as well as a cache, while dynamic content is created once on demand (e.g., result of a Google search), and must be retrieved from its original server (not from a cache). Additionally, we assume content requests are assumed to be genuine and correct, i.e., false and bogus content requests are not our focus here. We study essential invariant properties, guaranteed to hold at all times. These properties are primarily associated with content-oriented reachability and returnability. We formally specify these properties, using Alloy predicates and assertions. For verification, Alloy's built-in model finding engine is used to find satisfying instances and counterexamples. Any counterexample found indicates interoperability violations: e.g., a client cannot generate a request native to its domain, or the gateway does not know what to do with a returned response.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Satisfying Information-Centric Service Properties"
        },
        {
            "text": "Static Content Retrieval. In the static content retrieval (SCR) service, the request packets carry content IDs which the client requests, and the response packets produced by repositories (can be content producers or router caches) carry the data associated with that content ID. We describe two of SCR's essential content-oriented properties using Alloy (Listings 4.1 and 4.2). Property 1.1. SCR Reachability: For every client that wants to retrieve content associated with a content ID and has a direct route to a gateway, there is a repository with content having that ID reachable from that gateway. Property 1.2. SCR Returnability: For every client that reaches a repository with a request, there is a path back to the client for the response with the content. This property shows the importance of having two separate demux values in packets, namely both the request ID (required for Property 2.3.a) and client ID (required for Property 2.3.b), to make each dynamic request globally unique, for correct multiplexing/demultiplexing. If we remove either of those two elements, this property will be violated and counterexamples will arise; i.e., the gateway would not know how to demultiplex incoming response data to serve the correct, corresponding requesting client. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pull-Based Retrieval: Request/Response"
        },
        {
            "text": "In pub/sub, we have domain-specific multicast groups that are associated with prefixes [6] . We want a client to be able to subscribe to and receive all relevant publications in accordance with the prefix tree of the namespace over \"chain\" of groups across domains. Groups G1 and G2 form a chain if and only if the publisher of G1 can be a subscriber of G2, and is then able to relay data received from G2 to his subscribers in G1.",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 90,
                    "text": "[6]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Push-Based Retrieval: Publish/Subscribe"
        },
        {
            "text": "Property 3.1. Ability to subscribe to any prefix. For every client that wants to retrieve future publications under/associated with an existing prefix and has a direct route to a gateway, if there is some publisher that will publish content under that prefix, then that publisher is accessible through a chain of groups.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Push-Based Retrieval: Publish/Subscribe"
        },
        {
            "text": "Property 3.2. Ability to receive any content published directly associated with the subscribed prefix. For every client who is subscribed to a prefix and can reach the associated publisher, there is a path back to the client to carry any content with a content ID belonging to that prefix. For example, a subscriber of P 2 in Fig. 3 should receive publications pertaining to P 2 across domains.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 326,
                    "end": 332,
                    "text": "Fig. 3",
                    "ref_id": null
                }
            ],
            "section": "Push-Based Retrieval: Publish/Subscribe"
        },
        {
            "text": "This property says that for every client that has subscribed to a prefix and has reached the associated publisher, there is a path back to the client to carry any content with content ID either directly belonging to that prefix or under it in the hierarchy on the prefix tree. For example, a subscriber of P 2 in Fig. 3 should receive publications pertaining to P 2 and also P 4 across domains. The assertion rcvall in Listing 4.5 depends on how relationships among groups and also between content IDs and prefixes are represented by Connections and PTree. For a domain with a namespace that does not capture relationships between prefixes, i.e., does not map a prefix to a set of multiple relevant prefixes according to a graph, then rcvall would be equivalent to receiving a single content element (Property 3.2). Properties 3.1-3 collectively model and verify properties of a service offering hierarchical pub/sub. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 313,
                    "end": 319,
                    "text": "Fig. 3",
                    "ref_id": null
                }
            ],
            "section": "Property 3.3. Ability to receive all content published that is associated with prefixes under the subscribed prefix."
        },
        {
            "text": "In addition to the basic invariants (Sect. 4), there are other important aspects of formal analysis of networks that warrant a more quantitative analysis; among them are failure and mobility analysis. Failures and mobility of nodes can occur in a network, causing disruption and lack of content availability. To better compare how different network architectural components, e.g., routing, impact the number of success and violation scenarios, we perform model counting [7] . While we can consider the probability for all instances as being equal, we can also calculate each instance's probability by additionally factoring in the real-world probability of individual elements causing failures and mobility, provided as external information (e.g., the probability of a gateway failing when processing a content request, a route disconnecting while carrying a packet, etc.). Thus, we can provide a more realistic probabilistic analysis for the effect of failures and mobility using weighted model counting methods [5] . While the Alloy Analyzer (v4. 20) [2] allows for a limited, graphical iteration over instances, it does not enable an explicit counting of instances in an efficient manner. To perform model counting, we wrote an application [1] that counts all SAT solutions, using the SAT4J solver [13] (SAT4J can be replaced by any off-the-shelf SAT solver). We feed the Alloy model and properties, in Kodkod format [17] , to our application. Predicates and assertions are used for counting instances that satisfy or violate (counterexamples) respectively. Through this counting, we can also look into the details (relations and values) within each instance, and gain insight such as possible cause of violations (in case of counterexamples) and calculate the probability of occurrence of each instance in real-world scenarios. While we do not focus on the performance aspects of model counting in this paper, optimizations of this procedure can be leveraged for enhancing the scalability of our approach in case of very large problem sizes. At a minimum, our approach can provide a rough estimate of failure probabilities. Even if the model counting provided by the SAT solver is through \"approximate\" model counting (e.g., using repetitive halving procedures) [4] rather than an \"exact\" one, it still gives us a good enough assessment of the degree of success and violation of properties. ",
            "cite_spans": [
                {
                    "start": 470,
                    "end": 473,
                    "text": "[7]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1013,
                    "end": 1016,
                    "text": "[5]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1049,
                    "end": 1052,
                    "text": "20)",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1243,
                    "end": 1246,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1301,
                    "end": 1305,
                    "text": "[13]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1420,
                    "end": 1424,
                    "text": "[17]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 2266,
                    "end": 2269,
                    "text": "[4]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Reasoning About Failure and Mobility"
        },
        {
            "text": "Our interoperability framework depends on gateways that retain state information. What would happen to a response packet if that state is lost at the gateway for any reason? For reliability, we consider state sharing between redundant gateways that have the same domains on either side. Figure 4 depicts an example for this. Consider the gateway that received the request and created the state as the primary gateway for the request (GW 1 in the Fig.) , and the replicas that have the shared state as the secondary gateways (GW 2 and GW 3). Formally, we add an extra condition to our reachability and returnability properties such that, for two routes to connect, the gateway attaching them must be up and running at the time the packet is received. Additionally, for returnability, the state information must be present at the gateway. If any gateway goes down, the corresponding potential path going through it (p1-3) back for the content cannot be leveraged. If the gateway is neighboring an NDN domain (e.g., in Domain n or Domain n\u22121 ), then the gateway has to be the primary only, for correct operation with the NDN reverse-path-forwarding (RPF) policy [20] . For other domain types, a secondary gateway that is active and has the shared state information is adequate to forward the response data back. We model the conditions representing this in Alloy as shown in Listing 5.1. Gateways can go down due to various reasons such as completely failing or just losing state information due to a software failure. Our method can be used to reason about various scenarios and measure failure probability given an input configuration space, i.e., a set of Alloy facts that set constraints on some objects or variables while relaxing others. As Table 1 shows, a simple model finding analysis does not provide a helpful comparison between different such constraints:it will say that both cases lead to counterexamples raised (e.g., for the case that all gateways go down). To gain a better assessment of which constraint does better, we resort to model counting (Table 2) . Using model counting, we can count (satisfying) instances (I) and counterexamples (C), and calculate (even if approximately [7] ) the probability of reliability (R = I/(I + C)). This reliability indicates to what degree interoperability is impacted in presence of failure, given certain conditions (i.e., choice of domain policies, etc.).",
            "cite_spans": [
                {
                    "start": 1159,
                    "end": 1163,
                    "text": "[20]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 2196,
                    "end": 2199,
                    "text": "[7]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 287,
                    "end": 295,
                    "text": "Figure 4",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 446,
                    "end": 451,
                    "text": "Fig.)",
                    "ref_id": null
                },
                {
                    "start": 1744,
                    "end": 1751,
                    "text": "Table 1",
                    "ref_id": "TABREF7"
                },
                {
                    "start": 2060,
                    "end": 2069,
                    "text": "(Table 2)",
                    "ref_id": null
                }
            ],
            "section": "Failure"
        },
        {
            "text": "To model and analyze mobility (Fig. 5) , we add the notion of \"time\" to our model. In particular, we associate timeout values to state entries at gateways and birthT ime and deathT ime to routes (and similarly for reverse routes). We assume gateways are stationary, but other nodes can move, causing the \"death\" of their route (route1) to/from their closest gateway. A new route to the gateway is \"born\" (route2) after some time, assuming the existence of a domain-specific method to handle mobility. Temporal conditions must be incorporated into reachability/returnability properties. The most critical case is when a mobility event occurs while the packet is in-flight [21] . At high-level, the sum total latency formulated as f irstDeliveryAttempt+recovery+secondDeliveryAttempt, must be below a certain expiration threshold (at every gateway and consumer). f irstDeliveryAttempt is the incomplete partial delivery latency via route1 and secondDeliveryAttempt is the delivery via route2 (continuation in MF, and complete retransmission in IP and NDN). The recovery delay is the time it takes for the packet to be transmitted back on the new path again; it includes re-registration (MF and IP), FIB re-population (IP and NDN in case of provider mobility) and/or PIT re-population (for NDN in the case of consumer mobility) delays [16, 20, 21] . Using this formal method, we check properties in the presence of mobility, find appropriate values for a timeout threshold on gateways and investigate the effect of domain-specific mobility handling methods on interoperability. Listing 5.2 generally specifies how the reachability property (to deliver a named request) depends on the condition of mobility (stationary or mobile) and the domain policy on handling mobility (early binding or late binding). Returnability is similarly specified (for content). Predicates stationary, mobileEarlyBinding, and mobileLateBinding specify timing conditions for successful delivery assuming their corresponding conditions (details of the three properties are omitted here due to space but are in [1] ). As shown in Fig. 5 , we only consider intra-domain mobility here, i.e., the mobile node changes its location and point of attachment, but stays within its domain. ",
            "cite_spans": [
                {
                    "start": 671,
                    "end": 675,
                    "text": "[21]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1332,
                    "end": 1336,
                    "text": "[16,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1337,
                    "end": 1340,
                    "text": "20,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 1341,
                    "end": 1344,
                    "text": "21]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 2083,
                    "end": 2086,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 30,
                    "end": 38,
                    "text": "(Fig. 5)",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 2102,
                    "end": 2108,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Mobility"
        },
        {
            "text": "We implemented the ICI framework discussed in our model in Sect. 3, with gateways for interoperation among IP, NDN, and MF ( Fig. 1 as an example) in a software testbed (implementation details in [11] ). This section provides the description and results of our analysis of the ICI framework (our Alloy source code is approximately 800 lines of code in total [1] ).",
            "cite_spans": [
                {
                    "start": 196,
                    "end": 200,
                    "text": "[11]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 358,
                    "end": 361,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [
                {
                    "start": 125,
                    "end": 131,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Implementation and Results"
        },
        {
            "text": "To check for correctness, we performed verification (supported by Alloy Analyzer's model finding engine) of our ICI framework model, against the information-centric services properties (as specified in Sect. 4). In order to reach convincing proofs (as advised in [18] ), we pick the scopes for verification in Alloy that are large enough to contain all necessary cases (i.e., minimum number of actors and objects for each service), and small enough so that we do not encounter model explosion. The scopes, i.e., upper bounds on the number of key objects, are provided in Table 3 . For most properties, we consider 1 Client, 1 Server, 1 Content, and 1 ContentID. That is, different <client, request> pairs are considered independent of each other. However, for Properties 2.3.a/b, such a dependency matters, and we want to show lack of conflicts. For Property 2.3.a, we set 1 Client and 2 Contents (to generate scenarios where one client makes two separate request for two different contents), and for Property 2.3.b, we set 2 Clients and 1 Content (to look for conflicts between request for one content but by two clients). We use 3 Domains for most properties, as it contains all cases with 1, 2, or 3 domains of any type, i.e., IP, NDN, or MF. Also, with upper We use our proposed model counting approach to analyze scenarios with the failure of one or multiple gateways. The most important factor affecting returnability in scenarios with the possibility of failure, is domain-specific routing policies, in particular, whether or not it allows for a secondary (backup) gateway to relay the returning response content. Different domains have different policies; MF and IP decouple the forward (request) and return (response) paths, and they can be delivered through different gateways, while NDN strictly requires the two paths to be the same, due to RPF policy. To investigate the impact of that policy, we considered a scenario of two domains, with two gateways between them (one primary and one secondary), sharing state. Both gateways are Up (working) when the request is forwarded, and either may go Down (failing) when the response is one its way back. Table 4 shows different scenarios for reachability and returnability, with different domain constraints (with different routing policies). In particular, the two domain constraints we consider are the following: 1) no constraint on what any of the domains are; and 2) one domain is definitely NDN. The table shows the values of I (instances), C (counterexample), and R (reliability) for each scenario, as defined in Sect. 5. Our results for R in Table 4 prove that having an NDN domain on one side dramatically reduces the returnability reliability ratio, since basic NDN forwarding strictly forbids data coming back on a different path than the original path taken by the request.",
            "cite_spans": [
                {
                    "start": 263,
                    "end": 267,
                    "text": "[18]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [
                {
                    "start": 571,
                    "end": 578,
                    "text": "Table 3",
                    "ref_id": "TABREF9"
                },
                {
                    "start": 2161,
                    "end": 2168,
                    "text": "Table 4",
                    "ref_id": "TABREF10"
                },
                {
                    "start": 2607,
                    "end": 2614,
                    "text": "Table 4",
                    "ref_id": "TABREF10"
                }
            ],
            "section": "Implementation and Results"
        },
        {
            "text": "When a content producer (server) moves while a content request is in-flight (Fig. 5) , the domain's handling of mobility recovery determines the reachability probability. NDN and IP use early binding with retransmissions, while MF supports late binding with rerouting. We compare the impact of these mechanisms and techniques using our model counting method, with results shown in Table 5 . Our modeled scenario consists of two nodes in a domain, one requester (client or gateway) and one server (producer) with a route established among them. The 'Stationary' columns in the table show reachability results in the stationary server case. With 'Mobile', the route dies due to a server mobility event (at time t = 10), leading to the birth of the second route. We set the re-registration and re-population delays to 1 each. Also, a retransmission is initiated 1 time unit after the mobility event. Different binding techniques for mobility, i.e., late and early binding, are also shown in Table 5 . We compare cases with different ranges for Delivery Latency (DL), which is time approximately needed for a packet to travel from requester to server. For a delivery latency range of [0, 20], we see a higher R for stationary vs. mobility cases. The reason is that when the server does not move, the original route stays active, thus providing a higher chance for requests to reach the server. Comparing the two binding techniques, late binding leads to higher chance of reachability compared to early binding, as it allows for packets to be re-routed on the newly-born route, rather than retransmitting from the original requester. These results serve as proof that under similar scenarios, late binding outperforms early binding in ICI. Also, changing the delivery latency ranges, we can find out at what points, reachability is an invariant (if ever) under mobility conditions. As the table shows, with ranges within [0, 18], [0, 15] , and [0, 10] (rows in Table 5 labeled in first column accordingly), reachability becomes an invariant in cases of Stationary, Late Binding, and Early Binding, respectively; as zero counterexamples are raised. With a small enough delivery latency ranges, namely [0, 10], reachability becomes an invariant, no matter the mobility conditions or binding techniques. Our approach can be used to find such points of invariance, comparing different techniques, and prove them.",
            "cite_spans": [
                {
                    "start": 1925,
                    "end": 1928,
                    "text": "[0,",
                    "ref_id": null
                },
                {
                    "start": 1929,
                    "end": 1932,
                    "text": "15]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 76,
                    "end": 84,
                    "text": "(Fig. 5)",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 381,
                    "end": 388,
                    "text": "Table 5",
                    "ref_id": "TABREF11"
                },
                {
                    "start": 988,
                    "end": 995,
                    "text": "Table 5",
                    "ref_id": "TABREF11"
                },
                {
                    "start": 1956,
                    "end": 1963,
                    "text": "Table 5",
                    "ref_id": "TABREF11"
                }
            ],
            "section": "Implementation and Results"
        },
        {
            "text": "This paper presented an Alloy-based formal analysis model for informationcentric interoperability (ICI) for Future Internet environments. We showed how model finding can be used to analyze basic (reachability and returnability) properties of ICI. Additionally, our proposed model counting approach analyzes failure and mobility scenarios, which we used to prove the negative impact of certain routing policies (particularly, reverse path forwarding), and the helpfulness of certain mobility-handling mechanisms (particularly, late binding), providing necessary confidence and guidelines for Future Internet interoperability.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Alloy: A Language and Tool for Relational Models",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Enabling ICN in the internet protocol: analysis and evaluation of the hybrid-ICN architecture",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Carofiglio",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM ICN",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3357150.3357394"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A scalable approximate model counter",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Chakraborty",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "S"
                    ],
                    "last": "Meel",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "Y"
                    ],
                    "last": "Vardi",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "CP 2013",
            "volume": "8124",
            "issn": "",
            "pages": "200--216",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-40627-0_18"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "On probabilistic inference by weighted model counting",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chavira",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Darwiche",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "AI",
            "volume": "172",
            "issn": "6-7",
            "pages": "772--799",
            "other_ids": {
                "DOI": [
                    "10.1016/j.artint.2007.11.002"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "COPSS: an efficient content oriented publish/subscribe system",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "ACM/IEEE ANCS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1109/ANCS.2011.27"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Model counting: a new strategy for obtaining good bounds",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "P"
                    ],
                    "last": "Gomes",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sabharwal",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Selman",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Alloy: a lightweight object modelling notation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jackson",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "TOSEM",
            "volume": "11",
            "issn": "2",
            "pages": "256--290",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Networking named content",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Jacobson",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Name space analysis: verification of named data network data planes",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jahanian",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "K"
                    ],
                    "last": "Ramakrishnan",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM ICN",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3357150.3357406"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Managing the evolution to future internet architectures and seamless interoperation",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jahanian",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Proceedings of the 29th International Conference on Computer Communication and Networks (ICCCN)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Graph-based namespaces and load sharing for efficient information dissemination in disasters",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jahanian",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1109/ICNP.2019.8888047"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The SAT4J library, release 2.2, system description",
            "authors": [
                {
                    "first": "Le",
                    "middle": [],
                    "last": "Berre",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Parrain",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Satisf. Boolean Model. Comput",
            "volume": "7",
            "issn": "",
            "pages": "59--64",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "A survey on network verification and testing with formal methods: approaches and challenges",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Commun. Surv. Tutor",
            "volume": "21",
            "issn": "1",
            "pages": "940--969",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Enabling a permanent revolution in internet architecture",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Mccauley",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM SIGCOMM",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3341302.3342075"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "MobilityFirst: a robust and trustworthy mobility-centric architecture for the future internet",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Raychaudhuri",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ACM SIGMOBILE MCCR",
            "volume": "16",
            "issn": "3",
            "pages": "2--13",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Kodkod: a relational model finder",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Torlak",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jackson",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "TACAS 2007",
            "volume": "4424",
            "issn": "",
            "pages": "632--647",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-71209-1_49"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A practical comparison of alloy and spin",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zave",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Formal Aspects Comput",
            "volume": "27",
            "issn": "2",
            "pages": "239--253",
            "other_ids": {
                "DOI": [
                    "10.1007/s00165-014-0302-2"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "A formal model of addressing for interoperating networks",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zave",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "FM 2005",
            "volume": "3582",
            "issn": "",
            "pages": "318--333",
            "other_ids": {
                "DOI": [
                    "10.1007/11526841_22"
                ]
            }
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Named data networking",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ACM SIGCOMM CCR",
            "volume": "44",
            "issn": "3",
            "pages": "66--73",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "KITE: producer mobility support in named data networking",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ACM ICN",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/3267955.3267959"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Content IDs and Prefix Tree abstract sig ContentID{prefix: Prefix} sig URL extends ContentID{} --if in IP sig NDNName extends ContentID{} --if in NDN sig ContentGUID extends ContentID{} --if in MF sig Prefix{parent: lone Prefix, domains: some Domain} --each Prefix has exactly one parent and is at least in one domain one sig PTree {map: Prefix set -> set Prefix} Prefix tree example",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Gateway failure scenario",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Mobility scenario example: Route 2 established after B moves and changes its point of attachment",
            "latex": null,
            "type": "figure"
        },
        "TABREF1": {
            "text": "Listing 3.1. Domains Listing 3.2. Nodes abstract sig Node{domains: some Domain, id: some NodeID} sig Client extends Node{...}{...} sig Repos extends Node{...}{...} sig GW extends Node{...}{#domains=2 && ...}",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Listing 3.3. Connections: capture the connectivity of routes and groups one sig Connections{connected: Route->Route, revconnected: RevRoute->RevRoute, chain: Group->Group, revchain: Group->Group} fact connectivity{ --conditions for two (reverse) routes being ''connected'' all r1,r2:sRoute, c:Connections | (r1->r2) in c.connected <=> r1.acceptor = r2.initiator && r1.contentID = r2.contentID && r1.reposdomain = r2.reposdomain --requests for same content --similar condition for RevRoute paths (with extra criteria: gateway state information should match for the two connecting reverse routes) ... } Listing 3.4. Constraints to ensure that a path exists between any two nodes fact path_exists{ all co:Connections, disj n1,n2:Node, cid:ContentID, rd: Domain | (some r:Repos | rd in r.domains => (some r1,r2:Route | (r1->r2) in^(co.connected) && r1.initiator = n1 && r2.acceptor = n2 && r1.contentID = cid && r2.contentID = cid && r1.reposdomain = rd && r2.reposdomain = rd)) --similar condition for RevRoute paths ... }",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Listing 3.5. Constraints to ensure that a chain of connectivity exists between groups GW| g1.domain in gw.domains && g2.domain in gw.domains)) all disj d1,d2:Domain, co:Connections, p:Prefix | --chains for each prefix some disj g1,g2:Group | g1.domain = d1 && g2.domain = d2 && (g1->g2) in^(co.chain) && g1.prefix = p && g2.prefix = p --similiar conditions for revchain ... } Content naming is integral in ICI. We define names, i.e., ContentID objects for each Content. Based on domain type, ContentID can be either URL (in IP), NDNName (in",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "Listing 4.1. SCR reachability property pred reach[c:Client, cid:ContentID, re:Repos, gw:GW]{ --reachability predicate all co: Connections | cid in c.Dynamic Content Retrieval. In DCR, every request has to be mapped to a unique response, as opposed to SCR. To facilitate this, having a demux value (for multiplexing/demultiplexing) is essential for DCR, to provide the correct mapping of responses to requests; since every generated response is specific to not just the request's name, but also its input parameters. To access dynamic content from a server, a client generates a query for which the gateway keeps state as <nodeID, demux> of the requesting side and <demux> for the serving side. appropriately associated responses, should be received back. In no-conflict -A, the focus is on the distinction between two return-ed contents, associated with two distinct requests made by a given Client for distinct Keyword s k1 and k2. On the other hand, no-conflict -B focuses on the distinction between two return-ed contents, associated with requests for a particular Keyword initiated by two distinct Clients c1 and c2.",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "4.3. DCR -No conflict between 2 distinct requests from the same client",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Model finding",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "Listing 5.1. Failure scenario constraints: impact of gateway status on route connectivity",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "Verif. scopes for properties of ICI services",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "Failure analysis results",
            "latex": null,
            "type": "table"
        },
        "TABREF11": {
            "text": "Mobility analysis resultsbound n on the total number of Nodes, i.e., sum of Clients, Servers, and GW s, we specify the upper bound on the number of Routes (as well as RevRoutes) to be n(n \u2212 1), enabling the existence of any possible (uni-directional) route. For pub/sub services (i.e., Properties 3.1-3), we set 3 Prefix es, ContentIDs, and Contents, to capture inter-relationship of content IDs in a large enough namespace. Additionally, with the upper bound on Domains and ContentIDs both set at 3, we set the upper bound on total number of Groups (and GroupIDs) to be 3 \u00d7 3 = 9, so as to contain cases with one group per content ID per domain. The blank cells inTable 3indicate either \"N/A\" or \"no particular upper bound set\", in which case Alloy picks a default value. Within this scope, our verification passes successfully for each property, showing that the stated properties are invariants of our ICI framework. In other words, the framework design ensures that any sequence of interconnected IP, NDN, and MF domains are informationcentrically interoperable.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgements. This work was supported by the US Department of Commerce, National Institute of Standards and Technology (award 70NANB17H188) and US National Science Foundation grants CNS-1455815 and CNS-1818971.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}