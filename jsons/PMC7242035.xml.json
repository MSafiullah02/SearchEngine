{
    "paper_id": "PMC7242035",
    "metadata": {
        "title": "Formally Verified Architecture Patterns of\u00a0Hybrid Systems Using Proof and Refinement with Event-B",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Guillaume",
                "middle": [],
                "last": "Dupont",
                "suffix": "",
                "email": "guillaume.dupont@enseeiht.fr",
                "affiliation": {}
            },
            {
                "first": "Yamine",
                "middle": [],
                "last": "A\u00eft-Ameur",
                "suffix": "",
                "email": "yamine@enseeiht.fr",
                "affiliation": {}
            },
            {
                "first": "Marc",
                "middle": [],
                "last": "Pantel",
                "suffix": "",
                "email": "marc.pantel@enseeiht.fr",
                "affiliation": {}
            },
            {
                "first": "Neeraj",
                "middle": [
                    "K."
                ],
                "last": "Singh",
                "suffix": "",
                "email": "nsingh@enseeiht.fr",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Cyber-Physical Systems (CPS) can be described as complex systems that integrate both discrete and continuous features [19]. Such system generally consists of a discrete algorithm or controller that interacts with a continuous process or plant in order to control its behaviour. The controller can retrieve information from the plant through sensors and may alter its behaviour with actuators.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 121,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Because of this hybridation, CPS are often regarded as quite hard to trust. However, their versatility, adaptability and price made them unavoidable in our everyday life, from Internet of Things (IoT) to smart systems (e.g. home automation, smart factories and so on), including, of course, critical systems such as transportation and medical devices. Being able to formally model and certify CPS is thus a major challenge nowadays.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The design of formal modelling approaches for CPS development and/or certification has been addressed in various ways. In [4], Alur defines the hybrid automata formalism to model hybrid systems. Hybrid model-checkers such as HyTech, d/dt, PHaVer or SpaceEx can then be used to establish properties such as reachability.",
            "cite_spans": [
                {
                    "start": 123,
                    "end": 124,
                    "mention": "4",
                    "ref_id": "BIBREF17"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In terms of modelling techniques, [18] have proposed HybridCSP as a hybrid extension of CSP [17]. [7] proposes a continuous extension of Action System. In the same manner, [8] proposes an hybrid extension to the Event-B method.",
            "cite_spans": [
                {
                    "start": 35,
                    "end": 37,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 93,
                    "end": 95,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 99,
                    "end": 100,
                    "mention": "7",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 173,
                    "end": 174,
                    "mention": "8",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Proof-based approaches have also been used to try and formally prove CPS. [9] use Coq to that extent, starting from an annotated C program. [21] uses a special formalism (hybrid programs) to model and to prove hybrid systems using KeYmaera. Event-B has been used for modelling similar systems in [23] and [10].",
            "cite_spans": [
                {
                    "start": 75,
                    "end": 76,
                    "mention": "9",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 141,
                    "end": 143,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 297,
                    "end": 299,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 306,
                    "end": 308,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "However, all these approaches still require formal modelling expertise, where the developer needs to establish correctness using complex proof systems involving discrete and continuous mathematics features and proof rules. As a consequence, the use of these methods on a large scale is hindered, in particular in formal system engineering. So, easing CPS formal modelling and verification activities in presence of both discrete and continuous behaviours is still a challenge.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "To address this challenge, we propose a systematic correct-by-construction approach to design hybrid systems based on the definition of architecture patterns. Indeed, one commonly used method in formal system engineering is to provide formalised generic patterns where relevant generic properties are established. Furthermore, those patterns can be instantiated for specific systems. In such a setting, the system developer selects the most adapted pattern and instantiates it. Proof obligations, in particular regarding well-definedness, may need to be discharged in order to inherit all the properties of the generic pattern.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In our previous work [14], we used Event-B to design and formalise commonly used architecture patterns (AP) for centralised hybrid systems. We based those patterns on our generic approach [15], allowing to model both discrete and continuous behaviours. In this paper, we extend these architecture patterns to model distributed hybrid systems i.e. systems that manage multiple autonomous subsystems, linked together by a communication network. A case study is given as a possible instantiation of this pattern, involving independent liquid tanks enforcing a global invariant that expresses safety properties.",
            "cite_spans": [
                {
                    "start": 22,
                    "end": 24,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 189,
                    "end": 191,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "This paper is organised as follows: Sect. 2 gives an overview of Event-B and Sect. 3 presents hybrid modelling features needed for hybrid system development. Section 4 introduces the architecture patterns identified when modelling hybrid systems. Section 5 recalls our generic method for designing hybrid systems in Event-B. Section 6 introduces a case study to support our work, which is solved in Sect. 7. Finally, Sect. 8 provides an assessment of the approach, and Sect. 9 concludes the paper and discusses possible future research directions.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Event-B method [2] supports the development of correct-by-construction complex systems. First order logic and set theory are used as core modeling language. The design process consists of a series of refinements of an abstract model leading to the final concrete model. Refinement progressively contributes to add design decisions to the system.",
            "cite_spans": [
                {
                    "start": 16,
                    "end": 17,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Modelling Hybrid Systems with Event-B",
            "ref_spans": []
        },
        {
            "text": "Event-B machines formalize models described as state-transitions systems and a set of proof obligations are automatically generated for each model.",
            "cite_spans": [],
            "section": "Modelling Hybrid Systems with Event-B",
            "ref_spans": []
        },
        {
            "text": "Notation. We use the superscripts \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$^A$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$^C$$\\end{document} to denote abstract and concrete features.\nEvent-B Contexts (Table\n1.a).\nContexts are the static part of a model. They set up all the definitions (carrier sets s and constants c), axioms (A) and theorems (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{ ctx }$$\\end{document}) needed to describe the required concepts.Event-B Machines (Table\n1.b). A machine describes the dynamic part of a model as a transition system. A set of guarded events modifying a set of variables (state) represents the core concepts of a machine. Variables\nx, invariants\nI(x), theorems\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{ mch }(x)$$\\end{document}, variants\nV(x) and events\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ evt $$\\end{document} (possibly guarded by G and/or parameterized by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document}) are defined in a machine. Invariants and theorems formalize safety system properties while variants define convergence properties (reachability).Event-B Refinements (Table\n1.c). A system is gradually designed by introducing properties (functionality, safety, reachability) at various abstraction levels. Refinement decomposes a machine, a state-transitions system, into a more concrete one, with more design decisions (refined states and events) while moving from an abstract level to a less abstract one. Abstract and concrete variables are related by gluing invariants ensuring properties preservation between abstract and concrete models.Proof Obligations (PO) and Property Verification. To establish the correctness of an Event-B model, a set of POs are automatically generated from the calculus of substitutions. They need to be proved.Extensions with mathematical theories. In order to handle theories beyond set theory and first order logic, an Event-B extension to support externally defined mathematical theories has been proposed. It offers the capability to introduce new datatypes through the definition of new types, sets operators, theorems and associated rewrite and inference rules, in so-called theories.Event-B and its IDE Rodin. It offers resources for model edition, automatic PO generation, project management, refinement and proof, model checking, model animation and code generation. Several provers, like SMT solvers, are plugged to Rodin. In particular, a plug-in allows to define theories [11].\n",
            "cite_spans": [
                {
                    "start": 3872,
                    "end": 3874,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Modelling Hybrid Systems with Event-B",
            "ref_spans": [
                {
                    "start": 680,
                    "end": 681,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 1179,
                    "end": 1180,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 2528,
                    "end": 2529,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Modelling hybrid systems requires handling of continuous behaviours. We thus need to access specific mathematical objects and properties, not natively available in Event-B. These concepts such as differential equations and their associated properties have been modelled through an intensive use of Event-B theories and have been used to model various case studies found in [13\u201315].",
            "cite_spans": [
                {
                    "start": 374,
                    "end": 376,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 377,
                    "end": 379,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "In order to deal with continuous objects, theories have been defined for continuous functions, (ordinary) differential equations as well as for their properties. They are used throughout the defined models. Their complete definitions are available at https://irit.fr/~Guillaume.Dupont/models.php. Some of those concepts as they are used in this paper are recalled below.\n",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "Time. A notion of time is needed to define continuous behaviors. We thus introduce dense time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t \\in \\mathbb {R}^+$$\\end{document}, modeled as a continuously evolving variable.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "System State. According to the architecture of hybrid systems, we have identified two types of states.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "\nDiscrete state\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s \\in STATES $$\\end{document}, variable that represents the controller\u2019s internal state. It evolves in a pointwise manner with instantaneous changes.Continuous state\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_p \\in \\mathbb {R}^+ \\rightarrow S$$\\end{document} represents the plant\u2019s state and evolves continuously. It is modelled as a function of time with values in space S.Hybrid Modeling Features. Modeling hybrid systems requires the introduction of multiple specific features which are defined below.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {DE}(S)$$\\end{document} type for differential equations which solutions evolve over set S\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {ode}(f,\\eta _0,t_0)$$\\end{document} represents the ODE1\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\dot{\\eta }(t) = f(\\eta (t),t)$$\\end{document} with initial condition \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\eta (t_0) = \\eta _0$$\\end{document}\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {solutionOf}(D,\\eta ,\\mathcal {E})$$\\end{document} is the predicate stating that function \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\eta $$\\end{document} is a solution of equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {E}$$\\end{document} on subset D\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {Solvable}(D,\\mathcal {E},\\mathcal {I})$$\\end{document} is the predicate stating that equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {E}$$\\end{document} has a solution defined on subset D so that the solution satisfies the constraint \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I}$$\\end{document}\n",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "These features have been encoded in a theory from which we show a snippet on Fig. 1 (the theory accumulates more than 150 operators and 350 properties).\n",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": [
                {
                    "start": 82,
                    "end": 83,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Other, more specialised expressions and predicates are defined (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ FlowEquation $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ FlowODE $$\\end{document}) in additional theories. Note that all these definitions use algebraic datatypes together with axioms, theorems and proof rules.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "In the following, we use x to denote the union of discrete and continuous state variables.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "Continuous Assignment. Continuous variables are essentially functions of time and are at least defined on [0, t] (where t is the current time). Updating such variables thus requires to 1) make the time progress from t to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t' > t$$\\end{document}, and 2) append to the already existing function a new piece corresponding to its extended behavior (on \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$[t,t']$$\\end{document}) while ensuring its \u201cpast\u201d (i.e. whatever happened on [0, t]) remains unchanged.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "Similarly to the classic Event-B\u2019s before-after predicate (BAP), we define a continuous before-after predicate (CBAP) operator, denoted \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbin {:\\mid _{t \\rightarrow t'}}$$\\end{document}, as follows:PP\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\begin{aligned} x_p \\mathbin {:\\mid _{t \\rightarrow t'}} \\mathcal {P}(x_s, x_p,x_p')\\mathbin { \\& }\\mathcal {I}&\\equiv \\ [0,t] \\lhd x' = [0,t] \\lhd x \\end{aligned}$$\\end{document}\nPR\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\wedge \\mathcal {P}(x_s, [t,t'] \\lhd x_p, [t,t'] \\lhd x_p') \\end{aligned}$$\\end{document}\nLI\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\wedge \\forall t^*\\in [t,t'], x_p'(t^*) \\in \\mathcal {I} \\end{aligned}$$\\end{document}We note \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ CBAP (x_s, x_p,x_p')\\equiv PP(x_p,x_p') \\wedge PR(x_s,x_p,x_p')\\wedge LI(x_p,x_p')$$\\end{document}. The operator consists of 3 parts: past preservation and coherence at assignment point (PP), before-after predicate on the added section (PR), and local invariant preservation (LI). The discrete state variables \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s$$\\end{document} do not change in the interval \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$[t,t'] $$\\end{document} but the predicate \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {P}$$\\end{document} may use it for control purposes.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "Note that this operator is well-defined if and only if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t' > t$$\\end{document}, as otherwise the interval \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$[t,t']$$\\end{document} would not be well-defined.",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "From the above definition, shortcuts can be introduced for readability purposes:Continuous assignment: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ x \\mathbin {:=_{t \\rightarrow t'}} f \\mathbin { \\& }\\mathcal {I} \\ \\equiv \\ x \\mathbin {:\\mid _{t \\rightarrow t'}} x' = f \\mathbin { \\& }\\mathcal {I}$$\\end{document}Continuous evolution along a solvable differential equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {E} \\in \\mathbf {DE}(S)$$\\end{document}: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$  x \\mathbin {:\\sim _{t \\rightarrow t'}} \\mathcal {E} \\mathbin { \\& }\\mathcal {I} \\ \\equiv \\ x \\mathbin {:\\mid _{t \\rightarrow t'}} \\mathbf {solutionOf}([t,t'],x',\\mathcal {E}) \\mathbin { \\& }\\mathcal {I}$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Hybrid Systems Modelling Features",
            "ref_spans": []
        },
        {
            "text": "One of the most common architectures found in CPS (see Fig. 2) is a discrete software controller, which interacts by some means (e.g. actuators) with a plant and its physical environment (continuous physical phenomenon) in a closed-loop schema. Input from sensors is processed and output is generated and communicated to actuators [12]. Commands from a user or another controller may also be addressed to the controller.\n",
            "cite_spans": [
                {
                    "start": 332,
                    "end": 334,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": [
                {
                    "start": 60,
                    "end": 61,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Controllers are characterised by discrete state variables and transitions corresponding to control decisions; as for plants, they are defined by continuous state variables whose evolution is generally described using differential equations. Sensors, user commands control decision and actuators modify these variables.",
            "cite_spans": [],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": []
        },
        {
            "text": "In this paper, we focus on the verification of the correctness of such discrete controllers, which require correct composition of discrete and continuous models. We claim that correctness should arise from a design process based on sound abstractions and models of the relevant laws of physics.",
            "cite_spans": [],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": []
        },
        {
            "text": "Hybrid systems may combine the behaviours of multiple separated components (plants or controllers), which can lead to very different control strategies, following the number of controllers and plants to be controlled. Therefore, the generic architecture given in Fig. 2 should be refined into three types of architecture patterns:Single-to-Single AP corresponds to hybrid systems with one controller and one plant. Examples of hybrid systems corresponding to this pattern addressed in the literature include the automatic car braking [15], the signalised left-turn assist [13], heating systems [16], etc.Single-to-Many AP describes hybrid systems with one controller and many plants (more than one). This pattern corresponds to centralised control. An example of hybrid system corresponding to this pattern is the control of a global volume distributed over several tanks formalised with hybrid automata and with Event-B in [14].Many-to-Many AP characterises hybrid systems with many controllers and many plants. This pattern refers to the case where several hybrid systems are integrated together to implement a given function. Examples of such systems are UAV or rover fleet control modelled in Event-B [22].\n",
            "cite_spans": [
                {
                    "start": 535,
                    "end": 537,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 573,
                    "end": 575,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 595,
                    "end": 597,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 925,
                    "end": 927,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1206,
                    "end": 1208,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": [
                {
                    "start": 268,
                    "end": 269,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "All the patterns defined above refine the one of Fig. 2. The controller and the plant components may be refined to one or many components. These refinements introduce specific properties and behaviours associated to each pattern. The single-to-single AP defines one discrete state for the controller and one continuous state for the plant. The single-to-many AP defines a controller with one discrete state able to build a global continuous state aggregating the many states of each and every plants.",
            "cite_spans": [],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": [
                {
                    "start": 54,
                    "end": 55,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Finally, the many-to-many AP allows to define distributed hybrid systems where each component has a partial view of all the other systems. Here, it is difficult to build a global state of the whole system. Therefore, an approximation of this global state is used by each system controller to take control decisions. Then, the correctness of this approximation shall be ensured to establish global invariants. In other words, local invariants associated to each hybrid system contribute to ensure the global invariant of the whole system composed of all the hybrid systems.",
            "cite_spans": [],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": []
        },
        {
            "text": "Note: it is worth noticing that the case of many-to-many AP may be defined as a set of hybrid systems corresponding to either single-to-single AP or single-to-many AP. In the last case, single-to-many is abstracted by a single-to-single system, providing modular verification.",
            "cite_spans": [],
            "section": "Architecture Patterns for Modelling Hybrid Systems",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "Model State. The generic model deals with three variables. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s$$\\end{document} represents the controller\u2019s discrete state that belongs to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ STATES $$\\end{document} set consisting of the states of the system\u2019s mode automaton.",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_p$$\\end{document} is the system\u2019s continuous state. It is a function of time (inv3) valued in the (continuous) state space\nS, usually \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {R}^n$$\\end{document}. It represents the physical quantities that are sensed and/or controlled. Last, we recall that variable t models the physical, dense time.",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "Model Behaviour. The defined model follows the control-command principle depicted on Fig. 2. Two categories of events are defined. Discrete events are instantaneous. They are associated with changes in the state of the mode automaton either internal (Transition event) or induced by the sensing of the plant\u2019s state (Sense event). Continuous events, on the contrary, are not instantaneous. They describe the Plant\u2019s behaviour, either following environmental changes (behave event) or caused by actuation (actuate event). Note that all these generic events will be refined later for developing particular hybrid systems.\n",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": [
                {
                    "start": 90,
                    "end": 91,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Transition. Transition events (corresponding to command arrow and the Ctrl box of Fig. 2) model internal changes in the controller. They represent user commands, internal timers or non-deterministic choices that occur in the discrete part of the system (mode automata). It updates the state of the automaton (act1).\n",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": [
                {
                    "start": 87,
                    "end": 88,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Sense. Sensing events (corresponding to sense arrow of Fig. 2) model changes in the controller induced by the reading of the plant\u2019s state, generally obtained from sensors. As they are fired according to the plant\u2019s state and to the mode automaton\u2019s state, they are guarded by a predicate over \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_p(t)$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s$$\\end{document} (grd3). The purpose is to change state \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s$$\\end{document} in action act1 of the mode automaton.\n",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": [
                {
                    "start": 60,
                    "end": 61,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Behave. Behave events (corresponding to the environment arrow of Fig. 2) represent changes in the plant due to the environment: rain, wind, etc. These events enforce, in action act1, the dynamics of the plant to comply with a differential equation under solvability condition (gdr2) but without any condition on the state of the mode automaton.\n",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": [
                {
                    "start": 70,
                    "end": 71,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Actuate. Actuation events (corresponding to the actuate arrow of Fig. 2) model changes in the plant induced by the controller (generally performed by actuators). These events enforce, in action act1, the dynamics of the plant to comply with a differential equation under solvability condition (gdr2) and a constraint H on the plant evolution domain (gdr5 and gdr6). Moreover, unlike for Behave, since Actuate results from a change in the controller, it is guarded by a predicate on the mode automaton (gdr4).",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": [
                {
                    "start": 70,
                    "end": 71,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "As mentioned above, both Behave and Actuate are continuous events. They rely on the continuous evolution operators defined in Sect. 3. Both events enforce plant behaviour by setting up a corresponding differential equation.",
            "cite_spans": [],
            "section": "A Generic Event-B Model for Hybrid Systems ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "The semantics of hybrid models we use is close to the one of Hybrid Event-B [8], hybrid programs in [21] or continuous action systems [7, 20].",
            "cite_spans": [
                {
                    "start": 77,
                    "end": 78,
                    "mention": "8",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 101,
                    "end": 103,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 135,
                    "end": 136,
                    "mention": "7",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 138,
                    "end": 140,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Semantics ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "In classical Event-B semantics, each model is associated with a discrete state-transition system, in which transitions are the fired machine events and states consist of the machine\u2019s variables. A system is hence characterised by a set of licit traces i.e. a set of fired events that abide by the system\u2019s invariants.",
            "cite_spans": [],
            "section": "Semantics ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "In our approach, discrete events are timeless, while continuous ones have a duration. In order to properly handle the modelling of continuous behaviours, the semantics of Event-B is enhanced to handle modelling of continuous phenomena which are, in nature, different from discrete behaviours. We have identified two categories of events: discrete (instantaneous) events, which use discrete assignments operators such as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$:\\mid $$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ := $$\\end{document} and continuous (not instantaneous) events that span over some duration and use continuous assignment operators, namely \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbin {:\\mid _{t \\rightarrow t^\\prime }}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbin {:=_{t \\rightarrow t^\\prime }}$$\\end{document}. Note that, if several (continuous or discrete) events guards are enabled, these enabled events are fired non deterministically.",
            "cite_spans": [],
            "section": "Semantics ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "A model is then defined as follows. After initialisation, continuous events (Behave and Actuate events) run continuously unless a discrete, instantaneous event is enabled (either a Sense or a Transition event). In this case, discrete events are preemptive. This protocol ensures that when the conditions (events\u2019 guards) are met, the controller is able to trigger control actions (Sense or Transition) that may or may not change the continuous behaviour of the plant (through triggering an Actuate event). Unlike Actuate, the Behave event neither requires control action to be triggered nor any plant evolution constraint H. Sensing actions using the Sense event will re-establish the correct plant behaviour via the control loop in order to further trigger an Actuate event.",
            "cite_spans": [],
            "section": "Semantics ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "The generic model is the entry point for the method. Specific hybrid system models are obtained by refining it, providing the various witnesses issued from event parameters and substituted variables. In itself, this model generates 13 proof obligations that are easily discharged. Among them there is an important obligation stating that if equation e is solvable then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\mathbin {:\\sim _{t \\rightarrow t^\\prime }} e$$\\end{document} is feasible.",
            "cite_spans": [],
            "section": "The Generic Model in Rodin ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "This approach has been successfully applied to various case studies. [13, 15] show a class of systems with one controller and one plant while [14] demonstrates the possible use of the method for a system with one controller and several plants.",
            "cite_spans": [
                {
                    "start": 70,
                    "end": 72,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 74,
                    "end": 76,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 143,
                    "end": 145,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "The Generic Model in Rodin ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "Models for the generic approach, including the above-mentioned case studies can be found at https://www.irit.fr/~Guillaume.Dupont/models.php.",
            "cite_spans": [],
            "section": "The Generic Model in Rodin ::: Methodology for Hybrid System Design",
            "ref_spans": []
        },
        {
            "text": "The problem is depicted on Fig. 3 and can be described as follows: one or more tanks are filled with a liquid and connected to an input and an output pump. A controller can access the global volume V of all tanks and may control their pumps to start filling or emptying them. The goal of the controller is to keep the whole volume between \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ low }$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ high }$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Abstract System ::: Case Study: The Water Tank Problem",
            "ref_spans": [
                {
                    "start": 32,
                    "end": 33,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "The following safety requirements are defined. Let V, be the volume of the tanks (continuous state being controlled). V is physically bounded by 0 and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ max }$$\\end{document}, such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ high } \\le V_{{max}}$$\\end{document}, and it shall satisfy the following properties:SAF1 The volume never overflows nor underflows: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V(t) \\in [V_{ low },V_{ high }]$$\\end{document}SAF2 The variation of the volume is bounded (to avoid excessive turmoil in the tank): \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\dot{V}(t)| < \\varDelta V_{max}$$\\end{document}\n",
            "cite_spans": [],
            "section": "Abstract System ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "At this level, it is not needed to know the specific characteristics of the tanks (i.e. their shapes, their number, the behaviour of the pumps, the way the controller accesses V and so on). They are simply abstracted away so as to keep this description as generic as possible. The system is later refined for specific tanks and using specific architecture patterns.",
            "cite_spans": [],
            "section": "Abstract System ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "The system formerly introduced can be refined to illustrate the three architecture patterns identified in Sect. 4 and depicted on Fig. 4.\n",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": [
                {
                    "start": 135,
                    "end": 136,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "Single-to-Single Architecture Pattern. Within a refinement, the abstract model of Fig. 3 is instantiated by a concrete system composed of one controller managing one cylinder-shaped tank (see Fig. 4a). The abstract plant\u2019s volume is refined using the gluing invariant \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V = B\\cdot h$$\\end{document}, where B is the surface of the cylinder\u2019s base and h is the height of liquid in the tank (easier to measure than the direct volume). Constraints on h are strengthened by the well-definedness condition \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ max } \\le B\\cdot H_{ max }$$\\end{document}, ensuring that the cylinder can contain (at least) volume \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ max }$$\\end{document}.",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": [
                {
                    "start": 87,
                    "end": 88,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 197,
                    "end": 198,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "As a matter of simplification, the pumps are associated with a fixed flow rate and are either open (full flow) or closed (no flow), with no intermediate state. Therefore, a differential equation for the system is \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\dot{h} = { in }\\cdot \\delta _{ in }+{ out }\\cdot \\delta _{ out }$$\\end{document}, where in, out are the states of the pumps and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta _{ in }$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta _{{out}}$$\\end{document} are their respective flows.",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "This pattern has been previously instantiated in [13, 15].",
            "cite_spans": [
                {
                    "start": 50,
                    "end": 52,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 54,
                    "end": 56,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "Single-to-Many Architecture Pattern. The same case study can be used to illustrate the second architecture pattern, which involves a single controller and many plants. In this case, we assume that the controller has a global view of the system. In other words, it knows all the plants\u2019 continuous state variables.",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "Figure 4b depicts a simplified case for two cylinder tanks, but it scales to any number of tanks of various shapes provided the differential equations that governs these plants are known. For two cylindrical tanks, the gluing invariant is \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V= B_1\\cdot h_1 + B_2 \\cdot h_2$$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$B_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$B_2$$\\end{document} are the surface of the cylinders bases and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$h_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$h_2$$\\end{document} are the height of liquid in the tanks. The associated differential equations given as witnesses for instantiation are defined by a linear combination.",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "However, the interesting property in this instantiation relates to the feasibility of the refinement. Indeed, an additional well-definedness condition, expressed as an invariant, states that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{max}\\le B_1\\cdot H_{1, max } +B_2\\cdot H_{2, max } $$\\end{document} as to guarantee that the maximum abstract volume can be contained by the two cylinders representing the concrete plant.",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "This pattern has been thoroughly instantiated and studied in [14].",
            "cite_spans": [
                {
                    "start": 62,
                    "end": 64,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "Note: All the Event-B models corresponding to the two architecture patterns discussed above are available at https://www.irit.fr/~Guillaume.Dupont/models.php. We did not discuss them in this paper due to space limitations. More details can be found in [14, 15].",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 255,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 257,
                    "end": 259,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "Section 7 below, focuses only on the Event-B models corresponding to the most complex architecture pattern: many-to-many.",
            "cite_spans": [],
            "section": "Architecture Patterns as Abstract System Refinements ::: Case Study: The Water Tank Problem",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Abstract Tank Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "Machine State. The controlled variable is the volume V. As mentioned in Sect. 6.1 (SAF1 and SAF2), this quantity shall remain between \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ low }$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ high }$$\\end{document} and its derivative (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\dot{V}$$\\end{document}) shall be bounded by the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varDelta V_{ max }$$\\end{document} constant.",
            "cite_spans": [],
            "section": "Abstract Tank Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "The system operates in 4 modes: Emptying (volume decreases), Filling (volume increases), Normal (volume varies in an arbitrary way between \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ low }$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ high }$$\\end{document}) and Stable (volume does not vary) defining the set STATES.\n",
            "cite_spans": [],
            "section": "Abstract Tank Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "Transition and Sense. When the volume reaches \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ low }$$\\end{document} (resp. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ high }$$\\end{document}) the system moves to Filling (resp. Emptying) mode. Outside of these restrictions, the system may evolve arbitrarily from one mode to another, via transition events. Transition events are guarded by a stricter version of the safety invariant as to prevent the system from deliberately going into an unsafe mode.\n",
            "cite_spans": [],
            "section": "Abstract Tank Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "Behave and Actuate. The system performs actuation on the pumps. At this level, the shape of the tank(s) and the behaviour of the pumps are not known yet. The only constraint the actuation shall enforce is that whenever the system is in a specific state, the provided differential equation for actuation is such that its solutions have the expected behaviour (e.g. decreasing solutions when in Emptying mode, increasing solutions when in Filling mode, etc.).",
            "cite_spans": [],
            "section": "Abstract Tank Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "This constraint is captured by the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ FlowEq (x_s,D,e)$$\\end{document} predicate of guard grd3 and is defined in a theory, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s$$\\end{document} is the controller\u2019s state, D is the domain on which the predicated behaviour is expected to be true and e is the given equation.",
            "cite_spans": [],
            "section": "Abstract Tank Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "The model presented below corresponds to the system depicted on Fig. 4c.\n",
            "cite_spans": [],
            "section": "Many-to-many Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": [
                {
                    "start": 69,
                    "end": 70,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "Machine State. In this refinement, we want to control two tanks (although this could be extended to any number of tanks). Each tank has its own volume, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_2$$\\end{document} (see Fig. 4c) behaving as a global invariant. The abstract volume V is hence refined using the gluing invariant \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V = V_1 + V_2$$\\end{document}, and the safety invariant becomes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{{low}} \\le V_1 + V_2 \\le V_{ high }$$\\end{document} (corresponding to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ low } \\le B_1\\cdot h_1 + B_2\\cdot h_2 \\le V_{ high }$$\\end{document}). Each volume \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_i$$\\end{document} is bounded by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{{i,{ max }}}$$\\end{document}, and in order to have a coherent refinement we need to have \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ max } \\le V_{{1,{ max }}} + V_{{2,{ max }}}$$\\end{document}. The controller discrete abstract state \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_s$$\\end{document} is glued (inv02) with the two discrete controllers states using the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ guess\\_gs $$\\end{document} operator.",
            "cite_spans": [],
            "section": "Many-to-many Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": [
                {
                    "start": 744,
                    "end": 745,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "Each tank is controlled by an independent controller. In a many-to-many pattern, a controller does not know exactly the state of the other controllers (i.e. what the other controllers are doing). However, the physics asserts that an estimation of this other state, and as such of the global state, can be built. To model this situation, two additional continuous variables,  (resp. ) are introduced. They allow the controller 2 (resp. 1) to simulate (i.e. estimate) \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_1$$\\end{document} (resp. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_2$$\\end{document}).",
            "cite_spans": [],
            "section": "Many-to-many Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "Because it is an estimation,  is associated to a bound, , that represents the maximum error allowed for the controller to ensure a correct behaviour. We then need to have, at any time and for all i: , i.e.:  is a precise enough approximation of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_i$$\\end{document}. Again, these properties are borrowed from the physics.\n",
            "cite_spans": [],
            "section": "Many-to-many Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "Transition and Sense. Controller 1 needs to enforce the (local) invariant , and similarly for controller 2. This enforcement is used to prove the initially defined global invariant.",
            "cite_spans": [],
            "section": "Many-to-many Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "Behave and Actuate. The system\u2019s actuation is established using continuous refinement as presented in [14]: the witness for e (abstract differential equation) is a predicate that links the solutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_2$$\\end{document} (concrete differential equations) such that the sum \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_1^*+ V_2^*$$\\end{document} of any pair of solutions \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(V_1^*,V_2^*)$$\\end{document} of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(e_1,e_2)$$\\end{document} is a solution of e, in addition to having the relevant general constraints (namely, a correct behaviour as per the system\u2019s current state). The witness for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V'$$\\end{document} is given to establish the invariant after actuation.\n",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 105,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Many-to-many Model ::: Application of the Many-to-Many Architecture Pattern",
            "ref_spans": []
        },
        {
            "text": "The work presented in this paper showed that the generic model proposed in [15] applies to different architecture patterns of hybrid systems. Below, we provide an assessment of the approach with respect to the proof effort and set up methodology. The models presented in this paper have been developed on the Rodin platform and all the generated proof obligations were discharged.",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 78,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "Complete models can be found at https://irit.fr/~Guillaume.Dupont/models.php.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "Proof Effort. The abstract tank model generated 107 proof obligations, most of which are invariant (about 40%) or well-definedness (about 21%) related. Well-definedness also appears often in proofs subgoals. These POs are usually easy to prove, at least on paper. Feasibility POs, related to solution existence, are those difficult to prove.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "As for the many-to-many model, it yields 156 proof obligations, among which a good proportion (53%) consists of invariant POs alone. Again, most of them are not hard to discharge. The model also yields quite a few guard strengthening POs (around 15%) that ensure that the controllers behave properly despite the estimation it makes of the system. But the hardest POs to discharge are the one regarding refinement (witness well-definedness and feasibility, and simulation).",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "A great interest of the proposed methodology is there: the only complex proofs to carry on are related to refinement. Proofs for complicated invariants and so on have been realised at the abstract level and are done once and for all.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "Tool Support. Because of our heavy use of the theory plug-in in Rodin, proof automation (including SMTs and external provers) is nearly nonexistent for discharging the generated POs. Proof is thus mostly interactive, and even simple steps such as basic well-definedness are to be done fully manually using the interactive prover. That being said, the possibility to define rewrite and inference rules greatly improves the prover\u2019s overall ergonomy.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "Methodology. The use of patterns as methodological basis is not new in system engineering. The availability of architecture patterns offers a methodological guide to system designers, who simply need to identify which pattern matches the hybrid system under design and instantiate it with refinements and witnesses.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "The generic model offers a framework that is formally proven once and for all. It corresponds to a customisation of Event-B to offer resources for modelling controllers, plants, sensing and actuation, integrating both discrete and continuous behaviours. Proofs are done once for all and the designer does not need to re-prove them. This generic model is used as a ground model for further designs.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "Each defined architecture pattern is formalised as an instance of the generic model. The pattern to be chosen for instantiation depends on the number of controllers and plants required in the model. Instantiation is performed using Event-B refinement.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "One of the interests of the Event-B method is the capability to check well-definedness and feasibility conditions, which is particularly useful during instantiation. In our developments, it has been extensively used to provide conditions about the soundness of the defined instantiations. For example, it has been used to state that the cylinders given as refinement are capable of storing an abstractly specified volume of liquid \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_{ max }$$\\end{document}.",
            "cite_spans": [],
            "section": "Assessment",
            "ref_spans": []
        },
        {
            "text": "This paper presented a framework for modelling hybrid systems. It relies on a formal model of different hybrid systems architecture patterns formalised with the Event-B method using the Rodin platform. These patterns, commonly used when designing hybrid systems, are characterised by the number of controlled plants and by the kind of control strategy (centralised or distributed). Because this framework is formalised at a generic level, it offers a systematic methodology for hybrid systems development and verification.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "The approach extensively uses the mathematical extensions capabilities offered by the theory plug-in of Event-B, allowing to enrich Event-B models with continuous behaviours. Data types for reals, continuous functions, differential equations and so on have been defined within a sound Event-B theory. The available axioms and theorems were used to prove the relevant safety properties of the developed systems expressed as machine invariants. The developed models are scalable (modulo proof efforts), as they can deal an arbitrary number of state variables. Witnesses for the sets STATES and S are provided at instantiation using gluing invariants.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "This work revealed several research perspectives. Below, we summarise the identified future research actions.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "Need for Other Domain Theories. Although the definition of generic architecture patterns has reduced the number and the complexity of proof obligations and their proofs, the proof effort still needs to be reduced. Providing other sound domain theories contributes to such a reduction. One of the main extensions to our work consists in enriching the proposed framework with other theories. Two kinds of theories are expected: theories for other types of control and theories where the physics of considered plants is formalised. A library of such theories would help for such hybrid systems developments by making explicit knowledge in physics and in other related domains [3].",
            "cite_spans": [
                {
                    "start": 674,
                    "end": 675,
                    "mention": "3",
                    "ref_id": "BIBREF16"
                }
            ],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "Methodology. From the method formalisation point of view, the major improvement is to leverage the formalisation of architecture patterns at a higher abstraction level to handle controllers and plants as first class mathematical objects.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "Other patterns where the number of hybrid systems evolves dynamically could be considered. In this case, each system would have a partial knowledge of its environment. This kind of patterns may help to model autonomous aspects. However, defining safety properties remains a major challenge for such patterns.",
            "cite_spans": [],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        },
        {
            "text": "Integration of Simulation Tools.  To handle the traditional hybrid systems development processes where simulation is extensively used, coupling the developed models with simulation tools, like in [1], would help in animating these models.",
            "cite_spans": [
                {
                    "start": 197,
                    "end": 198,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Model structure\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Differential equation theory snippet",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Generic hybrid system representation",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Abstract tank",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: Three refinement patterns for the case study",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "Practical theory extension in Event-B",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Maamria",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theories of Programming and Formal Methods",
            "volume": "",
            "issn": "",
            "pages": "67-81",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "Secure control: towards survivable cyber-physical systems",
            "authors": [
                {
                    "first": "AA",
                    "middle": [],
                    "last": "Cardenas",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Amin",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sastry",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "System",
            "volume": "1",
            "issn": "a2",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Hybrid systems and Event-B: a formal approach to signalised left-turn assist",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Dupont",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "A\u00eft-Ameur",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pantel",
                    "suffix": ""
                },
                {
                    "first": "NK",
                    "middle": [],
                    "last": "Singh",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "New Trends in Model and Data Engineering",
            "volume": "",
            "issn": "",
            "pages": "153-158",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "Proof-based approach to hybrid systems development: dynamic logic and Event-B",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Dupont",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "A\u00eft-Ameur",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pantel",
                    "suffix": ""
                },
                {
                    "first": "NK",
                    "middle": [],
                    "last": "Singh",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Abstract State Machines, Alloy, B, TLA, VDM, and Z",
            "volume": "",
            "issn": "",
            "pages": "155-170",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Continuous action system refinement",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Meinicke",
                    "suffix": ""
                },
                {
                    "first": "IJ",
                    "middle": [],
                    "last": "Hayes",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Mathematics of Program Construction",
            "volume": "",
            "issn": "",
            "pages": "316-337",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "Hybrid automata: an algorithmic approach to the specification and verification of hybrid systems",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Alur",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Courcoubetis",
                    "suffix": ""
                },
                {
                    "first": "TA",
                    "middle": [],
                    "last": "Henzinger",
                    "suffix": ""
                },
                {
                    "first": "P-H",
                    "middle": [],
                    "last": "Ho",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "Hybrid Systems",
            "volume": "",
            "issn": "",
            "pages": "209-229",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "Modularity for timed and hybrid systems",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Alur",
                    "suffix": ""
                },
                {
                    "first": "TA",
                    "middle": [],
                    "last": "Henzinger",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "CONCUR \u201997: Concurrency Theory",
            "volume": "",
            "issn": "",
            "pages": "74-88",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "A system substitution mechanism for hybrid systems in Event-B",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Babin",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "A\u00eft-Ameur",
                    "suffix": ""
                },
                {
                    "first": "NK",
                    "middle": [],
                    "last": "Singh",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pantel",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Formal Methods and Software Engineering",
            "volume": "",
            "issn": "",
            "pages": "106-121",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "Continuous action systems as a model for hybrid systems",
            "authors": [
                {
                    "first": "RJ",
                    "middle": [],
                    "last": "Back",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Petre",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Porres",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Nord. J. Comput.",
            "volume": "8",
            "issn": "1",
            "pages": "2-21",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "Trusting computations: a mechanized proof from partial differential equations to actual program",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Boldo",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Cl\u00e9ment",
                    "suffix": ""
                },
                {
                    "first": "JC",
                    "middle": [],
                    "last": "Filli\u00e2tre",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mayero",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Melquiond",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Weis",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Comput. Math. Appl.",
            "volume": "68",
            "issn": "3",
            "pages": "325-352",
            "other_ids": {
                "DOI": [
                    "10.1016/j.camwa.2014.06.004"
                ]
            }
        }
    }
}