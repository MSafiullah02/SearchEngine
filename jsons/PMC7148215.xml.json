{
    "paper_id": "PMC7148215",
    "metadata": {
        "title": "A Hierarchical Model for Data-to-Text Generation",
        "authors": [
            {
                "first": "Joemon",
                "middle": [
                    "M."
                ],
                "last": "Jose",
                "suffix": "",
                "email": "joemon.jose@glasgow.ac.uk",
                "affiliation": {}
            },
            {
                "first": "Emine",
                "middle": [],
                "last": "Yilmaz",
                "suffix": "",
                "email": "emine.yilmaz@ucl.ac.uk",
                "affiliation": {}
            },
            {
                "first": "Jo\u00e3o",
                "middle": [],
                "last": "Magalh\u00e3es",
                "suffix": "",
                "email": "jm.magalhaes@fct.unl.pt",
                "affiliation": {}
            },
            {
                "first": "Pablo",
                "middle": [],
                "last": "Castells",
                "suffix": "",
                "email": "pablo.castells@uam.es",
                "affiliation": {}
            },
            {
                "first": "Nicola",
                "middle": [],
                "last": "Ferro",
                "suffix": "",
                "email": "ferro@dei.unipd.it",
                "affiliation": {}
            },
            {
                "first": "M\u00e1rio",
                "middle": [
                    "J."
                ],
                "last": "Silva",
                "suffix": "",
                "email": "mjs@inesc-id.pt",
                "affiliation": {}
            },
            {
                "first": "Fl\u00e1vio",
                "middle": [],
                "last": "Martins",
                "suffix": "",
                "email": "flaviomartins@acm.org",
                "affiliation": {}
            },
            {
                "first": "Cl\u00e9ment",
                "middle": [],
                "last": "Rebuffel",
                "suffix": "",
                "email": "clement.rebuffel@lip6.fr",
                "affiliation": {}
            },
            {
                "first": "Laure",
                "middle": [],
                "last": "Soulier",
                "suffix": "",
                "email": "laure.soulier@lip6.fr",
                "affiliation": {}
            },
            {
                "first": "Geoffrey",
                "middle": [],
                "last": "Scoutheeten",
                "suffix": "",
                "email": "geoffrey.scoutheeten@bnpparibas.com",
                "affiliation": {}
            },
            {
                "first": "Patrick",
                "middle": [],
                "last": "Gallinari",
                "suffix": "",
                "email": "patrick.gallinari@lip6.fr",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Knowledge and/or data is often modeled in a structure, such as indexes, tables, key-value pairs, or triplets. These data, by their nature (e.g., raw data or long time-series data), are not easily usable by humans; outlining their crucial need to be synthesized. Recently, numerous works have focused on leveraging structured data in various applications, such as question answering [24, 34] or table retrieval [7, 32]. One emerging research field consists in transcribing data-structures into natural language in order to ease their understandablity and their usablity. This field is referred to as \u201cdata-to-text\u201d [8] and has its place in several application domains (such as journalism [22] or medical diagnosis [25]) or wide-audience applications (such as financial [26] and weather reports [30], or sport broadcasting [4, 39]). As an example, Fig. 1 shows a data-structure containing statistics on NBA basketball games, paired with its corresponding journalistic description.\n",
            "cite_spans": [
                {
                    "start": 383,
                    "end": 385,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 387,
                    "end": 389,
                    "mention": "34",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 411,
                    "end": 412,
                    "mention": "7",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 414,
                    "end": 416,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 615,
                    "end": 616,
                    "mention": "8",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 688,
                    "end": 690,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 714,
                    "end": 716,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 769,
                    "end": 771,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 794,
                    "end": 796,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 822,
                    "end": 823,
                    "mention": "4",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 825,
                    "end": 827,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Introduction",
            "ref_spans": [
                {
                    "start": 851,
                    "end": 852,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Designing data-to-text models gives rise to two main challenges: (1) understanding structured data and (2) generating associated descriptions. Recent data-to-text models [18, 28, 29, 39] mostly rely on an encoder-decoder architecture [2] in which the data-structure is first encoded sequentially into a fixed-size vectorial representation by an encoder. Then, a decoder generates words conditioned on this representation. With the introduction of the attention mechanism [19] on one hand, which computes a context focused on important elements from the input at each decoding step and, on the other hand, the copy mechanism [11, 33] to deal with unknown or rare words, these systems produce fluent and domain comprehensive texts. For instance, Roberti et al. [31] train a character-wise encoder-decoder to generate descriptions of restaurants based on their attributes, while Puduppully et al. [28] design a more complex two-step decoder: they first generate a plan of elements to be mentioned, and then condition text generation on this plan. Although previous work yield overall good results, we identify two important caveats, that hinder precision (i.e. factual mentions) in the descriptions: Linearization of the data-structure. In practice, most works focus on introducing innovating decoding modules, and still represent data as a unique sequence of elements to be encoded. For example, the table from Fig. 1 would be linearized to [(Hawks, H/V, H), ..., (Magic, H/V, V), ...], effectively leading to losing distinction between rows, and therefore entities. To the best of our knowledge, only Liu et al. [17, 18] propose encoders constrained by the structure but these approaches are designed for single-entity structures.Arbitrary ordering of unordered collections in recurrent networks (RNN). Most data-to-text systems use RNNs as encoders (such as GRUs or LSTMs), these architectures have however some limitations. Indeed, they require in practice their input to be fed sequentially. This way of encoding unordered sequences (i.e. collections of entities) implicitly assumes an arbitrary order within the collection which, as demonstrated by Vinyals et al. [37], significantly impacts the learning performance.\n",
            "cite_spans": [
                {
                    "start": 171,
                    "end": 173,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 175,
                    "end": 177,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 179,
                    "end": 181,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 183,
                    "end": 185,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 235,
                    "end": 236,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 472,
                    "end": 474,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 625,
                    "end": 627,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 629,
                    "end": 631,
                    "mention": "33",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 760,
                    "end": 762,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 895,
                    "end": 897,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1612,
                    "end": 1614,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1616,
                    "end": 1618,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 2168,
                    "end": 2170,
                    "mention": "37",
                    "ref_id": "BIBREF30"
                }
            ],
            "section": "Introduction",
            "ref_spans": [
                {
                    "start": 1414,
                    "end": 1415,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "To address these shortcomings, we propose a new structured-data encoder assuming that structures should be hierarchically captured. Our contribution focuses on the encoding of the data-structure, thus the decoder is chosen to be a classical module as used in [28, 39]. Our contribution is threefold:We model the general structure of the data using a two-level architecture, first encoding all entities on the basis of their elements, then encoding the data structure on the basis of its entities;We introduce the Transformer encoder [36] in data-to-text models to ensure robust encoding of each element/entities in comparison to all others, no matter their initial positioning;We integrate a hierarchical attention mechanism to compute the hierarchical context fed into the decoder.\n",
            "cite_spans": [
                {
                    "start": 260,
                    "end": 262,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 264,
                    "end": 266,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 534,
                    "end": 536,
                    "mention": "36",
                    "ref_id": "BIBREF29"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We report experiments on the RotoWire benchmark [39] which contains around 5K statistical tables of NBA basketball games paired with human-written descriptions. Our model is compared to several state-of-the-art models. Results show that the proposed architecture outperforms previous models on BLEU score and is generally better on qualitative metrics.",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 51,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In the following, we first present a state-of-the art of data-to-text literature (Sect. 2), and then describe our proposed hierarchical data encoder (Sect. 3). The evaluation protocol is presented in Sect. 4, followed by the results (Sect. 5). Section 6 concludes the paper and presents perspectives.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Until recently, efforts to bring out semantics from structured-data relied heavily on expert knowledge [6, 30]. For example, in order to better transcribe numerical time series of weather data to a textual forecast, Reiter et al. [30] devise complex template schemes in collaboration with weather experts to build a consistent set of data-to-word rules.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 105,
                    "mention": "6",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 107,
                    "end": 109,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 231,
                    "end": 233,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Modern approaches to the wide range of tasks based on structured-data (e.g. table retrieval [7, 41], table classification [9], question answering [12]) now propose to leverage progress in deep learning to represent these data into a semantic vector space (also called embedding space). In parallel, an emerging task, called \u201cdata-to-text\u201d, aims at describing structured data into a natural language description. This task stems from the neural machine translation (NMT) domain, and early work [1, 15, 39] represent the data records as a single sequence of facts to be entirely translated into natural language. Wiseman et al. [39] show the limits of traditional NMT systems on larger structured-data, where NMT systems fail to accurately extract salient elements.",
            "cite_spans": [
                {
                    "start": 93,
                    "end": 94,
                    "mention": "7",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 96,
                    "end": 98,
                    "mention": "41",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 123,
                    "end": 124,
                    "mention": "9",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 147,
                    "end": 149,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 494,
                    "end": 495,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 497,
                    "end": 499,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 501,
                    "end": 503,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 627,
                    "end": 629,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "To improve these models, a number of work [16, 28, 40] proposed innovating decoding modules based on planning and templates, to ensure factual and coherent mentions of records in generated descriptions. For example, Puduppully et al. [28] propose a two-step decoder which first targets specific records and then use them as a plan for the actual text generation. Similarly, Li et al. [16] proposed a delayed copy mechanism where their decoder also acts in two steps: (1) using a classical LSTM decoder to generate delexicalized text and (2) using a pointer network [38] to replace placeholders by records from the input data.",
            "cite_spans": [
                {
                    "start": 43,
                    "end": 45,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 47,
                    "end": 49,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 51,
                    "end": 53,
                    "mention": "40",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 235,
                    "end": 237,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 385,
                    "end": 387,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 566,
                    "end": 568,
                    "mention": "38",
                    "ref_id": "BIBREF31"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Closer to our work, very recent work [17, 18, 29] have proposed to take into account the data structure. More particularly, Puduppully et al. [29] follow entity-centric theories [10, 20] and propose a model based on dynamic entity representation at decoding time. It consists in conditioning the decoder on entity representations that are updated during inference at each decoding step. On the other hand, Liu et al. [17, 18] rather focus on introducing structure into the encoder. For instance, they propose a dual encoder [17] which encodes separately the sequence of element names and the sequence of element values. These approaches are however designed for single-entity data structures and do not account for delimitation between entities.",
            "cite_spans": [
                {
                    "start": 38,
                    "end": 40,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 42,
                    "end": 44,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 46,
                    "end": 48,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 143,
                    "end": 145,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 179,
                    "end": 181,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 183,
                    "end": 185,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 418,
                    "end": 420,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 422,
                    "end": 424,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 525,
                    "end": 527,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Our contribution differs from previous work in several aspects. First, instead of flatly concatenating elements from the data-structure and encoding them as a sequence [18, 28, 39], we constrain the encoding to the underlying structure of the input data, so that the delimitation between entities remains clear throughout the process. Second, unlike all works in the domain, we exploit the Transformer architecture [36] and leverage its particularity to directly compare elements with each others in order to avoid arbitrary assumptions on their ordering. Finally, in contrast to [5, 29] that use a complex updating mechanism to obtain a dynamic representation of the input data and its entities, we argue that explicit hierarchical encoding naturally guides the decoding process via hierarchical attention.",
            "cite_spans": [
                {
                    "start": 169,
                    "end": 171,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 173,
                    "end": 175,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 177,
                    "end": 179,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 416,
                    "end": 418,
                    "mention": "36",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 581,
                    "end": 582,
                    "mention": "5",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 584,
                    "end": 586,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Let\u2019s consider the following notations:",
            "cite_spans": [],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} An entity\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document} is a set of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$J_i$$\\end{document} unordered records \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{r_{i,1}, ..., r_{i,j}, ..., r_{i,J_i}\\}$$\\end{document}; where record \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r_{i,j}$$\\end{document} is defined as a pair of key\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k_{i,j}$$\\end{document} and value\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i,j}$$\\end{document}. We outline that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$J_i$$\\end{document} might differ between entities.",
            "cite_spans": [],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} A data-structure\ns is an unordered set of I entities \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document}. We thus denote .",
            "cite_spans": [],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} For each data-structure, a textual description\ny is associated. We refer to the first t words of a description y as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_{1:t}$$\\end{document}. Thus, the full sequence of words can be noted as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y = y_{1:T}$$\\end{document}.",
            "cite_spans": [],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} The dataset\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {D}$$\\end{document} is a collection of N aligned (data-structure, description) pairs (s, y). For instance, Fig. 1 illustrates a data-structure associated with a description. The data-structure includes a set of entities (Hawks, Magic, Al Horford, Jeff Teague, ...). The entity Jeff Teague is modeled as a set of records {(PTS, 17), (REB, 0), (AST, 7) ...} in which, e.g., the record (PTS, 17) is characterized by a key (PTS) and a value (17).",
            "cite_spans": [],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": [
                {
                    "start": 696,
                    "end": 697,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "For each data-structure s in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {D}$$\\end{document}, the objective function aims to generate a description \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{y}$$\\end{document} as close as possible to the ground truth y. This objective function optimizes the following log-likelihood over the whole dataset \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {D}$$\\end{document}:1\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} {\\mathop {\\hbox {arg max}}\\limits _\\theta }\\, \\mathcal {L}(\\theta ) = {\\mathop {\\hbox {arg max}}\\limits _\\theta } \\sum _{(s,y) \\in \\mathcal {D}}{\\log P(\\hat{y}=y\\ |\\ s; \\theta )} \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\theta $$\\end{document} stands for the model parameters and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P(\\hat{y}=y\\ |\\ s; \\theta )$$\\end{document} the probability of the model to generate the adequate description y for table s.",
            "cite_spans": [],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "During inference, we generate the sequence \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{y}^*$$\\end{document} with the maximum a posteriori probability conditioned on table s. Using the chain rule, we get:2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\hat{y}_{1:T}^* = {\\mathop {\\hbox {arg max}}\\limits _{\\hat{y}_{1:T}}} \\prod _{t=1}^T P(\\hat{y}_t | \\hat{y}_{1:t-1}; s; \\theta ) \\end{aligned}$$\\end{document}This equation is intractable in practice, we approximate a solution using beam search, as in [17, 18, 28, 29, 39].",
            "cite_spans": [
                {
                    "start": 970,
                    "end": 972,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 974,
                    "end": 976,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 978,
                    "end": 980,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 982,
                    "end": 984,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 986,
                    "end": 988,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "Our model follows the encoder-decoder architecture [2]. Because our contribution focuses on the encoding process, we chose the decoding module used in [28, 39]: a two-layers LSTM network with a copy mechanism. In order to supervise this mechanism, we assume that each record value that also appears in the target is copied from the data-structure and we train the model to switch between freely generating words from the vocabulary and copying words from the input. We now describe the hierarchical encoder and the hierarchical attention.\n",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 53,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 152,
                    "end": 154,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 156,
                    "end": 158,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Notation and General Overview ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "As outlined in Sect. 2, most previous work [16, 28, 29, 39, 40] make use of flat encoders that do not exploit the data structure. To keep the semantics of each element from the data-structure, we propose a hierarchical encoder which relies on two modules. The first one (module A in Fig. 2) is called low-level encoder and encodes entities on the basis of their records; the second one (module B), called high-level encoder, encodes the data-structure on the basis of its underlying entities. In the low-level encoder, the traditional embedding layer is replaced by a record embedding layer as in [18, 28, 39]. We present in what follows the record embedding layer and introduce our two hierarchical modules.",
            "cite_spans": [
                {
                    "start": 44,
                    "end": 46,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 48,
                    "end": 50,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 52,
                    "end": 54,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 56,
                    "end": 58,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 60,
                    "end": 62,
                    "mention": "40",
                    "ref_id": "BIBREF34"
                },
                {
                    "start": 598,
                    "end": 600,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 602,
                    "end": 604,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 606,
                    "end": 608,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Hierarchical Encoding Model ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": [
                {
                    "start": 288,
                    "end": 289,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Record Embedding Layer. The first layer of the network consists in learning two embedding matrices to embed the record keys and values. Keys \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k_{i,j}$$\\end{document} are embedded to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {k}_{i,j} \\in \\mathbb {R}^{d}$$\\end{document} and values \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i,j}$$\\end{document} to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {v}_{i,j} \\in \\mathbb {R}^{d}$$\\end{document}, with d the size of the embedding. As in previous work [18, 28, 39], each record embedding \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {r}_{i,j}$$\\end{document} is computed by a linear projection on the concatenation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$[\\mathbf {k}_{i,j}$$\\end{document}; \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {v}_{i,j}]$$\\end{document} followed by a non linearity:3\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathbf {r}_{i,j} = \\text {ReLU}(\\mathbf {W}_{r}[\\mathbf {k}_{i,j};\\ \\mathbf {v}_{i,j}] + \\mathbf {b}_{r}) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {W}_r \\in \\mathbb {R}^{2d \\times d}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {b}_r \\in \\mathbb {R}^{d}$$\\end{document} are learnt parameters.",
            "cite_spans": [
                {
                    "start": 1459,
                    "end": 1461,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1463,
                    "end": 1465,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1467,
                    "end": 1469,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Hierarchical Encoding Model ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "The low-level encoder aims at encoding a collection of records belonging to the same entity while the high-level encoder encodes the whole set of entities. Both the low-level and high-level encoders consider their input elements as unordered. We use the Transformer architecture from [36]. For each encoder, we have the following peculiarities:the Low-level encoder encodes each entity \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document} on the basis of its record embeddings \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {r}_{i,j}$$\\end{document}. Each record embedding \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {r}_{i,j}$$\\end{document} is compared to other record embeddings to learn its final hidden representation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {h}_{i,j}$$\\end{document}. Furthermore, we add a special record [ENT] for each entity, illustrated in Fig. 2 as the last record. Since entities might have a variable number of records, this token allows to aggregate final hidden record representations \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{\\mathbf {h}_{i,j}\\}_{j=1}^{J_i}$$\\end{document} in a fixed-sized representation vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {h}_{i}$$\\end{document}.the High-level encoder encodes the data-structure on the basis of its entity representation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {h}_{i}$$\\end{document}. Similarly to the Low-level encoder, the final hidden state \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {e_i}$$\\end{document} of an entity is computed by comparing entity representation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {h}_{i}$$\\end{document} with each others. The data-structure representation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {z}$$\\end{document} is computed as the mean of these entity representations, and is used for the decoder initialization.\n",
            "cite_spans": [
                {
                    "start": 285,
                    "end": 287,
                    "mention": "36",
                    "ref_id": "BIBREF29"
                }
            ],
            "section": "Hierarchical Encoding Model ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": [
                {
                    "start": 1806,
                    "end": 1807,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "To fully leverage the hierarchical structure of our encoder, we propose two variants of hierarchical attention mechanism to compute the context fed to the decoder module.",
            "cite_spans": [],
            "section": "Hierarchical Attention ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nTraditional Hierarchical Attention. As in [29], we hypothesize that a dynamic context should be computed in two steps: first attending to entities, then to records corresponding to these entities. To implement this hierarchical attention, at each decoding step t, the model learns a first set of attention scores \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{i,t}$$\\end{document} over entities \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document} and a second set of attention scores \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta _{i,j,t}$$\\end{document} over records \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r_{i,j}$$\\end{document} belonging to entity \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document}. The \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{i,t}$$\\end{document} scores are normalized to form a distribution over all entities \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document}, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta _{i,j,t}$$\\end{document} scores are normalized to form a distribution over records \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r_{i,j}$$\\end{document} of entity \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e_i$$\\end{document}. Each entity is then represented as a weighted sum of its record embeddings, and the entire data structure is represented as a weighted sum of the entity representations. The dynamic context is computed as:4\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned}&\\mathbf {c_t} = \\sum _{i=1}^{I} (\\alpha _{i,t} \\big ( \\sum _{j} \\beta _{i,j,t} \\mathbf {r}_{i,j} \\big )) \\end{aligned}$$\\end{document}\n5\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} where ~~ \\alpha _{i,t}&\\propto exp(\\mathbf {d}_t\\mathbf {W}_\\alpha \\mathbf {e}_i) ~~and~~ \\beta _{i,j,t} \\propto exp(\\mathbf {d}_t\\mathbf {W}_\\beta \\mathbf {h}_{i,j}) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {d_t}$$\\end{document} is the decoder hidden state at time step t, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {W}_{\\alpha } \\in \\mathbb {R}^{d\\times d}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {W}_{\\beta } \\in \\mathbb {R}^{d\\times d}$$\\end{document} are learnt parameters, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\sum _i\\alpha _{i,t} = 1$$\\end{document}, and for all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i \\in \\{1,...,I\\}$$\\end{document}\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\sum _{j}\\beta _{i,j,t} = 1$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 337,
                    "end": 339,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Hierarchical Attention ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nKey-guided Hierarchical Attention. This variant follows the intuition that once an entity is chosen for mention (thanks to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{i,t}$$\\end{document}), only the type of records is important to determine the content of the description. For example, when deciding to mention a player, all experts automatically report his score without consideration of its specific value. To test this intuition, we model the attention scores by computing the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta _{i,j,t}$$\\end{document} scores from Eq. (5) solely on the embedding of the key rather than on the full record representation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {h}_{i,j}$$\\end{document}:6\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\hat{\\beta }_{i,j,t} \\propto exp(\\mathbf {d}_t\\mathbf {W}_{a_2}\\mathbf {k}_{i,j}) \\end{aligned}$$\\end{document}Please note that the different embeddings and the model parameters presented in the model components are learnt using Eq. 1.",
            "cite_spans": [],
            "section": "Hierarchical Attention ::: Hierarchical Encoder Model for Data-to-Text",
            "ref_spans": []
        },
        {
            "text": "To evaluate the effectiveness of our model, and demonstrate its flexibility at handling heavy data-structure made of several types of entities, we used the RotoWire dataset [39]. It includes basketball games statistical tables paired with journalistic descriptions of the games, as can be seen in the example of Fig. 1. The descriptions are professionally written and average 337 words with a vocabulary size of 11.3K. There are 39 different record keys, and the average number of records (resp. entities) in a single data-structure is 628 (resp. 28). Entities are of two types, either team or player, and player descriptions depend on their involvement in the game. We followed the data partitions introduced with the dataset and used a train/validation/test sets of respectively 3, 398/727/728 (data-structure, description) pairs.",
            "cite_spans": [
                {
                    "start": 174,
                    "end": 176,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "The Rotowire Dataset ::: Experimental Setup",
            "ref_spans": [
                {
                    "start": 317,
                    "end": 318,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "We evaluate our model through two types of metrics. The BLEU score [23] aims at measuring to what extent the generated descriptions are literally closed to the ground truth. The second category designed by [39] is more qualitative.",
            "cite_spans": [
                {
                    "start": 68,
                    "end": 70,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 207,
                    "end": 209,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Evaluation Metrics ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "BLEU Score. The BLEU score [23] is commonly used as an evaluation metric in text generation tasks. It estimates the correspondence between a machine output and that of a human by computing the number of co-occurrences for ngrams (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n \\in {1, 2, 3, 4}$$\\end{document}) between the generated candidate and the ground truth. We use the implementation code released by [27].",
            "cite_spans": [
                {
                    "start": 28,
                    "end": 30,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 633,
                    "end": 635,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                }
            ],
            "section": "Evaluation Metrics ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "Information Extraction-Oriented Metrics. These metrics estimate the ability of our model to integrate elements from the table in its descriptions. Particularly, they compare the gold and generated descriptions and measure to what extent the extracted relations are aligned or differ. To do so, we follow the protocol presented in [39]. First, we apply an information extraction (IE) system trained on labeled relations from the gold descriptions of the RotoWire train dataset. Entity-value pairs are extracted from the descriptions. For example, in the sentence Isaiah Thomas led the team in scoring, totaling 23 points [...]., an IE tool will extract the pair (Isaiah Thomas, 23, PTS). Second, we compute three metrics on the extracted information:Relation Generation (RG) estimates how well the system is able to generate text containing factual (i.e., correct) records. We measure the precision and absolute number (denoted respectively RG-P% and RG-#) of unique relations r extracted from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{y}_{1:T}$$\\end{document} that also appear in s.Content Selection (CS) measures how well the generated document matches the gold document in terms of mentioned records. We measure the precision and recall (denoted respectively CS-P% and CS-R%) of unique relations r extracted from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{y}_{1:T}$$\\end{document} that are also extracted from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_{1:T}$$\\end{document}.Content Ordering (CO) analyzes how well the system orders the records discussed in the description. We measure the normalized Damerau-Levenshtein distance [3] between the sequences of records extracted from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\hat{y}_{1:T}$$\\end{document} that are also extracted from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_{1:T}$$\\end{document}.\n",
            "cite_spans": [
                {
                    "start": 331,
                    "end": 333,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 2324,
                    "end": 2325,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Evaluation Metrics ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "CS primarily targets the \u201cwhat to say\u201d aspect of evaluation, CO targets the \u201chow to say it\u201d aspect, and RG targets both. Note that for CS, CO, RG-% and BLEU metrics, higher is better; which is not true for RG-#. The IE system used in the experiments is able to extract an average of 17 factual records from gold descriptions. In order to mimic a human expert, a generative system should approach this number and not overload generation with brute facts.",
            "cite_spans": [],
            "section": "Evaluation Metrics ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "We compare our hierarchical model against three systems. For each of them, we report the results of the best performing models presented in each paper.",
            "cite_spans": [],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nWiseman [39] is a standard encoder-decoder system with copy mechanism.",
            "cite_spans": [
                {
                    "start": 303,
                    "end": 305,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nLi [16] is a standard encoder-decoder with a delayed copy mechanism: text is first generated with placeholders, which are replaced by salient records extracted from the table by a pointer network.",
            "cite_spans": [
                {
                    "start": 298,
                    "end": 300,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nPuduppully-plan [28] acts in two steps: a first standard encoder-decoder generates a plan, i.e. a list of salient records from the table; a second standard encoder-decoder generates text from this plan.",
            "cite_spans": [
                {
                    "start": 311,
                    "end": 313,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nPuduppully-updt [29]. It consists in a standard encoder-decoder, with an added module aimed at updating record representations during the generation process. At each decoding step, a gated recurrent network computes which records should be updated and what should be their new representation.",
            "cite_spans": [
                {
                    "start": 311,
                    "end": 313,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "Model Scenarios. We test the importance of the input structure by training different variants of the proposed architecture:",
            "cite_spans": [],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nFlat, where we feed the input sequentially to the encoder, losing all notion of hierarchy. As a consequence, the model uses standard attention. This variant is closest to Wiseman, with the exception that we use a Transformer to encode the input sequence instead of an RNN.",
            "cite_spans": [],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nHierarchical-kv is our full hierarchical model, with traditional hierarchical attention, i.e. where attention over records is computed on the full record encoding, as in Eq. (5).",
            "cite_spans": [],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document}\nHierarchical-k is our full hierarchical model, with key-guided hierarchical attention, i.e. where attention over records is computed only on the record key representations, as in Eq. (6).\n",
            "cite_spans": [],
            "section": "Baselines ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "The decoder is the one used in [28, 29, 39] with the same hyper-parameters. For the encoder module, both the low-level and high-level encoders use a two-layers multi-head self-attention with two heads. To fit with the small number of record keys in our dataset (39), their embedding size is fixed to 20. The size of the record value embeddings and hidden layers of the Transformer encoders are both set to 300. We use dropout at rate 0.5. The models are trained with a batch size of 64. We follow the training procedure in [36] and train the model for a fixed number of 25K updates, and average the weights of the last 5 checkpoints (at every 1K updates) to ensure more stability across runs. All models were trained with the Adam optimizer [13]; the initial learning rate is 0.001, and is reduced by half every 10K steps. We used beam search with beam size of 5 during inference. All the models are implemented in OpenNMT-py [14]. All code is available at https://github.com/KaijuML/data-to-text-hierarchical.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 34,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 36,
                    "end": 38,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 40,
                    "end": 42,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 524,
                    "end": 526,
                    "mention": "36",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 742,
                    "end": 744,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 927,
                    "end": 929,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Implementation Details ::: Experimental Setup",
            "ref_spans": []
        },
        {
            "text": "Our results on the RotoWire testset are summarized in Table 1. For each proposed variant of our architecture, we report the mean score over ten runs, as well as the standard deviation in subscript. Results are compared to baselines [28, 29, 39] and variants of our models. We also report the result of the oracle (metrics on the gold descriptions). Please note that gold descriptions trivially obtain 100% on all metrics expect RG, as they are all based on comparison with themselves. RG scores are different, as the IE system is imperfect and fails to extract accurate entities 4% of the time. RG-# is an absolute count.\n",
            "cite_spans": [
                {
                    "start": 233,
                    "end": 235,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 237,
                    "end": 239,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 241,
                    "end": 243,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Results",
            "ref_spans": [
                {
                    "start": 60,
                    "end": 61,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Ablation Studies. To evaluate the impact of our model components, we first compare scenarios Flat, Hierarchical-k, and Hierarchical-kv. As shown in Table 1, we can see the lower results obtained by the Flat scenario compared to the other scenarios (e.g. BLEU 16.7 vs. 17.5 for resp. Flat and Hierarchical-k), suggesting the effectiveness of encoding the data-structure using a hierarchy. This is expected, as losing explicit delimitation between entities makes it harder a) for the encoder to encode semantics of the objects contained in the table and b) for the attention mechanism to extract salient entities/records.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": [
                {
                    "start": 154,
                    "end": 155,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Second, the comparison between scenario Hierarchical-kv and Hierarchical-k shows that omitting entirely the influence of the record values in the attention mechanism is more effective: this last variant performs slightly better in all metrics excepted CS-R%, reinforcing our intuition that focusing on the structure modeling is an important part of data encoding as well as confirming the intuition explained in Sect. 3.3: once an entity is selected, facts about this entity are relevant based on their key, not value which might add noise. To illustrate this intuition, we depict in Fig. 3 attention scores (recall \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{i,t}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta _{i,j,t}$$\\end{document} from Eqs. (5) and (6)) for both variants Hierarchical-kv and Hierarchical-k. We particularly focus on the timestamp where the models should mention the number of points scored during the first quarter of the game. Scores of Hierarchical-k are sharp, with all of the weight on the correct record (PTS_QTR1, 26) whereas scores of Hierarchical-kv are more distributed over all PTS_QTR records, ultimately failing to retrieve the correct one.\n",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": [
                {
                    "start": 589,
                    "end": 590,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "Comparison w.r.t. Baselines. From a general point of view, we can see from Table 1 that our scenarios obtain significantly higher results in terms of BLEU over all models; our best model Hierarchical-k reaching 17.5 vs. 16.5 against the best baseline. This means that our models learns to generate fluent sequences of words, close to the gold descriptions, adequately picking up on domain lingo. Qualitative metrics are either better or on par with baselines. We show in Fig. 4 a text generated by our best model, which can be directly compared to the gold description in Fig. 1. Generation is fluent and contains domain-specific expressions. As reflected in Table 1, the number of correct mentions (in green) outweights the number of incorrect mentions (in red). Please note that, as in previous work [16, 28, 29, 39], generated texts still contain a number of incorrect facts, as well hallucinations (in blue): sentences that have no basis in the input data (e.g. \u201c[...] he\u2019s now averaging 22 points [...].\u201d). While not the direct focus of our work, this highlights that any operation meant to enrich the semantics of structured data can also enrich the data with incorrect facts.",
            "cite_spans": [
                {
                    "start": 803,
                    "end": 805,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 807,
                    "end": 809,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 811,
                    "end": 813,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 815,
                    "end": 817,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Results",
            "ref_spans": [
                {
                    "start": 476,
                    "end": 477,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 577,
                    "end": 578,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 81,
                    "end": 82,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 665,
                    "end": 666,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Specifically, regarding all baselines, we can outline the following statements.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} Our hierarchical models achieve significantly better scores on all metrics when compared to the flat architecture Wiseman, reinforcing the crucial role of structure in data semantics and saliency. The analysis of RG metrics shows that Wiseman seems to be the more naturalistic in terms of number of factual mentions (RG#) since it is the closest scenario to the gold value (16.83 vs. 17.31 for resp. Wiseman and Hierarchical-k). However, Wiseman achieves only 75.62% of precision, effectively mentioning on average a total of 22.25 records (wrong or accurate), where our model Hierarchical-k scores a precision of 89.46%, leading to 23.66 total mentions, just slightly above Wiseman.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} The comparison between the Flat scenario and Wiseman is particularly interesting. Indeed, these two models share the same intuition to flatten the data-structure. The only difference stands on the encoder mechanism: bi-LSTM vs. Transformer, for Wiseman and Flat respectively. Results shows that our Flat scenario obtains a significant higher BLEU score (16.7 vs. 14.5) and generates fluent descriptions with accurate mentions (RG-P%) that are also included in the gold descriptions (CS-R%). This suggests that introducing the Transformer architecture is promising way to implicitly account for data structure.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} Our hierarchical models outperform the two-step decoders of Li and Puduppully-plan on both BLEU and all qualitative metrics, showing that capturing structure in the encoding process is more effective that predicting a structure in the decoder (i.e., planning or templating). While our models sensibly outperform in precision at factual mentions, the baseline Puduppully-plan reaches 34.28 mentions on average, showing that incorporating modules dedicated to entity extraction leads to over-focusing on entities; contrasting with our models that learn to generate more balanced descriptions.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": []
        },
        {
            "text": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bullet $$\\end{document} The comparison with Puduppully-updt shows that dynamically updating the encoding across the generation process can lead to better Content Ordering (CO) and RG-P%. However, this does not help with Content Selection (CS) since our best model Hierarchical-k obtains slightly better scores. Indeed, Puduppully-updt updates representations after each mention allowing to keep track of the mention history. This guides the ordering of mentions (CO metric), each step limiting more the number of candidate mentions (increasing RG-P%). In contrast, our model encodes saliency among records/entities more effectively (CS metric). We note that while our model encodes the data-structure once and for all, Puduppully-updt recomputes, via the updates, the encoding at each step and therefore significantly increases computation complexity. Combined with their RG-# score of 30.11, we argue that our model is simpler, and obtains fluent description with accurate mentions in a more human-like fashion.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": []
        },
        {
            "text": "We would also like to draw attention to the number of parameters used by those architectures. We note that our scenarios relies on a lower number of parameters (14 millions) compared to all baselines (ranging from 23 to 45 millions). This outlines the effectiveness in the design of our model relying on a structure encoding, in contrast to other approach that try to learn the structure of data/descriptions from a linearized encoding.",
            "cite_spans": [],
            "section": "Results",
            "ref_spans": []
        },
        {
            "text": "In this work we have proposed a hierarchical encoder for structured data, which (1) leverages the structure to form efficient representation of its input; (2) has strong synergy with the hierarchical attention of its associated decoder. This results in an effective and more light-weight model. Experimental evaluation on the RotoWire benchmark shows that our model outperforms competitive baselines in terms of BLEU score and is generally better on qualitative metrics. This way of representing structured databases may lead to automatic inference and enrichment, e.g., by comparing entities. This direction could be driven by very recent operation-guided networks [21, 35]. In addition, we note that our approach can still lead to erroneous facts or even hallucinations. An interesting perspective might be to further constrain the model on the data structure in order to prevent inaccurate of even contradictory descriptions.",
            "cite_spans": [
                {
                    "start": 667,
                    "end": 669,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 671,
                    "end": 673,
                    "mention": "35",
                    "ref_id": "BIBREF28"
                }
            ],
            "section": "Conclusion and Future Work",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Evaluation on the RotoWire testset using relation generation (RG) count (#) and precision (P%), content selection (CS) precision (P%) and recall (R%), content ordering (CO), and BLEU. \u2013: number of parameters unavailable.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Example of structured data from the RotoWire dataset. Rows are entities (either a team or a player) and each cell a record, its key being the column label and its value the cell content. Factual mentions from the table are boldfaced in the description.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Diagram of the proposed hierarchical encoder. Once the records are embedded, the low-level encoder works on each entity independently (A); then the high-level encoder encodes the collection of entities (B). In circles, we represent the hierarchical attention scores: the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} scores at the entity level and the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} scores at the record level.",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Right: Comparison of a generated sentence from Hierarchical-k and Hierarchical-kv. Left: Attention scores over entities (top) and over records inside the selected entity (bottom) for both variants, during the decoding of respectively 26 or 31 (circled in red). (Color figure online)",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: Text generated by our best model. Entites are boldfaced, factual mentions are in green, erroneous mentions in red and hallucinations are in blue. (Color figure online)",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "Neural multi-step reasoning for question answering on semi-structured tables",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Haug",
                    "suffix": ""
                },
                {
                    "first": "O-E",
                    "middle": [],
                    "last": "Ganea",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Grnarova",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Advances in Information Retrieval",
            "volume": "",
            "issn": "",
            "pages": "611-617",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Rhetorical structure theory: toward a functional theory of text organization",
            "authors": [
                {
                    "first": "WC",
                    "middle": [],
                    "last": "Mann",
                    "suffix": ""
                },
                {
                    "first": "SA",
                    "middle": [],
                    "last": "Thompson",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Text - Interdisc. J. Study Discourse",
            "volume": "8",
            "issn": "",
            "pages": "243-281",
            "other_ids": {
                "DOI": [
                    "10.1515/text.1.1988.8.3.243"
                ]
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "Making effective use of healthcare data using data-to-text technology: methodologies and applications",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pauws",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gatt",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Krahmer",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Reiter",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Data Science for Healthcare",
            "volume": "",
            "issn": "",
            "pages": "119-145",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "Choosing words in computer-generated weather forecasts",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Reiter",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sripada",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hunter",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Davy",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Artif. Intell.",
            "volume": "167",
            "issn": "1\u20132",
            "pages": "137-169",
            "other_ids": {
                "DOI": [
                    "10.1016/j.artint.2005.06.006"
                ]
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF27": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF28": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF29": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF30": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF31": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF32": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF33": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF34": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF35": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF36": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF37": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF38": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF39": {
            "title": "Survey of the state of the art in natural language generation: core tasks, applications and evaluation",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gatt",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Krahmer",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "J. Artif. Int. Res.",
            "volume": "61",
            "issn": "1",
            "pages": "65-170",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF40": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}