{
    "paper_id": "PMC7242041",
    "metadata": {
        "title": "Formal Verification of Interoperability Between Future Network Architectures Using Alloy",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Mohammad",
                "middle": [],
                "last": "Jahanian",
                "suffix": "",
                "email": "mjaha001@ucr.edu",
                "affiliation": {}
            },
            {
                "first": "Jiachen",
                "middle": [],
                "last": "Chen",
                "suffix": "",
                "email": "jiachen@winlab.rutgers.edu",
                "affiliation": {}
            },
            {
                "first": "K.",
                "middle": [
                    "K."
                ],
                "last": "Ramakrishnan",
                "suffix": "",
                "email": "kk@cs.ucr.edu",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Today\u2019s computer networks, the Internet being a dominant example, are heavily used to fulfill users\u2019 information-centric needs: users primarily seek information over the network without necessarily wanting to focus on its location or the underlying mechanisms used to retrieve it [9]. However, the current way of using \u201clocation-based\u201d access in IP networks results in a less convenient and less efficient means for information retrieval and dissemination. Information-Centric Networks (ICNs) address this content-oriented networking paradigm by separating content identity from its location [9]. ICN enables access to content based on its name, from wherever it resides, supporting mobility as well as accessing the named content from the best, any, or all source(s). It also allows for network-wide caching to reduce access latency. There are a variety of ICN architectures which have been proposed in the past decade. Two of the most notable ones, which we primarily focus on in this paper, are Named Data Networks (NDN) [20], and MobilityFirst [16], which have been considered for Future Internet designs [3].",
            "cite_spans": [
                {
                    "start": 281,
                    "end": 282,
                    "mention": "9",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 593,
                    "end": 594,
                    "mention": "9",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1025,
                    "end": 1027,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1049,
                    "end": 1051,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1110,
                    "end": 1111,
                    "mention": "3",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Currently, there are two main factors that make the discussion of network interoperability important: 1) Today, IP is ubiquitous and used on a majority of network devices, despite the legacy of end-point address-oriented communication, especially considering new services and demands on today\u2019s networks [15]. 2) Research on designing new network architectures radically different from IP, is ongoing, and in many cases has already led to implemented systems; our focus in this paper is on an important class of such architectures, namely ICN. It is anticipated that we may have a number of interconnected networks (domains) using different architectures [15]. To go beyond the interconnection (i.e., physical connections between different domains) towards interoperation between them (i.e., being able to use a service, or content, provided by one domain in another domain), we need network interoperability. In the past decade, several designs have been proposed for interoperation between an ICN architecture (either NDN or MF) with IP [3]. However, such designs and their requirements were presented informally, describing the primitives and operations. It has been observed that network interoperability is complex [19]; thus, a formal structure for analysis of information-centric interoperability (ICI) can be very helpful, as it can provide proofs or expose errors early on, before the universal deployment of ICI frameworks for Future Internet.",
            "cite_spans": [
                {
                    "start": 305,
                    "end": 307,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 656,
                    "end": 658,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1040,
                    "end": 1041,
                    "mention": "3",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1221,
                    "end": 1223,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Formal methods have been extensively used for designing and analyzing computer networks and protocols (surveyed in [14]). As for interoperability, work in [19] proposed a formal model to analyze interoperation of legacy networks. However, it only deals with host-centric interoperability (HCI), and only uses classic model finding [17] reasoning techniques. We extend that to support ICI as well as modeling failure and mobility with model counting [7] techniques. Network verification tools have also been proposed to analyze network data and control planes. Recently, work in [10] proposed a tool to verify ICN data planes, analyzing properties such as reachability. However, it only deals with a single domain, while our goal here is to cover multiple domains with different architectures coexisting with each other. Also, the symbolic execution nature of works such as [10] is computationally too expensive when expanded across multiple domains, each having its own data plane.",
            "cite_spans": [
                {
                    "start": 116,
                    "end": 118,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 156,
                    "end": 158,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 332,
                    "end": 334,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 450,
                    "end": 451,
                    "mention": "7",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 579,
                    "end": 581,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 874,
                    "end": 876,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We present an Alloy [8]-based formalization of ICI, to analyze interoperability correctness. We cover both pull-based (request/response) and push-based (publish/subscribe) [6] content retrieval services, and their most essential properties such as content reachability and returnability. To analyze content-oriented services, we distinguish between static and dynamic content, justifying their differences, and specifying no-conflict properties, especially for dynamic content retrieval. For verification of these properties, we use Alloy Analyzer\u2019s built-in SAT solver-based model finding engine [2]. We also consider failure and mobility; to analyze them, mere model finding is not sufficient, as failure and mobility, when severe, can cause any network protocol to become \u201cincorrect\u201d (and raise counterexamples). Thus, for such analysis, we resort to model counting (to count and compare the number of satisfying instances and counterexamples) to assess \u201chow well\u201d a particular domain or architecture is doing under failure and mobility.",
            "cite_spans": [
                {
                    "start": 21,
                    "end": 22,
                    "mention": "8",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 173,
                    "end": 174,
                    "mention": "6",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 598,
                    "end": 599,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The major contributions of this paper are: 1) a model finding method to analyze basic properties (mainly reachability and returnability) of information-centric interoperability (ICI); 2) a formally-verified ICI framework; and 3) a model counting method to analyze gateway failure and mobility.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "ICN enables access to content independent of its location, focusing on the fact that what matters to users is what the content is rather than where that content is located [9]. An ICN network layer recognizes and makes its forwarding decisions based on content names (or IDs) instead of addresses (unlike host-centric networks, as in today\u2019s IP networks), achieving efficiency and scalability.",
            "cite_spans": [
                {
                    "start": 173,
                    "end": 174,
                    "mention": "9",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Information-Centric Networking (ICN) and Interoperability ::: Background and Related Work",
            "ref_spans": []
        },
        {
            "text": "Among many different ICN architectures proposed recently, we focus on the two most popular ones, namely Named Data Networks (NDN) [20] and MobilityFirst (MF) [16]. Both allow users to retrieve content using content names, through pull-based request/response or push-based publish/subscribe methods [6]. In-network content caching in routers is an important feature of ICN, allowing for requests to be satisfied from an intermediate cache on the path to the server/repository [9]. An in-network namespace is generally a graphical structure that captures the content names and their relationships in an ICN\u2019s content space [12]. Despite both being ICNs, NDN and MF have important differences [16, 20]: NDN uses human-readable hierarchically-structured names, with Longest Prefix Matching-based forwarding. NDN content requests (called Interests) leave \u201cbreadcrumb\u201d state in the routers on their path, which the associated response (called Data packets) then follow back, via Reverse Path Forwarding (RPF). MF, on the other hand, uses flat IDs (called GUIDs) to identify content. Response packets contain the consumer\u2019s ID and do not need to follow the same path as the request. Also, MF inherently supports mobility by late binding, which re-directs in-flight packets towards a mobile content repository. Early binding assigns names to locations strictly at the original client, while late binding allows such assignment to be updated on its way in the network [16].",
            "cite_spans": [
                {
                    "start": 131,
                    "end": 133,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 159,
                    "end": 161,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 299,
                    "end": 300,
                    "mention": "6",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 476,
                    "end": 477,
                    "mention": "9",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 622,
                    "end": 624,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 691,
                    "end": 693,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 695,
                    "end": 697,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1460,
                    "end": 1462,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Information-Centric Networking (ICN) and Interoperability ::: Background and Related Work",
            "ref_spans": []
        },
        {
            "text": "There have been several proposals for interoperability frameworks for ICNs (surveyed in [3]). These frameworks typically consist of interoperation gateways between domains of different network architectures, performing translations between them. All of these proposals allow interoperation of just two domains, IP and one ICN (either NDN or MF), and often require addition of new protocols or modification of existing ones. We generalize these solutions in our model to an interoperability framework of multiple (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\ge $$\\end{document}2) domain types (we allow IP, NDN and MF to coexist simultaneously), and do not change any domain-specific protocols.",
            "cite_spans": [
                {
                    "start": 89,
                    "end": 90,
                    "mention": "3",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Information-Centric Networking (ICN) and Interoperability ::: Background and Related Work",
            "ref_spans": []
        },
        {
            "text": "Alloy is a declarative language based on relations and first order logic [8]. Alloy models a system, M, through the declaration of signatures (objects and their relations) and facts (constraints and axioms). A predicate is defined as a logical formula. An Assertion is a logical formula (which can be a combination of predicates) that are required to be always true (i.e., as invariants) in the system. Alloy Analyzer [2] allows the automatic analysis of models and their properties through utilizing off-the-shelf SAT solvers. The tool translates Alloy descriptions into Conjunctive Normal Form (CNF) expressions. It uses an enumeration of instances, also called model finding, within a bound (scope), to prove whether or not a predicate P\never holds (by SAT-solving \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$M \\wedge P$$\\end{document}), or an assertion A\nalways holds as an invariant (by SAT-solving \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$M\\wedge \\lnot A$$\\end{document}, to look for counterexamples).",
            "cite_spans": [
                {
                    "start": 74,
                    "end": 75,
                    "mention": "8",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 419,
                    "end": 420,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Alloy ::: Background and Related Work",
            "ref_spans": []
        },
        {
            "text": "Alloy has been used in modeling and analysis of many systems, including network protocols and architectures [8]. In the particular case of network interoperability, Zave [19] used Alloy to formally analyze host-centric interoperability for legacy networks, with domains of the Public Switched Telephone Network (PSTN), BoxOS and the Session Initiation Protocol (SIP). We extend the approach to model and analyze interoperability of information-centric services and architectures, since we are dealing with radically different network designs (name-based networking vs. address-based [9]) and required properties (node-to-content reachability vs. node-to-node reachability [10]). Additionally, we extend the classic Alloy-based model finding approach, such as in [19], to a model counting one, to quantitatively analyze the impacts of failure and mobility. An important feature of Alloy is its strength in efficiently handling graph structures and properties [18], a feature that we benefit from, in two ways: 1) the composite network topology, and 2) a graph-based information namespace. Further, Alloy helps provide proofs for properties with a reasonably large scope [18].",
            "cite_spans": [
                {
                    "start": 109,
                    "end": 110,
                    "mention": "8",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 171,
                    "end": 173,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 584,
                    "end": 585,
                    "mention": "9",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 673,
                    "end": 675,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 763,
                    "end": 765,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 959,
                    "end": 961,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1170,
                    "end": 1172,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Alloy ::: Background and Related Work",
            "ref_spans": []
        },
        {
            "text": "A sequence of interconnected domains in a network are information-centrically interoperable if and only if any client in any of the domains can access information-centric services provided in any other domain.",
            "cite_spans": [],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": []
        },
        {
            "text": "Throughout this paper, we use the term \u201cnetwork\u201d to mean \u201ca composition of multiple network domains\u201d, each domain being a different type of standalone architecture (e.g., IP, NDN, or MF). An interoperability framework (such as [3]) is a set of protocols and architectural components that allow interconnected networks of different types to interoperate. Information-centric services are broadly sub-categorized as: 1) requesting for and retrieving content (pull-based), and 2) subscribing to and receiving content (push-based). Both of these may be based on namespaces defined by content producers. An example 3-domain ICI scenario is depicted in Fig. 1. As shown, ICI accesses content by name, rather than an address. Also, requests can be satisfied at any cache node, not just the original server. As for formal analysis, in ICI, the main property we care about is node-to-content reachability [10], while in traditional host-centric interoperability (HCI) analysis [19], the focus is on node-to-node reachability.\n",
            "cite_spans": [
                {
                    "start": 228,
                    "end": 229,
                    "mention": "3",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 897,
                    "end": 899,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 969,
                    "end": 971,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": [
                {
                    "start": 652,
                    "end": 653,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "We model our networked environment using Alloy\u2019s relational and logical atoms. We have Domains (as abstract signatures), each of which can be an IP, NDN, or MF type (extended signatures) (Listing 3.1). A \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Node $$\\end{document} is at least in one Domain and has at least one \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ NodeID $$\\end{document}. A \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Node $$\\end{document} can be either a Client, Repos (repository/server), or GW (gateway). A gateway is associated with exactly two Domains (constrained using facts), that it is stitching together (Listing 3.2.)\n\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": []
        },
        {
            "text": "Our declarations specify a network meta-model [8], which maps to a number of instances (models) each being a network configuration (i.e., with their own topology, content, namespace, etc.). An example 2-domain instance is depicted in Fig. 2, as a high-level schematic, showing objects and their inter-relations. The Client here wishes to retrieve some Content using its \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document} or a (set of) \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Keyword $$\\end{document}(s). Objects of type Route and RevRoute (reverse route) couple the notion of \u201ca series of links\u201d and \u201cpackets carried over them\u201d, the packet carrying content request and response, respectively. A Route has attributes such as initiator, acceptor, and a request for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document}. We also extend signatures to add more fine-grained, domain-specific characteristics. One of Route\u2019s extended object types, namely \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ IPRoute $$\\end{document}, inherits its attributes and constraints, and also has additional attributes such as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ srcIPaddress $$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ destIPaddress $$\\end{document}, and constraints saying that source and destination IP addresses must correctly correspond to initiator and acceptor nodes. Gateways perform translation for forwarding requests (over a composition of Routes), and retain state information which they use to forward the content back to the client (over composition of RevRoutes). We also add a number of additional facts, such as uniqueness of node ID, absence of self-looping routes, and the existence of one-to-one mapping between NDN\u2019s forward and reverse routes (to reflect NDN\u2019s RPF policy [20]).",
            "cite_spans": [
                {
                    "start": 47,
                    "end": 48,
                    "mention": "8",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 3196,
                    "end": 3198,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": [
                {
                    "start": 239,
                    "end": 240,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "We define a global-state relation C that captures routes to/from gateways. To model connectivity, we use the transitive closure of the route-connections relation C where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(r1,r2) \\in C$$\\end{document} if and only if there exists a gateway between two domains that connects routes r1 and r2. E.g., if we have \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$C=\\{(r1,r2),(r2,r3)\\}$$\\end{document}, then its transitive closure \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$C^+=\\{(r1,r2),(r2,r3),(r1,r3)\\}$$\\end{document} will represent existing paths of any length (i.e., number of routes). We define object type Connections (as a singleton) to capture these connections (i.e., relation C); it has attributes being relations themselves, primarily connected and revconnected, to capture connection relations of Routes and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ RevRoute $$\\end{document}s respectively. Relation revconnected has an additional constraint, which says that for two reverse routes rr1 and rr2 connected at gateway gw, corresponding state information (associated with the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document} or other multiplexing/demultiplexing values in rr1 and rr2) must be stored on gw, so that the content can be carried over this cascade of reverse routes towards the consumer (Listing 3.3). Additionally, we define a fact (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$path\\_exists$$\\end{document}, Listing 3.4) that ensures any two nodes are connected (through one or multiple Routes or \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ RevRoute $$\\end{document}s), to reduce our instance space to only the ones with strongly connected topology.\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": []
        },
        {
            "text": "While Routes represent unicast exchange paths, we define Groups to denote multicast groups (one-to-many communication), enabling push-based notification models. Following the principles of ICN, each group is associated with a content name \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Prefix $$\\end{document} [6] and can be used for publish/subscribe exchanges regarding that prefix. Each group belongs to one domain. To model a connection of groups across multiple domains, we add relation attributes chain and revchain to Connections (Listing 3.3), to capture connectivity of groups (as a chain) for subscription and publication respectively. To ensure strong connectivity, we add a fact that says any two groups serving the same prefix are chained (Listing 3.5).\n",
            "cite_spans": [
                {
                    "start": 534,
                    "end": 535,
                    "mention": "6",
                    "ref_id": "BIBREF17"
                }
            ],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": []
        },
        {
            "text": "Content naming is integral in ICI. We define names, i.e., \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document} objects for each Content. Based on domain type, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document} can be either \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ URL $$\\end{document} (in IP), \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ NDNName $$\\end{document} (in NDN) or \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentGUID $$\\end{document} (in MF) (Listing 3.6). Each \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document} is a leaf node under a \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Prefix $$\\end{document} in the prefix tree (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ PTree $$\\end{document}). An example prefix tree is shown in Fig. 3, which represents the network\u2019s content namespace. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ PTree $$\\end{document} may contain a number of fragmented sub-trees (i.e., as a forest), each sub-tree representing the namespace of a different (set of) content provider(s) in different domains. To represent the structure of hierarchical prefixes, we use binary relations to model the immediate parent-child relationship between prefixes in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ PTree $$\\end{document}. In Fig. 3, the relation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P = \\{(P1,P2), (P1,P3), (P2,P4), (P2,P5)\\}$$\\end{document} represents such relationships, and is captured in the prefix-to-prefix relation map in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ PTree $$\\end{document} (Listing 3.6). We also use its transitive closure to model the ancestor-descendant relationships. We add additional facts to ensure basic constraints on the tree, such as the non-existence of loops.\n\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Modeling Information-Centric Interoperability",
            "ref_spans": [
                {
                    "start": 2617,
                    "end": 2618,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 3584,
                    "end": 3585,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "Static Content Retrieval. In the static content retrieval (SCR) service, the request packets carry content IDs which the client requests, and the response packets produced by repositories (can be content producers or router caches) carry the data associated with that content ID. We describe two of SCR\u2019s essential content-oriented properties using Alloy (Listings 4.1 and 4.2).",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Property 1.1. SCR Reachability:  For every client that wants to retrieve content associated with a content ID and has a direct route to a gateway, there is a repository with content having that ID reachable from that gateway.",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Property 1.2. SCR Returnability: For every client that reaches a repository with a request, there is a path back to the client for the response with the content.\n",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Dynamic Content Retrieval. In DCR, every request has to be mapped to a unique response, as opposed to SCR. To facilitate this, having a demux value (for multiplexing/demultiplexing) is essential for DCR, to provide the correct mapping of responses to requests; since every generated response is specific to not just the request\u2019s name, but also its input parameters. To access dynamic content from a server, a client generates a query for which the gateway keeps state as <nodeID, demux> of the requesting side and <demux> for the serving side. Reachability and returnability are still important in DCR (Properties 2.1\u20132.2). However, if the same SCR protocol is used for DCR, there can be conflicts between multiple requests, e.g., a cached content may get sent back to multiple distinct clients. Therefore, we define no-conflict properties for DCR (Property 2.3).",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Property 2.1\u20132.2. DCR Reachability and Returnability: These two properties are similar to those of SCR; with the difference being additional constraints regarding elements of DCR requests, i.e., including generation and verification of the correct demux values at gateways (i.e., in addition to contentID, etc.).",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Property 2.3. No-conflict between distinct requests/clients: For every client that searches for two distinct content items (no-\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ conflict $$\\end{document}-A, Listing 4.3), or a dynamic content requested by two different clients (no-\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ conflict $$\\end{document}-B, Listing 4.4), two distinct, appropriately associated responses, should be received back. In no-\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ conflict $$\\end{document}-A, the focus is on the distinction between two return-ed contents, associated with two distinct requests made by a given Client for distinct \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Keyword $$\\end{document}s k1 and k2. On the other hand, no-\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ conflict $$\\end{document}-B focuses on the distinction between two return-ed contents, associated with requests for a particular \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Keyword $$\\end{document} initiated by two distinct Clients c1 and c2.",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "This property shows the importance of having two separate demux values in packets, namely both the request ID (required for Property 2.3.a) and client ID (required for Property 2.3.b), to make each dynamic request globally unique, for correct multiplexing/demultiplexing. If we remove either of those two elements, this property will be violated and counterexamples will arise; i.e., the gateway would not know how to demultiplex incoming response data to serve the correct, corresponding requesting client.\n\n",
            "cite_spans": [],
            "section": "Pull-Based Retrieval: Request/Response ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "In pub/sub, we have domain-specific multicast groups that are associated with prefixes [6]. We want a client to be able to subscribe to and receive all relevant publications in accordance with the prefix tree of the namespace over \u201cchain\u201d of groups across domains. Groups G1 and G2 form a chain if and only if the publisher of G1 can be a subscriber of G2, and is then able to relay data received from G2 to his subscribers in G1.",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 89,
                    "mention": "6",
                    "ref_id": "BIBREF17"
                }
            ],
            "section": "Push-Based Retrieval: Publish/Subscribe ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Property 3.1. Ability to subscribe to any prefix. For every client that wants to retrieve future publications under/associated with an existing prefix and has a direct route to a gateway, if there is some publisher that will publish content under that prefix, then that publisher is accessible through a chain of groups.",
            "cite_spans": [],
            "section": "Push-Based Retrieval: Publish/Subscribe ::: Satisfying Information-Centric Service Properties",
            "ref_spans": []
        },
        {
            "text": "Property 3.2. Ability to receive any content published directly associated with the subscribed prefix. For every client who is subscribed to a prefix and can reach the associated publisher, there is a path back to the client to carry any content with a content ID belonging to that prefix. For example, a subscriber of P2 in Fig. 3 should receive publications pertaining to P2 across domains.",
            "cite_spans": [],
            "section": "Push-Based Retrieval: Publish/Subscribe ::: Satisfying Information-Centric Service Properties",
            "ref_spans": [
                {
                    "start": 330,
                    "end": 331,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "Property 3.3. Ability to receive all content published that is associated with prefixes under the subscribed prefix. This property says that for every client that has subscribed to a prefix and has reached the associated publisher, there is a path back to the client to carry any content with content ID either directly belonging to that prefix or under it in the hierarchy on the prefix tree. For example, a subscriber of P2 in Fig. 3 should receive publications pertaining to P2 and also\nP4 across domains. The assertion rcvall in Listing 4.5 depends on how relationships among groups and also between content IDs and prefixes are represented by Connections and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ PTree $$\\end{document}. For a domain with a namespace that does not capture relationships between prefixes, i.e., does not map a prefix to a set of multiple relevant prefixes according to a graph, then rcvall would be equivalent to receiving a single content element (Property 3.2). Properties 3.1\u20133 collectively model and verify properties of a service offering hierarchical pub/sub.\n",
            "cite_spans": [],
            "section": "Push-Based Retrieval: Publish/Subscribe ::: Satisfying Information-Centric Service Properties",
            "ref_spans": [
                {
                    "start": 434,
                    "end": 435,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "Our interoperability framework depends on gateways that retain state information. What would happen to a response packet if that state is lost at the gateway for any reason? For reliability, we consider state sharing between redundant gateways that have the same domains on either side. Figure 4 depicts an example for this. Consider the gateway that received the request and created the state as the primary gateway for the request (GW1 in the Fig.), and the replicas that have the shared state as the secondary gateways (GW2 and GW3). Formally, we add an extra condition to our reachability and returnability properties such that, for two routes to connect, the gateway attaching them must be up and running at the time the packet is received. Additionally, for returnability, the state information must be present at the gateway. If any gateway goes down, the corresponding potential path going through it (p1\u20133) back for the content cannot be leveraged. If the gateway is neighboring an NDN domain (e.g., in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$Domain_n$$\\end{document} or \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$Domain_{n-1}$$\\end{document}), then the gateway has to be the primary only, for correct operation with the NDN reverse-path-forwarding (RPF) policy [20]. For other domain types, a secondary gateway that is active and has the shared state information is adequate to forward the response data back. We model the conditions representing this in Alloy as shown in Listing 5.1.\n",
            "cite_spans": [
                {
                    "start": 1727,
                    "end": 1729,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Failure ::: Reasoning About Failure and Mobility",
            "ref_spans": [
                {
                    "start": 294,
                    "end": 295,
                    "mention": "4",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "Gateways can go down due to various reasons such as completely failing or just losing state information due to a software failure. Our method can be used to reason about various scenarios and measure failure probability given an input configuration space, i.e., a set of Alloy facts that set constraints on some objects or variables while relaxing others. As Table 1 shows, a simple model finding analysis does not provide a helpful comparison between different such constraints: it will say that both cases lead to counterexamples raised (e.g., for the case that all gateways go down). To gain a better assessment of which constraint does better, we resort to model counting (Table 2). Using model counting, we can count (satisfying) instances (I) and counterexamples (C), and calculate (even if approximately [7]) the probability of reliability (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R=I/(I+C)$$\\end{document}). This reliability indicates to what degree interoperability is impacted in presence of failure, given certain conditions (i.e., choice of domain policies, etc.).",
            "cite_spans": [
                {
                    "start": 812,
                    "end": 813,
                    "mention": "7",
                    "ref_id": "BIBREF18"
                }
            ],
            "section": "Failure ::: Reasoning About Failure and Mobility",
            "ref_spans": [
                {
                    "start": 365,
                    "end": 366,
                    "mention": "1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 683,
                    "end": 684,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "To model and analyze mobility (Fig. 5), we add the notion of \u201ctime\u201d to our model. In particular, we associate timeout values to state entries at gateways and birthTime and deathTime to routes (and similarly for reverse routes). We assume gateways are stationary, but other nodes can move, causing the \u201cdeath\u201d of their route (route1) to/from their closest gateway. A new route to the gateway is \u201cborn\u201d (route2) after some time, assuming the existence of a domain-specific method to handle mobility. Temporal conditions must be incorporated into reachability/returnability properties. The most critical case is when a mobility event occurs while the packet is in-flight [21]. At high-level, the sum total latency formulated as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$firstDeliveryAttempt+recovery+secondDeliveryAttempt$$\\end{document}, must be below a certain expiration threshold (at every gateway and consumer). firstDeliveryAttempt is the incomplete partial delivery latency via route1 and secondDeliveryAttempt is the delivery via route2 (continuation in MF, and complete retransmission in IP and NDN). The recovery delay is the time it takes for the packet to be transmitted back on the new path again; it includes re-registration (MF and IP), FIB re-population (IP and NDN in case of provider mobility) and/or PIT re-population (for NDN in the case of consumer mobility) delays [16, 20, 21]. Using this formal method, we check properties in the presence of mobility, find appropriate values for a timeout threshold on gateways and investigate the effect of domain-specific mobility handling methods on interoperability. Listing 5.2 generally specifies how the reachability property (to deliver a named request) depends on the condition of mobility (stationary or mobile) and the domain policy on handling mobility (early binding or late binding). Returnability is similarly specified (for content). Predicates stationary, mobileEarlyBinding, and mobileLateBinding specify timing conditions for successful delivery assuming their corresponding conditions (details of the three properties are omitted here due to space but are in [1]). As shown in Fig. 5, we only consider intra-domain mobility here, i.e., the mobile node changes its location and point of attachment, but stays within its domain.\n",
            "cite_spans": [
                {
                    "start": 669,
                    "end": 671,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1612,
                    "end": 1614,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1616,
                    "end": 1618,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1620,
                    "end": 1622,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 2362,
                    "end": 2363,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Mobility ::: Reasoning About Failure and Mobility",
            "ref_spans": [
                {
                    "start": 36,
                    "end": 37,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 2384,
                    "end": 2385,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "We implemented the ICI framework discussed in our model in Sect. 3, with gateways for interoperation among IP, NDN, and MF (Fig. 1 as an example) in a software testbed (implementation details in [11]). This section provides the description and results of our analysis of the ICI framework (our Alloy source code is approximately 800 lines of code in total [1]).\n\n",
            "cite_spans": [
                {
                    "start": 196,
                    "end": 198,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 357,
                    "end": 358,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Implementation and Results",
            "ref_spans": [
                {
                    "start": 129,
                    "end": 130,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "To check for correctness, we performed verification (supported by Alloy Analyzer\u2019s model finding engine) of our ICI framework model, against the information-centric services properties (as specified in Sect. 4). In order to reach convincing proofs (as advised in [18]), we pick the scopes for verification in Alloy that are large enough to contain all necessary cases (i.e., minimum number of actors and objects for each service), and small enough so that we do not encounter model explosion. The scopes, i.e., upper bounds on the number of key objects, are provided in Table 3. For most properties, we consider 1 Client, 1 Server, 1 Content, and 1 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document}. That is, different <client, request> pairs are considered independent of each other. However, for Properties 2.3.a/b, such a dependency matters, and we want to show lack of conflicts. For Property 2.3.a, we set 1 Client and 2 Contents (to generate scenarios where one client makes two separate request for two different contents), and for Property 2.3.b, we set 2 Clients and 1 Content (to look for conflicts between request for one content but by two clients). We use 3 Domains for most properties, as it contains all cases with 1, 2, or 3 domains of any type, i.e., IP, NDN, or MF. Also, with upper bound n on the total number of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Node $$\\end{document}s, i.e., sum of Clients, Servers, and GWs, we specify the upper bound on the number of Routes (as well as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ RevRoute $$\\end{document}s) to be \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n(n-1)$$\\end{document}, enabling the existence of any possible (uni-directional) route. For pub/sub services (i.e., Properties 3.1\u20133), we set 3 \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ Prefix $$\\end{document}es, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document}s, and Contents, to capture inter-relationship of content IDs in a large enough namespace. Additionally, with the upper bound on Domains and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ ContentID $$\\end{document}s both set at 3, we set the upper bound on total number of Groups (and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ GroupID $$\\end{document}s) to be \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$3\\times 3=9$$\\end{document}, so as to contain cases with one group per content ID per domain. The blank cells in Table 3 indicate either \u201cN/A\u201d or \u201cno particular upper bound set\u201d, in which case Alloy picks a default value. Within this scope, our verification passes successfully for each property, showing that the stated properties are invariants of our ICI framework. In other words, the framework design ensures that any sequence of interconnected IP, NDN, and MF domains are information-centrically interoperable.",
            "cite_spans": [
                {
                    "start": 264,
                    "end": 266,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Implementation and Results",
            "ref_spans": [
                {
                    "start": 576,
                    "end": 577,
                    "mention": "3",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 4485,
                    "end": 4486,
                    "mention": "3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "We use our proposed model counting approach to analyze scenarios with the failure of one or multiple gateways. The most important factor affecting returnability in scenarios with the possibility of failure, is domain-specific routing policies, in particular, whether or not it allows for a secondary (backup) gateway to relay the returning response content. Different domains have different policies; MF and IP decouple the forward (request) and return (response) paths, and they can be delivered through different gateways, while NDN strictly requires the two paths to be the same, due to RPF policy. To investigate the impact of that policy, we considered a scenario of two domains, with two gateways between them (one primary and one secondary), sharing state. Both gateways are Up (working) when the request is forwarded, and either may go Down (failing) when the response is one its way back. Table 4 shows different scenarios for reachability and returnability, with different domain constraints (with different routing policies). In particular, the two domain constraints we consider are the following: 1) no constraint on what any of the domains are; and 2) one domain is definitely NDN. The table shows the values of I (instances), C (counterexample), and R (reliability) for each scenario, as defined in Sect. 5. Our results for R in Table 4 prove that having an NDN domain on one side dramatically reduces the returnability reliability ratio, since basic NDN forwarding strictly forbids data coming back on a different path than the original path taken by the request.\n\n",
            "cite_spans": [],
            "section": "Implementation and Results",
            "ref_spans": [
                {
                    "start": 904,
                    "end": 905,
                    "mention": "4",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 1350,
                    "end": 1351,
                    "mention": "4",
                    "ref_id": "TABREF3"
                }
            ]
        },
        {
            "text": "When a content producer (server) moves while a content request is in-flight (Fig. 5), the domain\u2019s handling of mobility recovery determines the reachability probability. NDN and IP use early binding with retransmissions, while MF supports late binding with rerouting. We compare the impact of these mechanisms and techniques using our model counting method, with results shown in Table 5. Our modeled scenario consists of two nodes in a domain, one requester (client or gateway) and one server (producer) with a route established among them. The \u2018Stationary\u2019 columns in the table show reachability results in the stationary server case. With \u2018Mobile\u2019, the route dies due to a server mobility event (at time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t=10$$\\end{document}), leading to the birth of the second route. We set the re-registration and re-population delays to 1 each. Also, a retransmission is initiated 1 time unit after the mobility event. Different binding techniques for mobility, i.e., late and early binding, are also shown in Table 5. We compare cases with different ranges for Delivery Latency (DL), which is time approximately needed for a packet to travel from requester to server. For a delivery latency range of [0, 20], we see a higher R for stationary vs. mobility cases. The reason is that when the server does not move, the original route stays active, thus providing a higher chance for requests to reach the server. Comparing the two binding techniques, late binding leads to higher chance of reachability compared to early binding, as it allows for packets to be re-routed on the newly-born route, rather than retransmitting from the original requester. These results serve as proof that under similar scenarios, late binding outperforms early binding in ICI. Also, changing the delivery latency ranges, we can find out at what points, reachability is an invariant (if ever) under mobility conditions. As the table shows, with ranges within [0, 18], [0, 15], and [0, 10] (rows in Table 5 labeled in first column accordingly), reachability becomes an invariant in cases of Stationary, Late Binding, and Early Binding, respectively; as zero counterexamples are raised. With a small enough delivery latency ranges, namely [0, 10], reachability becomes an invariant, no matter the mobility conditions or binding techniques. Our approach can be used to find such points of invariance, comparing different techniques, and prove them.",
            "cite_spans": [],
            "section": "Implementation and Results",
            "ref_spans": [
                {
                    "start": 82,
                    "end": 83,
                    "mention": "5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 386,
                    "end": 387,
                    "mention": "5",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 1275,
                    "end": 1276,
                    "mention": "5",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 2241,
                    "end": 2242,
                    "mention": "5",
                    "ref_id": "TABREF4"
                }
            ]
        },
        {
            "text": "This paper presented an Alloy-based formal analysis model for information-centric interoperability (ICI) for Future Internet environments. We showed how model finding can be used to analyze basic (reachability and returnability) properties of ICI. Additionally, our proposed model counting approach analyzes failure and mobility scenarios, which we used to prove the negative impact of certain routing policies (particularly, reverse path forwarding), and the helpfulness of certain mobility-handling mechanisms (particularly, late binding), providing necessary confidence and guidelines for Future Internet interoperability.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Model finding\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Model counting\n",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3.: Verif. scopes for properties of ICI services\n",
            "type": "table"
        },
        "TABREF3": {
            "text": "Table 4.: Failure analysis results\n",
            "type": "table"
        },
        "TABREF4": {
            "text": "Table 5.: Mobility analysis results\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Information-centric interoperability (ICI): request for content",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Example (partial) instance for ICI Alloy model (objects and relations)",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Prefix tree example",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 4.: Gateway failure scenario",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fig. 5.: Mobility scenario example: Route 2 established after B moves and changes its point of attachment",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "The SAT4J library, release 2.2, system description",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Le Berre",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Parrain",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Satisf. Boolean Model. Comput.",
            "volume": "7",
            "issn": "",
            "pages": "59-64",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "A survey on network verification and testing with formal methods: approaches and challenges",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Commun. Surv. Tutor.",
            "volume": "21",
            "issn": "1",
            "pages": "940-969",
            "other_ids": {
                "DOI": [
                    "10.1109/COMST.2018.2868050"
                ]
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "MobilityFirst: a robust and trustworthy mobility-centric architecture for the future internet",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Raychaudhuri",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ACM SIGMOBILE MCCR",
            "volume": "16",
            "issn": "3",
            "pages": "2-13",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Kodkod: a relational model finder",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Torlak",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jackson",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Tools and Algorithms for the Construction and Analysis of Systems",
            "volume": "",
            "issn": "",
            "pages": "632-647",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "A practical comparison of alloy and spin",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zave",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Formal Aspects Comput.",
            "volume": "27",
            "issn": "2",
            "pages": "239-253",
            "other_ids": {
                "DOI": [
                    "10.1007/s00165-014-0302-2"
                ]
            }
        },
        "BIBREF10": {
            "title": "A formal model of addressing for interoperating networks",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Zave",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "FM 2005: Formal Methods",
            "volume": "",
            "issn": "",
            "pages": "318-333",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Named data networking",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ACM SIGCOMM CCR",
            "volume": "44",
            "issn": "3",
            "pages": "66-73",
            "other_ids": {
                "DOI": [
                    "10.1145/2656877.2656887"
                ]
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "A scalable approximate model counter",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Chakraborty",
                    "suffix": ""
                },
                {
                    "first": "KS",
                    "middle": [],
                    "last": "Meel",
                    "suffix": ""
                },
                {
                    "first": "MY",
                    "middle": [],
                    "last": "Vardi",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Principles and Practice of Constraint Programming",
            "volume": "",
            "issn": "",
            "pages": "200-216",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "On probabilistic inference by weighted model counting",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chavira",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Darwiche",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "AI",
            "volume": "172",
            "issn": "6\u20137",
            "pages": "772-799",
            "other_ids": {
                "DOI": [
                    "10.1016/j.artint.2007.11.002"
                ]
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "Alloy: a lightweight object modelling notation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jackson",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "TOSEM",
            "volume": "11",
            "issn": "2",
            "pages": "256-290",
            "other_ids": {
                "DOI": [
                    "10.1145/505145.505149"
                ]
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}