{
    "paper_id": "PMC7242048",
    "metadata": {
        "title": "Structuring the State and Behavior of\u00a0ASMs: Introducing a Trait-Based Construct for Abstract State Machine Languages",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Philipp",
                "middle": [],
                "last": "Paulweber",
                "suffix": "",
                "email": "philipp.paulweber@univie.ac.at",
                "affiliation": {}
            },
            {
                "first": "Emmanuel",
                "middle": [],
                "last": "Pescosta",
                "suffix": "",
                "email": "epescosta@casm-lang.org",
                "affiliation": {}
            },
            {
                "first": "Uwe",
                "middle": [],
                "last": "Zdun",
                "suffix": "",
                "email": "uwe.zdun@univie.ac.at",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "In 1993, Gurevich [1] introduced the ASM theory, which is a well-known state-based formal method consisting of transition rules and algebraic functions. It has been used extensively by scientists for a broad research field ranging from software and hardware to system engineering perspectives in order to specify, analyze, and verify systems in a formal way. ASMs are used to formally describe the evolution of function states in a step-by-step manner1 and are used to describe sequential, parallel, concurrent, reflective, and even quantum algorithms. Based on the ASM theory by Gurevich [1], several theory improvements and ASM-based language implementations were developed, which were summarized by B\u00f6rger and St\u00e4rk [2] and B\u00f6rger and Raschke [3].",
            "cite_spans": [
                {
                    "start": 19,
                    "end": 20,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 590,
                    "end": 591,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 720,
                    "end": 721,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 747,
                    "end": 748,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Prominent ASM languages and tools are AsmetaL [4], CASM [5], and CoreASM [6]. Today, a common thread in the various ASM languages and tools, as well as in most other state-based formal methods, is that the proposed specification languages lack easy-to-comprehend abstractions to describe reusable and maintainable type specifications. While very few have embraced basic object-oriented abstractions such as classes and inheritance, more advanced type abstractions are usually missing. Therefore, in this paper we propose a new language construct for ASM specification languages to express type abstractions in the form of traits [7] to modularize specifications into structural state and behavioral parts.",
            "cite_spans": [
                {
                    "start": 47,
                    "end": 48,
                    "mention": "4",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 57,
                    "end": 58,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 74,
                    "end": 75,
                    "mention": "6",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 630,
                    "end": 631,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Modern object-oriented languages offer a variety of advanced type abstractions, and most offer either interfaces [8], mixins [9], or traits [7] in addition to classes and inheritance concepts. Interfaces establish a protocol and define method signatures to which a type has to conform [8]. They are often compared to a contract. Mixins define reusable behavior and structure that can be used to combine and form new types [9, 10]. Traits are similar to interfaces except that they can define stateless behavior which depends on the trait itself [11]. There is a heated debate in the object-oriented community2, which of these abstractions is best suited to promote reusable and maintainable type specifications, and many implementations combine different language constructs to define type abstractions. A notable example would be the programming language Scala [12], which offers a trait syntax that is similar to the Java 8 [13] interface syntax and offers mixins type abstractions through the class-based implementation and extension syntax. Another example of mixed type abstraction concepts, namely interfaces and traits, can be found in the programming language Rust [14], where the language user has to express every interface definition through traits, and the types have to conform to specified traits and implement all required functionalities.",
            "cite_spans": [
                {
                    "start": 114,
                    "end": 115,
                    "mention": "8",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 126,
                    "end": 127,
                    "mention": "9",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 141,
                    "end": 142,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 286,
                    "end": 287,
                    "mention": "8",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 423,
                    "end": 424,
                    "mention": "9",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 426,
                    "end": 428,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 546,
                    "end": 548,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 863,
                    "end": 865,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 927,
                    "end": 929,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1174,
                    "end": 1176,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Motivation",
            "ref_spans": []
        },
        {
            "text": "In the world of ASMs, only AsmL [15] has introduced an object model in the language through classes and interfaces to represent type abstractions, and to achieve structuring of the ASM specifications. Only the ASM implementation and language XASM by [16] has introduced a sub-ASM construct to achieve a component-based modularization approach. A more generic concept called ambient ASMs [3] introduces the possibility to achieve hierarchical state partitioning through nesting of context-sensitive (sub)program environments. Based on this state of the art, we started to investigate the introduction of a new type abstraction language construct in ASMs. But which language construct is suitable for ASMs to represent such type abstractions?",
            "cite_spans": [
                {
                    "start": 33,
                    "end": 35,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 251,
                    "end": 253,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 388,
                    "end": 389,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Motivation",
            "ref_spans": []
        },
        {
            "text": "Basically every language construct for forming type abstractions is suitable for ASMs, but it influences the understandability of the language considerably. For such an ASM extension, we consider the following properties important: (1) reuse and embed existing specifications; (2) describe built-in behavior of a language itself in the language; and (3) allow encapsulation of ASM states and corresponding behavior through modularization. Driven by the properties and questions raised, we conducted empirical studies to determine, which language construct \u2013 interfaces, mixins, or traits \u2013 is most understandable to ASM language users for expressing type abstractions [17]. The result of the experiments showed that the participants with strong object-oriented backgrounds (highly familiar with interfaces, not familiar with traits at all) had a similar to equal understanding of an interface and traits language construct in the experimental ASM syntax variants. Mixins, on the other hand, had a significantly lower understandability compared to traits and interfaces. Since the interface and traits type abstraction language constructs offer a similar to equal understandability, and novice language users seem to understand traits without even knowing the concept of traits, we investigated introducing traits into ASMs.",
            "cite_spans": [
                {
                    "start": 669,
                    "end": 671,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Motivation",
            "ref_spans": []
        },
        {
            "text": "Moreover, the object-oriented communities often discuss traits more favorably than interfaces3 and even point out that \u201cTraits are Interfaces\u201d4 just with code-level reuse functionality. To gain a better understanding of how specifiers (language users) comprehend such trait-based specifications, we performed an eye-tracking experiment [17], where we observed the participants\u2019 gaze patterns. The results of this experiment showed that the participants could easily distinguish between behavioral and non-behavioral aspects of a given specification, when we applied our trait-based language construct to form state/behavior type abstractions.",
            "cite_spans": [
                {
                    "start": 337,
                    "end": 339,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Motivation",
            "ref_spans": []
        },
        {
            "text": "This section proposes our trait-based language construct to extend the syntax of ASM specification languages. The syntax rules are defined and expressed in BNF (see Listing 1.1). The semantics of the proposed trait-based syntax extension is defined by lowering and transforming the new syntax elements to appropriate Turbo ASM [2] equivalent definitions (see example trait-based ASM Listing 1.2 and the transformed Turbo ASM Listing 1.3). The ASM specifications presented use the syntax of the CASM specification language5. The trait-based syntax extension is divided into three parts, namely structural types, basic type behavior, and extended type behavior.",
            "cite_spans": [
                {
                    "start": 328,
                    "end": 329,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "A Trait-Based Construct for ASMs",
            "ref_spans": []
        },
        {
            "text": "In order to modularize the states (functions not classified as derived) in ASM, we introduce a structural type construct (see Listing 1.1, Line 2\u20134), which allows a language user to group one or multiple functions together (similar to members of an object-oriented class) to form a new structure type (see StructureDefinition grammar rule). Each structure type defines a trait type through the defined state functions. The access to these functions is only allowed inside a proper basic behavior definition to clearly specify the access to an instantiated structure\u2019s state over dedicated behaviors (data encapsulation).\n",
            "cite_spans": [],
            "section": "A Trait-Based Construct for ASMs",
            "ref_spans": []
        },
        {
            "text": "A basic type behavior (see Listing 1.1, Line 6\u201314) defines a set of rules and derived functions, which are associated with a certain domain type. We introduce a new ImplementDefinition to define a basic behavior consisting of one or more object-based derived function and/or rule definitions. The syntax for ObjectRuleDefinition and ObjectDerivedDefinition introduce a new keyword this as the first argument for all object-based rule and/or derived function definitions. The type of the argument variable this equals the type of the ImplementDefinition and it enables the access to the domain\u2019s or structure\u2019s behavior. The access happens through a MethodCall syntax, which uses a dot operator between a term, a target name, and a non-negative arity of arguments. The target name can be a function name or a rule name.",
            "cite_spans": [],
            "section": "A Trait-Based Construct for ASMs",
            "ref_spans": []
        },
        {
            "text": "An extended type behavior (see Listing 1.1, Line 16\u201322) defines a set of rules and derived functions, and forms a new type in the type system. If a domain and/or structural type wants to use the functionality, it has to implement the extended behavior. The BehaviorDefinition defines an explicit trait with type name consisting of zero or more ObjectRuleDeclaration rule names and/or ObjectDerivedDeclaration derived function names. Please note that for all object-based declarations we introduced a generic Object argument type at the first position. The Object type gets checked against the domain or structural type which is implementing this declared behavior. A specifier can use the Object type for any other argument or target type in a declaration. Additionally, a trait can define a default behavior through zero or more ObjectRuleDefinition rule names and/or ObjectDerivedDefinition derived function names, which depends only on the functionality of the trait itself. Each domain and/or structural type that wants to support a certain behavior has to specify an ImplementForDefinition and provide the missing definitions of the trait declarations. If the trait defines a default behavior, the domain and/or structural type inherits this definition. This enables code reuse capabilities.",
            "cite_spans": [],
            "section": "A Trait-Based Construct for ASMs",
            "ref_spans": []
        },
        {
            "text": "Listing 1.2 depicts an example trait-based ASM specification using all new syntax grammar rules and Listing 1.3 depicts the equivalent semantics-preserving Turbo ASM specification. The proposed trait-based syntax extension is realized in our CASM language implementation6. In order to provide a clean solution, we updated our CASM language front-end implementation and introduced two new internal AST representations before the specification gets transformed to the CASM-IR [5].",
            "cite_spans": [
                {
                    "start": 475,
                    "end": 476,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "A Trait-Based Construct for ASMs",
            "ref_spans": []
        },
        {
            "text": "By introducing the proposed trait-based construct, we were able to explicitly specify the behavior of the CASM language itself in CASM in the form of a prelude (See footnote 6) specification, which gets automatically loaded (imported) for every parsed CASM specification. Each functionality of the CASM language (e.g. operators) is mapped to a behavior (trait) in the prelude specification. The language user can explore and extend the behaviors of CASM in CASM. Moreover, the prelude specification reduced the complexity of the CASM implementation.",
            "cite_spans": [],
            "section": "A Trait-Based Construct for ASMs",
            "ref_spans": []
        },
        {
            "text": "In this paper, we present a trait-based construct for ASM languages. It allows to specify composable models through the usage of domain and structural type objects, where the behavior can be defined and implemented in a reusable manner. The modularization and composing of object-oriented models is achieved by specifying structural states along with their behaviors clearly separated through traits. Novel about this contribution is that ASM language users can directly define the semantics of operations over domain (structure) types through this trait-based construct in the ASM language itself. To clearly separate structure and behavior, we only allow the definition of modifications to structural objects through a proper behavior definition. Based on previously conducted empirical studies, the current state of the art, and our current proposed trait-based construct, we believe that this is the first step towards clearer and more understandable ASM specifications by separating the structural (state) and behavioral elements through dedicated definitions.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {},
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "Mixin-based inheritance",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Bracha",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Cook",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "ACM Sigplan Not.",
            "volume": "25",
            "issn": "10",
            "pages": "303-311",
            "other_ids": {
                "DOI": [
                    "10.1145/97946.97982"
                ]
            }
        },
        "BIBREF2": {
            "title": "Traits: composable units of behaviour",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Sch\u00e4rli",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ducasse",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Nierstrasz",
                    "suffix": ""
                },
                {
                    "first": "AP",
                    "middle": [],
                    "last": "Black",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "ECOOP 2003 \u2013 Object-Oriented Programming",
            "volume": "",
            "issn": "",
            "pages": "248-274",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Odersky",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Spoon",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Venners",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Programming in Scala",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Potts",
                    "suffix": ""
                },
                {
                    "first": "DH",
                    "middle": [],
                    "last": "Friedel",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Java Programming Language Handbook",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "The rust language",
            "authors": [
                {
                    "first": "ND",
                    "middle": [],
                    "last": "Matsakis",
                    "suffix": ""
                },
                {
                    "first": "FS",
                    "middle": [],
                    "last": "Klock",
                    "suffix": "II"
                }
            ],
            "year": 2014,
            "venue": "ACM SIGAda Ada Lett.",
            "volume": "34",
            "issn": "",
            "pages": "103-104",
            "other_ids": {
                "DOI": [
                    "10.1145/2692956.2663188"
                ]
            }
        },
        "BIBREF6": {
            "title": "Semantic essence of AsmL: extended abstract",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Gurevich",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Rossman",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Schulte",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Formal Methods for Components and Objects",
            "volume": "",
            "issn": "",
            "pages": "240-259",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "XASM- an extensible, component-based abstract state machines language",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Anlauff",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Abstract State Machines - Theory and Applications",
            "volume": "",
            "issn": "",
            "pages": "69-90",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "B\u00f6rger",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "St\u00e4rk",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Abstract State Machines: A Method for High-Level System Design and Analysis",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Control state diagrams (meta model)",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "B\u00f6rger",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Raschke",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Modeling Companion for Software Practitioners",
            "volume": "",
            "issn": "",
            "pages": "297-315",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "A metamodel-based language and a simulation engine for abstract state machines",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "J. Univ. Comput. Sci.",
            "volume": "14",
            "issn": "12",
            "pages": "1949-1983",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "CASM-IR: uniform ASM-based intermediate representation for model specification, execution, and transformation",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Paulweber",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Pescosta",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Zdun",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Abstract State Machines, Alloy, B, TLA, VDM, and Z",
            "volume": "",
            "issn": "",
            "pages": "39-54",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "CoreASM: an extensible ASM execution engine",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Farahbod",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Gervasi",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Gl\u00e4sser",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Fundam. Informaticae",
            "volume": "77",
            "issn": "1\u20132",
            "pages": "71-104",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}