{
    "paper_id": "PMC7242039",
    "metadata": {
        "title": "Diverse Scenario Exploration in Model Finders Using Graph Kernels and Clustering",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Robert",
                "middle": [],
                "last": "Claris\u00f3",
                "suffix": "",
                "email": "rclariso@uoc.edu",
                "affiliation": {}
            },
            {
                "first": "Jordi",
                "middle": [],
                "last": "Cabot",
                "suffix": "",
                "email": "jordi.cabot@icrea.cat",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "The structure and behavior of a software system can be described by means of software models, using notations such as Alloy [10], graph-based formalisms [20] or UML/OCL [17]. These notations describe software systems at a high level of abstraction, hiding implementation details while preserving its salient features. Analysing these models can reveal complex faults in the underlying systems.",
            "cite_spans": [
                {
                    "start": 125,
                    "end": 127,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 154,
                    "end": 156,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 170,
                    "end": 172,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this analysis, the key assets for checking the correctness of software models are model finders [8], tools capable of computing instances of a model that satisfy a set of constraints and properties of interest. Each model finder targets a particular modeling notation and uses a different reasoning engine, like search-based methods [1, 24], SAT [10], SMT [24, 28] or constraint programming [3].",
            "cite_spans": [
                {
                    "start": 100,
                    "end": 101,
                    "mention": "8",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 337,
                    "end": 338,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 340,
                    "end": 342,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 350,
                    "end": 352,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 360,
                    "end": 362,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 364,
                    "end": 366,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 395,
                    "end": 396,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "For verification purposes, it is usually enough to search for one instance, which either proves or disproves the property of interest. However, for testing and validation purposes several instances are usually required to increase our confidence in the correctness of the model. It is highly desirable that those instances exhibit diversity, i.e., distinct configurations of the system and interesting corner cases [11]. Lack of diversity may make validation and testing more time consuming, as the analysis includes almost-duplicate instances that do not provide added value; and less effective, as the sample of instances may fail to include relevant scenarios.",
            "cite_spans": [
                {
                    "start": 416,
                    "end": 418,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Nevertheless, most model finders focus on efficiency and expressiveness of the input modeling notation, so few of them ensure diversity of the generated instances [6, 11, 20, 23, 26]. In these few, diversity assurance is integrated into the solver: it guides the search process to look for diverse instances. However, this integration makes it harder to transfer the proposed methods to other solvers and notations. Thus, designers are limited in terms of expressiveness (e.g., no support for integer or string attributes [11, 20, 26] or dynamic properties [6, 11, 23, 24]) and cannot benefit from additional features provided by others model finders (e.g., computation of minimal instances [16] or support for max-satisfiability [28]).",
            "cite_spans": [
                {
                    "start": 164,
                    "end": 165,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 167,
                    "end": 169,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 171,
                    "end": 173,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 175,
                    "end": 177,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 179,
                    "end": 181,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 523,
                    "end": 525,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 527,
                    "end": 529,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 531,
                    "end": 533,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 558,
                    "end": 559,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 561,
                    "end": 563,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 565,
                    "end": 567,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 569,
                    "end": 571,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 692,
                    "end": 694,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 731,
                    "end": 733,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "This paper proposes a method for distilling diverse instances in the model finder output based on the use of clustering. Instances are classified into categories according to their similarity, which is calculated using information about their structure (the existing objects and the links between them), typing (the specific type of each object) and attribute values. This calculation is based on the use of graph kernels, a family of methods for computing distances among graphs. Selecting a representative instance from each category ensures diversity while reducing testing and validation time, as redundant instances can be safely discarded. As a drawback, this method does not force the model finder to look for diverse instances, it only distills the most diverse ones.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Compared with related works, our approach offers the following advantages:It is independent of the solver used by the model finder (SAT, SMT, ...) and the modeling notation being analyzed (Alloy, UML/OCL, ...).It does not require manual intervention from the designer to define what kind of instances are \u201crelevant\u201d or when two instances are \u201csimilar\u201d.The similarity computation can be customized, e.g., by selecting a trade-off between precision and accuracy.Paper Organization. The remainder of the paper is structured as follows. Section 2 presents an overview of the method illustrated with a simple example. Then, we describe the three steps of our method: the abstraction process for transforming instances into graphs (Sect. 3); graph kernels (Sect. 4), the framework for computing similarities among graphs; and clustering algorithms that can use this similarity to build groups of related instances (Sect. 5). Section 6 presents some experimental results of the application of this method. After that, Sect. 7 describes previous work on diversity and model finding. Finally, Sect. 8 outlines the conclusions and lines for future work.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": []
        },
        {
            "text": "The overview of our approach for identifying diverse instances in model finder output is depicted in Fig. 1. Our input is a set of instances computed by a model finder, and our output is a set of clusters grouping those instances according to their similarity. From this output, it is possible to select a representative instance for each cluster, e.g., choosing the smallest instance.",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": [
                {
                    "start": 106,
                    "end": 107,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The method can be divided into three steps: Graph abstraction: First, each instance is abstracted as a labeled graph, where labels store type and attribute value information and the underlying graph captures the objects and the links among them.Graph kernel: Then, the pairwise similarity among the n graphs is computed using a state-of-the-art labeled graph comparison technique. The result of this computation is a \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n \\times n$$\\end{document} matrix S where each cell \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_{ij}$$\\end{document} provides information about the similarity between graphs i and j.Clustering: Finally, the similarity data is used by a clustering procedure to classify instances into groups of similar instances. The most suitable number of groups is determined by using clustering validity indices, which measure whether elements in the cluster are similar to each other and different from elements in other clusters.\n\n",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": []
        },
        {
            "text": "To illustrate how the method works and the type of results it can achieve, we will use the UML class diagram in Fig. 2(a). This model describes the relationships between employees who work in or lead a department. There are two constraints regarding the salary, defined as OCL invariants: all salaries must be below a salary threshold and also below the salary of the department\u2019s director.",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": [
                {
                    "start": 117,
                    "end": 118,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "To be usable in practice, this model should be strongly satisfiable [3]: it should have some instance where all integrity constraints are satisfied with each class having a non-empty population. In our example, the class diagram is satisfiable and a potential solution is the instance shown in Fig. 2(b). Instances like this can then be used for validating and testing the UML/OCL model.",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 70,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Method Overview",
            "ref_spans": [
                {
                    "start": 299,
                    "end": 300,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "We have used the USE Model Validator [12] to generate 25 valid instances for this model. By manually inspecting these instances, we can easily realize that most of them are very similar. A designer would be interested in a smaller and more diverse set of instances that gives the same or even more information as the 25 original ones. We explain next how this can be achieved with our method.",
            "cite_spans": [
                {
                    "start": 38,
                    "end": 40,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Method Overview",
            "ref_spans": []
        },
        {
            "text": "Applying our method, each object diagram is abstracted as a labeled graph. As an example, Fig. 2(c) shows the abstraction for the object diagram in Fig. 2(b). We then apply hierarchical clustering to our 25 graphs using the similarity information provided by a graph kernel algorithm. From the results, validity indices recommend choosing 3 clusters. Thus, we have discovered that out of the 25 instances, there are only 3 types of solutions worth considering. The common pattern in each cluster is depicted in Fig. 2(d).",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": [
                {
                    "start": 95,
                    "end": 96,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 153,
                    "end": 154,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 516,
                    "end": 517,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Notice that one cluster identified by our method (the middle one) highlights a potential problem in the model: a department where the director works in another department. This is a corner case worth studying, to decide whether it should actually be allowed or it is a mistake in the model that needs to be fixed.",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": []
        },
        {
            "text": "The following sections describe the different phases of our approach in detail.",
            "cite_spans": [],
            "section": "Method Overview",
            "ref_spans": []
        },
        {
            "text": "Depending on the model finder, instances have a different structure, e.g., an object diagram, an enriched graph or a set of tuples. In order to take advantage of off-the-shelf graph comparison algorithms, we translate these instances into labeled undirected graphs. To this end, we define the vertices, edges and labels in the graph in terms of the original instance.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Intuitively, the vertices of the graph will describe the object elements in the instance, while the edges will describe the relationships among them. Labels are integer values assigned to vertices. Labels will be used to describe information such as the type of each element or the values of attributes that can, later on, help to establish whether a pair of vertices from two different graphs can be considered \u201cequivalent\u201d.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "The complexity of this step depends on the kind of output provided by the model finder. Our approach provides a specific solution for each type of output. As shown in Fig. 2, the abstraction of object diagrams is straightforward according to this pattern: objects and attributes becomes vertices, links become edges, and types and attribute values become labels. Similarly, the mapping from instances in graph-based modeling notations is also trivial: the vertices and edges of the original graph are preserved while the type of each element is used as a label for the corresponding vertex. Nevertheless, the transformation from the relational notation used by Alloy is more involved. Thus, we devote the remainder of this Section to formalize the abstraction of Alloy instances.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": [
                {
                    "start": 172,
                    "end": 173,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Alloy Models. An Alloy specification is defined as a collection of signatures and constraints, followed by a command.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Signatures (sig) describe the data in the model. Each signature has a unique name and represents a set of atoms, the base individuals in Alloy\u2019s logic. Signatures can have fields which take values for each atom of the signature. These values can be basic data types like integers, other signatures or complex values like functions or sets. Internally, these values are managed as relations, collections of tuples with the same arity (number of elements).",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "It is possible to define a hierarchy among signatures (extends). Moreover, fields and signatures may have multiplicity constraints limiting their population, e.g., one or lone (zero or one). In addition to user-defined signatures, Alloy provides some built-in signatures to describe common data types such as booleans, integers, strings or sequences.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Regarding constraints, there are different types of constraint: facts (fact) describe invariants that should always hold; assertions (assert) state desired properties that should be checked; and predicates (pred) are reusable constraints where some elements are passed as parameters. Each constraint can be defined using a mixture of logical operators (e.g., and, not or implies), relational operators (e.g., dot join or transpose) and quantifiers (e.g., all or some).",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Finally, commands instruct the solver which constraint should be analyzed and the scope (number of atoms) that should considered for each signature. Command check searches for a counterexample of an assertion, while command run searches for an example of a predicate.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Alloy Snapshots. Executing a command with the Alloy Analyzer may yield two outcomes: either no instance within the scope satisfies the constraints or an instance has been found. Instances are called snapshots in the Alloy terminology.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "An Alloy snapshot is defined by the following elements:A list of signatures, including both built-in and user-defined signatures.A list of relations, each one with a fixed arity n.A list of free variables in the model, e.g., parameters of predicates and existentially quantified variables.For each signature, a set of atoms.For each relation with arity n, a set of tuples of n atoms.For each free variable with arity n, a witness, i.e., a set of tuples of n atoms.\n",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "That is, when checking for a property with existential quantifiers, Alloy not only answers whether it is satisfied or not: if it holds, it also computes for which specific value of the quantified variable (the witness) the property holds.\n",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "From Snapshots to Graphs. We need to define how to translate: (1) built-in signatures, (2) user-defined signatures and (3) relations. As witnesses are a special type of relation, we do not need to treat them separately.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Regarding built-in signatures, we need to make sure that each value will be given the same label in different snapshots: an integer like 7 and a string like \u201cJohn\u201d should be considered equal among different snapshots. Thus, the first step is traversing the set of snapshots being abstracted to construct a vocabulary of values. In this way, we compute a unique label for each value of a basic type.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "\nBuilt-in signatures: We create a vertex for each atom in these signatures, plus a vertex for each built-in value (string, integer or sequence) used in the model. We label each vertex with the unique label for that built-in value.User-defined signatures: We create a vertex for each atom. It is labeled with its signature, i.e., the innermost signature in the signature hierarchy where it belongs.Relations: We create a vertex v for each tuple, labeled with the name of the relation. Then, for each i-th element in the tuple, we create a vertex1 labeled with i connected to both v and the vertex of the corresponding value.\n",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "Figure 3 shows an example of this abstraction process. The Alloy model in Fig. 3(a) describes a DNS server lookup process. We want to validate the potential scenarios in this process, for instance, whether two names may resolve to the same IP address. To do that, Alloy finds example instances, highlighting the offending names (n1 and n2) and DNS (d). Figure 3(b) and (c) show one sample Alloy instance in textual and graphical format. The corresponding graph abstraction is depicted in Fig. 3(d). For clarity, vertices are depicted in a different shape according to their origin: circles for atoms; rectangles for relations (white) and positions within relations (grayed); and hexagons for witnesses.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 79,
                    "end": 80,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 360,
                    "end": 361,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 493,
                    "end": 494,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "Abstraction and Diversity. Some approaches aimed at achieving diversity use uniform sampling [5, 14, 15, 18] as their goal: achieving a uniform distribution among solutions. Nevertheless, the desired notion of diversity may be more complex (a target probability distribution, a partition into meaningful classes), and specific to a domain or even a particular problem [6, 24]. In the following, we discuss how this information about the desired type of diversity can be integrated in the graph abstraction process with very few changes.",
            "cite_spans": [
                {
                    "start": 94,
                    "end": 95,
                    "mention": "5",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 97,
                    "end": 99,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 101,
                    "end": 103,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 105,
                    "end": 107,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 369,
                    "end": 370,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 372,
                    "end": 374,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                }
            ],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "For example, let us consider the specification of a banking system. From our domain knowledge, it seems reasonable to think that the name of the owner an account is not very relevant: if there are 10 clients in our system, the fact that all of them are called \u201cJohn Smith\u201d might not be problematic. Thus, the name of the owner could be abstracted away in our graph representation, i.e. remove from the graph the vertices related to this particular attribute. On the other hand, focusing on the balance of an account, we might be interested in considering accounts with a positive, negative and zero balance. In this case, we are not interested in specific values for the balance, only if they fit in these three categories. In our graph abstraction, this situation can be modeled by using these categories (instead of the integer value) as the label for the vertex.",
            "cite_spans": [],
            "section": "Graph Abstraction",
            "ref_spans": []
        },
        {
            "text": "There are different ways to compare a pair of graphs and establish the degree of similarity between them. For instance, the edit distance measures the number of atomic changes required to transform one graph into the other. An alternative is checking for isomorphism2 between the whole graphs or their subgraphs. However, these approaches have a high computational complexity and may be unsuitable for comparing large graphs or sizable collections of graphs.",
            "cite_spans": [],
            "section": "Graph Kernels",
            "ref_spans": []
        },
        {
            "text": "An alternative approach is taken by graph kernels [7, 27], a family of methods for measuring the (dis)similarity among pairs of graphs. Rather than computing an exact measure for similarity, kernels aim to provide an efficient approximation that can be computed efficiently but still captures relevant topological information about the graphs. A typical approach is counting the number of matching substructures within the graphs, like paths, subtrees or subgraphs. In this work, we have used the Weisfeiler-Lehman kernel [22], as it has been shown to provide good precision with an efficient computation in a variety of domains [13, 22].",
            "cite_spans": [
                {
                    "start": 51,
                    "end": 52,
                    "mention": "7",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 54,
                    "end": 56,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 523,
                    "end": 525,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 630,
                    "end": 632,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 634,
                    "end": 636,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Graph Kernels",
            "ref_spans": []
        },
        {
            "text": "Algorithm 1 describes the Weisfeiler-Lehman (WL) kernel. The procedure computes the distance between a pair of graphs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G_1$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G_2$$\\end{document} by counting the number of common subtrees up to height h. To avoid enumerating subtrees explicitly, a characteristic label is computed for each subtree. This label is constructed iteratively: each iteration i computes the label for the tree of height i rooted in each node v (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathtt {label}(i,v)$$\\end{document}). Iteration 0 (line 11) uses the original labels in the graph. Then, each iteration i (lines 14\u201321) assigns a label to each vertex v by combining the labels of v and its adjacent vertices in iteration \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i-1$$\\end{document}. Finally, the distance between the pair of graphs is computed by counting the original labels (line 12) and the labels for subtrees up to height h (line 22) and comparing their frequencies (lines 4\u20136). The complexity of this procedure is O(hm), with m being the number of edges in the graphs [22]. The parameter h allows us to control the trade-off between performance and precision.",
            "cite_spans": [
                {
                    "start": 2065,
                    "end": 2067,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Graph Kernels",
            "ref_spans": []
        },
        {
            "text": "Notice that thanks to how our graph abstraction process is defined (types and attribute values as labels), the similarity value computed by the kernel is implicitly taking advantage of topological, type and attribute value information from the instance.\n",
            "cite_spans": [],
            "section": "Graph Kernels",
            "ref_spans": []
        },
        {
            "text": "Clustering is one of the fundamental tasks in the field of Machine Learning (ML). Intuitively, it consists in the analysis of a collection of elements to identify groups of similar individuals, for a given definition of \u201csimilarity\u201d.",
            "cite_spans": [],
            "section": "Clustering",
            "ref_spans": []
        },
        {
            "text": "Algorithm Selection. Several algorithms have been proposed for this task [29]. There is no single \u201cbest\u201d clustering algorithm: the most suitable one depends on the collection being analyzed. This is because the strategies for finding clusters can be very different. For example, means and medoids are different definitions of the \u201ccenter\u201d of a cluster, and algorithms like K-means and K-medoids aim to find the best location for those centers. On the other hand, methods like hierarchical clustering initially consider each element as a cluster and then iteratively merge the two nearest clusters.",
            "cite_spans": [
                {
                    "start": 74,
                    "end": 76,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Clustering",
            "ref_spans": []
        },
        {
            "text": "In order to select which clustering algorithm should be used, the required input information should be considered:Feature versus Kernel methods: Some algorithms like K-means require each element to be described by a vector of features (relevant characteristics) of a fixed length. Meanwhile, other algorithms like hierarchical clustering only require a distance (or similarity) measure among pairs of elements.Target number of clusters: Algorithms like K-means or K-medoids require knowing the target number of clusters a priori. Conversely, algorithms like hierarchical clustering do not require this information beforehand.\n",
            "cite_spans": [],
            "section": "Clustering",
            "ref_spans": []
        },
        {
            "text": "In our context, the elements we are trying to cluster are labeled graphs abstracting the outputs of a model finder. The number of target clusters is unknown a priori and, as discussed in the previous section, we will be using a similarity metric. Given this setting, we have chosen hierarchical clustering.",
            "cite_spans": [],
            "section": "Clustering",
            "ref_spans": []
        },
        {
            "text": "Choice of Number of Clusters. Hierarchical clustering computes a hierarchical structure called dendogram, a tree that describes the order in which clusters should be merged according to their similarity. A clustering is obtained when we decide where (in which level of the tree) the merging should stop. In order to decide that, we can use cluster validity indices, metrics that measure the quality of a clustering. In a good clustering, elements within a cluster should be very similar and very dissimilar to elements in other clusters. The metric is evaluated in each level of the tree and the clustering providing the optimal value is selected.",
            "cite_spans": [],
            "section": "Clustering",
            "ref_spans": []
        },
        {
            "text": "In this work, we have used the silhouette coefficient [19], a classical metric that measures the average distance to elements in the same cluster compared to the minimum of the average distances to elements in other clusters. It provides a value in the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$[-1,1]$$\\end{document} range (higher is better), where values below 0.5 signal a bad fit in the clustering. As mentioned previously, the clustering achieving the highest average silhouette width is selected as our output.",
            "cite_spans": [
                {
                    "start": 55,
                    "end": 57,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Clustering",
            "ref_spans": []
        },
        {
            "text": "In order to assess the computational effort of the proposed method and the usefulness of its output, we have performed several experiments. These experiments aim to answer the following research questions:RQ1. How does the execution time of the method compare to model finding?RQ2. Do the resulting clusters provide a concise yet diverse summary of the model finder output?Experiment Design. We have analyzed a collection of Alloy models provided in the Alloy GitHub model repository3. Among them, we have chosen examples dealing with the generation of examples or counterexamples, rather than proving their absence. These type of models could be used for validation and testing, and thus they are the target of the proposed method. For these models, we have used the Alloy Analyzer to generate up to 100 instances (less if there are not enough valid instances available). Table 1 provides information about the size and complexity of these models: the number of signatures (Sig), fields (Fields), facts (Fact) and predicates (Pred) in each Alloy model.\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": [
                {
                    "start": 879,
                    "end": 880,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Implementation. We have implemented our method as two separate components. First, we have developed a Java program that calls the latest version of the Alloy API (5.0.0) to compute a collection of instances and generate their graph abstraction. The output of this tool is stored as a set of files in GML format. Then, a R script reads the GML files, computes the graph kernel and performs the clustering. This script takes advantage of existing libraries for representing graphs (the igraph package4), similarity analysis among graphs (the graphkernels package5) and clustering (the cluster package6).",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "The experiments have been performed on a quad-core Intel i5-760 2.8 GHz with 4 GB of RAM. On the software side, we have used Java 9.0.4 64 bits and R 3.50 64 bits. With respect to the settings, Alloy has used MiniSat as the SAT solver back-end with the highest amount of symmetry breaking (symmetry=20). Regarding the graph kernel, the Weisfeiler-Lehman graph kernel has been used with the default number of iterations (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$h=5$$\\end{document}).",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "Execution times have been measured in each step of the computation: the Alloy analysis, the graph abstraction phase and the kernel and clustering phases.\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "Results and Discussion. Table 2 shows, for each experiment, the scope used in the analysis (Scope) and the number of computed instances (Inst). Notice that for two models there were less than 100 satisfying instances. Then, we describe the time (in milliseconds) required by Alloy to compute the instances (Model finding), compared to the time taken by the different steps of our method: graph abstraction (Abst), graph kernel (Kern) and clustering (Clust). The total time for the three steps is reported as well. Finally, we list the optimal number of clusters (# Cl) identified by our method and the silhouette coefficient (Sil). As mentioned in Sect. 5, the silhouette is a value in the [\u22121,+1] range that estimates the quality of the clustering (higher is better).",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": [
                {
                    "start": 30,
                    "end": 31,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "Considering these results, regarding RQ1 (efficiency) the execution time of the method is always below 0.5 seconds and less than the time required by Alloy to compute the instances. This was somewhat expected, as the computational effort of our approach depends on the number of instances and their size, but it is unaffected by the hardness of finding instances, the decisive factor in Alloy\u2019s execution time. Therefore, we can conclude that using our approach does not incur in a significant overhead with respect to using the model finder.",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "With respect to the scalability of our approach, let us consider the computational complexity of our method. We consider two parameters in this analysis: n, the number of instances that will be computed by the model finder; and m, the size (number of atoms, tuples in the relation and witnesses) of an instance. Graph abstraction performs a traversal of the instance, requiring O(m) time. The graph kernel takes O(m) time for each comparison and performs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n^2)$$\\end{document} comparisons, so in total it requires \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m \\cdot n^2)$$\\end{document}. Finally, clustering requires \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n^3)$$\\end{document} time, so the overall complexity is \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m \\cdot n^2 + n^3)$$\\end{document}. In terms of space complexity, we require \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m \\cdot n)$$\\end{document} to store the n graphs, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n^2)$$\\end{document} to store the similarity matrix and perform clustering, that is, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m \\cdot n + n^2)$$\\end{document} in total.",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "Regarding RQ2 (quality of the output) we can see that the proposed number of clusters varies significantly from one model to another, and so does the silhouette coefficient:Models with a high silhouette (e.g., file-system and grandpa) exhibit some sort of symmetry that is not being detected by the Alloy Analyzer. For instance, in file-system there is a symmetry between directory names, so in practice, it is as if Alloy was only returning the same 3 effective instances all the time. Models like this one are the scenarios where our approach is most effective.Models with a low number of clusters and a low silhouette (e.g., flip-flop) highlight scenarios where all instances are very similar. For instance, in flip-flop the instance models 10 steps of a trace in the evolution of a flip-flop. All these traces are very similar, so no salient features can be used to classify them. Diversity can only be slightly improved for these scenarios.Models with a high number of clusters (e.g., genealogy or railway) describe scenarios where the instances produced by the solver are already very dissimilar among them. In this case, the output of the solver was already diverse before applying our method.The rest of models, with an average silhouette between (0.4\u20130.7) illustrate a middle ground: some instances share similarities but the boundaries between each group may overlap or be hard to establish. Choosing a representative from each cluster ensures diversity, but there is the risk (higher for lower silhouette values) of discarding relevant instances. To reduce this risk, it would be possible to select a higher number of representatives per cluster.\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "To sum up, our method can reduce the number of instances to consider while preserving diversity. Furthermore, this method provides an estimate of the quality of its result that helps designers deciding when and how to employ it.",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "Several works have considered how to improve the diversity in the output of model finders, e.g., [6, 9, 11, 20, 23, 26]. We will classify them according to two criteria: (i) how diversity is specified by the designer and (ii) how it is achieved.",
            "cite_spans": [
                {
                    "start": 98,
                    "end": 99,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 101,
                    "end": 102,
                    "mention": "9",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 104,
                    "end": 106,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 108,
                    "end": 110,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 112,
                    "end": 114,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 116,
                    "end": 118,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "We exclude from this discussion all methods designed for general-purpose solvers [5, 15, 25], as they have not been used within model finders and they consider diversity at a lower level of abstraction (e.g., assignments to a boolean formula) where some model-level similarities may be lost (e.g., isomorphic instances with different bit-vector representations are still equivalent). For instance, a related software engineering problem that relies on low-level constraint solvers is finding valid configurations in a software product line. In this context, it has been shown [18] that SAT solvers designed for uniform sampling (i.e., computing satisfying assignments that are distributed as close as possible to a uniform distribution) do not achieve a uniform distribution in the set of computed configurations.",
            "cite_spans": [
                {
                    "start": 82,
                    "end": 83,
                    "mention": "5",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 85,
                    "end": 87,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 89,
                    "end": 91,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 577,
                    "end": 579,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Definition of Diversity. The designer has different ways to specify the desired notion of diversity. Some methods [6, 23] need to be given a probability distribution that the output instances should follow. Otherwise, the designer can partition the universe of instances by defining predicates called classifying terms [9]. For instance, for an attribute the designer may only be interested in its sign (positive, negative or zero), defining 3 partitions. Diversity is then achieved by finding instances that cover each partition.",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 116,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 118,
                    "end": 120,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 320,
                    "end": 321,
                    "mention": "9",
                    "ref_id": "BIBREF28"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Meanwhile, other methods such as [11, 26] or the one proposed in this paper do not require any input from the designer: diversity is defined implicitly by ensuring non-equivalence or enforcing some distance metric between the output instances. Nevertheless, in our case, the designer has some degree of control over the desired type of diversity by adapting the graph abstraction process, as explained in Sect. 3.",
            "cite_spans": [
                {
                    "start": 34,
                    "end": 36,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 38,
                    "end": 40,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Implementation of Diversity. Most methods operate inside the model finder, reducing the number of instances being computed in different ways.",
            "cite_spans": [],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Some techniques aim to automatically detect equivalent solutions during the analysis in order to avoid exploring them. In the context of boolean satisfiability (SAT), SAT-Modulo Theories (SMT) and Constraint Programming (CP) this notion is called symmetry breaking [3, 10] and it is achieved by including additional constraints a priori. These constraints can also be added dynamically each time a new instance is found [9, 23], to forbid exploring equivalent instances in the future. Another way to avoid exploring equivalent instances is requiring the solution to be minimal [2, 4, 16].",
            "cite_spans": [
                {
                    "start": 266,
                    "end": 267,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 269,
                    "end": 271,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 421,
                    "end": 422,
                    "mention": "9",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 424,
                    "end": 426,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 578,
                    "end": 579,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 581,
                    "end": 582,
                    "mention": "4",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 584,
                    "end": 586,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "In search-based methods like genetic algorithms [2] or simulated annealing [4], similarity among solutions can be detected through a distance measure: neighbors that are too close to previously explored solutions can be ignored. Similarly, in graph solvers graph shape analysis [20, 21] can detect equivalent or similar graphs. Nevertheless, this approach does not support features like attributes, relations or witnesses like the approach presented in this paper.",
            "cite_spans": [
                {
                    "start": 49,
                    "end": 50,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 76,
                    "end": 77,
                    "mention": "4",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 279,
                    "end": 281,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 283,
                    "end": 285,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Moreover, model finders can introduce randomness [6], such as random selection of the next value to be explored or random restarts that can help explore different areas of the search space. Another take on randomness, randomized partitioning [11], shares the goal of classifying terms (partitioning the solution space) but generates the partitions by randomly splitting the domains of model elements. While this approach may be successful in problems with simple and local constraints, it is ineffective when dealing with complex constraints.",
            "cite_spans": [
                {
                    "start": 50,
                    "end": 51,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 243,
                    "end": 245,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Finally, the COMODI tool [6] provides several techniques for clustering the object diagrams produced by a UML/OCL model finder. First, it defines a feature vector encoding for object diagrams that captures, for each object, information about attribute values and adjacent objects. And second, it defines a centrality metric (similar to the pagerank algorithm of search engines) that measures the importance of each object within the object diagram. Compared to our method, this approach is specific for object diagrams: it cannot deal with features from other modeling notations, such as Alloy\u2019s relations or witnesses. Furthermore, the proposed similarity metrics do not consider information about types, structure and attribute values simultaneously: the centrality metric omits attribute values entirely; and the feature vector approach does not consider topological information about the structure of the object diagram.",
            "cite_spans": [
                {
                    "start": 26,
                    "end": 27,
                    "mention": "6",
                    "ref_id": "BIBREF25"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "We have presented a method for addressing the lack of diversity among the instances computed by a model finder. Our approach uses clustering to group instances according to their similarity, using information both about topology, types and attribute. The method is solver- and notation-agnostic: it can be applied to model finders using different types of solvers (e.g., SAT, SMT or CP) and even targeting different modeling notations (e.g., UML/OCL or Alloy).",
            "cite_spans": [],
            "section": "Conclusions",
            "ref_spans": []
        },
        {
            "text": "This approach is capable of computing meaningful clusters and has an execution time that is negligible with respect to that of the model finder itself. Still, as our diversity computation is an a posteriori procedure, it is intended for validation and testing scenarios where model finders are able to find instance solutions with relative ease. In this sense, our approach does not increase the diversity of the model finder output. However, it maximizes diversity by selecting, on behalf of the user, the widest possible variation among the output set.",
            "cite_spans": [],
            "section": "Conclusions",
            "ref_spans": []
        },
        {
            "text": "As future work, we plan to define custom kernels for comparing instances that take into account specific characteristics of the input model. For instance, the invariants and multiplicities in the model can be used to identify which model elements are more constrained: this is where diversity is most relevant, rather than elements where we are free to choose almost any value. Also, we plan to look into combining graph kernels with topological and label features [13] that can improve the quality of the similarity analysis. Finally, we will consider strategies for tailoring the graph abstraction to particular problems and domains.",
            "cite_spans": [
                {
                    "start": 466,
                    "end": 468,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Conclusions",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Summary of the models analyzed with the Alloy Analyzer.\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Experimental results.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Overview of the method presented in this paper.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Motivating example: (a) UML/OCL class diagram; (b) Sample instance; (c) Encoding of the instance as a labeled graph; (d) Graph shapes of the three clusters.",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Example of graph abstraction: (a) Alloy model; (b) Alloy snapshot in textual format; (c) Alloy snapshot depicted graphically; (d) Abstracted graph.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "Extensive validation of OCL models by integrating SAT solving into USE",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kuhlmann",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Hamann",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gogolla",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Objects, Models, Components, Patterns",
            "volume": "",
            "issn": "",
            "pages": "290-306",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Effective graph classification based on topological and label attributes",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Semerci",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Yener",
                    "suffix": ""
                },
                {
                    "first": "MJ",
                    "middle": [],
                    "last": "Zaki",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Stat. Anal. Data Mining",
            "volume": "5",
            "issn": "4",
            "pages": "265-283",
            "other_ids": {
                "DOI": [
                    "10.1002/sam.11153"
                ]
            }
        },
        "BIBREF5": {
            "title": "Uniform random generation of huge metamodel instances",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Mougenot",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Darrasse",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Blanc",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Soria",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Model Driven Architecture - Foundations and Applications",
            "volume": "",
            "issn": "",
            "pages": "130-145",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "Generating diverse solutions in SAT",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Nadel",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Theory and Applications of Satisfiability Testing - SAT 2011",
            "volume": "",
            "issn": "",
            "pages": "287-301",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Silhouettes: a graphical aid to the interpretation and validation of cluster analysis",
            "authors": [
                {
                    "first": "PJ",
                    "middle": [],
                    "last": "Rousseeuw",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "J. Comput. Appl. Math.",
            "volume": "20",
            "issn": "1",
            "pages": "53-65",
            "other_ids": {
                "DOI": [
                    "10.1016/0377-0427(87)90125-7"
                ]
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "Iterative generation of diverse models for testing specifications of DSL tools",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Semer\u00e1th",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Varr\u00f3",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Fundamental Approaches to Software Engineering",
            "volume": "",
            "issn": "",
            "pages": "227-245",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "Towards the automated generation of consistent, diverse, scalable and realistic graph models",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Varr\u00f3",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Semer\u00e1th",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Sz\u00e1rnyas",
                    "suffix": ""
                },
                {
                    "first": "\u00c1",
                    "middle": [],
                    "last": "Horv\u00e1th",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Graph Transformation, Specifications, and Nets",
            "volume": "",
            "issn": "",
            "pages": "285-312",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "MaxUSE: a tool for finding achievable constraints and conflicts for inconsistent UML class diagrams",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Integrated Formal Methods",
            "volume": "",
            "issn": "",
            "pages": "348-356",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF27": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF28": {
            "title": "Testing models and model transformations using classifying terms",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Hilken",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gogolla",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Burgue\u00f1o",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Vallecillo",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Softw. Syst. Modeling",
            "volume": "17",
            "issn": "3",
            "pages": "885-912",
            "other_ids": {
                "DOI": [
                    "10.1007/s10270-016-0568-3"
                ]
            }
        }
    }
}