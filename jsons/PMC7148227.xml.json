{
    "paper_id": "PMC7148227",
    "metadata": {
        "title": "Learning Based Methods for Code Runtime Complexity Prediction",
        "authors": [
            {
                "first": "Joemon",
                "middle": [
                    "M."
                ],
                "last": "Jose",
                "suffix": "",
                "email": "joemon.jose@glasgow.ac.uk",
                "affiliation": {}
            },
            {
                "first": "Emine",
                "middle": [],
                "last": "Yilmaz",
                "suffix": "",
                "email": "emine.yilmaz@ucl.ac.uk",
                "affiliation": {}
            },
            {
                "first": "Jo\u00e3o",
                "middle": [],
                "last": "Magalh\u00e3es",
                "suffix": "",
                "email": "jm.magalhaes@fct.unl.pt",
                "affiliation": {}
            },
            {
                "first": "Pablo",
                "middle": [],
                "last": "Castells",
                "suffix": "",
                "email": "pablo.castells@uam.es",
                "affiliation": {}
            },
            {
                "first": "Nicola",
                "middle": [],
                "last": "Ferro",
                "suffix": "",
                "email": "ferro@dei.unipd.it",
                "affiliation": {}
            },
            {
                "first": "M\u00e1rio",
                "middle": [
                    "J."
                ],
                "last": "Silva",
                "suffix": "",
                "email": "mjs@inesc-id.pt",
                "affiliation": {}
            },
            {
                "first": "Fl\u00e1vio",
                "middle": [],
                "last": "Martins",
                "suffix": "",
                "email": "flaviomartins@acm.org",
                "affiliation": {}
            },
            {
                "first": "Jagriti",
                "middle": [],
                "last": "Sikka",
                "suffix": "",
                "email": "jsikka@adobe.com",
                "affiliation": {}
            },
            {
                "first": "Kushal",
                "middle": [],
                "last": "Satya",
                "suffix": "",
                "email": "satya@adobe.com",
                "affiliation": {}
            },
            {
                "first": "Yaman",
                "middle": [],
                "last": "Kumar",
                "suffix": "",
                "email": "ykumar@adobe.com",
                "affiliation": {}
            },
            {
                "first": "Shagun",
                "middle": [],
                "last": "Uppal",
                "suffix": "",
                "email": "shagun16088@iiitd.ac.in",
                "affiliation": {}
            },
            {
                "first": "Rajiv",
                "middle": [
                    "Ratn"
                ],
                "last": "Shah",
                "suffix": "",
                "email": "rajivratn@iiitd.ac.in",
                "affiliation": {}
            },
            {
                "first": "Roger",
                "middle": [],
                "last": "Zimmermann",
                "suffix": "",
                "email": "rogerz@comp.nus.edu.sg",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Time Complexity computation is a crucial aspect in the study and design of well-structured and computationally efficient algorithms. It is a measure of the performance of a solution for a given problem. As a popular mistaken consideration, it is not the execution time of a code. Execution time depends upon a number of factors such as the operating system, hardware, processors etc. Since execution time is machine dependent, it is not used as a standard measure to analyze the efficiency of algorithms. Formally, Time Complexity quantifies the amount of time taken by an algorithm to process as a function of the input. For a given algorithm, we consider its worst case complexity, which reflects the maximum time required to process it, given an input. Time complexity is represented in Big O notation, i.e., O(n) denotes the asymptotic linear upper bound of an algorithm as a function of the input size n. Typically, the complexity classes in Computer Science refer to P and NP classes of decision problems, however, for the entire length of this paper, complexity class refers to a category of time complexity. The commonly considered categories in computer science as well in our work are O(1), O(logn), O(n), O(nlogn) and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n^2)$$\\end{document}.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this work, we try to predict the time complexity of a solution, given the code. This can have widespread applications, especially in the field of education. It can be used in automatic evaluation of code submissions on different online judges. It can also aid in static analyses, informing developers how optimized their code is, enabling more efficient development of industry level solutions.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Historically, there are a number of ways of predicting time complexity. For instance, master theorem [7] is effective to calculate run-time complexity of divide and conquer problems; but it is limited to only one type of problems and have several constraints on the permissible value of program\u2019s parameters.",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 103,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Mathematically speaking, it is impossible to find a universal function to compute the time complexity of all programs. Rice\u2019s theorem and other works in this area [1, 6] have established that it is impossible to formulate a single mathematical function that can calculate the complexity of all codes with polynomial order complexity.",
            "cite_spans": [
                {
                    "start": 164,
                    "end": 165,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 167,
                    "end": 168,
                    "mention": "6",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Therefore, we need a Machine Learning based solution which can learn the internal structure of the code effectively. Recent research in the areas of machine learning and deep learning for programming codes provide several potential approaches which can be extended to solve this problem [5, 13]. Also, several \u201cBig Code\u201d datasets have been made available publicly. The Public Git Archive is a dataset of a large collection of Github repositories [12, 16] and [15] are datasets of Question-code pairs mined from Stack Overflow. However, to the best of our knowledge, at the time of writing this paper, there is no existing public dataset that, given the source code, gives runtime complexity of the source code. In our work, we have tried to address this problem by creating a Code Runtime Complexity Dataset (CoRCoD) consisting of 932 code files belonging to 5 different classes of complexities, namely O(1), O(logn), O(n), O(nlogn) and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n^2)$$\\end{document} (see Table 1).",
            "cite_spans": [
                {
                    "start": 288,
                    "end": 289,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 291,
                    "end": 293,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 447,
                    "end": 449,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 451,
                    "end": 453,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 460,
                    "end": 462,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Introduction",
            "ref_spans": [
                {
                    "start": 1240,
                    "end": 1241,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "We aim to substantially explore and solve the problem of code runtime complexity prediction using machine learning with the following contributions:Releasing a novel annotated dataset of program codes with their runtime complexities.Proposing baselines of ML models with hand-engineered features and study of how these features affect the computational efficiency of the codes.Proposing another baseline, the generation of code embeddings from Abstract Syntax Tree of source codes to perform classification.\n",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Furthermore, we find that code embeddings have a comparable performance to hand-engineered features for classification using Support Vector Machines (SVMs). To the best of our knowledge, CoRCoD is the first public dataset for code runtime complexity, and this is the first work that uses Machine Learning for runtime complexity prediction.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The rest of this paper is structured as follows. In Sect. 3, we talk about dataset curation and its key characteristics. We experiment using two different baselines on the dataset: classification using hand engineered features extracted from code and using graph based methods to extract the code embeddings via Abstract Syntax Tree of code. Section 4 explains the details and key findings of these two approaches. In Sect. 5, we enumerate the results of our model and data ablation experiments performed on these two baselines.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In recent years, there has been extensive research in the deep learning community on programming codes. Hutter et al. [9] proposed supervised learning methods for algorithm runtime prediction. However, as explained before, execution time is not a standard measure to analyse efficiency of algorithms. Therefore, in our work, we do not consider algorithms\u2019 execution times. Most of the research in deep learning has been focused on two buckets, either on predicting some structure/attribute in the program or generating code snippets that are syntactically and/or semantically correct.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 120,
                    "mention": "9",
                    "ref_id": "BIBREF16"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Variable/Method name prediction is a widely attempted problem, wherein Allamanis et al. [3] used a convolutional neural network with attention technique to predict method names, Alon et al. [4] suggested the use of AST paths to be used as context for generating code embeddings and training classifiers on top of them. Yonai et al. [17] used call graphs to compute method embeddings and recommend names of existing methods with function similar to target function.",
            "cite_spans": [
                {
                    "start": 89,
                    "end": 90,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 191,
                    "end": 192,
                    "mention": "4",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 333,
                    "end": 335,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Another popular prediction problem is that of defect prediction, given a piece of code. Li et al. [11] used Abstract Syntax Trees of programs in their CNN for feature generation which were then used for defect prediction. A major goal in all these approaches is to come up with a representation of the source program, which effectively captures the syntactic and semantic features of the program. Chen and Monperrus [8] performed a survey on word embedding techniques used on source codes. However, so far, there has been no such work for predicting time complexity of programs using code embeddings. We have established the same as one of our baselines using graph2vec [13].",
            "cite_spans": [
                {
                    "start": 99,
                    "end": 101,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 417,
                    "end": 418,
                    "mention": "8",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 671,
                    "end": 673,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Srikant and Aggarwal [14] extract hand-engineered features from Control Flow and Data Dependency graphs of programs such as number of nested loops, number of instances of if statements in a loop etc. for automatic grading of programs. They then used the grading criteria, that correct test programs would have similar programming constructs/features as those in the correct hand-graded programs. We use the same idea of identifying key features as the other baseline, which are constructs that a human evaluator would look at, to compute complexity and use them to train the classification models. Though, unlike [14], our features are problem independent. Moreover, the solution in [14] is commercially deployed, and thus, their dataset is not publicly available.",
            "cite_spans": [
                {
                    "start": 22,
                    "end": 24,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 614,
                    "end": 616,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 684,
                    "end": 686,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "To construct our dataset, we collected source codes of different problems from Codeforces1. Codeforces is a platform that regularly hosts programming contests. The large availability of contests having a wide variety of problems both in terms of data structures and algorithms as well as runtime complexity, made Codeforces a viable choice for our dataset.\n\n",
            "cite_spans": [],
            "section": "Dataset",
            "ref_spans": []
        },
        {
            "text": "For the purpose of construction of our dataset, we collected Java source codes from Codeforces. We used the Codeforces API to retrieve problem and contest information, and further used web scraping to download the solution source codes. Sampling of source codes is done on the basis of data structure/algorithm tags associated with the problem, e.g., binary search, sorting etc. to ensure that the dataset contains source codes belonging to different complexity classes.",
            "cite_spans": [],
            "section": "Dataset",
            "ref_spans": []
        },
        {
            "text": "In order to ensure correctness of evaluated runtime complexity, the source codes selected should be devoid of issues such as compilation errors and segmentation faults. To meet this criterion, we filtered the source codes on the basis of their verdict and only selected the codes having verdicts Accepted or Time limit exceeded (TLE). For codes having TLE verdict, we ensured accuracy of solutions by only selecting codes that successfully passed at least four Test Cases. This criterion also allowed us to include multiple solutions for a single problem, different solutions having different runtime complexities. These codes were then manually annotated by a group of five experts, hailing from programming background each with a bachelor\u2019s degree in Computer Science. Each code was analyzed and annotated by two experts, in order to minimize the potential for error. Since calculating time complexity of a program comprises well-defined steps, inter-annotator agreement in our case was \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$100\\%$$\\end{document} (Cohen\u2019s kappa coefficient was 1). Only the order of complexity was recorded, for example, a solution having two variable inputs, n and m, and having a runtime complexity of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n*m)$$\\end{document} is labeled as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n\\_square$$\\end{document} (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O({n}^2)$$\\end{document}).",
            "cite_spans": [],
            "section": "Dataset",
            "ref_spans": []
        },
        {
            "text": "Certain agreed upon rules were followed for the annotation process. The rationale lies in the underlying implementations of these data structures in Java. Following points list down the rules followed for annotation and the corresponding rationale:Sorting algorithm\u2019s implementation in Java collections has worst case complexity O(nlogn).Insertion/retrieval in HashSet and HashMap is annotated to be O(1), given n elements.TreeSet and TreeMap are implemented as Red-Black trees and thus have O(logn) complexity for insertion/retrieval.\n",
            "cite_spans": [],
            "section": "Dataset",
            "ref_spans": []
        },
        {
            "text": "We removed few classes with insufficient data points, and ended up with 932 source codes, 5 complexity classes, corresponding annotation and extracted features. We selected nearly 400 problems from 170 contests, picking an average of 3 problems per contest. For 120 of these problems, we collected 4\u20135 different solutions, with different complexities.",
            "cite_spans": [],
            "section": "Dataset",
            "ref_spans": []
        },
        {
            "text": "In order to increase the size of the dataset for future work, we have created an online portal with an easy-to-use interface where contributors can upload source code and its complexity. Developers can also check the time complexity of a program predicted by our models.2\n",
            "cite_spans": [],
            "section": "Dataset",
            "ref_spans": []
        },
        {
            "text": "Feature Extraction. We identified key coding constructs and extracted 28 features, some of them are listed in Table 2. Our feature set is inspired from [14]. We used two types of features for our feature set, basic features were obtained by counting occurrences of keywords represeting fundamental programming constructs, and sequence features captured key sequences generally present in the program, e.g. Loop-Conditional frequency captured number of If statements present inside loops in the program. We extracted these features from the Abstract Syntax Tree (AST) of source codes. AST is a tree representation of syntax rules of a programming language. ASTs are used by compilers to check codes for accuracy. We used Eclipse JDT for feature extraction. A generic representation of AST as parsed by ASTParser in JDT is shown in Fig. 1.\n",
            "cite_spans": [
                {
                    "start": 153,
                    "end": 155,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Feature Engineering ::: Solution Approach",
            "ref_spans": [
                {
                    "start": 835,
                    "end": 836,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 116,
                    "end": 117,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "An ASTParser object creates the AST, and the ASTVisitor object \u201cvisits\u201d the nodes of the tree via visit and endVisit methods using Depth First Search. One of the features chosen was the maximum depth of nested loops. Code snippet (Listing 1) depicts how the value of depth of nested loops was calculated using ASTVisitor provided by JDT. Other features were calculated in a similar manner.",
            "cite_spans": [],
            "section": "Feature Engineering ::: Solution Approach",
            "ref_spans": []
        },
        {
            "text": "We observed that our code samples often had unused code like methods or class implementations never invoked from the main function. Removing such unused code manually from each code sample is tedious. Instead, we used JDT plugins to identify the methods reachable from main function and used those methods for extracting the listed features. The same technique was also used while creating the AST for the next baseline.\n",
            "cite_spans": [],
            "section": "Feature Engineering ::: Solution Approach",
            "ref_spans": []
        },
        {
            "text": "Figure 2 represents the density distribution of features across different classes. For nested loops, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n\\_square$$\\end{document} has peak at depth 2 as expected; similarly n and nlogn have peak at depth 1 loop depth (see Fig. 2(a)). For number of loops (see Fig. 2(b)), we find that the mean value of the number of loops in code increases with the increase in complexity. On qualitative analysis, we find out that in case of O(n) complexity, one loop is being used in code for processing the inputs and the other loop is being used for computing the solution to the problem. As we move towards \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n\\_square)$$\\end{document} codes, there is often one nested loop in the code and one loop is being used for input processing. Hence, it has a peak centered at a frequency of 3. This confirms our intuition that number of loops and nested loops are important parameters in complexity computation.",
            "cite_spans": [],
            "section": "Feature Engineering ::: Solution Approach",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 493,
                    "end": 494,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 530,
                    "end": 531,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "The Abstract Syntax Tree of a program captures comprehensive information regarding a program\u2019s structure, syntactic and semantic relationships between variables and methods. An effective method to incorporate this information is to compute code embeddings from the program\u2019s AST. An AST is infact a graph and thus using graph based methods for computing code embeddings was the right approach. We used graph2vec, a neural embedding framework [13], which can be used to compute embeddings for any generic graph. Graph2vec automatically generates task agnostic embeddings, and does not require a large corpus of data, making it apt for our problem. We used the graph2vec implementation from [2] to compute code embeddings.",
            "cite_spans": [
                {
                    "start": 443,
                    "end": 445,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 690,
                    "end": 691,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Code Embeddings ::: Solution Approach",
            "ref_spans": []
        },
        {
            "text": "Graph2vec is analogous to doc2vec [10] which predicts a document embedding given the sequence of words in it. The goal of graph2vec is, given a set of graphs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {G} = \\{G_1, G_2, ... G_n\\}$$\\end{document}, learn a \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta $$\\end{document}-dimensional embedding vector for each graph. Here, each graph G is represented as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(N,E,\\lambda )$$\\end{document} where N are the nodes of the graph, E the edges and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\lambda $$\\end{document} represents a function \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n \\rightarrow l$$\\end{document} which assigns a unique label from alphabet l to every node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n \\in N$$\\end{document}. To achieve the same, graph2vec extracts nonlinear substructures, more specifically, rooted subgraphs from each graph which are analogical to words in doc2vec. It uses skipgram model for learning graph embeddings which correspond to code embeddings in our scenario. The model works by considering a subgraph \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s_j \\in c(g_i)$$\\end{document} to be occurring in the context of graph \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g_i$$\\end{document} and tries to maximize the log likelihood in Eq. 1:1\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\sum _{j=1}^{D} log \\; Pr({s_j}|{g_i}) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c(g_i)$$\\end{document} gives all subgraphs of a graph \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g_i$$\\end{document} and D is the total number of subgraphs in the entire graph corpus.",
            "cite_spans": [
                {
                    "start": 35,
                    "end": 37,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Code Embeddings ::: Solution Approach",
            "ref_spans": []
        },
        {
            "text": "We extracted AST from all codes using the JDT plugins. Each node in AST has two attributes: a Node Type and an optional Node Value. For e.g., a MethodDeclaration Type node will have the declared function name as the node value. Graph2vec expects each node to have a single label. To get a single label, we followed two different representations: Concatenating Node Type and Node Value.Choosing selectively for each type of node whether to include node type or node value. For instance, every identifier node has a SimpleName node as its child. For all such nodes, only node value i.e. identifier name was considered as the label.\n",
            "cite_spans": [],
            "section": "Code Embeddings ::: Solution Approach",
            "ref_spans": []
        },
        {
            "text": "For both the AST representations, we used graph2vec to generate 1024-dimensional code embeddings. These embeddings were further used to train SVM based classification model and several experiments were performed as discussed in the next section.",
            "cite_spans": [],
            "section": "Code Embeddings ::: Solution Approach",
            "ref_spans": []
        },
        {
            "text": "Deep Learning (DL) algorithms tend to improve their performance with the amount of data available unlike classical machine learning algorithms. With lesser amount of data and correctly hand engineered features, Machine Learning (ML) methods outperform many DL models. Moreover, the former are computationally less expensive as compared to the latter. Therefore, we choose traditional ML classification algorithms to verify the impact of various features present in programming codes on their runtime complexities. We also perform a similar analysis on a simple Multi level Perceptron (MLP) classifier and compare against others. Table 3 depicts the accuracy score, weighted precision, recall and F1-score values for this classification task using 8 different algorithms, with the best accuracy score achieved using the ensemble approach of random forests.\n\n",
            "cite_spans": [],
            "section": "Feature Engineering ::: Experiments and Results",
            "ref_spans": [
                {
                    "start": 635,
                    "end": 636,
                    "mention": "3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "Further, as per Table 4 showing per-feature-analysis, we distinctly make out that for the collected dataset, the most prominent feature which solely gives maximum accuracy is nested loop depth, followed by loops. Tables 5 and 6 demarcate the difference between accuracy scores considering data samples from classes O(1), O(n), \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O{(n}^2)$$\\end{document} as compared to classes O(1), O(logn), O(nlogn). A clear increment in accuracy scores is noticed amongst all the algorithms considered for the classification task for both sets of 3 classes as compared to the set of 5 classes except MLP classifier.",
            "cite_spans": [],
            "section": "Feature Engineering ::: Experiments and Results",
            "ref_spans": [
                {
                    "start": 22,
                    "end": 23,
                    "mention": "4",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 220,
                    "end": 221,
                    "mention": "5",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 226,
                    "end": 227,
                    "mention": "6",
                    "ref_id": "TABREF5"
                }
            ]
        },
        {
            "text": "We extracted ASTs from source codes, computed 1024-dimensional code embeddings from ASTs using graph2vec and trained an SVM classifier on these embeddings. Results are tabulated in Table 7. We note that the average accuracy obtained for SVM on code embeddings is greater than that of SVM on hand-engineered features. Also, average precision and recall is higher for code embedding model. We performed statistical significance tests on results of 100 different runs of the two algorithms on the dataset. We observed that the data distribution was non-Gaussian and thus we used the Kolmogorov-Smirnov test. The p-value of the test for 100 different experimental precision scores for each algorithm was found to be 1.02\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e-$$\\end{document}13 while for recall, it was 4.52\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e-$$\\end{document}17. Thus, we established that the difference in precision and recall results from the two experiments is statistically significant and the code embeddings baseline has better precision and recall scores for both representations of AST.",
            "cite_spans": [],
            "section": "Code Embeddings ::: Experiments and Results",
            "ref_spans": [
                {
                    "start": 187,
                    "end": 188,
                    "mention": "7",
                    "ref_id": "TABREF6"
                }
            ]
        },
        {
            "text": "To get further insight into the learning framework, we performed following data ablation tests:",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Label Shuffling. Training models with shuffled class labels can indicate whether the model is learning useful features pertaining to the task at hand. If the performance does not significantly decrease upon shuffling, it can imply that the model is hanging on to statistical cues that do not contain meaningful information w.r.t. the problem.",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Method/Variable Name Alteration. Graph2vec uses node labels along with edge information to generate graph embeddings. Out of randomly selected 50 codes having correct prediction, if the predicted class labels before and after data ablation are different for a significant number of test samples, it would imply that the model relies on method/variable name tokens whereas it should only rely on the relationships between variables/methods.\n\n",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Replacing Input Variables with Constant Literals. Program complexity is a function of input variables. Thus, to test the robustness of models, we replace the input variables with constant values making resultant complexity O(1) for 50 randomly chosen codes, which earlier had non-constant complexity. A good model should have a higher percentage of codes with predicted complexity as O(1).",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Removing Graph Substructures. We randomly remove program elements such as for, if blocks with a probability of 0.1. The expectation is that the correctly predicted class labels should not change heavily as the complexity most likely does not change and hence a good model should have a higher percentage of codes with same correct label before and after removing graph substructures. This would imply that the model is robust to changes in code that do not change the resultant complexity.",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Following are our observations regarding data ablation results in Table 8:",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": [
                {
                    "start": 72,
                    "end": 73,
                    "mention": "8",
                    "ref_id": "TABREF7"
                }
            ]
        },
        {
            "text": "Label Shuffling. The drop in test performance is higher in graph2vec than that in the basic model indicating that graph2vec learns better features compared to simple statistical models.\n",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Method/Variable Name Alteration. Table 8 shows that SVM correctly classifies most of the test samples\u2019 embeddings upon altering method and variable names, implying that the embeddings generated do not rely heavily on the actual method/variable name tokens.",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": [
                {
                    "start": 39,
                    "end": 40,
                    "mention": "8",
                    "ref_id": "TABREF7"
                }
            ]
        },
        {
            "text": "Replacing Input Variables with Constant Literals. We see a significant and unexpected dip in accuracy, highlighting one of the limitations of our model.",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "Removing Graph Substructures. Higher accuracy for code embeddings as compared to feature engineering implies that the model must be learning the types of nodes and their effect on complexity to at least some extent, as removing substructures does not change the predicted complexity class of a program significantly.\n",
            "cite_spans": [],
            "section": "Data Ablation Experiments ::: Experiments and Results",
            "ref_spans": []
        },
        {
            "text": "The most pertinent limitation of our dataset is its size which is fairly small compared to what is considered standard today. Another limitation of our work is moderate accuracy of the models. An important point to note is that although we established that using code embeddings is a better approach, still their accuracy does not beat feature engineering significantly. One possible solution is to increase dataset size so that generated code embeddings can better model the characteristics of programs that differentiate them into multiple complexity classes, when trained on larger number of codes. However, generating a larger dataset is a challenging task since annotation process is tedious and needs people with a sound knowledge of algorithms. In order to increase the size of our dataset, we have created an online portal to crowd source the data. Lastly, we observe that replacing variables with constant literals does not change the prediction to O(1) which highlights the inability of graph2vec to identify the variable on which complexity depends.",
            "cite_spans": [],
            "section": "Limitations",
            "ref_spans": []
        },
        {
            "text": "Computational complexity is a quantification of computational efficiency. Computationally efficient programs better utilize resources and improve software performance. With rapid advancements, there is a growing demand for resources; at the same time, there is greater need for optimizing existing solutions. Thus, writing computationally efficient programs is an asset for both students and professionals. With this dataset, we aim to analyze attributes and capture relationships that best define the computational complexity of codes. We do so, not just by heuristically picking up evident features, but by investigating their role in the quality, structure and dynamics of the problem using ML paradigm. We also capture relationships between various programming constructs by generating code embeddings from Abstract Syntax Trees. This dataset can not only help automate the process of predicting complexities, but we plan on using the dataset to develop a feedback based recommendation system which can help learners decide apt features for well-structured and efficient codes. It can also be used to train models that can be further integrated with IDEs and assist professional developers in writing computationally efficient programs for fast performance software development.",
            "cite_spans": [],
            "section": "Usefulness of the Dataset",
            "ref_spans": []
        },
        {
            "text": "The dataset presented and the baseline models established should serve as guidelines for the future work in this area. The dataset presented is balanced and well-curated. Though both the baselines; Code Embeddings and Handcrafted features have comparable accuracy, we have established through data ablation tests that code embeddings learned from Abstract Syntax Tree of the code better capture relationships between different code constructs that are essential for predicting runtime complexity. Work can be done in future to increase the size of the dataset to verify our hypothesis that code embeddings will perform significantly better than hand crafted features. Moreover, we hope that the approaches discussed in this work, their usage becomes explicit for programmers and learners to bring into practice efficient and optimized codes.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Classwise data distribution\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Sample Extracted features\n",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3.: Accuracy Score, Precision and Recall values for different classification algorithms\n",
            "type": "table"
        },
        "TABREF3": {
            "text": "Table 4.: Per feature accuracy score, averaged over different classification algorithms.\n",
            "type": "table"
        },
        "TABREF4": {
            "text": "Table 5.: Accuracy, Precision and Recall values for different classification algorithms considering samples from complexity classes O(1), O(n) and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O{(n}^2)$$\\end{document}\n",
            "type": "table"
        },
        "TABREF5": {
            "text": "Table 6.: Accuracy, Precision and Recall values for different classification algorithms considering samples from complexity classes O(1), O(logn) and O(nlogn)\n",
            "type": "table"
        },
        "TABREF6": {
            "text": "Table 7.: Accuracy, Precision, Recall values for classification of graph2vec embeddings, with and without node type & node value concatenation in node label.\n",
            "type": "table"
        },
        "TABREF7": {
            "text": "Table 8.: Data Ablation Tests Accuracy of feature engineering and code embeddings (for two different AST representations) baselines\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Code Representation as an AST; being traversed by AST Parser",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Density plot for the different features",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Code2vec: learning distributed representations of code",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "Alon",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zilberstein",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Yahav",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proc. ACM Program. Lang.",
            "volume": "3",
            "issn": "POPL",
            "pages": "40:1-40:29",
            "other_ids": {
                "DOI": [
                    "10.1145/3290353"
                ]
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "A general method for solving divide-and-conquer recurrences",
            "authors": [
                {
                    "first": "JL",
                    "middle": [],
                    "last": "Bentley",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Haken",
                    "suffix": ""
                },
                {
                    "first": "JB",
                    "middle": [],
                    "last": "Saxe",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "SIGACT News",
            "volume": "12",
            "issn": "3",
            "pages": "36-44",
            "other_ids": {
                "DOI": [
                    "10.1145/1008861.1008865"
                ]
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}