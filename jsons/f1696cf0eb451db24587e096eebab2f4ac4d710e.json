{
    "paper_id": "f1696cf0eb451db24587e096eebab2f4ac4d710e",
    "metadata": {
        "title": "Data Centers Job Scheduling with Deep Reinforcement Learning",
        "authors": [
            {
                "first": "Sisheng",
                "middle": [],
                "last": "Liang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Texas Tech University",
                    "location": {
                        "settlement": "Lubbock",
                        "country": "USA"
                    }
                },
                "email": "sisheng.liang@ttu.edu"
            },
            {
                "first": "Zhou",
                "middle": [],
                "last": "Yang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Texas Tech University",
                    "location": {
                        "settlement": "Lubbock",
                        "country": "USA"
                    }
                },
                "email": "zhou.yang@ttu.edu"
            },
            {
                "first": "Yong",
                "middle": [],
                "last": "Chen",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Texas Tech University",
                    "location": {
                        "settlement": "Lubbock",
                        "country": "USA"
                    }
                },
                "email": "yong.chen@ttu.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "Efficient job scheduling on data centers under heterogeneous complexity is crucial but challenging since it involves the allocation of multi-dimensional resources over time and space. To adapt the complex computing environment in data centers, we proposed an innovative Advantage Actor-Critic (A2C) deep reinforcement learning based approach called A2cScheduler for job scheduling. A2cScheduler consists of two agents, one of which, dubbed the actor, is responsible for learning the scheduling policy automatically and the other one, the critic, reduces the estimation error. Unlike previous policy gradient approaches, A2cScheduler is designed to reduce the gradient estimation variance and to update parameters efficiently. We show that the A2cScheduler can achieve competitive scheduling performance using both simulated workloads and real data collected from an academic data center.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Job scheduling is a critical and challenging task for computer systems since it involves a complex allocation of limited resources such as CPU/GPU, memory and IO among numerous jobs. It is one of the major tasks of the scheduler in a computer system's Resource Management System (RMS), especially in highperformance computing (HPC) and cloud computing systems, where inefficient job scheduling may result in a significant waste of valuable computing resources. Data centers, including HPC systems and cloud computing systems, have become progressively more complex in their architecture [15] , configuration (e.g., special visualization nodes in a cluster) [6] and the size of work and workloads received [3] , all of which increase the job scheduling complexities sharply.",
            "cite_spans": [
                {
                    "start": 587,
                    "end": 591,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 657,
                    "end": 660,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 705,
                    "end": 708,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The undoubted importance of job scheduling has fueled interest in the scheduling algorithms on data centers. At present, the fundamental scheduling methodologies [18] , such as FCFS (first-come-first-serve), backfilling, and priority queues that are commonly deployed in data centers are extremely hard and time-consuming to configure, severely compromising system performance, flexibility and usability. To address this problem, several researchers have proposed data-driven machine learning methods that are capable of automatically learning the scheduling policies, thus reducing human interference to a minimum.",
            "cite_spans": [
                {
                    "start": 162,
                    "end": 166,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Specifically, a series of policy based deep reinforcement learning approaches have been proposed to manage CPU and memory for incoming jobs [10] , schedule time-critical workloads [8] , handle jobs with dependency [9] , and schedule data centers with hundreds of nodes [2] .",
            "cite_spans": [
                {
                    "start": 140,
                    "end": 144,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 180,
                    "end": 183,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 214,
                    "end": 217,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 269,
                    "end": 272,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Despite the extensive research into job scheduling, however, the increasing heterogeneity of the data being handled remains a challenge. These difficulties arise from multiple issues. First, policy gradient DRL method based scheduling method suffers from a high variance problem, which can lead to low accuracy when computing the gradient. Second, previous work has relied on used Monte Carlo (MC) method to update the parameters, which involved massive calculations, especially when there are large numbers of jobs in the trajectory.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To solve the above-mentioned challenges, we propose a policy-value based deep reinforcement learning scheduling method called A2cScheduler, which can satisfy the heterogeneous requirements from diverse users, improve the space exploration efficiency, and reduce the variance of the policy. A2cScheduler consists of two agents named actor and critic respectively, the actor is responsible for learning the scheduling policy and the critic reduces the estimation error. The approximate value function of the critic is incorporated as a baseline to reduce the variance of the actor, thus reducing the estimation variance considerably [14] . A2cScheduler updates parameters via the multi-step Temporal-difference (TD) method, which speeds up the training process markedly compared to conventional MC method due to the way TD method updates parameters. The main contributions are summarized as below:",
            "cite_spans": [
                {
                    "start": 631,
                    "end": 635,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "1. This represents the first time that A2C deep reinforcement has been successfully applied to a data center resource management, to the best of the authors' knowledge. 2. A2cScheduler updates parameters via multi-step Temporal-difference (TD) method which speeds up the training process comparing to MC method due to the way TD method updates parameters. This is critical for the real world data center scheduling application since jobs arrive in real time and low latency is undeniably important. 3. We tested the proposed approach on both real-world and simulated datasets, and results demonstrate that our proposed model outperformed many existing widely used methods.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Job Scheduling with Deep Reinforcement Learning . Recently, researchers have tried to apply deep reinforcement learning on cluster resources management. A resource manager DeepRM was proposed in [10] to manage CPU and memory for incoming jobs. The results show that policy based deep reinforcement learning outperforms the conventional job scheduling algorithms such as Short Job First and Tetris [4] . [8] improves the exploration efficiency by adding baseline guided actions for time-critical workload job scheduling. [17] discussed heuristic based method to coordinate disaster response. Mao proposed Decima in [9] which could handle jobs with dependency when graph embedding technique is utilized. [2] proved that policy gradient based deep reinforcement learning can be implemented to schedule data centers with hundreds of nodes.",
            "cite_spans": [
                {
                    "start": 195,
                    "end": 199,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 397,
                    "end": 400,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 403,
                    "end": 406,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 520,
                    "end": 524,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 614,
                    "end": 617,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 702,
                    "end": 705,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Related Work"
        },
        {
            "text": "Learning . Actor-critic algorithm is the most popular algorithm applied in the reinforcement learning framework [5] which falls into three categories: actor-only, critic-only and actor-critic methods [7] . Actorcritic methods combine the advantages of actor-only and critic-only methods. Actor-critic methods usually have good convergence properties, in contrast to critic-only [5] . At the core of several recent state-of-the-art Deep RL algorithms is the advantage actor-critic (A2C) algorithm [11] . In addition to learning a policy (actor) \u03c0(a|s; \u03b8), A2C learns a parameterized critic: an estimate of value function v \u03c0 (s), which then uses both to estimate the remaining return after k steps, and as a control variate (i.e. baseline) that reduces the variance of the return estimates [13] .",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 115,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 200,
                    "end": 203,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 378,
                    "end": 381,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 496,
                    "end": 500,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 789,
                    "end": 793,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Actor-Critic Reinforcement"
        },
        {
            "text": "In this section, we first review the framework of A2C deep reinforcement learning, and then explain how the proposed A2C based A2cScheduler works in the job scheduling on data centers. The rest part of this section covers the essential details about model training.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Method and Problem Formulation"
        },
        {
            "text": "The Advantage Actor-critic (A2C), which combines policy based method and value based method, can overcome the high variance problem from pure policy gradient approach. The A2C algorithm is composed of a policy \u03c0 (a t |s t ; \u03b8) and a value function V (s t ; w), where policy is generated by policy network and value is estimated by critic network. The proposed the A2cScheduler framework is shown in Fig. 1 , which consists of an actor network, a critic network and the cluster environment. The cluster environment includes a global queue, a backlog and the simulated machines. The queue is the place holding the waiting jobs. The backlog is an extension of the queue when there is not enough space for waiting jobs. Only jobs in the queue will be allocated in each state.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 399,
                    "end": 405,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "A2C in Job Scheduling"
        },
        {
            "text": "-Actor: The policy \u03c0 is an actor which generates probability for each possible action. \u03c0 is a mapping from state s t to action a t . Actor can choose a job from the queue based on the action probability generated by the policy \u03c0. For instance, given the action probability P = {p 1 , . . . , p N } for N actions, p i denotes the probability that action a i will be selected. If the action is chosen according to the maximum probability (action = arg max i\u2208[0,N ],i\u2208N + p i ), the actor acts greedily which limits the exploration of the agent. Exploration is allowed in this research. The policy is estimated by a neural network \u03c0(a|s, \u03b8), where a is an action, s is the state of the system and \u03b8 is the weights of the policy network. -Critic: A state-value function v(s) used to evaluate the performance of the actor. It is estimated by a neural networkv(s, w) in this research where s is the state and w is the weights of the value neural network. -State s t \u2208 S: A state s t is defined as the resources allocation status of the data center including the status of the cluster and the status of the queue at time t. The states S is a finite set. Figure 2 shows an example of the state in one time step. The state includes three parts: status of the resources allocated and the available resources in the cluster, resources requested by jobs in the queue, and status of the jobs waiting in the backlog. The scheduler will only schedules jobs in the queue. -Action a t \u2208 A: An action a t = {a t } N 1 denotes the allocation strategy of jobs waiting in the queue at time t, where N is the number of slots for waiting jobs in the queue. The action space A of an actor specifies all the possible allocations of jobs in the queue for the next iteration, which gives a set of N +1 discrete actions represented by {\u2205, 1, 2, . . . , N} where a t = i( \u2200i \u2208 {1, . . . , N}) means the allocation of the i th job in the queue and a t = \u2205 denotes a void action where no job is allocated.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1147,
                    "end": 1155,
                    "text": "Figure 2",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "The Setting of A2C"
        },
        {
            "text": "-Environment: The simulated data center contains resources such as CPUs, RAM and I/O. It also includes resource management queue system in which jobs are waiting to be allocated. -Discount Factor \u03b3: A discount factor \u03b3 is between 0 and 1, and is used to quantify the difference in importance between immediate rewards and future rewards. The smaller of \u03b3, the less importance of future rewards. -Transition function P : S \u00d7 A \u2192 [0, 1]: Transition function describes the probabilities of moving between current state to the next state. The state transition probability p(s t+1 |s t , a t ) represents the probability of transiting to s t+1 \u2208 S given a joint action a t \u2208 A is taken in the current state s t \u2208 S. -Reward function r \u2208 R = S \u00d7 A \u2192 (\u2212\u221e, +\u221e): A reward in the data center scheduling problem is defined as the feedback from the environment An example of the tensor representation of a state. At each iteration, the decision combination of number of jobs will be scheduled is 2 T otal jobs , which has exponential growth rate. We simplify the case by selecting a decision from decision domain = {0, 1, . . . , N}, where N is a fixed hyper-parameter, decision = i denotes select i th job, and decision = 0 denotes no job will be selected.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Setting of A2C"
        },
        {
            "text": "when the actor takes an action at a state. The actor attempts to maximize its expected discounted reward:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Setting of A2C"
        },
        {
            "text": "The agent reward at time t is defined as r t = \u2212 1 Tj , where T j is the runtime for job j.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Setting of A2C"
        },
        {
            "text": "The goal of data center job scheduling is to find the optimal policy \u03c0 * (a sequence of actions for agents) that maximizes the total reward. The state value function Q \u03c0 (s, a) is introduced to evaluate the performance of different policies. Q \u03c0 (s, a) stands for the expected total reward with discount from current state s on-wards with the policy \u03c0, which is equal to:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Setting of A2C"
        },
        {
            "text": "where s is the next state, and a is the action for the next time step. Function approximation is a way for generalization when the state and/or action spaces are large or continuous. Several reinforcement learning algorithms have been proposed to estimate the value of an action in various contexts such as the Q-learning [16] and SARSA [12] . Among them, the model-free Q-learning algorithm stands out for its simplicity [1] . In Q-learning, the algorithm uses a Q-function to calculate the total reward, defined as Q : S \u00d7 A \u2192 R. Q-learning iteratively evaluates the optimal Q-value function using backups:",
            "cite_spans": [
                {
                    "start": 322,
                    "end": 326,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 337,
                    "end": 341,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 422,
                    "end": 425,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "The Setting of A2C"
        },
        {
            "text": "where \u03b1 \u2208 [0, 1) is the learning rate and the term in the brackets is the temporaldifference (TD) error. Convergence to Q \u03c0 * is guaranteed in the tabular case provided there is sufficient state/action space exploration.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Setting of A2C"
        },
        {
            "text": "Loss function of the critic is utilized to update the critic network parameters.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Loss Function for Critic."
        },
        {
            "text": "where s is the state encountered after state s. Critic update the parameters of the value network by minimizing critic loss in Eq. 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Loss Function for Critic."
        },
        {
            "text": "Advantage Actor-critic. The critic updates state-action value function parameters, and the actor updates policy parameters, in the direction suggested by the critic. A2C updates both the policy and value-function networks with the multi-step returns as described in [11] . Critic is updated by minimizing the loss function of Eq. 3. Actor network is updated by minimizing the actor loss function in equation",
            "cite_spans": [
                {
                    "start": 266,
                    "end": 270,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "The Loss Function for Critic."
        },
        {
            "text": "where \u03b8 i is the parameters of the actor neural network and w i is the parameters of the critic neural network. Note that the parameters \u03b8 i of policy and w i of value are distinct for generality. Algorithm 1 presents the calculation and update of parameters per episode.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Loss Function for Critic."
        },
        {
            "text": "The A2C consists of an actor and a critic, and we implement both of them using deep convolutional neural network. For the Actor neural network, it takes the afore-mentioned tensor representation of resource requests and machine status as the input, and outputs the probability distribution over all possible actions, representing the jobs to be scheduled. For the Critic neural network, it takes as input the combination of action and the state of the system, and outputs the a single value, indicating the evaluation for actor's action.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Training Algorithm"
        },
        {
            "text": "The experiments are executed on a desktop computer with two RTX-2080 GPUs and one i7-9700k 8-core CPU. A2cScheduler is implemented using Tensorflow framework. Simulated jobs arrive online in Bernouli process. A piece of job trace from a real data center is also tested. CPU and Memory are the two kinds of resources considered in this research. The training process begins with an initial state of the data center. At each time step, a state is passed into the policy network \u03c0. An action is generated under policy \u03c0. A void action is made or a job is chosen from the global queue and put into the cluster for execution. Then a new state is generated and some reward is collected. The states, actions, policy and rewards are collected as trajectories. Meanwhile, the state is also passed into the value network to estimate the value, which used to evaluate the performance of the action. Actor in A2cScheduler learns to produce resource allocation strategies from experiences after epochs. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiment Setup"
        },
        {
            "text": "Reinforcement learning algorithms, including A2C, have been mostly evaluated by converging speed. However, these metrics are not very informative in domainspecific applications such as scheduling. Therefore, we present several evaluation metrics that are helpful for access the performance of the proposed model. Given a set of jobs J = {j 1 , . . . , j N }, where i th job is associated with arrival time t a i , finish time t f i , and execution time t e i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation Metrics"
        },
        {
            "text": "Average Job Slowdown. The slowdown for i th job is defined as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation Metrics"
        },
        {
            "text": "i is the completion time of the job and t i is the duration of the job. The average job slowdown is defined as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation Metrics"
        },
        {
            "text": "ci ti . The slowdown metric is important because it helps to evaluate normalized waiting time of a system.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation Metrics"
        },
        {
            "text": "Average Job Waiting Time. For the i th job, the waiting time t wi is the time between arrival and start of execution, which is formally defined as t wi = t s i \u2212 t a i .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Evaluation Metrics"
        },
        {
            "text": "We simulated the data center cluster containing N nodes with two resources: CPU and Memory. We trained the A2cScheduler with different neural networks including a fully connected layer and Convolutional Neural Networks (CNN). In order to design the best performance neural networks, we explore different CNN architectures and compare whether it converges and how is the converge speed with different settings. As shown in Table 3 , fully connected layer (FC layer) with a flatten layer in front did not converge. This is because the state of the environment is a matrix with location information while some location information lost in the flatten layer when the state is processed. To keep the location information, we utilize CNN layers (16 3 * 3-filters CNN layer and 32 3 * 3-filters CNN layer) and they show better results. Then, we explored CNN with max-pooling and CNN with flattening layer behind. Results show both of them could converge but CNN with max-pooling gets poorer results. This is due to some of the state information also get lost when it passes max-pooling layer. According to the experiment results, we decide to choose the CNN with a flattening layer behind architecture as it converges fast and gives the best performance.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 422,
                    "end": 429,
                    "text": "Table 3",
                    "ref_id": "TABREF3"
                }
            ],
            "section": "A2cScheduler with CNN"
        },
        {
            "text": "The performance of the proposed method is compared with some of the mainstream baselines such as Shortest Job First (SJF), Tetris [4] , and random policy. SJF sorts jobs according to their execution time and schedules jobs with the shortest execution time first; Tetris schedules job by a combined score of preferences for the short jobs and resource packing; random policy schedules jobs randomly. All of these baselines work in a greedy way that allocates as many jobs as allowed by the resources, and share the same resource constraints and take the same input as the proposed model. ",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 133,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Baselines"
        },
        {
            "text": "Performance on Synthetic Dataset. In our experiment, the A2cScheduler utilized an A2C reinforcement learning method. It is worth to mention that the model includes the option to have multiple episodes in order to allow us to measure the average performance achieved and the capacity to learn for each scheduling policy. Algorithm 1 presents the calculation and update of parameters per episode. Figure 3 shows experimental results with synthetic job distribution as input. Figure 3 (a) and Figure 3 (b) present the rewards and averaged slowdown when the new job rate is 0.7. Cumulative rewards and averaged slowdown converge around 500 episodes. A2cScheduler has lower averaged slowdown than random, Tetris and SJF after 500 episodes. Figure 3 (c) and Figure 3(d) show the average completion time and average waiting time of the A2cScheduler algorithm versus baselines. As we can see, the performance of A2cScheduler is the best comparing to all the baselines. Table 1 , 2 present the steady state simulation results at different job rates. We can see the A2cScheduler algorithm gets the best or close to the best performance regrading slowdown, average completion time and average waiting time at different job rates ranging from 0.6 to 0.9.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 395,
                    "end": 403,
                    "text": "Figure 3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 473,
                    "end": 481,
                    "text": "Figure 3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 490,
                    "end": 498,
                    "text": "Figure 3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 735,
                    "end": 743,
                    "text": "Figure 3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 752,
                    "end": 763,
                    "text": "Figure 3(d)",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 961,
                    "end": 968,
                    "text": "Table 1",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Performance Comparison"
        },
        {
            "text": "We ran experiments with a piece of job trace from an academic data center. The results were shown in Fig. 4 . The job traces were preprocessed before they are trained with the A2cScheduler. There was some fluctuation at the first 500 episodes in Fig. 4(a) , then it started to converge. Figure 4(b) shows the average slowdown was better than all the baselines and close to optimal value 1, which means the average waiting time was almost 0 as shown in Fig. 4(d) . This happens because there were only 60 jobs in this case study and jobs runtime are small. This was an case where almost no job was waiting for the allocation when it was optimally scheduled. A2cScheduler also gains the shortest completion time among different methods from Fig. 4(c) . Table 4 shows the steady state results from a real-world job distribution running on an academic cluster. A2cScheduler gets optimal scheduling results since there is near 0 average waiting time for this jobs distribution. Again, this experimental results proves A2cScheduler effectively finds the proper scheduling policies by itself given adequate training, both on simulation dataset and real-world dataset. There were no rules predefined for the scheduler in advance, instead, there was only a reward defined with the system optimization target included. This proven our defined reward function was effective in helping the scheduler to learn the optimal strategy automatically after adequate training.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 101,
                    "end": 107,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 246,
                    "end": 255,
                    "text": "Fig. 4(a)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 287,
                    "end": 298,
                    "text": "Figure 4(b)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 452,
                    "end": 461,
                    "text": "Fig. 4(d)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 739,
                    "end": 748,
                    "text": "Fig. 4(c)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 751,
                    "end": 758,
                    "text": "Table 4",
                    "ref_id": "TABREF4"
                }
            ],
            "section": "Performance on Real-world Dataset."
        },
        {
            "text": "Job scheduling with resource constraints is a long-standing but critically important problem for computer systems. In this paper, we proposed an A2C deep reinforcement learning algorithm to address the customized job scheduling problem in data centers We defined a reward function related to averaged job waiting time which leads A2cScheduler to find scheduling policy by itself. Without the need for any predefined rules, this scheduler is able to automatically learn strategies directly from experience and thus improve scheduling policies. Our experiments on both simulated data and real job traces for a data center show that our proposed method performs better than widely used SJF and Tetris for multi-resource cluster scheduling algorithms, offering a real alternative to current conventional approaches. The experimental results reported in this paper are based on two-resource (CPU/Memory) restrictions, but this approach can also be easily adapted for more complex multi-resource restriction scheduling scenarios.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Model-free Q-learning designs for linear discrete-time zerosum games with application to H-infinity control",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Al-Tamimi",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Automatica",
            "volume": "43",
            "issn": "3",
            "pages": "473--481",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "CuSH: cognitive scheduler for heterogeneous high performance computing system",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Domeniconi",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "K"
                    ],
                    "last": "Lee",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Morari",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "SLA-based resource provisioning for heterogeneous workloads in a virtualized cloud datacenter",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "K"
                    ],
                    "last": "Garg",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "K"
                    ],
                    "last": "Gopalaiyengar",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Buyya",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Proceedings ICA3PP",
            "volume": "",
            "issn": "",
            "pages": "371--384",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Multi-resource packing for cluster schedulers",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Grandl",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Comput. Commun. Rev",
            "volume": "44",
            "issn": "4",
            "pages": "455--466",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A survey of actor-critic reinforcement learning: standard and natural policy gradients",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Grondman",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "IEEE Trans. Syst. Man Cybern",
            "volume": "42",
            "issn": "6",
            "pages": "1291--1307",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Scheduling in HPC resource management systems: queuing vs. planning",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hovestadt",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kao",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Keller",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Streit",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "JSSPP 2003",
            "volume": "2862",
            "issn": "",
            "pages": "1--20",
            "other_ids": {
                "DOI": [
                    "10.1007/10968987_1"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Actor-critic algorithms",
            "authors": [
                {
                    "first": "V",
                    "middle": [
                        "R"
                    ],
                    "last": "Konda",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Proceedings of NIPS",
            "volume": "",
            "issn": "",
            "pages": "1008--1014",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "A reinforcement learning based resource management approach for time-critical workloads in distributed computing environment",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Rao",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of Big Data",
            "volume": "",
            "issn": "",
            "pages": "252--261",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Learning scheduling algorithms for data processing clusters",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Mao",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "arXiv": [
                    "arXiv:1810.01963"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Resource management with deep reinforcement learning",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Mao",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Alizadeh",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Menache",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kandula",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "HotNets 2016",
            "volume": "",
            "issn": "",
            "pages": "50--56",
            "other_ids": {
                "DOI": [
                    "10.1145/3005745.3005750"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Asynchronous methods for deep reinforcement learning",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Mnih",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of ICML",
            "volume": "",
            "issn": "",
            "pages": "1928--1937",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Multiple-goal reinforcement learning with modular Sarsa(O",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Sprague",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Ballard",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Actor-critic policy optimization in partially observable multiagent environments",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Srinivasan",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of NIPS",
            "volume": "",
            "issn": "",
            "pages": "3422--3435",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Introduction to Reinforcement Learning",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "S"
                    ],
                    "last": "Sutton",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "G"
                    ],
                    "last": "Barto",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "135",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Scheduling heterogeneous multi-cores through performance impact estimation (PIE)",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Van Craeynest",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Computer Architecture News",
            "volume": "40",
            "issn": "",
            "pages": "213--224",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Q-learning",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "J"
                    ],
                    "last": "Watkins",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Dayan",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Mach. Learn",
            "volume": "8",
            "issn": "3-4",
            "pages": "279--292",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Coordinating disaster emergency response with heuristic reinforcement learning",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nguyen",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Jin",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Exploring distributed resource allocation techniques in the SLURM job management system",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lang",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Raicu",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "A2cScheduler job scheduling framework.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2. An example of the tensor representation of a state. At each iteration, the decision combination of number of jobs will be scheduled is 2 T otal jobs , which has exponential growth rate. We simplify the case by selecting a decision from decision domain = {0, 1, . . . , N}, where N is a fixed hyper-parameter, decision = i denotes select i th job, and decision = 0 denotes no job will be selected.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Average completion time. (d) Average waiting time.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "A2C performance with a job arrival rate = 0.7",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Average completion time. (d) Average waiting time.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "A2C performance with real world log data",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Algorithm 1. A2C reinforcement learning scheduling algorithm",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Performance comparison when model converged.",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Performance comparison when model converged.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Performances of different network architectures.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "Results of job traces.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We are thankful to the anonymous reviewers for their valuable feedback. This research is supported in part by the National Science Foundation under grant CCF-1718336 and CNS-1817094.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgement."
        }
    ]
}