{
    "paper_id": "PMC7206631",
    "metadata": {
        "title": "Recompression: Technique for Word Equations and Compressed Data",
        "authors": [
            {
                "first": "Alberto",
                "middle": [],
                "last": "Leporati",
                "suffix": "",
                "email": "alberto.leporati@unimib.it",
                "affiliation": {}
            },
            {
                "first": "Carlos",
                "middle": [],
                "last": "Mart\u00edn-Vide",
                "suffix": "",
                "email": "carlos.martin@urv.cat",
                "affiliation": {}
            },
            {
                "first": "Dana",
                "middle": [],
                "last": "Shapira",
                "suffix": "",
                "email": "shapird@g.ariel.ac.il",
                "affiliation": {}
            },
            {
                "first": "Claudio",
                "middle": [],
                "last": "Zandron",
                "suffix": "",
                "email": "zandron@disco.unimib.it",
                "affiliation": {}
            },
            {
                "first": "Artur",
                "middle": [],
                "last": "Je\u017c",
                "suffix": "",
                "email": "aje@cs.uni.wroc.pl",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "The word equation problem, i.e. solving equations in the algebra of words, was first investigated by Markov in the fifties. In this problem we get as an input an equation of the form\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} u = v \\end{aligned}$$\\end{document}where u and v are strings of letters (from a fixed alphabet) as well as variables and a solution is a substitution of words for variables that turns this formal equation into a true equality of strings of letters (over the same fixed alphabet). It is relatively easy to show a reduction of this problem to the Hilbert\u2019s 10-th problem, i.e. the question of solving systems of Diophantine equations. Already then it was generally accepted that Hilbert\u2019s 10-th problem is undecidable and Markov wanted to show this by proving the undecidability of word equations.",
            "cite_spans": [],
            "section": "Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Alas, while Hilbert\u2019s 10-th problem is undecidable, the word equation problem is decidable, which was shown by Makanin [54]. The termination proof of his algorithm is very complex and yields a relatively weak bound on the computational complexity, thus over the years several improvements and simplifications over the original algorithm were proposed [27, 29, 43, 79]. Simplifications have many potential advantages: it seems natural that simpler algorithm can be generalised or extended more easily (for instance, to the case of equations in groups) than a complex one. Moreover, simpler algorithm should be more effective in practical applications and should have a lower complexity bounds.",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 122,
                    "mention": "54",
                    "ref_id": "BIBREF49"
                },
                {
                    "start": 352,
                    "end": 354,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 356,
                    "end": 358,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 360,
                    "end": 362,
                    "mention": "43",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 364,
                    "end": 366,
                    "mention": "79",
                    "ref_id": "BIBREF76"
                }
            ],
            "section": "Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Subcases. It is easy to show NP-hardness for word equations, so far no better computational complexity lower bound is known. Such hardness stimulated a search for a restricted subclasses of the problem for which efficient (i.e. polynomial) algorithms can be given [4]. One of such subclasses is defined by restricting the amount of different variables that can be used in an equation: it is known that equations with one [11, 45] and two [4, 10, 28] variables can be solved in polynomial time. Already for three variables it is not known, whether they are in NP or not [71] and partial results require nontrivial analysis [71].",
            "cite_spans": [
                {
                    "start": 265,
                    "end": 266,
                    "mention": "4",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 422,
                    "end": 424,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 426,
                    "end": 428,
                    "mention": "45",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 439,
                    "end": 440,
                    "mention": "4",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 442,
                    "end": 444,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 446,
                    "end": 448,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 570,
                    "end": 572,
                    "mention": "71",
                    "ref_id": "BIBREF68"
                },
                {
                    "start": 623,
                    "end": 625,
                    "mention": "71",
                    "ref_id": "BIBREF68"
                }
            ],
            "section": "Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Generalisations. Since Makanin\u2019s original solution much effort was put into extending his algorithm to other structures. Three directions seemed most natural:adding constraints to word equations;equations in free groups;partial commutation;equations in terms.\nConstraints. From the application point of view, it is advantageous to consider word equations that can also use some additional constraints, i.e. we require that the solution for X has some additional properties. This was first done for regular constraints [79], on the other hand, for several types of constraints, for instance length-constraints, it is still open, whether the resulting problem is decidable or not (it becomes undecidable, if we allow counting occurrences of particular letter in the substitutions and arithmetic operations on such counts [3]).Free groups. From the algebraic point of view, the word equation problem is solving equations in a free semigroup. It is natural to try to extend an algorithm from the free semigroup also to the case of free groups and then perhaps even to a larger class of groups (observe, that there are groups and semigroups for which the word problem is undecidable). The first algorithm for the group case was given by Makanin [55, 56], his algorithm was not primitively-recursive [44]. Furthermore, Razborov showed that this algorithm can be used to give a description of all solutions of an equation [68] (more readable description of the Razborov\u2019s construction is available in [41]). As a final comment, note that such a description was the first step in proving the Tarski\u2019s Conjecture for free groups (that the theory of free groups is decidable) [42].Partial commutation. Another natural generalization is to allow partial commutation between the letters, i.e. for each pair of letters we specify, whether \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ab = ba$$\\end{document} or not. Such partially commutative words are usually called traces and the corresponding groups are usually known as Right-Angled Artin Groups, RAAGs for short. Decidability for trace equations was shown by Matiyasevich [57] and for RAAGs by Diekert and Muscholl [15]. In both cases, the main step in the proof was a reduction from a partially commutative case to a non-commutative one.Terms. We can view words as very simple terms: each letter is a function symbol of arity 1. In this way word equations are equations over (very simple) terms. It is known, that term unification can be decided in polynomial time, assuming that variables represent closed (full) terms [69]; thus such a problem is unlikely to generalise word equations. A natural generalisation of term unification and word equations is a second-order unification, in which we allow variables to represent functions that take arguments (which need to be closed terms). However, it is known that this problem is undecidable, even in many restricted subcases [16, 26, 47, 49]. Context unification [7, 8, 74] is a natural problem \u2018in between\u2019: we allow variables representing functions, but we insist that they use their argument exactly once. It is easy to show that such defined problem generalises word equations, on the other hand, the undecidability proofs for second-order unification do not transfer directly to this model. Being a natural generalisation is not enough to explain the interest in this problem, more importantly, context unification has natural connections with other, well-studied problems (equality up to constraints [61], linear second-order unification [47, 50], one-step term rewriting [62], bounded second order unification [76], ...). Unfortunately, for over two decades the question of decidability of context unification remained open. Despite intensive research, not much is known about the decidability of this problem: only results for some restricted subcases are known: [8, 19, 47, 48, 51, 75, 77, 78].\n",
            "cite_spans": [
                {
                    "start": 519,
                    "end": 521,
                    "mention": "79",
                    "ref_id": "BIBREF76"
                },
                {
                    "start": 820,
                    "end": 821,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 1241,
                    "end": 1243,
                    "mention": "55",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 1245,
                    "end": 1247,
                    "mention": "56",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 1295,
                    "end": 1297,
                    "mention": "44",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 1416,
                    "end": 1418,
                    "mention": "68",
                    "ref_id": "BIBREF64"
                },
                {
                    "start": 1495,
                    "end": 1497,
                    "mention": "41",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 1667,
                    "end": 1669,
                    "mention": "42",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 2340,
                    "end": 2342,
                    "mention": "57",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 2383,
                    "end": 2385,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 2789,
                    "end": 2791,
                    "mention": "69",
                    "ref_id": "BIBREF65"
                },
                {
                    "start": 3144,
                    "end": 3146,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 3148,
                    "end": 3150,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 3152,
                    "end": 3154,
                    "mention": "47",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 3156,
                    "end": 3158,
                    "mention": "49",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 3182,
                    "end": 3183,
                    "mention": "7",
                    "ref_id": "BIBREF66"
                },
                {
                    "start": 3185,
                    "end": 3186,
                    "mention": "8",
                    "ref_id": "BIBREF77"
                },
                {
                    "start": 3188,
                    "end": 3190,
                    "mention": "74",
                    "ref_id": "BIBREF71"
                },
                {
                    "start": 3725,
                    "end": 3727,
                    "mention": "61",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 3763,
                    "end": 3765,
                    "mention": "47",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 3767,
                    "end": 3769,
                    "mention": "50",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 3797,
                    "end": 3799,
                    "mention": "62",
                    "ref_id": "BIBREF58"
                },
                {
                    "start": 3836,
                    "end": 3838,
                    "mention": "76",
                    "ref_id": "BIBREF73"
                },
                {
                    "start": 4090,
                    "end": 4091,
                    "mention": "8",
                    "ref_id": "BIBREF77"
                },
                {
                    "start": 4093,
                    "end": 4095,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 4097,
                    "end": 4099,
                    "mention": "47",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 4101,
                    "end": 4103,
                    "mention": "48",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 4105,
                    "end": 4107,
                    "mention": "51",
                    "ref_id": "BIBREF46"
                },
                {
                    "start": 4109,
                    "end": 4111,
                    "mention": "75",
                    "ref_id": "BIBREF72"
                },
                {
                    "start": 4113,
                    "end": 4115,
                    "mention": "77",
                    "ref_id": "BIBREF74"
                },
                {
                    "start": 4117,
                    "end": 4119,
                    "mention": "78",
                    "ref_id": "BIBREF75"
                }
            ],
            "section": "Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "For more than 20 years since Makanin\u2019s original solution there was very small progress in algorithms for word equations: the algorithm was improved in many places, in particular this lead to a better estimation of the running time; however, the main idea (and the general complexity of the proof) was essentially the same.",
            "cite_spans": [],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "The breakthrough was done by Plandowski and Rytter [67], who, for the first time, used the compression to solve word equations. They showed, that the shortest solution (of size N) of the word equation (of size n) has an SLP representation of size \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathsf{{poly}}(n, \\log N)$$\\end{document}; here a Straight Line Programme (SLP for short) is simply a context free grammar generating exactly one word. Using the algorithm for testing the equality of two SLPs [63] this easily yields a (non-deterministic) algorithm running in time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathsf{{poly}}(n, \\log N)$$\\end{document}. Unfortunately, this work did not provide any bound on N and the only known bound (4 times exponential in n) came directly from Makanin\u2019s algorithm, together those two results yielded a 3NEXPTIME algorithm. Soon after the bound on the size of the shortest solution was improved to triply exponential [27], which immediately yielded an algorithm from class 2NEXPTIME, however, the same paper [27] improved Makanin\u2019s algorithm, so that it workd in EXPSPACE.",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 54,
                    "mention": "67",
                    "ref_id": "BIBREF63"
                },
                {
                    "start": 727,
                    "end": 729,
                    "mention": "63",
                    "ref_id": "BIBREF59"
                },
                {
                    "start": 1411,
                    "end": 1413,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1502,
                    "end": 1504,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                }
            ],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Next, Plandowski gave a better (doubly exponential) bound on the size of the shortest solution [64] and thus obtained a NEXPTIME algorithm, in particular, at that time this was the best known algorithm for this problem. The proof was based on novel factorisations of words. By better exploiting the interplay between factorisations and compression, he improved the algorithm so that it worked in PSPACE [65].",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 98,
                    "mention": "64",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 404,
                    "end": 406,
                    "mention": "65",
                    "ref_id": "BIBREF61"
                }
            ],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "It is worth mentioning, that the solution proposed by Plandowski is essentially different than the one given by Makanin. In particular, it allowed generalisations more easily: Diekert, Guti\u00e9rrez and Hagenah [13] showed, that Plandowski\u2019s algorithm can be extended to the case in which we allow regular constraints in the equation (i.e. we want that the word substituted for X is from a regular language, whose description by a finite automaton is part of the input) and inversion; such an extended algorithm still works in polynomial space. It is easy to show that solving equations in free groups reduces to the above-mentioned problem of word equations with regular constraints and inversion [13] (it is worth mentioning, that in general we do not know whether solving equations in free groups is easier or harder than solving the ones in a free semigroup).",
            "cite_spans": [
                {
                    "start": 208,
                    "end": 210,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 695,
                    "end": 697,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "On the other hand, Plandowski showed, that his algorithm can be used to generate a finite representation of all solutions of a word equation [66], which allows solving several decision problems concerning the set of all solutions (finiteness, boundedness, boundedness of the exponent of periodicity etc.). It is not known, whether this algorithm can be generalised so that it generates all solutions also in the case of regular constraints and inversion (or in a free group).",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 144,
                    "mention": "66",
                    "ref_id": "BIBREF62"
                }
            ],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "The new, simpler algorithm for word equations and demonstration of connections between compression and word equations gave a new hope for solving the context unification problem. The first results were very promising: by using \u2018tree\u2019 equivalents of SLPs [2] computational complexity of some problems related to context unification was established [9, 19, 48]. Unfortunately, this approach failed to fully generalise Plandowski\u2019s algorithm for words: the equivalent of factorisations that were used in the algorithm were not found for trees.",
            "cite_spans": [
                {
                    "start": 255,
                    "end": 256,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 348,
                    "end": 349,
                    "mention": "9",
                    "ref_id": "BIBREF79"
                },
                {
                    "start": 351,
                    "end": 353,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 355,
                    "end": 357,
                    "mention": "48",
                    "ref_id": "BIBREF42"
                }
            ],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "It is worth mentioning, that Rytter and Plandowski\u2019s approach, in which we compress a solution using SLPs (or in the non-deterministic case\u2014we guess the compressed representation of the solution) and then perform the computation directly on the SLP-compressed representations using known algorithm that work in polynomial time, turned out to be extremely fruitful in many branches of computer science. The recent survey by Lohrey gives several such successful applications [53].",
            "cite_spans": [
                {
                    "start": 474,
                    "end": 476,
                    "mention": "53",
                    "ref_id": "BIBREF48"
                }
            ],
            "section": "Compression and Word Equations ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Recompression was developed for a specific problem concerning compressed data (fully compressed membership problem for finite automata [30]) and was later successfully applied to word equations [36] and other problems related to compressed representations. The usual approach for word equations (and compressed data in general) is that one tries to extract information about the combinatorics of the underlying words from the equation (compressed representation) and use this structure to solve the problem at hand. This is somehow natural: if the word can be represented compactly (be it as a solution of a word equation or using some compression mechanism) then it should have a lot of internal structure.",
            "cite_spans": [
                {
                    "start": 136,
                    "end": 138,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 195,
                    "end": 197,
                    "mention": "36",
                    "ref_id": "BIBREF29"
                }
            ],
            "section": "Recompression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Recompression takes a different approach: our aim is to perform simple compression operations on the solution word of the word equation directly on the compressed representation. We need to modify the equation a bit in order to do that, however, the choice of the compression operation and the analysis focuses on the compressed representation and its properties and (almost) completely ignores the properties of the solution. The idea of performing the compression operation is somehow natural in view of the already mentioned Plandowski and Rytter result [67], that the (length-minimal) solution has a small SLP: since such an SLP exists, we can try to build it bottom-up, i.e. the SLP has a rule \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a \\rightarrow bc$$\\end{document} and so we will replace each bc in the solution by a. (There are some complications in case of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$b=c$$\\end{document}, as then the compression is ambiguous: we solve this by replacing the maximal repetitions of b letter instead of replacing bb).",
            "cite_spans": [
                {
                    "start": 558,
                    "end": 560,
                    "mention": "67",
                    "ref_id": "BIBREF63"
                }
            ],
            "section": "Recompression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Of course, performing such a compression on the equation might be difficult or even impossible at all and we sometimes need to modify the equation. However, it turns out that a greedy choice suffices to guarantee that the kept equation is of quadratic size. The correctness and size analysis turns out to be surprisingly easy. The method is also very robust, so that it can be applied to various scenarios related to word equations: one variable word equations [35], equations in free groups [14], twisted word equations [12], context unification [31], ...See the following Sections for details of some of those results.",
            "cite_spans": [
                {
                    "start": 462,
                    "end": 464,
                    "mention": "35",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 493,
                    "end": 495,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 522,
                    "end": 524,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 548,
                    "end": 550,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                }
            ],
            "section": "Recompression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Due to ever-increasing amount of data, compression is widely applied in order to decrease the data\u2019s size. Still, the stored data is accessed and processed. Decompressing it on each such an occasion basically wastes the gain of reduced storage size. Thus there is a demand for algorithms dealing directly with the compressed data, without explicit decompression. Indeed, efficient algorithms for fundamental text operations (pattern matching, equality testing, etc.) are known for various practically used compression methods (LZ77, LZW, their variants, etc.) [20\u201325, 63].",
            "cite_spans": [
                {
                    "start": 561,
                    "end": 563,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 564,
                    "end": 566,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 568,
                    "end": 570,
                    "mention": "63",
                    "ref_id": "BIBREF59"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Note that above the compression can be seen as a source of problem that we want to overcome. However, as demonstrated by Plandowski and Rytter [67], the compression can also be seen as a solution to some problems, i.e. if we can show that the instance or its solutions is (highly) compressible, then we can compress it and, using the algorithms mentioned above, perform the computation on the compressed representation. See a recent survey of Lohrey [53], which gives examples of application of this approach in various fields, ranging from group theory, computational topology to program verification.",
            "cite_spans": [
                {
                    "start": 144,
                    "end": 146,
                    "mention": "67",
                    "ref_id": "BIBREF63"
                },
                {
                    "start": 451,
                    "end": 453,
                    "mention": "53",
                    "ref_id": "BIBREF48"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Compression standards differ in the main idea as well as in details. Thus when devising algorithms for compressed data, quite early one needs to focus on the exact compression method, to which the algorithm is applied. The most practical (and challenging) choice is one of the widely used standards, like LZW or LZ77. However, a different approach is also pursued: for some applications (and most of theory-oriented considerations) it would be useful to model one of the practical compression standard by a more mathematically well-founded and \u2018clean\u2019 method. The already mentioned Straight-Line Programs (SLPs), are such a clean formulation for many block compression methods: each LZ77 compressed text can be converted into an equivalent SLP of size \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}( n \\log ( N / n))$$\\end{document} and in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log (N/n))$$\\end{document} time [5, 70] (where N is the size of the decompressed text), while each SLP can be converted to an equivalent LZ77-like of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n)$$\\end{document} size in polynomial time. Other reasons of popularity of SLPs is that usually they compress well the input text [46, 60] Lastly, a greedy grammar compression can be efficiently implemented and thus can be used as a preprocessing to other compression methods, like those based on Burrows-Wheeler transform [39].",
            "cite_spans": [
                {
                    "start": 1393,
                    "end": 1394,
                    "mention": "5",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 1396,
                    "end": 1398,
                    "mention": "70",
                    "ref_id": "BIBREF67"
                },
                {
                    "start": 1923,
                    "end": 1925,
                    "mention": "46",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 1927,
                    "end": 1929,
                    "mention": "60",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 2116,
                    "end": 2118,
                    "mention": "39",
                    "ref_id": "BIBREF32"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "One can treat an SLP as a system of (very simple) word equations, i.e. a production \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X \\rightarrow \\alpha $$\\end{document} is rewritten as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X = \\alpha $$\\end{document}, and so the recompression algorithm generalizes also to such setting. It can be then seen as a variant of locally consistent parsing [1, 58, 72], and indeed those techniques were one of the sources of the recompression approach.",
            "cite_spans": [
                {
                    "start": 838,
                    "end": 839,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 841,
                    "end": 843,
                    "mention": "58",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 845,
                    "end": 847,
                    "mention": "72",
                    "ref_id": "BIBREF69"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "It is no surprise that the highly non-deterministic recompression algorithm determinises when applied to SLPs, what is surprising is that it can be made efficient. In particular, it can be used to checking the equality of two SLPs in roughly quadratic time, which is the fastest known algorithm for this problem [33] (and also for the generalisation of this problem, the fully compressed pattern matching).",
            "cite_spans": [
                {
                    "start": 313,
                    "end": 315,
                    "mention": "33",
                    "ref_id": "BIBREF26"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "The main drawback of grammar compression is that the size of the smallest grammar cannot be even approximated within (small enough) constant factor [5, 80]. There are many algorithms that achieve a logarithmic approximation ratio [5, 70, 73], recompression can also be used to obtain one (in fact: two different). One of those algorithms [32] seems to have a slightly better practical behaviour than the other ones, the second has much simpler analysis than other approximation algorithms [34] (as it is essentially a greedy left-to-right scan).",
            "cite_spans": [
                {
                    "start": 149,
                    "end": 150,
                    "mention": "5",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 152,
                    "end": 154,
                    "mention": "80",
                    "ref_id": "BIBREF78"
                },
                {
                    "start": 231,
                    "end": 232,
                    "mention": "5",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 234,
                    "end": 236,
                    "mention": "70",
                    "ref_id": "BIBREF67"
                },
                {
                    "start": 238,
                    "end": 240,
                    "mention": "73",
                    "ref_id": "BIBREF70"
                },
                {
                    "start": 339,
                    "end": 341,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 490,
                    "end": 492,
                    "mention": "34",
                    "ref_id": "BIBREF27"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "Just as recompression generalizes from word equations to context unification (i.e. term equations), the approximation algorithm based on recompression for strings can be generalized to trees [38], in which case it produces a so-called tree SLP [2]. This was the first approximation algorithm for this problem.",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 194,
                    "mention": "38",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 245,
                    "end": 246,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "\nSurvey\u2019s Limitations\n",
            "cite_spans": [],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "As this is an informal survey presentations, most of the proofs are only sketched or omitted. Due to space constraints, only some applications and results are explained in detail.",
            "cite_spans": [],
            "section": "Algorithms for Grammar-Based Compression ::: Introduction",
            "ref_spans": []
        },
        {
            "text": "For an equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u = v$$\\end{document}, solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document} and pair ab an occurrence of ab in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(u) $$\\end{document} (or \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(v)$$\\end{document}) isexplicit, if it consists solely of letters coming from u (or v);implicit, if it consists solely of letters coming from a substitution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} for a fixed occurrence of some variable X;crossing, otherwise.\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "A pair ab is crossing (for a solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document}) if it has at least one crossing occurrence and non-crossing (for a solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document}) otherwise.",
            "cite_spans": [],
            "section": "Definition 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "We similarly define explicit, implicit and crossing occurrences for blocks of letter a; a is crossing, if at least one of its blocks has a crossing occurrence. (In other words: aa is crossing).",
            "cite_spans": [],
            "section": "Definition 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Equation\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} aaX bb abab ab a = Xaa bb Y ab X \\end{aligned}$$\\end{document}has a unique solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X) = a$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(Y) = abab$$\\end{document}, under which sides evaluate to\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} aaa bb abab ab a = aaa bb abab ab a. \\end{aligned}$$\\end{document}Pair ba is crossing (as the first letter of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(Y) $$\\end{document} is a and first Y is preceded by a letter b, moreover, the last letter of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(Y) $$\\end{document} is b and the second Y is succeeded by a letter a), pair ab is non-crossing. Letter b is non-crossing, letter a is crossing (as X is preceded by a letter a on the left-hand side of the equation and on the right-hand side of the equation X is succeeded by a letter a).",
            "cite_spans": [],
            "section": "Example 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "\n\n Fix a pair ab and a solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document} of the equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u = v$$\\end{document}. If ab is non-crossing, performing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf PairComp (ab,S(u))$$\\end{document} is easy: we need to replace every explicit occurrence (which we do directly on the equation) as well as each implicit occurrence, which is done \u2018implicitly\u2019, as the solution is not stored, nor written anywhere. Due to the similarities to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf PairComp $$\\end{document} we will simply use the name \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf PairComp $$\\end{document}(ab,\u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019), when we make the pair compressions on the equation. The argument above shows, that if the equation had a solution for which ab is non-crossing then also the obtained equation has a solution. The same applies to the block compression, called \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf BlockComp $$\\end{document}(a,\u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019) for simplicity. On the other hand, if the obtained equation has a solution, then also the original equation had one (this solution is obtained by replacing each letter c by ab, the argument for the block compressions the same).",
            "cite_spans": [],
            "section": "Example 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Let the equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u = v$$\\end{document} have a solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document}, such that ab is non-crossing for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document}. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u' = v'$$\\end{document} obtained by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf PairComp $$\\end{document}(ab,\u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019) is satisfiable. If the obtained equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u' = v'$$\\end{document} is satisfiable, then also the original equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u = v$$\\end{document} is. The same applies to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf BlockComp $$\\end{document}(a,\u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019).",
            "cite_spans": [],
            "section": "Lemma 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Unfortunately Lemma 1 is not enough to simulate Compression(w) directly on the equation: In general there is no guarantee that the pair ab (letter a) is non-crossing, moreover, we do not know which pairs have only implicit occurrences. It turns out, that the second problem is trivial: if we restrict ourselves to the shortest solutions then every pair that has an implicit occurrence has also a crossing or explicit one, a similar statement holds also for blocks of letters.",
            "cite_spans": [],
            "section": "Lemma 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "([67]). Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document} be a shortest solution of an equation \u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019. Then:If ab is a substring of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(u)$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a \\ne b$$\\end{document}, then a, b have explicit occurrences in the equation and ab has an explicit or crossing occurrence.If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a^k$$\\end{document} is a maximal block in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(u)$$\\end{document} then a has an explicit occurrence in the equation and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a^k$$\\end{document} has an explicit or crossing occurrence.\n",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "67",
                    "ref_id": "BIBREF63"
                }
            ],
            "section": "Lemma 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "The proof is simple: suppose that a pair has only implicit occurrences. Then we could remove them and the obtained solution is shorter, contradicting the assumption. The argument for blocks is a bit more involved, as they can overlap.",
            "cite_spans": [],
            "section": "Lemma 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Getting back to the crossing pairs (and blocks), if we fix a pair ab (letter a), then it is easy to \u2018uncross\u2019 it: by Definition 1 we can conclude that the pair ab is crossing if and only if for some variables X and Y (not necessarily different) one of the following conditions holds (we assume that the solution does not assign an empty word to any variable\u2014otherwise we could simply remove such a variable from the equation):(CP1) aX occurs in the equation and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} begins with b;(CP2) Yb occurs in the equation and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(Y)$$\\end{document} ends with a;(CP3) YX occurs in the equation, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} begins with b and b\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(Y)$$\\end{document} ends with a.\n",
            "cite_spans": [],
            "section": "Lemma 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "In each of these cases the \u2018uncrossing\u2019 is natural: in (1) we \u2018pop\u2019 from X a letter b to the left, in (2) we pop a to the right from Y, in (3) we perform both operations. It turns out that in fact we can be even more systematic: we do not have to look at the occurrences of variables, it is enough to consider the first and last letter of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} for each variable X:If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} begins with b then we replace X with bX (changing implicitly the solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X) = b w$$\\end{document} to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S '(X) = w$$\\end{document}), if in the new solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X) = \\epsilon $$\\end{document}, i.e. it is empty, then we remove X from the equation;if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} ends with a then we apply a symmetric procedure.\n",
            "cite_spans": [],
            "section": "Lemma 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Such an algorithm is called \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf Pop $$\\end{document}.\n",
            "cite_spans": [],
            "section": "Lemma 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "It is easy to see, that for appropriate non-deterministic choices the obtained equation has a solution for which ab is non-crossing: for instance, if aX occurs in the equation and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} begins with b then we make the corresponding non-deterministic choices, popping b to the left and obtaining abX; a simple proof requires a precise statement of the claim as well as some case analysis.",
            "cite_spans": [],
            "section": "Lemma 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "If the equation \u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019 has a solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document} then for an appropriate run of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf Pop (a,b,{ `{u{} = v{}}\\hbox {'} })$$\\end{document} (for appropriate non-deterministic choices) the obtained equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u' = v'$$\\end{document} has a corresponding solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S '$$\\end{document}, i.e. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(u) = S '(u')$$\\end{document}, for which ab is a non-crossing pair. If the obtained equation has a solution then also the original equation had one.",
            "cite_spans": [],
            "section": "Lemma 3 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Thus, we know how to proceed with a crossing ab-pair compression: we first turn ab into a non-crossing pair (Pop) and then compress it as a non-crossing pair (PairComp).",
            "cite_spans": [],
            "section": "Lemma 3 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "We would like to perform similar operations for block compression. For non-crossing blocks we can naturally define a similar algorithm \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf BlockComp $$\\end{document}(a,\u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019). It remains to show how to \u2018uncross\u2019 a letter a. Unfortunately, if aX occurs in the equation and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} begins with a then replacing X with aX is not enough, as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} may still begin with a. In such a case we iterate the procedure until the first letter of X is not a (this includes the case in which we remove the whole variable X). Observe, that instead of doing this letter by letter, we can uncross a in one step: it is enough to remove from variable X its whole a-prefix and a-suffix of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X)$$\\end{document} (if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w = a^\\ell w' a^r$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w'$$\\end{document} does not begin nor end with a, a-prefix w is \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a^\\ell $$\\end{document} and a-suffix is \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a^r$$\\end{document}; if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w = a^\\ell $$\\end{document} then a-suffix and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$w'$$\\end{document} are empty). Such an algorithm is called \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf CutPrefSuff $$\\end{document}.\n",
            "cite_spans": [],
            "section": "Lemma 3 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Similarly as in Pop, we can show that after an appropriate run of CutPrefSuff the obtained equation has a (corresponding) solution for which a is non-crossing. Unfortunately, there is another problem: we need to write down the lengths \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\ell $$\\end{document} and r of a-prefixes and suffixes. We can write them as binary numbers, in which case they use \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(\\log \\ell + \\log r)$$\\end{document} bits of memory. However in general those still can be arbitrarily large numbers. Fortunately, we can show that in some solution those values are at most exponential (and so their description is polynomial-size). This easily follows from the exponential bound on exponent of periodicity [43]. For the moment it is enough that we know that:",
            "cite_spans": [
                {
                    "start": 1225,
                    "end": 1227,
                    "mention": "43",
                    "ref_id": "BIBREF37"
                }
            ],
            "section": "Lemma 3 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "([43]). In the shortest solution of the equation \u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019 each a-prefix and a-suffix has at most exponential length (in terms of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|u|+|v|$$\\end{document}).",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "43",
                    "ref_id": "BIBREF37"
                }
            ],
            "section": "Lemma 4 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Thus in Pop we can restrict ourselves to a-prefixes and suffixes of at most exponential length.",
            "cite_spans": [],
            "section": "Lemma 4 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S$$\\end{document} be a shortest solution of \u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019. For some non-deterministic choices, i.e. after some run of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf CutPrefSuff (a,{ `{u{} = v{}}\\hbox {'} })$$\\end{document}, the obtained equation \u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u' = v'$$\\end{document}\u2019 has a corresponding solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S '$$\\end{document}, such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S '(u') = S(u) $$\\end{document}, and a is a non-crossing letter for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S '$$\\end{document}, moreover, the explicit a blocks in \u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u' = v'$$\\end{document}\u2019 have at most exponential length. If the obtained equation has a solution then also the original equation had one.",
            "cite_spans": [],
            "section": "Lemma 5 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "After Pop we can compress a-blocks using \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\textsc {}\\mathsf BlockComp $$\\end{document}(a,\u2018\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u{} = v{}$$\\end{document}\u2019), observe that afterwards long a-blocks are replaced with single letters.",
            "cite_spans": [],
            "section": "Lemma 5 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "We are now ready to simulate Compression directly on the equation. The question is, in which order we should compress pairs and blocks? We make the choice nondeterministically: if there are any non-crossing pairs or letters, we compress them. This is natural, as such compression decreases both the size of the equation and the size of the length-minimal solution of the equation. If all pairs and letters are crossing, we choose greedily, i.e. the one that leads to the smallest equation (in one step). It is easy to show that such a strategy keeps the equation quadratic, more involved strategy, in which we compress many pairs/blocks in parallel, leads to a linear-length equation. Call one iteration of the main loop a phase.",
            "cite_spans": [],
            "section": "Lemma 5 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "The correctness of the algorithm follows from the earlier discussion on the correctness of BlockComp, CutPrefSuff, PairComp and Pop. In particular, the length of the length-minimal solution drops by at least 1 in each iteration, thus the algorithm terminates.",
            "cite_spans": [],
            "section": "Lemma 5 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Algorithm WordEqSAT has \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(N)$$\\end{document} phases, where N is the length of the shortest solution of the input equation.",
            "cite_spans": [],
            "section": "Lemma 6 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Let us bound the space needed by the algorithm: we claim that for appropriate nondeterministic choices the stored equation has at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$8n^2$$\\end{document} letters (and n variables). To see this, observe first that each Pop introduces at most 2n letters, one at each side of the variable. The same applies to CutPrefSuff (formally, CutPrefSuff introduces long blocks but they are immediately replaced with single letters, and so we can think that in fact we introduce only 2n letters). By (1)\u2013(3) we know that there are at most 2n crossing pairs and crossing letters (as each crossing pair/each crossing letter corresponds to one occurrence of a variable and one \u2018side\u2019 of such an occurrence). If the equation has m letters (and at most n occurrences of variables) and there is an occurrence of a non-crossing pair or block then we choose it for compression. Otherwise, there are m letters in the equation and each is covered by at least one pair/block, so for one of 2n choice at least \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\frac{m}{2n}$$\\end{document} letters are covered, so at least \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\frac{m}{4n}$$\\end{document} letters are removed by some compression. Thus the new equation has at most\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\underbrace{m}_{\\text {previous}} - \\underbrace{\\frac{m}{4n}}_{\\text {removed}} + \\underbrace{2n}_{\\text {popped}}&= m \\left( 1 - \\frac{1}{4n}\\right) + 2n\\\\&\\le 8n^2\\left( 1 - \\frac{1}{4n}\\right) + 2n\\\\&= 8n^2 -2n + 2n = 8n^2 \\end{aligned}$$\\end{document}letters, where the inequality follows by the inductive assumption that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$m \\le 8n^2$$\\end{document}. Going for the bit-size, each symbol requires at most logarithmic number of bits, and so",
            "cite_spans": [],
            "section": "Lemma 6 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "WordEqSAT runs in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n^2 \\log n)$$\\end{document} (bit) space.",
            "cite_spans": [],
            "section": "Lemma 7 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "With some effort we can make the above if analysis much tighter, see Sect. 4.1.",
            "cite_spans": [],
            "section": "Lemma 7 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "([36]). The recompression based algorithm (nondeterministically) decides word equations problem in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log n)$$\\end{document} bit-space; moreover, the stored equation has linear length.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "36",
                    "ref_id": "BIBREF29"
                }
            ],
            "section": "Theorem 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Moreover, with some extra effort one can remove also the logarithmic dependency, and show that satisfiability of word equations is in non-deterministic linear space, i.e. the problem is context sensitive. Surprisingly, it is enough to employ Huffman coding for the equation and run a variant of the algorithm. However, the analysis requires a deeper understanding of how fragments of the equation are changed during the algorithm and how they depend one on another.",
            "cite_spans": [],
            "section": "Theorem 1 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "([37]). A variant of recompression based algorithm which encodes the equation using Huffman coding (nondeterministically) decides word equations problem in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(m)$$\\end{document} bit-space; where m is the bit-size encoding of the input using any prefix-free code.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "37",
                    "ref_id": "BIBREF30"
                }
            ],
            "section": "Theorem 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Note that we allow some bit-optimization in the size of the input problem.",
            "cite_spans": [],
            "section": "Theorem 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "As a reminder: a PSPACE algorithm for this problem was already known [65]. Its memory consumption is not stated explicitly in that work, however, it is much larger than \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log n)$$\\end{document}: the stored equations are of length \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n^3)$$\\end{document} and during the transformations the algorithm uses essentially more memory.",
            "cite_spans": [
                {
                    "start": 70,
                    "end": 72,
                    "mention": "65",
                    "ref_id": "BIBREF61"
                }
            ],
            "section": "Theorem 2 ::: Recompression for Word Equations",
            "ref_spans": []
        },
        {
            "text": "In order to improve the space consumption from quadratic to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log n)$$\\end{document} we want to perform several compressions in parallel. To make it more precise, observe thatAll block compressions (also for different letters) can be performed in parallel, as such blocks do not overlap. Moreover, uncrossing different letters can also be done in parallel: if a is the first letter of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X) $$\\end{document} and b the last, then we pop from X the a-prefix and b-suffix.If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma _\\ell $$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma _r$$\\end{document} are disjoint, then the pair compressions for ab with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a \\in \\varSigma _\\ell $$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$b \\in \\varSigma _r$$\\end{document} can be done in parallel. Similarly as in the previous case, uncrossing can be done in parallel, by popping first letter if it is from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma _r$$\\end{document} and last if it is from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma _\\ell $$\\end{document}.We do not compress all pairs, only those from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(1)$$\\end{document} partitions \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma _\\ell $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varSigma _r$$\\end{document} that cover \u2018many\u2019 occurrences of pairs in the equation and in the solution.\n",
            "cite_spans": [],
            "section": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log n)$$\\end{document} Space ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "The crucial things is the choice of partitions. It turns out that choosing a random partition reduces the length of the solution by a constant fraction: consider two consecutive letters ab in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X) $$\\end{document}. If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a = b$$\\end{document} then they will be compressed as part of the maximal block. If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a \\ne b$$\\end{document} then there is 1/4 chance that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ab \\in \\varSigma _\\ell \\varSigma _r$$\\end{document}. Thus, in expectation, the length of the word shortens by one fourth of its length.",
            "cite_spans": [],
            "section": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log n)$$\\end{document} Space ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "A similar argument also shows that the number of letters in the equation remains linear, when a random partition is chosen. Thus, the equation will be of linear size (though each letter may need \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(\\log n)$$\\end{document} bits for the encoding).",
            "cite_spans": [],
            "section": "\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log n)$$\\end{document} Space ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "([6, 14]). A recompression based algorithm generates in polynomial space the description of all solutions of a word equation in free semigroups with inversion and regular constraints.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 3,
                    "mention": "6",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 5,
                    "end": 7,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Theorem 3 ::: Equations with Regular Constraints and Inversion; Equations in Free Groups ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Consider a signature \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\{ f, c, c'\\}$$\\end{document}, where f has arity 2 while \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c,c'$$\\end{document} have arity 0 and consider an equation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X(c) = Y(c')$$\\end{document}, where X and Y are context variables. The equation has a solution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X) = f(\\varOmega ,c'), S(Y) = f(c, \\varOmega )$$\\end{document} and then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S(X(c)) = f(c,c') = S(Y(c')) $$\\end{document}.",
            "cite_spans": [],
            "section": "Example 2 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Example 2 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "We try to apply the main idea of the recompression also in the case of terms: we iterate local compression operations and we guarantee that the word (term) equation is polynomial size. Since several term problems were solved using compression-based methods [9, 17\u201319, 48], there is a reasonable hope that our approach may succeed.",
            "cite_spans": [
                {
                    "start": 258,
                    "end": 259,
                    "mention": "9",
                    "ref_id": "BIBREF79"
                },
                {
                    "start": 261,
                    "end": 263,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 264,
                    "end": 266,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 268,
                    "end": 270,
                    "mention": "48",
                    "ref_id": "BIBREF42"
                }
            ],
            "section": "Example 2 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Pair and block compression easily generalise to sequences of letters of arity 1 (we can think of them as words), unfortunately, there is no guarantee that a term has even one such letter. Intuitively, we rather expect that it has mostly leaves and symbols of larger arity. This leads us to another local compression operation: leaf compression. Consider a node labelled with f and its i-th child that is a leaf. We want to compress f with this child, leaving other children (and their subtrees) unchanged. Formally, given f of arity at least 1, position \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 \\le i \\le {{\\,\\mathrm{ar}\\,}}(f)$$\\end{document} and a letter c of arity 0 the LeafComp(f, i, c, t) operation (leaf compression) replaces in term t nodes labelled with f and subterms \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t_1,\\ldots ,t_{i-1},c,t_{i+1},\\ldots ,t_{{{\\,\\mathrm{ar}\\,}}(f)}$$\\end{document} (where c and position i are fixed, while other terms \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t_1,\\ldots ,t_{i-1},t_{i+1},\\ldots ,t_{{{\\,\\mathrm{ar}\\,}}(f)}$$\\end{document}\u2014varying) by a term labelled with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$f'$$\\end{document} and subterms \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t_1',\\ldots ,t_{i-1}',t_{i+1}',\\ldots ,t_{{{\\,\\mathrm{ar}\\,}}(f)}'$$\\end{document} that are obtained by applying recursively LeafComp to terms \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t_1,\\ldots ,t_{i-1},t_{i+1},\\ldots ,t_{{{\\,\\mathrm{ar}\\,}}(f)}$$\\end{document}; in other words, we first change the label from f to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$f'$$\\end{document} and then remove the i-th child, which has a label c and we apply such a compression to all occurrences of f and c in parallel.",
            "cite_spans": [],
            "section": "Example 2 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "The notion of crossing pair generalizes to this case in a natural way and the uncrossing replaces a term variable with a constant or replaces X(t) with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X(f(x_1,\\ldots ,x_i,t,x_{i+1},\\ldots , x_\\ell ))$$\\end{document}. Note that this introduces new variables.",
            "cite_spans": [],
            "section": "Example 2 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "Now the whole algorithm looks similar as in the case of word equations, we simply use additional compression operation. However, the analysis is much more involved, as the new uncrossing introduces fresh term variables. However, their number at any point can be linearly bounded and the polynomial upper-bound follows.",
            "cite_spans": [],
            "section": "Example 2 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "([31]). Recompression based algorithm solves context unification in nondeterministic polynomial space.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                }
            ],
            "section": "Theorem 4 ::: Context Unification ::: Extensions of the Algorithm for Word Equations",
            "ref_spans": []
        },
        {
            "text": "The recompression for SLPs runs in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log N)\\le \\mathcal {O}(n^2)$$\\end{document} time, where n is the size of the input SLP and N is the length of the defined word.",
            "cite_spans": [],
            "section": "Lemma 8 ::: Straight Line Programs and Recompression ::: Recompression and Compressed Data",
            "ref_spans": []
        },
        {
            "text": "([33]). The recompression based algorithm for equality testing for SLPs runs in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log N)$$\\end{document} time, where n is the sum of SLPs\u2019 sizes while N the size of the defined (decompressed) words.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "33",
                    "ref_id": "BIBREF26"
                }
            ],
            "section": "Theorem 5 ::: SLP Equality and Fully Compressed Pattern Matching ::: Recompression and Compressed Data",
            "ref_spans": []
        },
        {
            "text": "In order to use the recompression technique for the fully compressed pattern matching problem, we need some essential modifications: consider ba-pair compression on a pattern ab and text bab. We obtain the same pattern ab and text cb, loosing the only occurrence of the pattern in the text. This happens because the compression (on the text) is done partially on the pattern occurrence and partially outside it. To remedy this, we perform the compression operations in a particular order, which takes into the account what are the first and last letters of pattern and text. (In the considered example, we make the ab-pair compression first and this preserves the occurrences of the pattern.) Similar approach works also for block compression.",
            "cite_spans": [],
            "section": "Theorem 5 ::: SLP Equality and Fully Compressed Pattern Matching ::: Recompression and Compressed Data",
            "ref_spans": []
        },
        {
            "text": "([33]). The recompression based algorithm for fully compressed pattern matching runs in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(n \\log M)$$\\end{document} time, where n is the sum of SLPs\u2019 sizes while M the length of the (uncompressed) pattern.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "33",
                    "ref_id": "BIBREF26"
                }
            ],
            "section": "Theorem 6 ::: SLP Equality and Fully Compressed Pattern Matching ::: Recompression and Compressed Data",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "Fig. 1.: A context and the same context applied on an argument.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Term f(h(c, c, c), f(c, f(c, c))) viewed as a tree, f is of arity 2, h: 3 and c: 0.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "Solving two-variable word equations",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Da\u0327browski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Automata, Languages and Programming",
            "volume": "",
            "issn": "",
            "pages": "408-419",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "On word equations in one variable",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Da\u0327browski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Algorithmica",
            "volume": "60",
            "issn": "4",
            "pages": "819-828",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-009-9375-3"
                ]
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2005.04.002"
                ]
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "Solvability of equations in free partially commutative groups is decidable",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Muscholl",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Int. J. Algebr. Comput.",
            "volume": "16",
            "issn": "",
            "pages": "1047-1070",
            "other_ids": {
                "DOI": [
                    "10.1142/S0218196706003372"
                ]
            }
        },
        "BIBREF7": {
            "title": "Simple second-order languages for which unification is undecidable",
            "authors": [
                {
                    "first": "WM",
                    "middle": [],
                    "last": "Farmer",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Theor. Comput. Sci.",
            "volume": "87",
            "issn": "1",
            "pages": "25-41",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(06)80003-4"
                ]
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Unification and matching on compressed terms",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gasc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Godoy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "ACM Trans. Comput. Log.",
            "volume": "12",
            "issn": "4",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1145/1970398.1970402"
                ]
            }
        },
        "BIBREF10": {
            "title": "Context unification with one context variable",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gasc\u00f3n",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Godoy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tiwari",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "J. Symb. Comput.",
            "volume": "45",
            "issn": "2",
            "pages": "173-193",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jsc.2008.10.005"
                ]
            }
        },
        "BIBREF11": {
            "title": "Efficient memory representation of XML document trees",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Busatto",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lohrey",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Maneth",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Inf. Syst.",
            "volume": "33",
            "issn": "4\u20135",
            "pages": "456-474",
            "other_ids": {
                "DOI": [
                    "10.1016/j.is.2008.01.004"
                ]
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "Pattern matching in Lempel-Ziv compressed strings: fast, simple, and deterministic",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gawrychowski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Algorithms \u2013 ESA 2011",
            "volume": "",
            "issn": "",
            "pages": "421-432",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "Optimal pattern matching in LZW compressed strings",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gawrychowski",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ACM Trans. Algorithms",
            "volume": "9",
            "issn": "3",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1145/2483699.2483705"
                ]
            }
        },
        "BIBREF18": {
            "title": "The undecidability of the second-order unification problem",
            "authors": [
                {
                    "first": "WD",
                    "middle": [],
                    "last": "Goldfarb",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Theor. Comput. Sci.",
            "volume": "13",
            "issn": "",
            "pages": "225-230",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(81)90040-2"
                ]
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "Two-variable word equations",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ilie",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "ITA",
            "volume": "34",
            "issn": "6",
            "pages": "467-501",
            "other_ids": {
                "DOI": [
                    "10.1051/ita:2000126"
                ]
            }
        },
        "BIBREF21": {
            "title": "Minimal and complete word unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Jaffar",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "J. ACM",
            "volume": "37",
            "issn": "1",
            "pages": "47-85",
            "other_ids": {
                "DOI": [
                    "10.1145/78935.78938"
                ]
            }
        },
        "BIBREF22": {
            "title": "Definability in the existential theory of concatenation and undecidable extensions of this theory",
            "authors": [
                {
                    "first": "JR",
                    "middle": [],
                    "last": "B\u00fcchi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Senger",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "Math. Log. Q.",
            "volume": "34",
            "issn": "4",
            "pages": "337-342",
            "other_ids": {
                "DOI": [
                    "10.1002/malq.19880340410"
                ]
            }
        },
        "BIBREF23": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "Faster fully compressed pattern matching by recompression",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ACM Trans. Algorithms",
            "volume": "11",
            "issn": "3",
            "pages": "20:1-20:43",
            "other_ids": {
                "DOI": [
                    "10.1145/2631920"
                ]
            }
        },
        "BIBREF27": {
            "title": "A really simple approximation of smallest grammar",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci.",
            "volume": "616",
            "issn": "",
            "pages": "141-150",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2015.12.032"
                ]
            }
        },
        "BIBREF28": {
            "title": "One-variable word equations in linear time",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Algorithmica",
            "volume": "74",
            "issn": "",
            "pages": "1-48",
            "other_ids": {
                "DOI": [
                    "10.1007/s00453-014-9931-3"
                ]
            }
        },
        "BIBREF29": {
            "title": "Recompression: a simple and powerful technique for word equations",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "J. ACM",
            "volume": "63",
            "issn": "1",
            "pages": "4:1-4:51",
            "other_ids": {
                "DOI": [
                    "10.1145/2743014"
                ]
            }
        },
        "BIBREF30": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF31": {
            "title": "Approximation of smallest linear tree grammar",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Je\u017c",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lohrey",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Inf. Comput.",
            "volume": "251",
            "issn": "",
            "pages": "215-251",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2016.09.007"
                ]
            }
        },
        "BIBREF32": {
            "title": "Grammar precompression speeds up Burrows\u2013Wheeler compression",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "K\u00e4rkk\u00e4inen",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Mikkola",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kempa",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "String Processing and Information Retrieval",
            "volume": "",
            "issn": "",
            "pages": "330-335",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF33": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF34": {
            "title": "Pattern-matching for strings with short descriptions",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Karpinski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shinohara",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Combinatorial Pattern Matching",
            "volume": "",
            "issn": "",
            "pages": "205-214",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF35": {
            "title": "Irreducible affine varieties over a free group. II: systems in triangular quasi-quadratic form and description of residually free groups",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kharlampovich",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Myasnikov",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Algebra",
            "volume": "200",
            "issn": "",
            "pages": "517-570",
            "other_ids": {
                "DOI": [
                    "10.1006/jabr.1997.7184"
                ]
            }
        },
        "BIBREF36": {
            "title": "Elementary theory of free non-abelian groups",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kharlampovich",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Myasnikov",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. Algebra",
            "volume": "302",
            "issn": "",
            "pages": "451-552",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jalgebra.2006.03.033"
                ]
            }
        },
        "BIBREF37": {
            "title": "Complexity of Makanin\u2019s algorithm",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ko\u015bcielski",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pacholski",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "J. ACM",
            "volume": "43",
            "issn": "4",
            "pages": "670-684",
            "other_ids": {
                "DOI": [
                    "10.1145/234533.234543"
                ]
            }
        },
        "BIBREF38": {
            "title": "Makanin\u2019s algorithm is not primitive recursive",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ko\u015bcielski",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pacholski",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Theor. Comput. Sci.",
            "volume": "191",
            "issn": "1\u20132",
            "pages": "145-156",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(96)00321-0"
                ]
            }
        },
        "BIBREF39": {
            "title": "Word equations with one unknown",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Laine",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Int. J. Found. Comput. Sci.",
            "volume": "22",
            "issn": "2",
            "pages": "345-375",
            "other_ids": {
                "DOI": [
                    "10.1142/S0129054111008088"
                ]
            }
        },
        "BIBREF40": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF41": {
            "title": "Linear second-order unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "Rewriting Techniques and Applications",
            "volume": "",
            "issn": "",
            "pages": "332-346",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF42": {
            "title": "On the complexity of bounded second-order unification and stratified context unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Villaret",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Log. J. IGPL",
            "volume": "19",
            "issn": "6",
            "pages": "763-789",
            "other_ids": {
                "DOI": [
                    "10.1093/jigpal/jzq010"
                ]
            }
        },
        "BIBREF43": {
            "title": "On the undecidability of second-order unification",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Veanes",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Inf. Comput.",
            "volume": "159",
            "issn": "1\u20132",
            "pages": "125-150",
            "other_ids": {
                "DOI": [
                    "10.1006/inco.2000.2877"
                ]
            }
        },
        "BIBREF44": {
            "title": "The smallest grammar problem",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Charikar",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "IEEE Trans. Inf. Theory",
            "volume": "51",
            "issn": "7",
            "pages": "2554-2576",
            "other_ids": {
                "DOI": [
                    "10.1109/TIT.2005.850116"
                ]
            }
        },
        "BIBREF45": {
            "title": "Linear second-order unification and context unification with tree-regular constraints",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Villaret",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Rewriting Techniques and Applications",
            "volume": "",
            "issn": "",
            "pages": "156-171",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF46": {
            "title": "Currying second-order unification problems",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Villaret",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Rewriting Techniques and Applications",
            "volume": "",
            "issn": "",
            "pages": "326-339",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF47": {
            "title": "Processing compressed texts: a tractability border",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Lifshits",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Combinatorial Pattern Matching",
            "volume": "",
            "issn": "",
            "pages": "228-240",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF48": {
            "title": "Algorithmics on SLP-compressed strings: a survey",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lohrey",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Groups Complex. Cryptol.",
            "volume": "4",
            "issn": "2",
            "pages": "241-299",
            "other_ids": {
                "DOI": [
                    "10.1515/gcc-2012-0016"
                ]
            }
        },
        "BIBREF49": {
            "title": "The problem of solvability of equations in a free semigroup",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Makanin",
                    "suffix": ""
                }
            ],
            "year": 1977,
            "venue": "Matematicheskii Sbornik",
            "volume": "2",
            "issn": "103",
            "pages": "147-236",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF50": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF51": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF52": {
            "title": "Some decision problems for traces",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Matiyasevich",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Logical Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "248-257",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF53": {
            "title": "Maintaining dynamic sequences under equality tests in polylogarithmic time",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Mehlhorn",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Sundar",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Uhrig",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Algorithmica",
            "volume": "17",
            "issn": "2",
            "pages": "183-198",
            "other_ids": {
                "DOI": [
                    "10.1007/BF02522825"
                ]
            }
        },
        "BIBREF54": {
            "title": "An improved pattern matching algorithm for strings in terms of straight-line programs",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Miyazaki",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shinohara",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Takeda",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Combinatorial Pattern Matching",
            "volume": "",
            "issn": "",
            "pages": "1-11",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF55": {
            "title": "Solution sets for equations over free groups are EDT0L languages",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ciobanu",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Diekert",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Elder",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "IJAC",
            "volume": "26",
            "issn": "5",
            "pages": "843-886",
            "other_ids": {
                "DOI": [
                    "10.1142/S0218196716500363"
                ]
            }
        },
        "BIBREF56": {
            "title": "Identifying hierarchical structure in sequences: a linear-time algorithm",
            "authors": [
                {
                    "first": "CG",
                    "middle": [],
                    "last": "Nevill-Manning",
                    "suffix": ""
                },
                {
                    "first": "IH",
                    "middle": [],
                    "last": "Witten",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "J. Artif. Intell. Res. (JAIR)",
            "volume": "7",
            "issn": "",
            "pages": "67-82",
            "other_ids": {
                "DOI": [
                    "10.1613/jair.374"
                ]
            }
        },
        "BIBREF57": {
            "title": "On equality up-to constraints over finite trees, context unification, and one-step rewriting",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Niehren",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pinkal",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Ruhrberg",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Automated Deduction\u2014CADE-14",
            "volume": "",
            "issn": "",
            "pages": "34-48",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF58": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF59": {
            "title": "Testing equivalence of morphisms on context-free languages",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Algorithms \u2014 ESA \u201994",
            "volume": "",
            "issn": "",
            "pages": "460-470",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF60": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF61": {
            "title": "Satisfiability of word equations with constants is in PSPACE",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "J. ACM",
            "volume": "51",
            "issn": "3",
            "pages": "483-496",
            "other_ids": {
                "DOI": [
                    "10.1145/990308.990312"
                ]
            }
        },
        "BIBREF62": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF63": {
            "title": "Application of Lempel-Ziv encodings to the solution of word equations",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Plandowski",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Automata, Languages and Programming",
            "volume": "",
            "issn": "",
            "pages": "731-742",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF64": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF65": {
            "title": "A machine-oriented logic based on the resolution principle",
            "authors": [
                {
                    "first": "JA",
                    "middle": [],
                    "last": "Robinson",
                    "suffix": ""
                }
            ],
            "year": 1965,
            "venue": "J. ACM",
            "volume": "12",
            "issn": "1",
            "pages": "23-41",
            "other_ids": {
                "DOI": [
                    "10.1145/321250.321253"
                ]
            }
        },
        "BIBREF66": {
            "title": "Completion of rewrite systems with membership constraints. Part I: deduction rules",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Comon",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Symb. Comput.",
            "volume": "25",
            "issn": "4",
            "pages": "397-419",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.1997.0185"
                ]
            }
        },
        "BIBREF67": {
            "title": "Application of Lempel-Ziv factorization to the approximation of grammar-based compression",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Rytter",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Theor. Comput. Sci.",
            "volume": "302",
            "issn": "1\u20133",
            "pages": "211-222",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(02)00777-6"
                ]
            }
        },
        "BIBREF68": {
            "title": "On the complexity of Hmelevskii\u2019s theorem and satisfiability of three unknown equations",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Saarela",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Developments in Language Theory",
            "volume": "",
            "issn": "",
            "pages": "443-453",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF69": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF70": {
            "title": "A fully linear-time approximation algorithm for grammar-based compression",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Sakamoto",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "J. Discrete Algorithms",
            "volume": "3",
            "issn": "2\u20134",
            "pages": "416-430",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jda.2004.08.016"
                ]
            }
        },
        "BIBREF71": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF72": {
            "title": "A decision algorithm for stratified context unification",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "J. Log. Comput.",
            "volume": "12",
            "issn": "6",
            "pages": "929-953",
            "other_ids": {
                "DOI": [
                    "10.1093/logcom/12.6.929"
                ]
            }
        },
        "BIBREF73": {
            "title": "Decidability of bounded second order unification",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Inf. Comput.",
            "volume": "188",
            "issn": "2",
            "pages": "143-178",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2003.08.002"
                ]
            }
        },
        "BIBREF74": {
            "title": "On the exponent of periodicity of minimal solutions of context equations",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "KU",
                    "middle": [],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "Rewriting Techniques and Applications",
            "volume": "",
            "issn": "",
            "pages": "61-75",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF75": {
            "title": "Solvability of context equations with two context variables is decidable",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Schmidt-Schau\u00df",
                    "suffix": ""
                },
                {
                    "first": "KU",
                    "middle": [],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "J. Symb. Comput.",
            "volume": "33",
            "issn": "1",
            "pages": "77-122",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.2001.0438"
                ]
            }
        },
        "BIBREF76": {
            "title": "Makanin\u2019s algorithm for word equations-two improvements and a generalization",
            "authors": [
                {
                    "first": "KU",
                    "middle": [],
                    "last": "Schulz",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Word Equations and Related Topics",
            "volume": "",
            "issn": "",
            "pages": "85-150",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF77": {
            "title": "Completion of rewrite systems with membership constraints. Part II: constraint solving",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Comon",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "J. Symb. Comput.",
            "volume": "25",
            "issn": "4",
            "pages": "421-453",
            "other_ids": {
                "DOI": [
                    "10.1006/jsco.1997.0186"
                ]
            }
        },
        "BIBREF78": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF79": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}