{
    "paper_id": "6f630d64c02a5e9226ed771f7c23ab0d8ef44f66",
    "metadata": {
        "title": "LOCATER: Cleaning WiFi Connectivity Datasets for Semantic Localization",
        "authors": [
            {
                "first": "Yiming",
                "middle": [],
                "last": "Lin",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": "yiminl18@uci.edu"
            },
            {
                "first": "Daokun",
                "middle": [],
                "last": "Jiang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": "daokunj@uci.edu"
            },
            {
                "first": "Roberto",
                "middle": [],
                "last": "Yus",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": ""
            },
            {
                "first": "Georgios",
                "middle": [],
                "last": "Bouloukakis",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": ""
            },
            {
                "first": "Andrew",
                "middle": [],
                "last": "Chio",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": "achio@uci.edu"
            },
            {
                "first": "Sharad",
                "middle": [],
                "last": "Mehrotra",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": "sharad@ics.uci.edu"
            },
            {
                "first": "Nalini",
                "middle": [],
                "last": "Venkatasubramanian",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine"
                    }
                },
                "email": "nalini@ics.uci.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "This paper explores the data cleaning challenges that arise in using WiFi connectivity data to locate users to semantic indoor locations such as buildings, regions, rooms. WiFi connectivity data consists of sporadic connections between devices and nearby WiFi access points, each of which may cover a relatively large area within a building. Our system, entitled semantic LOCATion cleanER (LOCATER), postulates semantic localization as a series of data cleaning challenges -first, it treats the problem of determining the AP to which a device is connected between any two of its connection events as a missing value detection and repair problem. It then associates the device with the semantic subregion (e.g., a conference room in the region) by postulating it as a location disambiguation problem. We propose a bootstrapping semi-supervised learning method for the coarse localization and probabilistic method to achieve finer localization. We show that LOCATER can achieve significantly high accuracy at both the coarse and fine levels. LOCATER offers several benefits over traditional indoor localization approaches since it neither requires active cooperation from users (e.g., downloading code on a mobile device and communicating with the server) nor installing external hardware (e.g., network monitors).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "This paper studies the challenge of cleaning connectivity data collected by WiFi infrastructure to support semantic localization [15] inside buildings. Semantic localization refers to locating people in a semantic indoor location such as within a building, a floor, a region, and/or a room. WiFi connectivity data refers to association events between a device and the WiFi infrastructure (e.g., access points in buildings). Such association events are readily available in large WiFi infrastructures that may consist of hundreds to thousands of Access Points (APs) (e.g., in university campuses, airports, shopping malls, etc.) 1 and consist of observations in the form of mac address, time stamp, wap which correspond to the MAC of the WiFi-enabled connected device, the timestamp when the connection occurred and the WiFi AP (wap) to which the device is connected. Connectivity events of mobile devices (e.g., handhelds, wearables) can be exploited to locate individuals carrying such devices to a region covered by the access points. For example, in Fig. 1 (b) an event e1 can lead to the observation that the owner of the the device with mac address 7bfh... was located in the region covered by wap3 (which includes rooms 2059, 2061, 2065, 2066, 2068, 2069, 2072, 2074, 2076, and 2099 ) at 2019-08-22 13:04: 35 .",
            "cite_spans": [
                {
                    "start": 129,
                    "end": 133,
                    "text": "[15]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1232,
                    "end": 1288,
                    "text": "2061, 2065, 2066, 2068, 2069, 2072, 2074, 2076, and 2099",
                    "ref_id": null
                },
                {
                    "start": 1312,
                    "end": 1314,
                    "text": "35",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [
                {
                    "start": 1053,
                    "end": 1059,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "INTRODUCTION"
        },
        {
            "text": "WiFi connectivity can be a powerful technology for indoor localization especially for applications where localizing individuals to a semantically meaningful location (such as inside/outside buildings, on a given floor, in a given region, or in a given room) suffices. Such applications include maintaining accurate assessment of occupancy of different parts of the building for HVAC (Heating, Ventilation and Air Conditioning) control [4] , constructing accurate models of building usage for space planning, or other customized services, and even tracking individual inside large buildings [14, 22] . In the context of recent COVID-19 epidemic, such data can be used to determine regions/areas of high traffic in buildings, monitoring adherence to social distancing, and building systems to alert people who might have been exposed based on possible contact with someone who has been infected.",
            "cite_spans": [
                {
                    "start": 435,
                    "end": 438,
                    "text": "[4]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 590,
                    "end": 594,
                    "text": "[14,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 595,
                    "end": 598,
                    "text": "22]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "While several indoor localization technologies exist based on a variety of sensors (e.g., bluetooth beacons, video-based tracing, fingerprint analysis of WiFi signal strength, ultrawide band signals, inertial sensors) or their fusion to accurately locate people inside buildings, using WiFi connectivity data offers several unique benefits. First, since WiFi infrastructure is ubiquitous in modern buildings, using the infrastructure for semantic localization does not incur any additional hardware costs either to users or to the built infrastructure owner. Such would be the case if we were 1 When a device associates with an AP to connect to the network, the associated AP sends an association event to a wireless controller for tasks such as roaming management, load balancing, traffic fairness among clients, and wireless channel interference mitigation. Controllers can collect WiFi association data from APs in real-time using SNMP (Simple Network Management Protocol) which is the most widely used protocol, or using NETCONF [10] , a more recent network management protocol. Some infrastructures may alternatively uses Syslog [11] to gather the operation log, including association events, from APs. to retrofit buildings with technologies such as RFID, ultra wideband (UWB), bluetooth, camera, etc. [19] . Besides (almost) zero cost, another artifact of ubiquity of WiFi networks is that such a solution has wide applicability to all types of buildings -airports, residences, office spaces, university campuses, government buildings, etc. Another key advantage is that localization using WiFi connectivity can be performed passively without requiring users to either install new applications on their smartphones, or to actively participate in the localization process. In contrast, active approaches [8, 24] require individuals to download special software/apps and send information to a localization system [8] that significantly limits technology adoption. Nonparticipation by a non-negligible population renders applications that perform aggregate level analysis (e.g., analysis of space utilization and crowd flow patterns) very difficult to implement. While such a limitation of active localization has sparked significant interest in passive localization mechanisms, e.g., [18, 20, 22, 25, 30, 32, 34] , such prior approaches have required external hardware capable of monitoring and capturing (or extracting) signals from user devices to be deployed that can detect environmental changes [20, 22] to help locate individuals. Such hardware makes the solution prohibitively costly at a large scale, and furthermore, may not be possible due to physical restrictions of space. In contrast, WiFi infrastructure is readily available in most commercial buildings and offers a relatively untapped potential for exploiting as a localization framework for applications where semantic localization suffices.",
            "cite_spans": [
                {
                    "start": 1033,
                    "end": 1037,
                    "text": "[10]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1134,
                    "end": 1138,
                    "text": "[11]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1308,
                    "end": 1312,
                    "text": "[19]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1810,
                    "end": 1813,
                    "text": "[8,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1814,
                    "end": 1817,
                    "text": "24]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1918,
                    "end": 1921,
                    "text": "[8]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 2289,
                    "end": 2293,
                    "text": "[18,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 2294,
                    "end": 2297,
                    "text": "20,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 2298,
                    "end": 2301,
                    "text": "22,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 2302,
                    "end": 2305,
                    "text": "25,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 2306,
                    "end": 2309,
                    "text": "30,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 2310,
                    "end": 2313,
                    "text": "32,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 2314,
                    "end": 2317,
                    "text": "34]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 2505,
                    "end": 2509,
                    "text": "[20,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 2510,
                    "end": 2513,
                    "text": "22]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "Comparing with state-of-the-art WiFi-based localization systems. Several WiFi-based localization systems are passive and do not require external hardware [16, 28] . They rely on CSI (Channel State Information) or RSSI (Received Signal Strength Indicator) to localize devices to achieve a median accuracy of decimeter-level, e.g., 40cm and 65cm for SpotFi [16] and Chronos [28] . The key limitation of such techniques is that they require the WiFi AP to work in monitor mode where the AP serves as dedicated WiFi channel sensor that collects WiFi data packets on the channel. Most APs in monitor mode have restrictions for packet transmission [3, 7] , which means that those APs cannot handle data traffic between client devices and the infrastructure. Even for some limited types of AP whose monitor mode can support normal WiFi association, localization process will affect the network traffic [28] . In practice, WiFi networks are normally deployed for communication (i.e., to maximize data throughput and network coverage) rather than localization purposes, and our work tries to provide localization on top of it without interfering with users' network connection. Challenges in exploiting WiFi connectivity data. Using WiFi data, besides offering new opportunities, raises several significant data cleaning challenges.",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 158,
                    "text": "[16,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 159,
                    "end": 162,
                    "text": "28]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 355,
                    "end": 359,
                    "text": "[16]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 372,
                    "end": 376,
                    "text": "[28]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 642,
                    "end": 645,
                    "text": "[3,",
                    "ref_id": null
                },
                {
                    "start": 646,
                    "end": 648,
                    "text": "7]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 895,
                    "end": 899,
                    "text": "[28]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 Missing value detecting and repairing. Devices might get disconnected from the network even when the user carrying them are still in the space. Depending on the specific device, connectivity events might occur only sporadically and at different periodicity, making prediction more complex. These lead to missing values challenge. As an instance, in Fig. 1 (c) we have raw connectivity data for device 7fbh at time 13:04:35 and 13:18:11. Location between these two consecutive time stamps is missing.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 351,
                    "end": 357,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 Location disambiguation. APs cover large regions within a building that might involve multiple rooms and hence simply knowing which AP a device is connected to may not offer room-level localization. For example, in Fig. 1 , the device 3ndb connects to wap2, which covers rooms: 2004, 2057, 2059,..., 2068. These values are dirty for room-level localization. Such a challenge can be viewed as a location disambiguation challenge.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 217,
                    "end": 223,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 Scalability. The volume of WiFi data is huge -for instance, in our campus, with over 200 buildings and 2,000 access points, we generate several million WiFi connectivity tuples in one day on average. Thus, data cleaning technique needs to be able to scale to large data sets.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "To address the above challenges, this paper proposes an online location cleaning system, entitled LOCATER, to efficiently clean WiFi connectivity data for room-level localization. LOCATER mainly consists of two parts, a cleaning engine and a caching engine. Cleaning engine takes input of WiFi connectivity dataset, metadata (such as the type of rooms, as will be explained later), and a query that requests the location of a device at given time, and outputs the location of the device at the room-level. Caching engine is used to cache cleaning results of past queries to speed up the system. Specifically, we make the following contributions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 We propose a novel approach to semantic indoor localization by formalizing the challenge as a combination of missing value cleaning and disambiguation problems. \u2022 We propose a semi-supervised method to resolve missing value problem and a novel probability-based approach to disambiguate room locations without using label data. \u2022 We design an efficient caching technique to enable LO-CATER to answer the query in near real-time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 We validate our approach in a real world testbed and The rest of the paper is structured as follows. Section 2 formalizes the data cleaning challenges. Section 3 and 4 describe the coarse and fine localization algorithms. Section 5 describes LOCATER's prototype and caching technique. Section 6 reports experimental results. Section 7 discusses related works and Section 8 concludes the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "In this section, we formalize the two data cleaning challenges in LOCATER: 1) Missing value detection and repairing and 2) Location disambiguation. First, we develop the notation used in the rest of the paper (see in Table 1 ). Space Model. LOCATER aims to semantically localize users within a specific building at a given time. While LO-CATER's space model can be easily generalized to other spatial models, in this paper we partition it in three granularitylevels, from coarse to fine, building, region, room, as follows: Building: The coarsest level of localization relates to whether the user is in the building or not. At building granularity B, we consider two localization options representing whether the person is inside of the building or outside, denoted by B = bin / bout, respectively. We call a device that is inside of the building as online device; otherwise offline device. Region: A building contains a set of regions where each region represents a portion of the building. At region granularity, we consider as localization options all the regions within the building, denoted as G(bin) = {gj : j \u2208 [1...|G|]}. We consider a region gj to be the area covered by the network connectivity of a specific WiFi AP [27] (represented with dotted lines in Fig. 1(a) ). Let W AP = {wapj : j \u2208 [1...|W AP|]} be the set of APs within the building. Hence, |G| = |W AP| and each wapj is related to one and only one gj. In Fig. 1(a) , there exist four APs wap1, ..., wap4 and thus there exist four regions such that G(bin) = {g1, g2, g3, g4}. As shown in the figure, regions can/often do overlap. Room: The finest level of localization relates to the specific room a user is located in. A building contains a set of rooms R = {rj : [1...|R|]} where rj represents the ID of a room within the building -e.g., r1 \u2192 2065. Furthermore, a region gx contains a subset of R. Hence, at room-level granularity and given a specific region gx, the localization options are R(gx) = {rj : [1...|R(gx)|]}. Since regions can overlap, a specific room can be part of different regions if its extent intersects with multiple regions. For instance, in Fig. 1 -(a) room 2059 belongs to both regions g2 and g3.",
            "cite_spans": [
                {
                    "start": 1227,
                    "end": 1231,
                    "text": "[27]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [
                {
                    "start": 217,
                    "end": 224,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 1266,
                    "end": 1275,
                    "text": "Fig. 1(a)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 1427,
                    "end": 1436,
                    "text": "Fig. 1(a)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2136,
                    "end": 2142,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "We consider that rooms in a building have metadata associated that can be leveraged for the localization problem. In particular, we classify rooms into two types: (i) public: shared facilities such as meeting rooms, lounges, kitchens, food courts, etc., that are accessible to multiple users (denoted by R pb \u2286 R); and (ii) private: rooms typically restricted to or owned by certain users such as a person's office (denoted by R = R pb \u222a R pr ). Fig. 1(b) ) Each tuple ei is defined as ei = {eidi, M AC(dj), t l , wap k } where eidi is the id of the specific event logged by wap k at time t l that the device with MAC address M AC(dj) was connected. We refer to an attribute value (e.g., t l ) of a tuple ei using ei.t 2 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 446,
                    "end": 455,
                    "text": "Fig. 1(b)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "We further divide the connectivity events E based on the devices. We denote the connectivity events in E in which a specific device di participated by E(di). We also denote the connectivity events that occur in a time period T by ET = {ej : ti \u2264 ej.t \u2264 tj} where T extends from ti to tj.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "Connectivity events occur stochastically even when devices are stationary and/or the signal strength is stable. Events are typically generated when (i) a device connects to a WiFi AP for the first time, (ii) the OS of the device decides to probe available WiFi APs around, or (iii) when the device changes its status, etc. Hence, connectivity logs do not contain an event for every instant of time a device is connected to the WiFi AP or located in a space. Because of the sporadic nature of connectivity events, we associate to each event a validity period denoted by \u03b4. The value of \u03b4 depends on the actual device dj (in Appendix we show how to estimate \u03b4) and is denoted by \u03b4(dj) (see Fig. 2 for some sample connectivity events of device di). We consider an event en at time tn to be valid in the interval (tn \u2212 \u03b4(di), tn + \u03b4(di)) if its validity interval does not overlap with subsequent events of the same device (e.g., event e0 in Fig. 2) ; otherwise, the validity interval of en is updated to the timestamp of its closest event (e.g., e1 is valid in (t1 \u2212 \u03b4(di), t2) in Fig. 2 ). While we assume that an event is valid for \u03b4 period, there can be portions of time in which no connectivity event is valid in the log for a specific device. We refer to such time periods as gaps. Each gap gapj is associated with gapj.tstr and gapj.t end that correspond to the begin and end times of the gap. Let the two consecutive connectivity events of device di corresponding to gapj be e0 and e1 with associated timestamps t0 and t1 respectively (see Fig 2) . Thus, the start time of the gap gapj.tstr = t0 +\u03b4(di), and furthermore, gapj.t end = t1 \u2212 \u03b4(di). We will alternatively denote gaps based on the timestamp values of the connectivity events they occur: gapt 0 ,t 1 (di). We further define the set of all the gaps in the connectivity log of a device di by GAP (di).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 688,
                    "end": 694,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 937,
                    "end": 944,
                    "text": "Fig. 2)",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1077,
                    "end": 1083,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1543,
                    "end": 1549,
                    "text": "Fig 2)",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "We now define the data cleaning challenges that arise in semantic localization using WiFi connectivity data. Coarse-grained Localization. Let Q = (di, tq) be the query requesting the location of device di at time tq and E be the WiFi connectivity events table. The goal of the coarse level localization is to identify the region gx which di is located in at time tq.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "If tq is within the validity interval of some connectivity event in E, i.e., \u2203 an event en of di in table E where tn \u2212 \u03b4(di) \u2264 tq \u2264 tn + \u03b4(di), then di is assumed to be in the region covered by en.wapx. Otherwise, if tq falls in any gap gapt n,tn+1 (di), the coarse level localization approach needs to determine whether di is inside/outside the building. Then, if di is inside the building, the algorithm needs to determine which region gx is di located in at time tq. The coarse-grained localization problem, thus, consists of first detecting missing values (identifying gaps for WiFi connectivity data of di) and then, repairing missing values of location (i.e., identifying the gx that di is located in) at time tq, if tq is within a gap. Fine-grained Localization. Let Q = (di, tq) be the query requesting location of device di at time tq, given be the output of the coarse-level localization as gx 3 . The goal of the fine-grained localization is to determine the room rj \u2208 R(gx), such that the device di is located in rj.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "Fine localization can be viewed as a location disambiguation problem wherein the goal is to choose (one of the) possible rooms in the region where the device is located (based on the output of the coarse level localization).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FORMALIZING DATA CLEANING CHAL-LENGES"
        },
        {
            "text": "In this section, we discuss how LOCATER addresses the missing value detection and repair associated with the coarselevel localization discussed above. We will assume that the query Q = (di, tq) falls in a gap, else, the coarse level location of di would be covered by the corresponding AP, as discussed above. Determining di's location is not a trivial task. LOCATER estimates this by classifying the corresponding gap as an interval where the device is outside of the building or inside in a specific region. Classification of gaps. To classify gaps, we utilize a semisupervised learning algorithm combined with bootstrapping techniques. The algorithm takes as input a set of historical connectivity events of a particular device di for time period T consisting of N past days, where N is a parameter set experimentally (discussed more in Section 6). Let GAPT (di) be the set of all gaps in ET (di). For each gapj \u2208 GAPT (di), let tstr.time (t end .time) and tstr.date (t end .date) refer to the time and date corresponding to the timestamps. Likewise, let tstr.day (and t end .day) refer to the day of the week 4 . We extract the following features for each gap gapj and represent them as a vector:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 gapj.tstr.time, gapj.t end .time: corresponding to the begin and end time of gapj.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 duration \u03b4(gapj): representing the duration of the gap (i.e., gapj.t end .time \u2212 gapj.tstr.time). \u2022 gapj.tstr.day (gapj.t end .day): representing the day of the week in which gapj occurred (ended).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 gapj.gstr, gapj.g end : corresponding to the region associated when the event occurred at tstr and ended at t end .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 connection density \u03c9: representing the average number of logged connectivity events for the device di during the same time period of a gapj for each day in T . LOCATER uses a semi-supervised learning method, combined with bootstrapping techniques, to train two logistic regression classifiers based on such vectors to label gaps: 1) As inside/outside and 2) Within a specific region, if inside. Bootstrapping. The bootstrapping process labels a gap as inside or outside the building by using heuristics that take into consideration the duration of the gap (short gaps inside and long gaps outside). In particular, we set two thresholds, \u03c4 l and \u03c4 h , such that a gap is labeled as bin if \u03b4(gapj) \u2264 \u03c4 l and as bout if \u03b4(gapj) \u2265 \u03c4 h (different values of \u03c4 l and \u03c4 h are tested in Section 6). If the duration of a gap is between \u03c4 l and \u03c4 h , then we cannot label it as either inside/outside using the above heuristic, and such gaps are marked as unlabeled. We, thus, partition the set of gaps of device di, i.e., GAPT (di) into two subsets -S labeled , S unlabeled . For gaps in S labeled that are classified as inside of the building, to further label them with a region at which the device is located, the heuristic takes into account the start and end region of the gap. This is done as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 If gapj.gstr = gapj.g end , then the assigned labeled is gapj.gstr (in other words, if the regions at the start and end of the gap are the same, the device is considered to be in the same region (i.e., gapj.gstr) for the entire duration of the gap). \u2022 Otherwise, we assign as label a region g k which corresponds to the most visited region of di in connectivity events E(di) that overlap with the gap (i.e., whose connection time is between gapj.tstr.time and gapj.t end .time).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "Semi-supervised learning. We use semi-supervised learning to label the remaining (unlabeled) gaps S unlabeled \u2286 GAPT (di), as described in Algorithm 1. In particular, for each device di, we learn logistic regression classifiers on S labeled (function TrainClassifier(S labeled ) in Algorithm 1), which are then used to classify the unlabeled gaps associated with the device 5 . Algorithm 1 is firstly executed at building level to learn a model to classify if an unlabeled gap is inside/outside the building. To this end, let L be the set of possible training labels -i.e., inside/outside the building. The method Predict(classif ier, gap), returns an array of numbers from 0 to 1, where each number represents the probability of the gap being assigned to a label in L (all numbers in the array sum up to 1), and the label with highest probability in the array. In the array returned by Predict, a larger variance means that the probability of assigning a certain label to 5 We assume that connectivity events exist for the device in the historical data considered, as is the case with our data set. If data for the device does not exist, e.g., if a person enters the building for the first time, then, we can label such devices based on aggregated location, e.g., most common label for other devices. this gap is higher than other gaps. Thus, we use the variance of the array as the confidence value of each prediction. In each outer iteration of the loop (lines 1-11), as a first step, a logistic regression classifier is trained on S labeled . Then, it is applied to all gaps in S unlabeled . For each iteration, the gap with the highest prediction confidence is removed from S unlabeled and added to S labeled along with its predicted label. This algorithm terminates when S unlabeled is empty and the classifier trained in the last round will be returned. The same process is then followed to learn a model at the region level for gaps labeled as inside the building. In this case, when executing the algorithm L contains the set regions in the building (i.e., G(bin)). The output is a classifier that can label a gap with the region where the device might be located.",
            "cite_spans": [
                {
                    "start": 973,
                    "end": 974,
                    "text": "5",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "Algorithm 1: Semi-supervised learning algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "Given the two trained classifiers, for each query in which the associated device di is in a gap, we first use the inside/outside classifier to classify the gap as inside or outside of the building. If the gap is classified as outside, then the query can be answered as the location of the device will be outside. Otherwise, we further classify the gap using the region classifier to obtain its associated region. Then, the device will be located in such region and LOCATER will perform the room-level fine-grained localization as we will explain in the following section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "COARSE-GRAINED LOCALIZATION"
        },
        {
            "text": "Given a query Q = (di, tq) where di is localized in region gx at time tq (e.g., as predicted by the coarse-level localization algorithm), this step determines the specific room rj \u2208 R(gx) where di is located at time tq.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FINE-GRAINED LOCALIZATION"
        },
        {
            "text": "As shown in Fig. 1(b) , events e1, e2, are logged for two devices d1 and d2 with MAC addresses 7fbh and 3ndb, respectively. Assume that we aim to identify the room in which device d1 was located at 2019-08-22 13:04. Given that d1 was connected to wap3 at that time, the device should have been located in one of the rooms in that region g3 -i.e., R(g3) = {2059, 2061, 2065, 2069, 2099}. These are called candidate rooms of d1 (we omit the remaining candidate rooms: 2066, 2068, 2072, 2074, and 2099 for simplicity). The main goal of the fine-grained location approach, is to identify in which candidate room d1 was located. Affinity. LOCATER bases its fine-grained location prediction on the concept of affinity which models relationships between devices and rooms.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 12,
                    "end": 21,
                    "text": "Fig. 1(b)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "FINE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 Room affinity: \u03b1(di, rj, tq) denotes the affinity between a device di and a room rj (i.e., the chance of di being located in rj at time tq), given the region gx i in which di is located at time tq.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FINE-GRAINED LOCALIZATION"
        },
        {
            "text": "\u2022 Group affinity: \u03b1(D, rj, tq) represents the affinity of a set of devices D to be in a room rj at time tq (i.e., the chance of all devices in D being located in rj at tq), given that device di \u2208 D is located in region gx i at time tq.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FINE-GRAINED LOCALIZATION"
        },
        {
            "text": "Note that the concept of group affinity generalizes that of room affinity. While room affinity is a device's conditional probability of being in a specific room, given the region it is located in, group affinity of a set of devices represents the probability of the the set of devices being co-located in a specific room rj at tq. We differentiate between these since methods we use to learn these affinities are different as will be discussed in the following section. We first illustrate how affinities affect localization prediction using the example in Fig. 3 , which shows a hypergraph representing room and group affinities at time tq. For instance, an edge between d1 and the room 2065 in the figure shows the affinity \u03b1(d1, 2065, tq) = 0.3. Likewise the hyperedge d1, d2, 2065 with the label 0.12 represents the group affinity, represented as \u03b1({d1, d2}, 2065, tq) = 0.12 6 . If at time tq device d2 is not online (i.e., there are no events associated with d2 at tq in that region), we can predict that d1 is in room 2061 since d1's affinity to 2061 is the highest. On the other hand, if d2 is online at tq, the chance that d1 is in room 2065 increases due to the group affinity \u03b1({d1, d2}, 2065, tq) = 0.12. The location prediction for a device di, thus, must account for both room affinity between the device and rooms, and also group affinity between groups of devices and rooms. Room Probability. Let P r(di, rj, tq) be the probability that a device di is in room rj at time tq. Given a query Q = (di, tq) and R(gx), the goal of the fine-grained location prediction algorithm is to find the room rj \u2208 R(gx) of di at time tq, such that rj has the maximum P r(di, rj, tq), \u2200rj \u2208 R(gx). We develop such an algorithm based on estimating P r(di, rj, tq) based on both room and group affinities in Section 9.2. However, before we discuss the algorithm, we first describe how affinity values are estimated in Section 4.1.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 557,
                    "end": 563,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "FINE-GRAINED LOCALIZATION"
        },
        {
            "text": "Learning Room Affinity. One of the challenges in estimating room affinity is the potential lack of historical roomlevel location data for devices -collecting such a data would be prohibitively expensive, specially when we consider large spaces with tens of thousands of people/devices as in our setting. Our approach, thus, does not assume availability of room-level localization data which could have been used to 6 Affinity computation is discussed in Section 4.1.",
            "cite_spans": [
                {
                    "start": 415,
                    "end": 416,
                    "text": "6",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Affinity Learning"
        },
        {
            "text": "train specific models 7 . Instead, we compute it based on the available background knowledge and space metadata.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Affinity Learning"
        },
        {
            "text": "To compute \u03b1(di, rj, tq), we associate for each device di a set of preferred rooms R pf (di) -e.g., the personal room of di's owner (space metadata), or the most frequent rooms di's owner enters (background knowledge). R pf (di) is an empty set if di's owner does not have any preferred rooms. If rj is one the preferred rooms of di (rj \u2208 R pf (di)), we assign to rj the highest weight denoted by w pf . Similarly, if rj is a public room (rj \u2208 (R(gx) \u2229 R pb ) R pf (di)), we assign to rj the second highest weight denoted by w pb . Finally, if rj is a private room (rj \u2208 (R(gx) \u2229 R pr ) R pf (di)), we assign to rj the lowest weight denoted by w pr . In general, these weights are assigned only if the following conditions are satisfied: (1) w pf > w pb > w pr and (2) w pf + w pb + w pr = 1. The influence of different combinations of w pf , w pb , w pr is evaluated in Section 6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Affinity Learning"
        },
        {
            "text": "We illustrate the assignment of these weights by using the graph of our running example. As already pointed out, d1 connects to wap3 of region g3, where R(g3) = {2059, 2061, 2065, 2069, 2099}. In addition, d1's office room 2061 is the only preferred room (R pf (d1) = {2061}) and 2065 is a public room (meeting room). Therefore, the remaining rooms in R pf (d1) are other personal offices associated with other devices. Based on Fig. 3 , a possible assignment of w pf , w pb , w pr to the corresponding rooms is as follows:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 429,
                    "end": 435,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Affinity Learning"
        },
        {
            "text": "shares the same room affinity, which is w pr 3 = 0.066. Note that since room affinity is not data dependent, we can pre-compute and store it to speed up computation. Furthermore, preferred rooms could be time dependent (e.g., user is expected to be in the break room during lunch, while being in office during other times). Such a time dependent model would potentially result in more accurate room level localization if such metadata was available. Learning Group Affinity. Before describing how we compute group affinity, we first define the concept of device affinity, denoted by \u03b1(D) which intuitively captures the probability of devices/users to be part of a group and be co-located (which serves as a basis to compute group affinity). Consider all the connectivity events E. Let E(di) be the set of events corresponding to device di \u2208 D, and E(D) be the connectivity events of devices in D. Consider the set of connectivity events such that for each event e \u2208 E(di), belonging to that set, and for every other device dj \u2208 D\\di, there exists a connectivity event e \u2208 E(dj) where e .t is within the validity interval of e and both devices are connected to the same AP, i.e., |e .t \u2212 e.t| \u2264 \u03b4(di) and e .wap = e.wap. Intuitively, such an event set represents the times when all the devices in D are in the same area (since they are connected to the same WiFi AP). We compute device affinity \u03b1(D) as a fraction of such intersecting events among all events in E(D).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Affinity Learning"
        },
        {
            "text": "Given device affinity \u03b1(D), we can now compute the group affinity among devices D in room rj at time tq ,i.e., \u03b1(D, rj, tq). Let Ris be the set of intersecting rooms of connected regions for each device in D at time tq 8 : Ris = R(ei.g), ei \u2208 7 Extending our approach when such data is obtainable, at least some a subset of devices, through techniques such as crowd-sourcing, is interesting and part of our future work. 8 Note that, devices in D can be connected to different APs at time tq but still all be located in the same space as re-Et q (D). If rj is not one of the intersecting rooms, rj / \u2208 Ris, then \u03b1(D, rj, tq) = 0. Otherwise, to compute \u03b1(D, rj, tq), we first determine conditional probability of a device di \u2208 D to be in rj given that rj \u2208 Ris at time tq.",
            "cite_spans": [
                {
                    "start": 420,
                    "end": 421,
                    "text": "8",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Affinity Learning"
        },
        {
            "text": "Let @(di, rj, tq) represent the fact that device di is in room rj at time tq, and likewise @(di, Ris, tq) represent the fact that di is in one of the rooms in Ris at tq. P (@(di, rj, tq)|@(di, Ris, tq)) = P (@(d i ,r j ,tq )) P (@(d i ,R is ,tq )) , where P (@(di, Ris, tq)) = r k \u2208R is P (@(di, r k , tq) ). We now compute \u03b1(D, rj, tq), where rj \u2208 Ris as follows:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 289,
                    "end": 305,
                    "text": "(@(di, r k , tq)",
                    "ref_id": null
                }
            ],
            "section": "Affinity Learning"
        },
        {
            "text": "Intuitively, group affinity captures the probability of the set of devices to be in a given room (based on the room level affinity of individual devices) given that the (individual's carrying the) devices are collocated, which is captured using the device affinity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Affinity Learning"
        },
        {
            "text": "We explain the notation using the the example in Fig. 3(b) . Let us assume that the device affinity between d1 and d2 (not shown in the figure) is ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 49,
                    "end": 58,
                    "text": "Fig. 3(b)",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 136,
                    "end": 143,
                    "text": "figure)",
                    "ref_id": null
                }
            ],
            "section": "Affinity Learning"
        },
        {
            "text": "Given a query Q = (di, tq) and candidate rooms R(gx), we compute the room probability P r(di, rj, tq) for each rj \u2208 R(gx) and select the room with highest probability as an answer to Q. Based on the room and group affinities, we first define the concept of the set of neighbor devices of di, denoted by Dn(di). A device d k \u2208 Dn(di) is a neighbor of di if: (i) d k is online at time tq(inside the building); (ii) \u03b1({di, d k }, rj, tq) > 0 for each rj \u2208 R(gx); and (iii) R(gx) \u2229 R(gy) = \u2205, where R(gy) is the region that d k is located in. In Fig 3(b) , d2 is a neighbor of d1. Essentially, neighbors of a device di could influence the location prediction of di (since they will contribute a non-zero group affinity for di)",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 539,
                    "end": 550,
                    "text": "In Fig 3(b)",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Localization Algorithm"
        },
        {
            "text": "Since we use the concept of neighbor always in the context of a a device Di, we will simplify the notation and refer to Dn(di) as Dn. Since processing every device in Dn can be computationally expensive, the localization algorithm considers the neighbors iteratively until there is enough confidence that the unprocessed devices will not change the current answer. LetDn \u2286 Dn be the set of devices that the algorithm has processed. We denote P (rj|Dn) the probability of rj being the answer of Q given the devices and their locations inDn 9 that have been processed by the algorithm so far. Using Bayes's rule: P (rj|Dn) = P (Dn|rj)P (rj) P (Dn|rj)P (rj) + P (Dn|\u00acrj)P (\u00acrj)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "(2)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "where we estimate P (rj) using the room affinity \u03b1(di, rj, tq).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "gions covered by APs might be overlapping as explained in Section 2). 9 Note that we could express the above using the notation discussed in Section 4.1 as P (@(di, rj, tq)|Dn). We use the simplified notation for brevity of formulas later. rj being the answer of query Q means di is in rj at time tq, and we write rj here for simplicity. We first compute P (rj|Dn), under the simplifying assumption that probability of di to be in room rj given any two neighbors in Dn is conditionally independent. We then consider the case when multiple neighbor devices may together influence the probability of di to be in a specific room rj.",
            "cite_spans": [
                {
                    "start": 70,
                    "end": 71,
                    "text": "9",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "%neighbor devices Dn we consider two cases as below. Independence Assumption: Since we have assumed conditional independence: P (Dn|rj) = d k \u2208Dn P (@(d k , rj, tq)|rj) where @(d k , rj, tq) represents that d k is located in rj at time tq. By definition, P (@(d k , rj, tq)|rj) = P (@(d k ,r j ,tq ),r j ) P (r j )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": ". The numerator represents the group affinity, i.e., P (@(d k , rj, tq), rj) = \u03b1({d k , di}, rj, tq). Similarly, P (\u00ac(@(d k , rj, tq), \u00acrj) = 1 \u2212 \u03b1({d k , di}, rj, tq), and thus:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "To guarantee that our algorithm determines the answer of Q by processing the minimum possible devices inDn, we compute the minimum, maximum and expected probability of rj being the answer based on neighbor devices in Dn.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "To compute these probabilities, not only we consider the processed devicesDn, but also unprocessed devices Dn \\Dn. Thus, we consider all the possible room locations (given by coarse-location) for unprocessed devices. We denote the set or all possibilities for locations of these devices (i.e., the set of possible worlds [2]) by W(Dn \\Dn). For each possible world W \u2208 W(Dn \\Dn), let P (W ) be the probability of the world W and P (rj|Dn, W ) be the probability of rj being the answer of Q given the observations of processed devices Dn and the possible world W . We now formally define the expected/max/min probability of rj given all the possible worlds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Definition 1. Given a query Q = (di, tq), a region R(gx), a set of neighbor devices Dn, a set of processed devicesDn \u2286 Dn and the candidate room rj \u2208 R(gx) of di, the expected probability of rj being the answer of Q, denoted by expP (rj|Dn), is defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "In addition, the maximum probability of rj, denoted by maxP (rj|Dn, W ), is defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "similarly, the minimum probability can be defined. The algorithm terminates the iterations only if there exists a room ri \u2208 R(gx), for any other room rj \u2208 R(gx), ri = rj, such that minP (ri|Dn) > maxP (rj|Dn). However, it is often difficult to satisfy such strict condition in practice. Thus, we relax this condition using the following two conditions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "1. minP (ri|Dn) > expP (rj|Dn)(or P (rj|Dn)) 2. expP (ri|Dn)(or P (ri|Dn)) > maxP (rj|Dn)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "In Section 6 we show that these loosen conditions enable the algorithm to terminate efficiently without sacrificing the quality of the results.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Next, the key question that arises is, how do we compute these probabilities efficiently? To compute the maximum probability of di being in rj, we can assume that all unprocessed devices are in room rj as described in the theorem below. (All the proofs of theorems are shown in Appendix.)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Theorem 1. Given a set of already processed devicesDn, a candidate room rj of di and the possible world W where all devices Dn \\Dn are in room rj, then, maxP (rj|Dn) = P r(rj|Dn, W ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Likewise, to compute the minimum probability, we can simply assume that none of the unprocessed devices are in room rj. The following theorem states that we can compute the minimum by placing all the unprocessed devices in the room (other than rj) in which di has the highest chance of being at time tq (that is, the highest probability of being the answer, other than rj).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Theorem 2. Given a set of already processed devicesDn, a candidate room rj \u2208 R(gx), rmax = argmax r i \u2208R(gx)\\r j P (ri|Dn) and a possible world W where all devices in Dn \\ Dn are in room rmax, then, minP (rj|Dn) = P (rj|Dn, W ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "For the expected probability of rj being the answer of Q, we prove that it equals to P (rj|Dn).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Theorem 3. Given a set of independent devices Dn, the set of already processed devicesDn and the candidate room rj, then, expP (rj|Dn) = P (rj|Dn).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Relaxing the Independence Assumption: We next consider relaxing the conditional independence assumption we have made so far. In this case, we cannot treat each neighbor device independently. Instead, we divideDn into several clusters where every neighbor device in a cluster have nonzero group affinity with the rest of the devices. LetD nl \u2286 Dn be a cluster where \u2200d k , d k \u2208D nl , \u03b1({d k , d k }, rj, tq) > 0. In addition, group affinity of devices of any pair of devices in different clusters equals zero, i.e., \u2200d k \u2208D nl , d k \u2208 D nl , where l = l , \u03b1({d k , d k }, rj, tq) = 0. In Fig 4(b) , Dn1 = {d2, d3, d4} andDn2 = {d5, d6}. Naturally, we hav\u0113 Dn = lD nl . In this case, we assume that each cluster affects the location prediction of di independently.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 588,
                    "end": 596,
                    "text": "Fig 4(b)",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Localization Algorithm"
        },
        {
            "text": "Thus, the probability P (Dn|rj) = l P (D nl |rj). For each cluster, we compute its conditional probability P (D nl |rj) = P (D nl ,r j ) P (r j ) , where P (D nl , rj) = \u03b1({D nl , di}, rj, tq). The reason is that P (D nl , rj) is the probability that all devices in D nl and di are in room rj, which equals \u03b1({D nl , di}, rj, tq) by definition. Thus,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "the algorithm terminates when the group affinity for any cluster turns zero. Finally, we describe the complete fine-grained location cleaning algorithm in Algorithm 2. Given Q = (di, tq), we observe only the neighbor devices at time tq. (Line 4-5)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "Algorithm 2: Fine-grained Localization Input: Q = (di, tq), Dn, E, R(gx) 1 Stop f lag \u2190 false; 2Dn \u2190 \u2205; 3 for d k \u2208 Dn do 4Dn \u2190 d k ; 5 for rj \u2208 R(gx) do 6 Compute P (rj |Dn); 7 if Dn independent then 8 Find top-2 probability P (ra|Dn), P (r b |Dn); 9 Compute minP (ra|Dn), maxP (ra|Dn), expP (ra|Dn); 10 Compute minP (r b |Dn), maxP (r b |Dn), expP (r b |Dn); 11 if minP (ra|Dn) \u2265 expP (r b |Dn) or expP (ra|Dn) \u2265 maxP (r b |Dn) then Next, we compute the probability of P (rj|Dn) for every candidate room in R(gx) (Line 7-8). If devices are independent, we select two rooms with top-2 probability and use loosen stop condition to check if the algorithm converges (Line [10] [11] [12] [13] [14] . Otherwise, we check if all clusters have zero group affinity (Line 15-17). Finally, we output the room when the stop condition is satisfied (Line 13-16).",
            "cite_spans": [
                {
                    "start": 134,
                    "end": 135,
                    "text": "5",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 154,
                    "end": 155,
                    "text": "6",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 176,
                    "end": 177,
                    "text": "7",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 250,
                    "end": 251,
                    "text": "9",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 302,
                    "end": 304,
                    "text": "10",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 361,
                    "end": 363,
                    "text": "11",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 670,
                    "end": 674,
                    "text": "[10]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 675,
                    "end": 679,
                    "text": "[11]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 680,
                    "end": 684,
                    "text": "[12]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 685,
                    "end": 689,
                    "text": "[13]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 690,
                    "end": 694,
                    "text": "[14]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Localization Algorithm"
        },
        {
            "text": "In this section, we describe the prototype of LOCATER built based on the previous coarse-grained and fine-grained localization algorithms. Also, we describe a caching engine to scale LOCATER to large connectivity data sets. Architecture of LOCATER. Fig. 5 shows the high-level architecture of the LOCATER prototype. LOCATER ingests a real-time stream of WiFi connectivity events (as discussed in Section 2). Additionally, LOCATER takes as input metadata about the space which includes the set of WiFi APs deployed in the building, the set of rooms in the building (including whether each room is a public or private space -see Section 2-), the coverage of WiFi APs in terms of list of rooms covered by each AP, and the temporal validity of connectivity events per type of device in the building 10 .",
            "cite_spans": [
                {
                    "start": 795,
                    "end": 797,
                    "text": "10",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 249,
                    "end": 255,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "LOCATER supports queries of the form Q = (di, tq) that request the location of device di at time tq, where tq could be the current time (e.g., for real-time tracking/personalized 10 Appendix 9 describes how this metadata can be obtained in practice for a real deployment of LOCATER. Figure 6 : Generation of global affinity graph (d) from local affinity graphs (a,b,c) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 283,
                    "end": 291,
                    "text": "Figure 6",
                    "ref_id": null
                },
                {
                    "start": 361,
                    "end": 368,
                    "text": "(a,b,c)",
                    "ref_id": null
                }
            ],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "services) or a past timestamp (e.g., for historical analysis). Given Q, LOCATER's cleaning engine determines if tq falls in a gap. If so, it executes the coarse-grained localization (Section 3). If at tq, di was inside the building, the cleaning engine performs the fine-grained localization (Section 4). Scaling LOCATER. The cleaning engine computes room and group affinities which requires time-consuming processing of historic data. Algorithm 2 iteratively performs such computation for each neighbor device of the queried device.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "In deployments with large WiFi infrastructure and large number of users, this might involve processing connectivity events of large number of devices which can be a challenge if applications expect real-time answers. LOCATER caches computations performed to answer queries and leverages this information to answer subsequent queries. Such cached information constitutes what we will refer to as a global affinity graph G g = (V g , E g ), where nodes correspond to devices and edges correspond to pairwise device affinities. Given a query Q = (di, tq), LOCATER uses the global affinity graph G g to determine the appropriate order in which neighbor devices to di have to be processed. Intuitively, devices with higher device affinity w.r.t. di have higher impact on the computation of the fine-grained location of di (e.g., a device which is usually collocated with di will provide more information about di's location than a device than a device that just appeared in the dataset). We empirically show in our experiments (see Section 6) that processing neighbor devices in decreasing order of device affinity instead of a random order makes the cleaning algorithm converge much faster.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "(1) Building local affinity graph. The affinities computed in Section 4 can be viewed as a graph, which we refer to as local affinity graph G l = (V l , E l ), where V l =Dn \u222a di. In this time-dependent local affinity graph, each device inDn as well as the queried device di are nodes and the edges represent their affinity. Let e l ab \u2208 E l be an edge between nodes da and d b and w(e l ab , tq) be its weight measuring the probability that da and d b are in the same room at time tq. The value of w(e l ab , tq) is computed based on Algorithm 2 as w(e l ab , tq) =",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "(2) Building global affinity graph. After generating a local affinity graph for di at time tq, this information is used to update the global affinity graph. We will illustrate the process using Fig. 6 . Given the current global affinity graph G g = (V g , E g ) and a local affinity graph G l = (V l , E l ), the updated global affinity graph G g = (V g ,\u00ca g ) is such that V g = V g \u222a V l and\u00ca g = E g \u222a E l . Note that, as affinity graphs are time-dependent, in the global affinity graph we associate each edge included from an affinity graph with its times-tamp tq along with its weight. Hence, in the global affinity graph, the edge in between two nodes is a vector which stores the weight-timestamp pairs associated with different local affinity graphs v g ab = {(w(e l ab ), t1), ..., (w(e l ab ), tn)}. When merging the edge set, we merge corresponding vectors -i.e., v g ab = v g ab \u222a w(e l ab , tq) for every e g ab \u2208 E g . For instance, in the global affinity graph in Fig. 6(d) , which has been constructed from three different local affinity graphs (Fig. 6(a),(b),(c) ), the edge that connects nodes d1 and d2 has the weighttimestamp values extracted from each local affinity graph (.4, t1), (.3, t2) , (.5, t3).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 194,
                    "end": 200,
                    "text": "Fig. 6",
                    "ref_id": null
                },
                {
                    "start": 979,
                    "end": 988,
                    "text": "Fig. 6(d)",
                    "ref_id": null
                },
                {
                    "start": 1061,
                    "end": 1079,
                    "text": "(Fig. 6(a),(b),(c)",
                    "ref_id": null
                },
                {
                    "start": 1194,
                    "end": 1212,
                    "text": "(.4, t1), (.3, t2)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "(3) Using global affinity graph. When a new query Q = (di, tq) is posed, our goal is to identify the neighbor devices that share high affinities with di and use them to compute the location of di using Algorithm 2. Given Dn, the set of neighbor devices to di at time t1, we compute the affinity between di and each device d k \u2208 Dn, denoted by w(e g ik , tq), using the global affinity graph. As each edge in the global affinity graph contains a vector of affinities wrt time, we compute affinity by assigning a higher value to those instances that are closer to the query time tq as follows: w(e g ik , tq) = j=n j=1 ljw(e l ik , tj), where lj follows a normal distribution, \u00b5 = tq and \u03c3 2 = 1 that is normalized. Finally, we create a new set of neighbor devices N g (di) and include each device d k \u2208 Dn in descending order of the computed affinity w(e g ik , tq). This new set replaces Dn in Algorithm 2, which means that the iterative algorithm will process first the devices with a higher affinity in the global affinity graph.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LOCATER SYSTEM"
        },
        {
            "text": "We implemented a prototype of LOCATER and performed experiments to test its performance in terms of quality of the cleaned data, efficiency, and scalability. The experiments were executed in an 8 GB, 2 GHz Quad-Core Intel Core i7 machine and with a real dataset as well as a synthetic one. In the following we refer to the implementation of LOCATER's fine-grained algorithms based on independent and relaxing independent(dependent) assumptions as I-FINE and D-FINE. Correspondingly, we will refer to the system using those algorithms as I-LOCATER and D-LOCATER, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "EVALUATION"
        },
        {
            "text": "Dataset. To validate LOCATER, we used connectivity data captured by the TIPPERS system [21] in our Donald Bren Hall building at UC Irvine, with 64 WiFi APs, 300+ rooms (including classrooms, offices, conference rooms, etc.) and an average daily occupancy of about 3,000. On average, each WiFi AP covers 11 rooms. The dataset (in the following DBH-WIFI) contains 6 months of data, from Jan. 22nd, 2018 to July 8th comprising 38, 670, 714 connectivity events for 94, 764 different devices. Ground truth. Validating LOCATER required us to collect ground truth about fine-grained location of individuals, which is a challenging process and was achieved in the following two ways. First, we asked 9 participants to log their daily activity within the building (the room where they were located and how much time they spent in it) for a week. The participants filled in comprehensive and precise logs of their activity amounting to 422 hours in total. Second, we selected three cameras in the building that cover three different types of spaces (i.e., faculty offices area, student offices area, and lounge space). We manually reviewed all the camera footage to identify individuals in it (the area covered is in our portion of the building so we identified 13 individuals known to us -5 of them were also participants of the daily activity logging-) and their location. We requested the identified individuals for the MAC address of their devices. This way, if a person p with MAC address m was observed to enter a room r at time t1 and leaving the room at time t2, we created an entry in our ground truth locating m in room r during the interval (t1, t2). Queries. We generated a set of 5, 008 queries, denoted by Q, related to individuals in the ground truth (3, 129 queries for participants that logged their activities and 1, 879 queries for individuals detected in the camera images). The number of queries per individual are approximately the same, as far as differences in the labeled elements per user allow it.",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 91,
                    "text": "[21]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Setup"
        },
        {
            "text": "Baselines. Traditional indoors localization algorithms are either based on active localization or passive localization using information such as signal strength maps (as explained in Section 1). Hence, we defined two baselines used in practice for the kind of semantic localization described in this paper (i.e., coarse and fine-grained level localization based on connectivity logs and background information). The baselines are defined as follows: Baseline1 and Baseline2 use Coarse-Baseline for coarse localization and for fine-grained localization they use Fine-Baseline1 and Fine-Baseline2, respectively. In Coarse-Baseline, the device is considered outside if the duration of a gap is at least one hour, otherwise the device is inside and the predicted region is the same as the last known region. Fine-Baseline1 selects the predicted room randomly from the set of candidates in the region whereas Fine-Baseline2 selects the room associated to the user based on metadata (e.g., his/her office). Quality metric. We used precision as the quality metric. Considering a query set Q, let Qout, Qregion, Qroom be the query sets where LOCATER returns correctly the answer to be outside, a specific region, and a specific room, respectively. We define the precision of the coarse-grained algorithm as Pc = (|Qout| + |Qregion|)/|Q|, of the fine-grained algorithm as P f = |Qroom|/|Qregion|, and of the overall system as Po = (|Qroom| + |Qout|)/|Q|.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Setup"
        },
        {
            "text": "In this experiment, we test the performance of LOCATER, in terms of precision, for the DBH-WIFI dataset. As LO-CATER exploits the notion of recurring patterns of movement/usage of the space, we analyze the performance wrt the level of predictability of different user profiles. We consider the fact that some people spend most of their time in the building in the same room (e.g., their offices or a classroom) as a sign of predictable behaviour. We can consider this as their \"preferred room\". We group individuals in the dataset into 4 classes based on the percentage of time they Impact of thresholds in coarse localization. The algorithms presented for coarse and fine-grained localization require certain configurable parameters. We analyze the impact of those in the performance of the system. The coarselevel localization algorithm to detect whether a device is inside the building or not during a gap depends upon two thresholds: \u03c4 l and \u03c4 h . We vary \u03c4 l 's value from 10 to 30 minutes and \u03c4 h 's value from 60 to 180 minutes. We fix \u03c4 h = 180 when running experiments for \u03c4 l and fix \u03c4 l = 20 when running experiments for \u03c4 h . From Fig. 7 we observe that, with the increasing of \u03c4 l , the precision increases first and then slightly decreases after it peaks at \u03c4 l = 20. For \u03c4 h , when it increases, precision gradually increases and levels off when \u03c4 h is beyond 170. The algorithm that determines the region in which the device, computed to be inside of the building, is, requires two parameters: \u03c4 l and \u03c4 h . We tested different settings and observed a similar performance with \u03c4 l = 20 and \u03c4 h = 40 obtaining the best results. Impact of weights of room affinity. In this part we examine the impact of weights used in computing room affinity, w pf , w pb , w pr . Table 2 1}. We observe that all the combinations for both I-FINE and D-FINE obtain a similar precision (with C2 achieving a slightly higher accuracy). Hence, the algorithm is not too sensitive to the weight distributions in this test. Also, D-FINE outperforms I-FINE by 4.6% on average. Impact of historical data. We use historical data to train the models in the coarse algorithm and to learn the affinities in the fine algorithm. We explored how the amount of historical data used affects the performance of LOCATER. We report the coarse, fine, and overall precision for the [40,55)% and [55,70)% predictability groups, in Fig. 8(a) , Fig. 8(b) , and Fig. 8(c) , respectively. The graphs plot the accuracy of the algorithm with increasing amount of historical data, from no data at all up to 9 weeks of data. The precision of the coarse-grained algorithm increases with increasing amount of historical data and it reaches a plateau when 8 weeks of data are used. The reason is that the semi-supervised learning algorithm used to train the model becomes more generalized the more data is used for the training. In the case of the fine-grained algorithm, the performance is poor when no historical data is used (as this effectively means selecting the room just based on its type). However, when just one week of historical data is used the performance almost doubles. The accuracy keeps increasing with increasing number of weeks of data though the plateau is reached when three weeks of data are used. The results show that the kind of affinities computed by the algorithm are temporally localized. The overall performance of the system follows a similar pattern. With no data, mistakes made by the fine-grained localization algorithm penalize the overall performance. With increasing amount of historical data, the performance increases due to the coarse-grained algorithm labeling gaps more correctly. In all the graphs, the performance of the overall system and its algorithms increases with increasing level of predictability of users (we will explore this further in the following). Impact of caching. We examine how the fine-grained algorithm's caching technique (see Section 4) affects the precision of the system. We compute the precision of both I-LOCATER and D-LOCATER compared to their counterparts using caching I-LOCATER+C and D-LOCATER+C. Fig. 9 (a) plots the overall precision of the system averaged for all the tested users. We observe that adding caching incurs in a reduction of the precision from 5%-10%, which does not significantly affect the performance. This means that the device processing order generated by caching technique maintains a good precision while decreasing the cleaning time (as we will explore in Section 6.4). Comparison with baselines. We compare precision of LOCATER against the two baselines described before, and use 8 weeks of historical connectivity data. Table 3 reports the results, and each cell in the table contains three values: Pc, P f , Po. We round up all the values due to space limitation. We observe that both I-LOCATER and D-LOCATER significantly outperform Baseline1 regardless of the predictability level of people. This is due to the criteria to select the room in which the user is located when performing finegrained localization. Deciding this at random works sometimes in situations where the AP covers a small set of large rooms but incurs in errors in situations where an AP covers a large set of rooms (e.g., in our dataset up to 11 rooms are covered by the same AP). Baseline2 uses an strategy where this decision is made based on selecting the space where the user spends most of his/her time, if that space is in the region where the user has been localized. This strategy only works well with very predictable people and therefore LOCATER outperforms Baseline2 in every situation except for the highest predictable group where Baseline2 obtains a slightly better precision. As observed in the previous experiment, the precision of D-LOCATER is consistently higher than I-LOCATER. However, both of them perform signif- icantly better than the baselines except for the situation highlighted before.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1143,
                    "end": 1149,
                    "text": "Fig. 7",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 1779,
                    "end": 1786,
                    "text": "Table 2",
                    "ref_id": "TABREF5"
                },
                {
                    "start": 2404,
                    "end": 2413,
                    "text": "Fig. 8(a)",
                    "ref_id": null
                },
                {
                    "start": 2416,
                    "end": 2425,
                    "text": "Fig. 8(b)",
                    "ref_id": null
                },
                {
                    "start": 2432,
                    "end": 2441,
                    "text": "Fig. 8(c)",
                    "ref_id": null
                },
                {
                    "start": 4134,
                    "end": 4140,
                    "text": "Fig. 9",
                    "ref_id": null
                },
                {
                    "start": 4684,
                    "end": 4691,
                    "text": "Table 3",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "Precision on DBH-WIFI Dataset"
        },
        {
            "text": "In order to explore the generality of LOCATER and its applicability to scenarios other than the building we tested it on, we test LOCATER on synthetic connectivity datasets. Generating synthetic datasets. We generate WiFi connectivity datasets of different scenarios using the Smart-Bench simulator [1]. Predictability of users' behaviours, understood as the degree to which we can predict a person's location given historical data, is an important aspect, as reflected above. The SmartBench simulator enables us to configure that aspect by defining a space, a set of users, and their interactions (in terms of spatio-temporal events associated with different rooms in the space that different users attend). With this, the simulator generates realistic trajectories of people in the space. By defining access points in their space, along with their coverage area, the simulator generates also connectivity events based on user trajectories.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Precision on Simulated Scenarios"
        },
        {
            "text": "For that reason, we generated datasets emulating realistic interactions of different types of people with the space considered. The developed tool generates connectivity data based on trajectories of people who move around the space to attend events. It considers the effect of indoor topology on the object (device) movement in indoor space based on the specific floor map. Events have an associated spatiotemporal footprint -they are associated with spaces over time. For instance, in a University setting, an event may be a class or a meeting that periodically repeats. Likewise, in an airport setting, catching a specific flight might be an event. People, based on their profiles, have a probability of participating in events. Such a participation is subject to constraints. For instance, in a class, number of students associated may be limited to be below a maximum enrollment. Likewise, only a single faculty may be associated with a class. Based on the input parameters, the tool generates synthetic trajectories of people based on their probabilities of participating in events while ensuring data follows the constraints specified in the input configuration files. To translate such trajectories into connectivity data, we simulate presence of WiFi APs in different places in the smart space (along with their coverage). We model the connectivity patterns described in Section 2, where devices connect to APs differently and connectivity events are not always generated even when the device is in the coverage area of an AP, by setting up probabilities of a device in the coverage of an AP producing a connectivity event. The output of the tool is then a set of connectivity events and a set of trajectories of people (which will be used as ground truth).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Precision on Simulated Scenarios"
        },
        {
            "text": "We generated four synthetic datasets simulating the following environments, which we list in order of increasing predictability: airport, mall, university, and office. For each of them we used a real blueprint (e.g., Santa Ana's airport for the first scenario) and created types of people (e.g., TSA staff, passengers, etc) and events they attend (e.g., security checks, boarding flights, etc.) based on our observations. Due to space limitation, we only discuss how we simulated the Airport dataset using SmartSim. We based the generation of data for the airport scenario on the blueprint of a part of the Santa Ana airport. Based on our observations, we simulated different profiles of people: restaurant staff (15 individuals), store staff (15) , airline representatives (20) , TSA staff (15) , and passengers (200). For the 15 days for which we generate trajectories, we assigned users to events that occur in the day such as security checks (of which TSA staff is very likely to attend), dining (of which restaurant staff and passengers are likely to attend), boarding flights (of which passengers and airline representatives attend), and shopping (of which passengers and store staff will attend). In particular, a user will select an event that they can attend (in a timely matter) and attend it with some (constant) probability.",
            "cite_spans": [
                {
                    "start": 743,
                    "end": 747,
                    "text": "(15)",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 774,
                    "end": 778,
                    "text": "(20)",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 791,
                    "end": 795,
                    "text": "(15)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Precision on Simulated Scenarios"
        },
        {
            "text": "Results. Table 4 shows the accuracy of D-LOCATER (which in the previous experiments performed slightly better than I-LOCATER) for different profiles of people on the simulated scenarios. Each cell shows the rounded up precision of the coarse (Pc) and fine (P f ) algorithms, and the overall system (Po), followed by a value in brackets that represents the difference between the overall accuracy of LOCATER and that of the best baseline (Baseline2).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 9,
                    "end": 16,
                    "text": "Table 4",
                    "ref_id": "TABREF7"
                }
            ],
            "section": "Precision on Simulated Scenarios"
        },
        {
            "text": "The first thing to notice is that LOCATER still outperforms the baselines for all the scenarios/profiles. The difference between LOCATER's performance and the baseline decreases for very unpredictable profiles where choosing the appropriate room is challenging for both systems. LO-CATER performs well in more predictable scenarios such as the office and university buildings as the predictability of the profiles withing is higher (e.g., the amount of highly predictable employees is way higher than the amount of visitors in an office building when compared, for instance, to the amount of highly predictable employees in an airport and the amount of unpredictable passengers). When looking at the two components of LOCATER, we can see that the coarse-grained localization algorithm obtains high precision (above 80%) in all the situations. The fine-grained localization algorithm performs well (above 75%) for people with more predictable profiles, as expected, regardless of the scenario. Notice that this is consistent across scenarios which shows that our approach could be effective beyond our university building.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Precision on Simulated Scenarios"
        },
        {
            "text": "We examine the efficiency and scalability of LOCATER on the DBH-WIFI dataset using two set of queries: 1) The query set used in the previous experiment which contains 5,008 queries (referred to as university query set in the following); 2) A larger query set which contains 100k queries (referred to as generated). For each query in the generated set, we selected a device from the set of all devices in the dataset (including those without associated ground truth) and a timestamp from Jan. 22nd, 2018 to July 8th, 2018, both following uniform distribution. We randomly order both sets of queries per run and repeat the experiment 5 times with different orderings. Fig. 10 plots the average running time per query for the university query set (on the left) and the generated set (on the right). In both graphs, we can see that when we process the first query, D-LOCATER+C takes around 5 seconds as the global affinity graph (see Section 5) is empty. As we pro- cess more queries, the running time of D-LOCATER+C goes down fast to around 1 second and then converges. This is because the global affinity graph caches more affinities from processed queries and thus provides a more accurate processing order for neighbor devices for later queries until the point where the global affinity graph contains enough information about all the devices and therefore, the performance remains the same. Notice that the convergence point differs from one dataset to the other (around 2.5K queries for university and around 20K for generated). The reason is that in the university set, the number of queried devices is small (19 in total) and the global affinity graph for those can be generated quickly, whereas in the generated dataset there is large number of devices being queried. On the other hand, I-LOCATER+C, due to its independency assumption for devices which makes affinity computation simpler, outperforms D-LOCATER+C and maintains a constant processing time regardless the number of queries. We examine how loose stop conditions in I-LOCATER affect its efficiency. Fig. 11 plots the average time per query for both query sets when the system uses or not the stopping conditions described in Section 4. Without stop conditions, I-LOCATER has to process all neighbor devices, whereas with the stop conditions the early stop brings a considerable improvement in the execution time. Finally, Fig. 12 reports the average time cost per query for the two query workloads to explore the performance attributed to the caching strategy. Indeed, the caching strategy decreases the computation time from round 5 seconds to 1 second for D-LOCATER.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 666,
                    "end": 673,
                    "text": "Fig. 10",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2066,
                    "end": 2073,
                    "text": "Fig. 11",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2389,
                    "end": 2396,
                    "text": "Fig. 12",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Efficiency and Scalability"
        },
        {
            "text": "LOCATER postulates the semantic localization problem given WiFi connectivity data as a set of data cleaning problems. In the following, we review works in the field of sensor data cleaning and indoor data management.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RELATED WORK"
        },
        {
            "text": "Cleaning sensor data to drive real-time decisions/actuation and/or interactive exploratory analysis in the context of specific applications (e.g., object-tracking) has been studied previously [5, 6, 9, 26, 29, 33, 36] . These include statistical methods to detect and repair cross readings and missing readings in RFID signals to support object tracking [5, 13, 33] and techniques to detect outliers in sensor readings [9, 26] . These techniques are specific to RFID data and, as such, do not apply to cleaning WiFi connectivity data as studied in this paper. Online cleaning of sensor data, specially qualitative techniques that can exploit domain semantics and constraints in the system to improve data quality, have been identified as an important direction of research in survey papers such as [6, 29] . [12] presented Extensible receptor Stream Processing (ESP), a declarative query-based framework designed to clean the data streams produced by sensor devices. Other works in data cleaning domain target to clean time series/sequential data, such as statistics-based sequential data cleaning [35] and time series anomaly repairing [36] . Wrt indoor positioning data management: [17] proposes a system to translate raw indoor positioning data into mobility semantics that describe what, where, and when in a more concise and semantics-oriented way. [14] presents a graph model based approach to indoor tracking that offers a uniform data management infrastructure for different symbolic positioning technologies. [31] proposes several techniques for efficient distance-aware queries on indoor moving objects.",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 195,
                    "text": "[5,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 196,
                    "end": 198,
                    "text": "6,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 199,
                    "end": 201,
                    "text": "9,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 202,
                    "end": 205,
                    "text": "26,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 206,
                    "end": 209,
                    "text": "29,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 210,
                    "end": 213,
                    "text": "33,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 214,
                    "end": 217,
                    "text": "36]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 354,
                    "end": 357,
                    "text": "[5,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 358,
                    "end": 361,
                    "text": "13,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 362,
                    "end": 365,
                    "text": "33]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 419,
                    "end": 422,
                    "text": "[9,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 423,
                    "end": 426,
                    "text": "26]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 798,
                    "end": 801,
                    "text": "[6,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 802,
                    "end": 805,
                    "text": "29]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 808,
                    "end": 812,
                    "text": "[12]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1098,
                    "end": 1102,
                    "text": "[35]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 1137,
                    "end": 1141,
                    "text": "[36]",
                    "ref_id": "BIBREF32"
                },
                {
                    "start": 1184,
                    "end": 1188,
                    "text": "[17]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 1354,
                    "end": 1358,
                    "text": "[14]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1518,
                    "end": 1522,
                    "text": "[31]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK"
        },
        {
            "text": "In this paper, we propose LOCATER that cleans existing WiFi connectivity datasets to perform semantic localization of individuals. The key benefit of LOCATER is that it: 1) Leverages existing WiFi infrastructure without requiring deployment of any additional hardware (such as monitors typically used in passive localization); 2) Does not require explicit cooperation of people (like active indoor localization approaches). Instead, LOCATER leverages historical connectivity data to resolve coarse and fine locations of devices by cleaning connectivity data. Our experiments, using real data captured at a University building, show that LOCATER achieves good fine-grained localization precision, 87%, and a great robustness under various simulated scenarios. Optimizations made LOCATER scale to datasets with more than 100k devices and achieve near real-time response. 9. APPENDIX 9.1 Metadata Coverage of WiFi APs: Multiple works in the literature focus on estimating the coverage of indoors WiFi APs [23, 27] . In general, locations of APs in buildings are static and thus the computation of their coverage needs to be performed only once. WiFi APs may not cover all rooms in a building which would limit the localization performed in those. Type of rooms: Information about whether a room is public (e.g., conference rooms, halls, corridors, etc.) or not (e.g., office, restricted areas, etc.) is in general available to the administrator of the space. Room owner: Also usually available to the administrator of a space. Otherwise, it can be collected, e.g., through periodical surveys among the users in the building. Note that this information is not a must for LOCATER and can be including at run time. Event validity: Can be extracted directly from the WiFi connectivity data along with ground through. E.g., while a specific device is in a room, the connectivity log shows how many connections the device performs in an interval.",
            "cite_spans": [
                {
                    "start": 1002,
                    "end": 1006,
                    "text": "[23,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1007,
                    "end": 1010,
                    "text": "27]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "CONCLUSIONS"
        },
        {
            "text": "Proof of Theorem 1 Consider another possible world W0 where some unseen devices are not in rj. We denote by W0(d) the room where d is located in W0. We can transform W to W0 step by step, where in each step for a device that is not in rj in W0, we change its room location from rj to W0(d). Assuming the transformation steps are W, Wn, ..., W1, W0, we can prove easily: P r(rj|Dn, W ) > P r(rj|Dn, Wn) > ... > P r(rj|Dn, W1) > P r(rj|Dn, W0). Proof of Theorem 2 Consider another possible world W0 where some unseen devices are not in room rmax and d is located in room W0(d). We can transform W to W0 step by step, where in each step for a device which is located in room W0(d) = rmax in W0, we change its value from rmax to W0(d). Assuming the transformation steps are W, Wn, ..., W1, W0, we can prove easily: P r(rj|Dn, W ) < P r(rj|Dn, Wn) < ... < P r(rj|Dn, W1) < P r(rj|Dn, W0). Proof of Theorem 3 We compute the probability of each possible world according to the probabilities of the rooms being the answer, which are in turn computed based on observations onDn. P r(W |Dn) P r(Dn)P r(rj |Dn)P r(W |Dn) P r(Dn)P r(W |Dn) = W \u2208W(Dn \\Dn ) P r(W |Dn)P r(rj |Dn) = P r(rj |Dn)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proofs for Section 4.2"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Theory and applications of hvac control systems-a review of model predictive control (mpc)",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Afram",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Janabi-Sharifi",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "343--355",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Learning-based cleansing for indoor rfid data",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "I"
                    ],
                    "last": "Baba",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "925--936",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Data cleaning: Overview and emerging challenges",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Chu",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [
                        "F"
                    ],
                    "last": "Ilyas",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Krishnan",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "2201--2206",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "CISSP study guide",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Conrad",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Misenar",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Feldman",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "A survey of active and passive indoor localisation systems",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Deak",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Computer Communications",
            "volume": "",
            "issn": "",
            "pages": "1939--1954",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Another outlier bites the dust: Computing meaningful aggregates in sensor networks",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Deligiannakis",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ICDE",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Netconf configuration protocol",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Enns",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bjorklund",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schoenwaelder",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "RFC",
            "volume": "4741",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "The syslog protocol",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gerhards",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "RFC",
            "volume": "5424",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "A pipelined framework for online cleaning of sensor data streams",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Jeffery",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Alonso",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Franklin",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Hong",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Widom",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "ICDE",
            "volume": "",
            "issn": "",
            "pages": "140--140",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Adaptive cleaning for rfid data streams",
            "authors": [
                {
                    "first": "S",
                    "middle": [
                        "R"
                    ],
                    "last": "Jeffery",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Garofalakis",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Franklin",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "VLDB",
            "volume": "",
            "issn": "",
            "pages": "163--174",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Graph model based indoor tracking",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "S"
                    ],
                    "last": "Jensen",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "MDM",
            "volume": "",
            "issn": "",
            "pages": "122--131",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Soundloc: Accurate room-level indoor localization using acoustic signatures",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Jia",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "CASE",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Decimeter level localization using wifi",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kotaru",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "SIGCOMM",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Trips: A system for translating raw indoor positioning data into visual mobility semantics",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "11",
            "issn": "",
            "pages": "1918--1921",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "A passive wifi source localization system based on fine-grained power-based trilateration",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "WoWMoM",
            "volume": "",
            "issn": "",
            "pages": "1--9",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Survey of wireless indoor positioning techniques and systems",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "SMC",
            "volume": "",
            "issn": "",
            "pages": "1067--1080",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Self-bootstrapping fine-grained passive indoor localization using wifi monitors",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Luo",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "IEEE TMC",
            "volume": "",
            "issn": "",
            "pages": "466--481",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Tippers: A privacy cognizant iot environment",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mehrotra",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "PerCom Workshops",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Tracking unmodified smartphones using wi-fi monitors",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Musa",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Eriksson",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Sensys",
            "volume": "",
            "issn": "",
            "pages": "281--294",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Coverage prediction and optimization algorithms for indoor environments",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Plets",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "EURASIP Journal on Wireless Communications and Networking",
            "volume": "2012",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "The cricket location-support system",
            "authors": [
                {
                    "first": "N",
                    "middle": [
                        "B"
                    ],
                    "last": "Priyantha",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Chakraborty",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Balakrishnan",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "MobiCom",
            "volume": "",
            "issn": "",
            "pages": "32--43",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Nuzzer: A large-scale device-free passive localization system for wireless environments",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Seifeldin",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "TMC",
            "volume": "",
            "issn": "",
            "pages": "1321--1334",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Online outlier detection in sensor data using non-parametric models",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Subramaniam",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "VLDB",
            "volume": "",
            "issn": "",
            "pages": "187--198",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Applying and comparing two measurement approaches for the estimation of indoor wifi coverage",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tervonen",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "NTMS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Decimeter-level localization with a single wifi access point",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Vasisht",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "NSDI",
            "volume": "",
            "issn": "",
            "pages": "165--178",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Time series data cleaning: A survey",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "IEEE Access",
            "volume": "8",
            "issn": "",
            "pages": "1866--1881",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "The active badge location system",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Want",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hopper",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Falcao",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gibbons",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "TOIS",
            "volume": "10",
            "issn": "1",
            "pages": "91--102",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Efficient distance-aware query evaluation on indoor moving objects",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Xie",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "ICDE",
            "volume": "",
            "issn": "",
            "pages": "434--445",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Scpl: Indoor device-free multi-subject counting and localization using radio signal strength",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IPSN",
            "volume": "",
            "issn": "",
            "pages": "79--90",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "An improved smurf scheme for cleaning rfid data",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Ding",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sgandurra",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IJGUC",
            "volume": "",
            "issn": "",
            "pages": "170--178",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Challenges: device-free passive localization for wireless environments",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Youssef",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mah",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Agrawala",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "222--229",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Sequential data cleaning: a statistical approach",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Song",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "909--924",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Time series data cleaning: From anomaly detection to anomaly repairing",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Song",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "S"
                    ],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Motivating Example.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Connectivity events of device d i and their validity.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Graph view in fine-grained location cleaning.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": ".4, i.e., \u03b1({d1, d2}) = .4. The set Ris = {2065, 2069, 2099}. We compute \u03b1({d1, d2}, 2065, tq) as follows. P (@(d1, 2065, tq)|@(d1, Ris, tq)) = .3 .3+.06+.06 = .69. Similarly, P (@(d2, 2065, tq)|@(d2, Ris, tq)) = .4 .4+.01+.5 = .44. Finally, \u03b1({d1, d2}, 2065, tq) = .4 * .69 * .44 = .12.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Graph view in fine-grained location cleaning.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Dn dependent then 14 if \u2200D nl \u2286Dn, \u03b1({D nl , di}, rj , tq) Architecture of LOCATER.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Thresholds testing in coarse localization.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Impact of historical data used on precision. Caching precision. spend in their preferred room: [40, 55), [55, 70), [70, 85) and [85, 100), where [40, 55) means that the user spent 40-55 percent of their time in that room (no user in the ground truth data spent less than 40% of his/her time in a specific room).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "reports the fine precision of the four weight combinations satisfying the rules defined in that section: C1 = {0.7, 0.2, 0.1}, C2 = {0.6, 0.3, 0.1}, C3 = {0.5, 0.3, 0.2}, and C4 = {0.5, 0.4, 0.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Efficiency testing on two datasets.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Stop Condition.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Scalability.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "\u2208W(Dn \\Dn ) P r(W |Dn) P r(Dn)P r(rj , W |Dn) P r(Dn)P r(W |Dn) = W \u2208W(Dn \\Dn )",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Model variables and shorthand notation.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "WiFi Connectivity Data Model. W AP = {wapj : j \u2208 [1...|W AP|]} is the set of WiFi APs in a building. Let D = {dj : j \u2208 [1...|D|]} be the set of devices. Each device dj has associated a MAC-address, denoted by M AC(dj), that uniquely identifies it. Let E = {ei : i \u2208 [1...|E|]} be the WiFi connectivity events table with schema {eid, mac address, timestamp, wap}.(As shown in",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Accuracy for different profiles for simulated scenarios.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}