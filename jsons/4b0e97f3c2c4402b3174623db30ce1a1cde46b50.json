{"paper_id": "4b0e97f3c2c4402b3174623db30ce1a1cde46b50", "metadata": {"title": "A memory-efficient algorithm for multiple sequence alignment with constraints", "authors": [{"first": "Chin", "middle": ["Lung"], "last": "Lu", "suffix": "", "affiliation": {"laboratory": "", "institution": "National Chiao Tung University", "location": {"postCode": "300", "settlement": "Hsinchu", "country": "Taiwan, Republic of China"}}, "email": ""}, {"first": "Yen", "middle": ["Pin"], "last": "Huang", "suffix": "", "affiliation": {"laboratory": "", "institution": "National Chiao Tung University", "location": {"postCode": "300", "settlement": "Hsinchu", "country": "Taiwan, Republic of China"}}, "email": ""}]}, "abstract": [{"text": "Motivation: Recently, the concept of the constrained sequence alignment was proposed to incorporate the knowledge of biologists about structures/functionalities/consensuses of their datasets into sequence alignment such that the userspecified residues/nucleotides are aligned together in the computed alignment. The currently developed programs use the so-called progressive approach to efficiently obtain a constrained alignment of several sequences. However, the kernels of these programs, the dynamic programming algorithms for computing an optimal constrained alignment between two sequences, run in O(\u03b3 n 2 ) memory, where \u03b3 is the number of the constraints and n is the maximum of the lengths of sequences. As a result, such a high memory requirement limits the overall programs to align short sequences only. Results: We adopt the divide-and-conquer approach to design a memory-efficient algorithm for computing an optimal constrained alignment between two sequences, which greatly reduces the memory requirement of the dynamic programming approaches at the expense of a small constant factor in CPU time. This new algorithm consumes only O(\u03b1n) space, where \u03b1 is the sum of the lengths of constraints and usually \u03b1 n in practical applications. Based on this algorithm, we have developed a memory-efficient tool for multiple sequence alignment with constraints. Availability: http://genome.", "cite_spans": [], "ref_spans": [], "section": "Abstract"}], "body_text": [{"text": "Multiple sequence alignment (MSA) is one of the fundamental problems in computational molecular biology that have been studied extensively, because it is a useful tool in the phylogenetic analyses among various organisms, the identification of conserved motifs and domains in a group of related proteins, the secondary and tertiary structure prediction of a protein (or RNA), and so on (Carrillo and Lipman, 1988; Chan et al., 1992; Gusfield, 1997; Nicholas et al., 2002; Notredame, 2002) . Moreover, MSA is one of the most challenging * To whom correspondence should be addressed. problems in computational molecular biology because it has been shown to be NP-complete under the consideration of sum-of-pairs scoring criteria (Kececioglu, 1993; Wang and Jiang, 1994; Bonizzoni and Vedova, 2001) , which means that it seems to be hard to design an efficient algorithm for finding the mathematically optimal alignment. Hence, some approximate methods (Gusfield, 1993; Pevzner, 1992; Bafna et al., 1997; Li et al., 2000) and heuristic methods (Feng and Doolittle, 1987; Taylor, 1987; Corpet, 1988; Higgins and Sharpe, 1988; Thompson et al., 1994) were introduced to overcome this problem.", "cite_spans": [{"start": 386, "end": 413, "text": "(Carrillo and Lipman, 1988;", "ref_id": "BIBREF2"}, {"start": 414, "end": 432, "text": "Chan et al., 1992;", "ref_id": "BIBREF3"}, {"start": 433, "end": 448, "text": "Gusfield, 1997;", "ref_id": "BIBREF11"}, {"start": 449, "end": 471, "text": "Nicholas et al., 2002;", "ref_id": "BIBREF24"}, {"start": 472, "end": 488, "text": "Notredame, 2002)", "ref_id": "BIBREF25"}, {"start": 727, "end": 745, "text": "(Kececioglu, 1993;", "ref_id": "BIBREF16"}, {"start": 746, "end": 767, "text": "Wang and Jiang, 1994;", "ref_id": "BIBREF41"}, {"start": 768, "end": 795, "text": "Bonizzoni and Vedova, 2001)", "ref_id": "BIBREF1"}, {"start": 950, "end": 966, "text": "(Gusfield, 1993;", "ref_id": "BIBREF10"}, {"start": 967, "end": 981, "text": "Pevzner, 1992;", "ref_id": "BIBREF27"}, {"start": 982, "end": 1001, "text": "Bafna et al., 1997;", "ref_id": "BIBREF0"}, {"start": 1002, "end": 1018, "text": "Li et al., 2000)", "ref_id": "BIBREF19"}, {"start": 1041, "end": 1067, "text": "(Feng and Doolittle, 1987;", "ref_id": "BIBREF9"}, {"start": 1068, "end": 1081, "text": "Taylor, 1987;", "ref_id": "BIBREF35"}, {"start": 1082, "end": 1095, "text": "Corpet, 1988;", "ref_id": "BIBREF6"}, {"start": 1096, "end": 1121, "text": "Higgins and Sharpe, 1988;", "ref_id": "BIBREF12"}, {"start": 1122, "end": 1144, "text": "Thompson et al., 1994)", "ref_id": "BIBREF37"}], "ref_spans": [], "section": "INTRODUCTION"}, {"text": "Recently, the concept of the constrained sequence alignment was proposed to incorporate the knowledge of biologists regarding the structures/functionalities/consensuses of their datasets into sequence alignment such that the userspecified residues/nucleotides are aligned together in the computed alignment (Tang et al., 2003) . Tang et al. (2003) first designed a dynamic programming algorithm for finding an optimal constrained alignment of two sequences and then used it as a kernel to develop a constrained multiple sequence alignment (CMSA) tool based on the progressive approach, where each constraint considered by Tang et al. is a single residue/nucleotide only. Their proposed algorithm for the two sequences runs in O(\u03b3 n 4 ) time and consumes O(n 4 ) space, where \u03b3 is the number of constrained residues and n is the maximum lengths of the sequences. Later, this result was improved independently by two groups of researchers to O(\u03b3 n 2 ) time and O(\u03b3 n 2 ) space using the same approach of dynamic programming (Yu, 2003; Chin et al., 2003) . In fact, each constraint requested to be aligned together can represent a conserved site of a protein/DNA/RNA family and each conserved site may consist of a short segment of residues/nucleotides, instead of a single residue/nucleotide. In other words, the constraint specified by the biologists can be a fragment of several residues/nucleotides. For some applications, biologists may further expect that some mismatches are allowed among the residues/nucleotides of the columns requested to be aligned. Hence, Tsai et al. (2004) studied such a kind of the constrained sequence alignment and designed an algorithm of O(\u03b3 n 2 ) time and O(\u03b3 n 2 ) space for two sequences. The improvements and extension above greatly increase the performances and practical usage of the CMSA tools developed using the progressive approach. However, the requirement of O(\u03b3 n 2 ) memory still limits the existing CMSA tools to align a set of short sequences, at most several hundreds of residues/nucleotides. To align large genomic sequences of at least several thousands of residues/nucleotides, there is a need to design a memoryefficient algorithm for the constrained pairwise sequence alignment (CPSA) problem, which is the key limiting factor relating to the applicable extent of the progressive CMSA tools. Hence, in this paper, we adopt the so-called divide-andconquer approach to design a memory-efficient algorithm for solving the CPSA problem, which runs in O(\u03b3 n 2 ) time, but consumes only O(\u03b1n) space, where \u03b1 is the sum of the lengths of constraints and usually \u03b1 n in practical applications. Based on this algorithm, we have finally developed a memoryefficient CMSA tool using the progressive approach. Note that applying the divide-and-conquer approach to memoryefficiently align two or more sequences without any constraints has been studied extensively (Myers and Miller, 1988; Chao et al., 1994; T\u00f6nges et al., 1996; Stoye et al., 1997a,b; Stoye, 1998) . In contrast to the progressive approach used here, the divide-and-conquer algorithms proposed by Stoye et al. (T\u00f6nges et al., 1996; Stoye et al., 1997a,b; Stoye, 1998) considered the input sequences simultaneously and heuristically compute the good, but not necessarily optimal, dividing positions so that the resulting total MSA is close to an optimal MSA of the original sequences. In fact, many other CMSAs have been proposed from various perspectives, even using different approaches (Schuler et al., 1991; Depiereux and Feytmans, 1992; Taylor, 1994; Myers et al., 1996; Notredame et al., 2000; Thompson et al., 2000; Sammeth et al., 2003) . Of these various CMSAs, it is worth mentioning that Myers et al. (1996) obtained their CMSA by performing progressive multiple alignment under position-based constraints that are given by users; Sammeth et al. (2003) got their CMSA by performing simultaneous multiple alignment under segment-based constraints (as same as we studied here) that are pre-computed via a local segmented-based algorithm (Morgenstern, 1999) . We refer the reader to their papers for details.", "cite_spans": [{"start": 307, "end": 326, "text": "(Tang et al., 2003)", "ref_id": "BIBREF34"}, {"start": 329, "end": 347, "text": "Tang et al. (2003)", "ref_id": "BIBREF34"}, {"start": 1022, "end": 1032, "text": "(Yu, 2003;", "ref_id": "BIBREF43"}, {"start": 1033, "end": 1051, "text": "Chin et al., 2003)", "ref_id": "BIBREF5"}, {"start": 1565, "end": 1583, "text": "Tsai et al. (2004)", "ref_id": "BIBREF40"}, {"start": 2905, "end": 2929, "text": "(Myers and Miller, 1988;", "ref_id": "BIBREF22"}, {"start": 2930, "end": 2948, "text": "Chao et al., 1994;", "ref_id": "BIBREF4"}, {"start": 2949, "end": 2969, "text": "T\u00f6nges et al., 1996;", "ref_id": "BIBREF39"}, {"start": 2970, "end": 2992, "text": "Stoye et al., 1997a,b;", "ref_id": null}, {"start": 2993, "end": 3005, "text": "Stoye, 1998)", "ref_id": "BIBREF31"}, {"start": 3105, "end": 3139, "text": "Stoye et al. (T\u00f6nges et al., 1996;", "ref_id": "BIBREF39"}, {"start": 3140, "end": 3162, "text": "Stoye et al., 1997a,b;", "ref_id": null}, {"start": 3163, "end": 3175, "text": "Stoye, 1998)", "ref_id": "BIBREF31"}, {"start": 3496, "end": 3518, "text": "(Schuler et al., 1991;", "ref_id": "BIBREF30"}, {"start": 3519, "end": 3548, "text": "Depiereux and Feytmans, 1992;", "ref_id": "BIBREF8"}, {"start": 3549, "end": 3562, "text": "Taylor, 1994;", "ref_id": "BIBREF36"}, {"start": 3563, "end": 3582, "text": "Myers et al., 1996;", "ref_id": "BIBREF23"}, {"start": 3583, "end": 3606, "text": "Notredame et al., 2000;", "ref_id": "BIBREF26"}, {"start": 3607, "end": 3629, "text": "Thompson et al., 2000;", "ref_id": "BIBREF38"}, {"start": 3630, "end": 3651, "text": "Sammeth et al., 2003)", "ref_id": "BIBREF29"}, {"start": 3706, "end": 3725, "text": "Myers et al. (1996)", "ref_id": "BIBREF23"}, {"start": 3849, "end": 3870, "text": "Sammeth et al. (2003)", "ref_id": "BIBREF29"}, {"start": 4053, "end": 4072, "text": "(Morgenstern, 1999)", "ref_id": "BIBREF21"}], "ref_spans": [], "section": "INTRODUCTION"}, {"text": "Let S = {S 1 , S 2 , . . . , S \u03c7 } be the set of \u03c7 sequences over the alphabet . Then an MSA of S is a rectangular matrix consisting of \u03c7 rows of characters of \u222a {-} such that no column consists entirely of dashes and removing dashes from row i leaves S i for any 1 \u2264 i \u2264 \u03c7 . The sum-of-pairs score (SP score) of an MSA is defined to be the sum of the scores of all columns, where the score of each column is the sum of the scores of all distinct pairs of characters in the column. In practice, the score of the pair of two dashes is usually set to zero. Then the problem of finding an MSA of S with the optimal SP score is the so-called sum-of-pairs MSA problem (Carrillo and Lipman, 1988; Chan et al., 1992; Gusfield, 1997; Nicholas et al., 2002; Notredame, 2002) .", "cite_spans": [{"start": 663, "end": 690, "text": "(Carrillo and Lipman, 1988;", "ref_id": "BIBREF2"}, {"start": 691, "end": 709, "text": "Chan et al., 1992;", "ref_id": "BIBREF3"}, {"start": 710, "end": 725, "text": "Gusfield, 1997;", "ref_id": "BIBREF11"}, {"start": 726, "end": 748, "text": "Nicholas et al., 2002;", "ref_id": "BIBREF24"}, {"start": 749, "end": 765, "text": "Notredame, 2002)", "ref_id": "BIBREF25"}], "ref_spans": [], "section": "PROBLEM FORMULATION"}, {"text": "Let \u03b4(T 1 , T 2 ) denote the Hamming distance between two subsequences T 1 and T 2 of equal length, which is equal to the number of mismatched pairs in the alignment of T 1 and T 2 without any gap. Given an alignment L of S, a band is defined as a block of consecutive columns in L (i.e. a submatrix of L). For any band L of L, let subseq(S i , L ) denote the subsequence of S i whose residues/nucleotides are all in the band L , where 1 \u2264 i \u2264 \u03c7 . A subsequence T = t 1 t 2 . . . t \u03bb is said to appear in L if L contains a band L of \u03bb columns, say \u03c0 1 , \u03c0 2 , . . . , \u03c0 \u03bb , such that the characters of column \u03c0 j , 1 \u2264 j \u2264 \u03bb, are all equal to t j , or equivalently, subseq(S i , L ) = T for each 1 \u2264 i \u2264 \u03c7 . If \u03b4[subseq(S i , L ), T ] \u2264 \u03bb \u00d7 for a given error ratio 0 \u2264 < 1 [i.e. some mismatches are allowed between subseq(S i , L ) and T ], then T is said to approximately appear in L. From the biological viewpoint, T can be considered as the consensus among the subsequences in L and hence T is also called as an induced consensus by the band L . For any two subsequences T 1 and T 2 , T 1 \u227a T 2 is used to denote that T 1 (approximately) appears strictly before T 2 in L (i.e. their corresponding bands do not overlap). Let = (C 1 , C 2 , . . . , C \u03b3 ) be an ordered set of \u03b3 constraints (i.e. subsequences), each", "cite_spans": [], "ref_spans": [], "section": "PROBLEM FORMULATION"}, {"text": "Then the CMSA of S with respect to is defined as an alignment L of S in which all the constraints of approximately appear in the order C 1 \u227a C 2 \u227a \u00b7 \u00b7 \u00b7 \u227a C \u03b3 such that \u03b4(subseq(S i , L j ), C j ) \u2264 \u03bb j \u00d7 for all 1 \u2264 i \u2264 \u03c7 and 1 \u2264 j \u2264 \u03b3 , where L j is the band of L whose induced consensus is C j . Given a set S of \u03c7 sequences along with an ordered set of \u03b3 constraints and an error ratio , the so-called CMSA problem is to find a CMSA w.r.t. with the optimal SP score. When the number of sequences in S is restricted to two (i.e. \u03c7 = 2), the CMSA problem is called as the CPSA problem.", "cite_spans": [], "ref_spans": [], "section": "PROBLEM FORMULATION"}, {"text": "In this section, we shall first design a memory-efficient algorithm for solving the CPSA problem with two given sequences A = a 1 a 2 . . . a m and B = b 1 b 2 . . . b n , a given ordered set", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "and a given error threshold . After that, we shall use it as the kernel to heuristically solve the CMSA problem.", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "For any sequence T , let pref(T , l) [respectively, suff(T , l)] phase don't change denote the prefix (respectively, suffix) of T with length l. For any two characters a, b \u2208 , let \u03c3 (a, b) denote the score of aligning a with b. The gap penalty adopted here is the so-called affine gap penalty that penalizes a gap of length l with w o +l \u00d7w e , where w o > 0 is the gap-open penalty and w e > 0 is the gap-extension penalty. For convenience, let A i = pref(A, i) = a 1 a 2 . . . a i ,", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "Let M k (i, j) denote the score of an optimal constrained alignment of A i and B j w.r.t. k . Clearly, M \u03b3 (m, n) is the score of an optimal constrained alignment of A and B w.r.t. . An alignment L is called as a semi-constrained alignment of A i and B j w.r.t. k if it is a constrained alignment of A i and B j w.r.t. k\u22121 and also ends (or begins) with a band whose induced consensus is equal to a prefix of C k (or a suffix of C 1 ). N k (i, j , h) is defined to be the score of an optimal semi-constrained alignment of A i and B j w.r.t. k that ends with an induced consensus equal to", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": ", which is defined to be the maximum score of all constrained alignments of A i and B j w.r.t. k that end with a substitution pair (a i , b j ). Let ", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "Case 3: The last aligned pair of L is an insertion pair. Then the score of L is M I k (i \u2212 1, j) and (a i , \u2212) is charged by a gap-open penalty and a gap-extension penalty in M D k (i, j).", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "However, by including an extra M D k (i \u2212 1, j) \u2212 w o \u2212 w e into the right-hand side of the above recurrence, we can reformulate", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "According to the recurrences above, we designed an algorithm to compute M \u03b3 (m, n) and its corresponding constrained alignment using the technique of dynamic programming as follows. For convenience, we depicted the recurrences of matrices M k , M D k , M I k and N k for all 0 \u2264 k \u2264 \u03b3 by a three-dimensional (3D) grid graph G, which consists of (m + 1) \u00d7 (n + 1) \u00d7 (\u03b3 + 1) entries and each entry (i, j , k) Figure 1 shows the relationship of four adjacent entries", "cite_spans": [], "ref_spans": [{"start": 407, "end": 415, "text": "Figure 1", "ref_id": "FIGREF1"}], "section": "ALGORITHM"}, {"text": "Note that there is a directed edge, which is not shown in Figure 1 ", "cite_spans": [], "ref_spans": [{"start": 58, "end": 66, "text": "Figure 1", "ref_id": "FIGREF1"}], "section": "ALGORITHM"}, {"text": "node of entry (m, n, \u03b3 ) corresponds to a constrained alignment of A and B w.r.t. . As a result, an optimal constrained alignment of A and B can be obtained by backtracking a shortest path from M \u03b3 (m, n) to M 0 (0, 0) in G. It is not hard to see that the algorithm costs both computer time and memory in the order of O(\u03b3 mn). We call the above algorithm based on the dynamic programming approach as CPSA-DP algorithm. Hirschberg (1975) had developed a linear-space algorithm for solving the longest common subsequence problem based on the divide-and-conquer technique. Since then, this strategy has been extended to yield a number of memory-efficient algorithms for aligning biological sequences (Myers and Miller, 1988; Chao et al., 1994) . In this paper, we generalize the Hirschberg's algorithm so that it is capable of dealing with the CPSA. As compared with others, our generalization is more complicated because the grid graph G dealt here is 3D, instead of 2D, and the input sequences are accompanied with several constraints that need to be considered carefully. The central idea of our memory-efficient algorithm is to determine a middle position (i mid , j mid , k mid ) on an optimal path from M 0 (0, 0) to M \u03b3 (m, n) in G so that we were able to divide the constrained alignment problem into two smaller constrained alignment problems; then these smaller constrained alignment problems are continued to be divided in the same manner, and finally the optimal constrained alignment is obtained completely by merging the series of the calculated mid-points (Fig. 2) .", "cite_spans": [{"start": 419, "end": 436, "text": "Hirschberg (1975)", "ref_id": "BIBREF13"}, {"start": 697, "end": 721, "text": "(Myers and Miller, 1988;", "ref_id": "BIBREF22"}, {"start": 722, "end": 740, "text": "Chao et al., 1994)", "ref_id": "BIBREF4"}], "ref_spans": [{"start": 1568, "end": 1576, "text": "(Fig. 2)", "ref_id": null}], "section": "ALGORITHM"}, {"text": "Before describing our algorithm, some notation must be introduced as follows. Let A i and B j denote the suffixes a i+1 a i+2 . . . a m and b j +1 b j +2 . . . b n of A and B, respectively, for 1 \u2264 i \u2264 m and 1 \u2264 j \u2264 n. Let k denote the ordered subset (C k+1 , C k+2 , . . . , C \u03b3 ) for 1 \u2264 k \u2264 \u03b3 . ", "cite_spans": [], "ref_spans": [], "section": "ALGORITHM"}, {"text": "Schematic diagram of divide-and-conquer approach: two light gray areas are the reduced subproblems after middle position (i mid , j mid , k mid ) is determined, each of which will be further divided into two subproblems of dark gray areas.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Define M k (i, j) to be the score of an optimal constrained alignment of A i and B j w.r.t. k , and define M S k (i, j) (M D k (i, j) and M I k (i, j), respectively) to be the maximum score of all constrained alignments of A i and B j w.r.t. k that begin with a substitution [deletion and insertion, ", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Next, we describe our divide-and-conquer algorithm, termed as CPSA-DC algorithm, for computing an optimal constrained alignment between A and B w.r.t.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "as follows. The key point is to determine the middle position (i mid , j mid , k mid ) of the optimal path in G to divide the problem into two subproblems, each of which is recursively divided into two smaller subproblems using the same way. Given an alignment L, we use score(L) to denote the score of L. Let L \u03b3 (A, B) be an optimal constrained alignments of A and B w.r.t. and clearly score[L \u03b3 (A, B)] = M \u03b3 (m, n). Let i mid = m 2 . Then, we partition L \u03b3 (A, B) into two parts by cutting it at the position immediately after a i mid and we let L k mid (A i mid , B j mid ) denote the part containing a i mid and L k mid (A i mid , B j mid ) denote the remaining part, where b j mid denotes the last character in L k mid (A i mid , B j mid ) from B, and k mid denotes the largest index so that pref(C k mid , h mid ) (approximately) appears in L k mid (A i mid , B j mid ). Then there are two possibilities when we consider the last aligned pair of L k mid (A i mid , B j mid ).", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Case 1: The last aligned pair of L k mid (A i mid , B j mid ) is a substitution pair [i.e. (a i mid , b j mid )]. In this case, we have M \u03b3 (m, n) = score(L \u03b3 (A, B)) = score(L k mid (A i mid , B j mid )) + score(L k mid (A i mid , B j mid )). If (a i mid , b j mid ) is not a constrained column in L \u03b3 (A, B) , then L k mid (A i mid , B j mid ) is an optimal constrained alignment of A i mid and B j mid w.r.t. k mid ending with a substitution pair (a i mid , b j mid ), and L k mid (A i mid , B j mid ) is an optimal constrained alignment of A i mid and B j mid w.r.t. k mid . Hence,", "cite_spans": [], "ref_spans": [{"start": 303, "end": 309, "text": "(A, B)", "ref_id": null}], "section": "Fig. 2."}, {"text": "is an optimal semi-constrained alignment of A i mid and B j mid w.r.t. k mid (h mid ) ending with a band L whose induced consensus is equal to pref(C k mid , h mid ). If h mid < \u03bb k mid , then L k mid (A i mid , B j mid ) is an optimal semi-constrained alignment of A i mid and B j mid w.r.t. k mid (h mid ) beginning with a band L whose induced consensus is equal to suff(C k mid , \u03bb k mid \u2212 h mid ). Moreover, the induced consensus of the merge of L and L have to be equal to C k mid . In this case, we have M \u03b3 (m, n) = N k mid (i mid , j mid , h mid ) + N k mid (i mid , j mid , h mid ). If h mid = \u03bb k mid , then L k mid (A i mid , B j mid ) is an optimal constrained alignment of A i mid and B j mid w.r.t. k mid (h mid ), and hence M \u03b3 (m, n) = N k mid (i mid , j mid , \u03bb k mid ) + M k mid (i mid , j mid ).", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Case 2: The last aligned pair of L k mid (A i mid , B j mid ) is a deletion pair [i.e. (a i mid , \u2212)]. If the first aligned", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "We need to compensate it by adding w o because the open penalty of the gap containing a i mid and a i mid +1 in L \u03b3 (A, B) is charged twice by M D k mid (i mid , j mid ) and M D k mid (i mid , j mid ). In summary, the recurrence of M \u03b3 (m, n) is derived as follows:", "cite_spans": [], "ref_spans": [{"start": 116, "end": 122, "text": "(A, B)", "ref_id": null}], "section": "Fig. 2."}, {"text": "is added to the right-hand side, the above recurrence is not changed, but can be reformulated as follows:", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "In other words, j mid , k mid and h mid are the indices j , k and h, where 1 \u2264 j \u2264 n, 0 \u2264 k \u2264 \u03b3 and 1 \u2264 h < \u03bb k , such that the following maximal value is the maximum.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Now, we show how to use O(\u03b1n), instead of O(\u03b3 mn), memory to determine j mid , k mid and h mid , where \u03b1 = 1\u2264k\u2264\u03b3 \u03bb k and \u03b1 \u2264 min{m, n} intrinsically. In fact, a single matrix E of size (\u03b3 + 1) \u00d7 (n + 1) with each entry E(k, j) of \u03bb k + 4 space is enough to compute M k (i mid , j), M S k (i mid , j), M D k (i mid , j) M I k (i mid , j) and N k (i mid , j , h), for 1 \u2264 j \u2264 n, 0 \u2264 k \u2264 \u03b3 and 1 \u2264 h \u2264 \u03bb k . When reaching the entry (i, j , k) of 3D grid graph G, we use entry E(k, j) of E to hold the most recently computed values of M k (i, j), M S k (i, j), M D k (i, j) M I k (i, j) and N k (i, j , h), which clearly needs a total of \u03bb k + 4 space. Note that the old values in entry E(k, j) will be moved into an extra entry, termed as V k whose space is equal to E(k, j), before they are overwritten by their newly computed values. Before moving the old values in E(k, j) into V k ; however, we need to first move M k (i \u22121, j \u22121) in V k into a space, named as v k,k+1 , where 1 \u2264 i \u2264 m. The mechanism above will enable us to compute N k (i, j , 1), which needs to", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": ", which needs to refer M k (i \u2212 1, j \u2212 1) that is kept in V k ; and finally we were able to compute M k (i, j). Figure 3 shows the grid locations of E(k \u2212 1), E(k) and the values in V k\u22121 and V k when we reach the entry (i, j , k) of G for the computation, where E(k) denotes the k-th row of E. Hence, the total needed space for computing and storing all M k (i mid , j), M S k (i mid , j), M D k (i mid , j) M I k (i mid , j) and N k (i mid , j , h) is the sum of the space of matrix E, the space of all V k and the space of all v k,k+1 , where 1 \u2264 j \u2264 n, 0 \u2264 k \u2264 \u03b3 and 1 \u2264 h \u2264 \u03bb k , which is equal to O(\u03b1n). Similarly, the required matrix, denoted by E, for computing all M k (i mid , j), M S k (i mid , j), M D k (i mid , j) M I k (i mid , j) and N k (i mid , j , h) still needs O(\u03b1n) space. Hence, the determination of j mid , k mid and h mid can be performed in O(\u03b1n) space. The details of CPSA-DC algorithm are described as follows. Note that the program code of BestScoreRev is similar to that of BestScore and hence is omitted here. In the codes, the variable E(M k (i mid , j)) is used to denote the value of M k (i mid , j) in E(k, j) and others are analogous. The global variables", "cite_spans": [], "ref_spans": [{"start": 112, "end": 120, "text": "Figure 3", "ref_id": "FIGREF2"}], "section": "Fig. 2."}, {"text": "are computed in Algorithm BestScore so that they can be used directly in Algorithm CPSA-DC.", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Algorithm CPSA-DC(i start , i end , j start , j end , k start , k end ) Input: Sequences a i start \u00b7 \u00b7 \u00b7 a i end and b j start \u00b7 \u00b7 \u00b7 b j end with constraints (C k start , . . . , C k end )", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "Align the nonempty sequence with spaces; else i mid = i start +i end 2 ; BestScore(i start , i mid , j start , j end , k start , k end );", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "if E(N k (i mid , j , \u03bb k )) + E(M k (i mid , j)) > max then max = E(N k (i mid , j , \u03bb k )) + E(M k (i mid , j)); j mid = j ; k mid = k; h mid = h; type = case 5; end if end if end if end for end for 3: if type = case 1 then CPSA-DC(i start , i mid \u2212 1, j start , j mid , k start , k mid ); Align a i mid with a space; CPSA-DC(i mid + 1, i end , j mid + 1, j end , k mid + 1, k end ); end if if type = case 2 then CPSA-DC(i start , i mid \u2212 1, j start , j mid , k start , k mid ); Align a i mid a i mid +1 with two spaces; CPSA-DC(i mid + 2, i end , j mid + 1, j end , k mid + 1, k end ); end if if type = case 3 then CPSA-DC(i start , i mid \u2212 1, j start , j mid \u2212 1, k start , k mid ); Align a i mid with b j mid ; CPSA-DC(i mid + 1, i end , j mid + 1, j end , k mid + 1, k end ); end if if type = case 4 then CPSA-DC(i start , i mid \u2212 h mid , j start , j mid \u2212 h mid , k start , k mid \u2212 1); Align a i mid \u2212h mid +1 \u00b7 \u00b7 \u00b7 a i mid +\u03bb k \u2212h mid with b j mid \u2212h mid +1 \u00b7 \u00b7 \u00b7 b j mid +\u03bb k \u2212h mid ; CPSA-DC(i mid + \u03bb k \u2212 h mid + 1, i end , j mid + \u03bb k \u2212 h mid + 1, j end , k mid + 1, k end ); end if if type = case 5 then CPSA-DC(i start , i mid \u2212 \u03bb k , j start , j mid \u2212 \u03bb k , k start , k mid \u2212 1); Align a i mid \u2212\u03bb k +1 \u00b7 \u00b7 \u00b7 a i mid with b j mid \u2212\u03bb+1 \u00b7 \u00b7 \u00b7 b j mid ; CPSA-DC(i mid + 1, i end , j mid + 1, j end , k mid + 1, k end ); end if Algorithm BestScore(i start , i end , j start , j end , k start , k end ) Input: Sequences a i start \u00b7 \u00b7 \u00b7 a i end and b j start \u00b7 \u00b7 \u00b7 b j end with constraints (C k start , . . . , C k end ) 1: /* Reindex */ m = i start \u2212 i end + 1; n = j start \u2212 j end + 1; \u03b3 = k start \u2212 k end + 1; 2: /* Initialization */ for j = 0 to n do for k = 0 to \u03b3 do", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "if k \u2265 1 then for h = 1 to \u03bb k do E(N k (i mid , j , h)) = \u2212\u221e; end if end for end for 3: /* Computation */ for i = 1 to m do for k = 0 to \u03b3 do /* For the case of", "cite_spans": [], "ref_spans": [], "section": "Fig. 2."}, {"text": "end if end for end if end for end for end for Now, we analyze the time-complexity of our CPSA-DC algorithm for solving the CPSA. As shown in Figure 2 , after determining the middle position (i mid , j mid , k mid ) of the optimal path in G, we can divide the original problem into two subproblems, each of which further can be recursively divided into two smaller subproblems using the same way. Note that regardless of where the optimal path passes through (i mid , j mid , k mid ), the total size of the two reduced subproblems is just half the size of the original problem, where the size is measured by the number of entries in G. It is not hard to see that the time-complexity of determining the middle position of each subproblem at each recursive stage is proportional to the size of the subproblem. Let denote the size of the original problem (i.e. = \u03b3 mn). Then the total time-complexity of our CPSA-DC algorithm is equal to + 2 + 4 + \u00b7 \u00b7 \u00b7 = 2 , which is twice as high as the CPSA-DP algorithm. Using the CPSA-DC algorithm as a kernel, we were able to design a memory-efficient algorithm, termed CMSA-DC, for progressively aligning multiple input sequences into a CMSA according to the branching order of a guide tree. The above progressive method we adopted was proposed by Tang et al. (2003) . Owing to space limitation, we refer the reader to their paper for the details of its implementation.", "cite_spans": [{"start": 1285, "end": 1303, "text": "Tang et al. (2003)", "ref_id": "BIBREF34"}], "ref_spans": [{"start": 141, "end": 149, "text": "Figure 2", "ref_id": null}], "section": "Fig. 2."}, {"text": "We use Java language to implement the CMSA-DC algorithm as a web server, called as MuSiC-ME (Memory-Efficient tool for Multiple Sequence Alignment with Constraints). The input of the MuSiC-ME system consists of a set of protein/DNA/RNA sequences and a set of user-specified constraints, each with a fragment of residue/nucleotide that (approximately) appears in all input sequences. The output of MuSiC-ME is a CMSA in which the fragments of the input sequences whose residues/nucleotides exhibit a given degree The memory usage includes JVM (Java Virtual Machine), code (MuSiC/MuSiC-ME) and data, and MuSiC cannot deal with the case of CoV-3 -UTR due to running out of memory.", "cite_spans": [], "ref_spans": [], "section": "EXPERIMENTAL RESULTS"}, {"text": "of similarity to a constraint are aligned together. For its biological applications, we refer the reader to other related papers (Tang et al., 2003; Tsai et al., 2004) . In the following, we evaluate our memory-efficient MuSiC-ME system and compare its running time and memory to the original MuSiC system (Tsai et al., 2004) , whose kernel CPSA algorithm was implemented by the dynamic programming approach. We chose five families of protein/RNA sequences as our testing datasets, each of which has been shown to contain an ordered series of conserved motifs related to the structures/functionalities/consensuses of the family (McClure et al., 1994; Chin et al., 2003; Tang et al., 2003; Tsai et al., 2004) : (1) the aspartic acid protease family (Protease), (2) the hemoglobins family (Globin), (3) the ribonuclease family (RNase), (4) the kinase family (Kinase) and (5) the 3 -untranslated region of the coronaviruses (CoV-3 -UTR). From each family, we have selected a representative set of sequences and adopted the ordered series of conserved motifs as the constraints. Table 1 lists the information of the tested families and their constraints. All tests were run with default parameters on IBM PC with 1.26 GHz processor and 512 MB RAM under Linux system. Table 2 lists the CPU time and memory usage of our experiments using MuSiC and MuSiC-ME. It shows that the memory usage of MuSiC-ME is much smaller than that of MuSiC for large-scale sequences, and the CPU time required by MuSiC-ME is smaller than that required by MuSiC for short sequences, since we have simplified the recurrences of the dynamic programming here.", "cite_spans": [{"start": 129, "end": 148, "text": "(Tang et al., 2003;", "ref_id": "BIBREF34"}, {"start": 149, "end": 167, "text": "Tsai et al., 2004)", "ref_id": "BIBREF40"}, {"start": 306, "end": 325, "text": "(Tsai et al., 2004)", "ref_id": "BIBREF40"}, {"start": 628, "end": 650, "text": "(McClure et al., 1994;", "ref_id": "BIBREF20"}, {"start": 651, "end": 669, "text": "Chin et al., 2003;", "ref_id": "BIBREF5"}, {"start": 670, "end": 688, "text": "Tang et al., 2003;", "ref_id": "BIBREF34"}, {"start": 689, "end": 707, "text": "Tsai et al., 2004)", "ref_id": "BIBREF40"}], "ref_spans": [{"start": 1075, "end": 1082, "text": "Table 1", "ref_id": "TABREF1"}, {"start": 1263, "end": 1270, "text": "Table 2", "ref_id": "TABREF2"}], "section": "EXPERIMENTAL RESULTS"}, {"text": "It is worth mentioning that in MuSiC-ME system, the letters representing the constraints are not just the individual residues/nucleotides, but also the IUPAC (International Union of Pure and Applied Chemistry) codes. For example, nucleotides N and R have the meanings of any nucleotides and purine (i.e. A or G), respectively. This enhanced improvement will enable the user to define more flexible constraints or combine several small constraints with fixed distances into a large one. For example, consider our fifth experiment above related to the 3 -UTRs of the coronavirus sequences, including HCV-229E (human coronavirus), PEDV (porcine epidemic diarrhea virus), TGEV (porcine transmissible gastroenteritis virus), BCV (bovine coronavirus), MHV (mouse hepatitis virus) and SARS-TW1 (severe acute respiratory syndrome virus). All the 12 adopted constraints appear in the fragment sequences that were able to fold themselves into a stable pseudoknot structure (Williams et al., 1999; Tsai et al., 2004) . However, these adopted constraints are too short to correctly align the truly conserved motifs of sequences together, since the short constraints occur frequently in the large genomic sequences that led to the difficulty in identifying the true occurrences. In fact, four pairs of two consecutive constraints appear in the stem regions (containing no loops) of pseudoknots and each paired constraints is separated by a non-conserved subsequence of fixed length. Hence, we can combine each pair of constraints into a new and larger constraint by representing the non-conserved part with N. Consequently, we got eight new constraints with the order of (CUNNNNC, A, AA, G, C, UNNNA, GNNNNAG, UNNNA) for this dataset. After running MuSiC-ME, a satisfied CMSA was found (Figure 4) , where the band of the resulting CMSA corresponding to a constraint is black and its corresponding constraint is displayed beneath it. This resulting CMSA implies that the fragment of SARS-TW1 between the first band and the last band may fold into a pseudoknot structure that is possibly involved in replicating SARS viruses (Pleij, 1994; Deiman and Pleij, 1997) . In fact, this fragment is the pseudoknot sequence of SART-TW1 that was found by Tsai et al. (2004) using MuSiC to align the 3 -UTR of SARS-TW1 with the pseudoknot sequences, instead of 3 -UTRs, of other coronaviruses. The input sequences of the above experiment were also tested by Clustal W 1.82, the most commonly used MSA tool. According to its resulting MSA as shown in Figure 5 , the fragments of all pseudoknots, including our detected pseudoknot for SARS-TW1, were not able to align well so that it is difficult for us to identify the exact fragment of the SARS-TW1 pseudoknot from this MSA.", "cite_spans": [{"start": 963, "end": 986, "text": "(Williams et al., 1999;", "ref_id": "BIBREF42"}, {"start": 987, "end": 1005, "text": "Tsai et al., 2004)", "ref_id": "BIBREF40"}, {"start": 2110, "end": 2123, "text": "(Pleij, 1994;", "ref_id": "BIBREF28"}, {"start": 2124, "end": 2147, "text": "Deiman and Pleij, 1997)", "ref_id": "BIBREF7"}, {"start": 2230, "end": 2248, "text": "Tsai et al. (2004)", "ref_id": "BIBREF40"}], "ref_spans": [{"start": 1773, "end": 1783, "text": "(Figure 4)", "ref_id": "FIGREF3"}, {"start": 2524, "end": 2532, "text": "Figure 5", "ref_id": "FIGREF4"}], "section": "EXPERIMENTAL RESULTS"}, {"text": "In this paper, we designed a memory-efficient program for performing the CMSA, which can incorporate the knowledge of biologists about the structures/functionalities/consensuses of their datasets into sequence alignment such that the userspecified residues/nucleotides are aligned together. We first used the divide-and-conquer approach to design a memoryefficient algorithm for optimally aligning two sequences with constraints, and then based on this algorithm, we used the progressive method to develop a memory-efficient tool, called MuSiC-ME, for heuristically aligning multiple sequences with constraints. The proposed MuSiC-ME system makes it possible to align several large-scale protein/DNA/RNA sequences with constraints through the desktop PC with the limited memory. In this system, moreover, the letters allowed to represent the constraints are the IUPAC codes, which will enable the user to define more flexible constraints or combine several small constraints with fixed distances into a large one. It is worth mentioning that the A * algorithm, a heuristic search method in Artificial Intelligence, has been extensively used to time-and/or memory-efficiently solve the general MSA problem without constraints Imai, 1994, 1999; Kobayashi and Imai, 1999; Lermen and Reinert, 2000) . Hence, it is interesting to study whether or not the A * algorithm can still be applied to the CMSA problem.", "cite_spans": [{"start": 1225, "end": 1242, "text": "Imai, 1994, 1999;", "ref_id": null}, {"start": 1243, "end": 1268, "text": "Kobayashi and Imai, 1999;", "ref_id": "BIBREF17"}, {"start": 1269, "end": 1294, "text": "Lermen and Reinert, 2000)", "ref_id": "BIBREF18"}], "ref_spans": [], "section": "CONCLUSIONS"}], "bib_entries": {"BIBREF0": {"ref_id": "b0", "title": "Approximation algorithms for multiple sequence alignment", "authors": [{"first": "V", "middle": [], "last": "Bafna", "suffix": ""}, {"first": "E", "middle": ["L"], "last": "Lawler", "suffix": ""}, {"first": "P", "middle": ["A"], "last": "Pevzner", "suffix": ""}], "year": 1997, "venue": "Theoret. Comput. Sci", "volume": "182", "issn": "", "pages": "233--244", "other_ids": {}}, "BIBREF1": {"ref_id": "b1", "title": "The complexity of multiple sequence alignment with SP-score that is a metric", "authors": [{"first": "P", "middle": [], "last": "Bonizzoni", "suffix": ""}, {"first": "G", "middle": ["D"], "last": "Vedova", "suffix": ""}], "year": 2001, "venue": "Theoret. Comput. Sci", "volume": "259", "issn": "", "pages": "63--79", "other_ids": {}}, "BIBREF2": {"ref_id": "b2", "title": "The multiple sequence alignment problem in biology", "authors": [{"first": "H", "middle": [], "last": "Carrillo", "suffix": ""}, {"first": "D", "middle": [], "last": "Lipman", "suffix": ""}], "year": 1988, "venue": "SIAM J. Appl. Math", "volume": "48", "issn": "", "pages": "1073--1082", "other_ids": {}}, "BIBREF3": {"ref_id": "b3", "title": "A survey of multiple sequence comparison methods", "authors": [{"first": "S", "middle": ["C"], "last": "Chan", "suffix": ""}, {"first": "A", "middle": ["K C"], "last": "Wong", "suffix": ""}, {"first": "D", "middle": ["K Y"], "last": "Chiu", "suffix": ""}], "year": 1992, "venue": "Bull. Math. Biol", "volume": "54", "issn": "", "pages": "563--598", "other_ids": {}}, "BIBREF4": {"ref_id": "b4", "title": "Recent developments in linear-space alignment methods: a survey", "authors": [{"first": "K", "middle": ["M"], "last": "Chao", "suffix": ""}, {"first": "R", "middle": ["C"], "last": "Hardison", "suffix": ""}, {"first": "W", "middle": [], "last": "Miller", "suffix": ""}], "year": 1994, "venue": "J. Comput. Biol", "volume": "1", "issn": "", "pages": "271--291", "other_ids": {}}, "BIBREF5": {"ref_id": "b5", "title": "Efficient constrained multiple sequence alignment with performance guarantee", "authors": [{"first": "F", "middle": ["Y L"], "last": "Chin", "suffix": ""}, {"first": "N", "middle": ["L"], "last": "Ho", "suffix": ""}, {"first": "T", "middle": ["W"], "last": "Lamy", "suffix": ""}, {"first": "P", "middle": ["W H"], "last": "Wong", "suffix": ""}, {"first": "M", "middle": ["Y"], "last": "Chan", "suffix": ""}], "year": 2003, "venue": "Proceedings of the IEEE Computer Society Bioinformatics Conference", "volume": "", "issn": "", "pages": "337--346", "other_ids": {}}, "BIBREF6": {"ref_id": "b6", "title": "Multiple sequence alignment with hierarchical clustering", "authors": [{"first": "F", "middle": [], "last": "Corpet", "suffix": ""}], "year": 1988, "venue": "Nucleic Acids Res", "volume": "16", "issn": "", "pages": "10881--10890", "other_ids": {}}, "BIBREF7": {"ref_id": "b7", "title": "Pseudoknots: a vital feature in viral RNA", "authors": [{"first": "B", "middle": [], "last": "Deiman", "suffix": ""}, {"first": "C", "middle": ["W A"], "last": "Pleij", "suffix": ""}], "year": 1997, "venue": "Semin. Virol", "volume": "8", "issn": "", "pages": "166--175", "other_ids": {}}, "BIBREF8": {"ref_id": "b8", "title": "MATCH-BOX: a fundamentally new algorithm for the simultaneous alignment of several protein sequences", "authors": [{"first": "E", "middle": [], "last": "Depiereux", "suffix": ""}, {"first": "E", "middle": [], "last": "Feytmans", "suffix": ""}], "year": 1992, "venue": "Comput. Appl. Biosci", "volume": "8", "issn": "", "pages": "501--509", "other_ids": {}}, "BIBREF9": {"ref_id": "b9", "title": "Progressive sequence alignment as a prerequisite to correct phylogenetic trees", "authors": [{"first": "D", "middle": ["F"], "last": "Feng", "suffix": ""}, {"first": "R", "middle": ["F"], "last": "Doolittle", "suffix": ""}], "year": 1987, "venue": "J. Mol. Evol", "volume": "25", "issn": "", "pages": "351--360", "other_ids": {}}, "BIBREF10": {"ref_id": "b10", "title": "Efficient methods for multiple sequence alignment with guaranteed error bounds", "authors": [{"first": "D", "middle": [], "last": "Gusfield", "suffix": ""}], "year": 1993, "venue": "Bull. Math. Biol", "volume": "55", "issn": "", "pages": "141--154", "other_ids": {}}, "BIBREF11": {"ref_id": "b11", "title": "Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology", "authors": [{"first": "D", "middle": [], "last": "Gusfield", "suffix": ""}], "year": 1997, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF12": {"ref_id": "b12", "title": "CLUSTAL: a package for performing multiple sequence alignment on a microcomputer", "authors": [{"first": "D", "middle": [], "last": "Higgins", "suffix": ""}, {"first": "P", "middle": [], "last": "Sharpe", "suffix": ""}], "year": 1988, "venue": "Gene", "volume": "73", "issn": "", "pages": "237--244", "other_ids": {}}, "BIBREF13": {"ref_id": "b13", "title": "A linear space algorithm for computing maximal common subsequences", "authors": [{"first": "D", "middle": ["S"], "last": "Hirschberg", "suffix": ""}], "year": 1975, "venue": "Commun. ACM", "volume": "18", "issn": "", "pages": "341--343", "other_ids": {}}, "BIBREF14": {"ref_id": "b14", "title": "Fast A * algorithms for multiple sequence alignment", "authors": [{"first": "T", "middle": [], "last": "Ikeda", "suffix": ""}, {"first": "H", "middle": [], "last": "Imai", "suffix": ""}], "year": 1994, "venue": "Proceedings of the Genome Informatics Workshop", "volume": "", "issn": "", "pages": "90--99", "other_ids": {}}, "BIBREF15": {"ref_id": "b15", "title": "Enhanced A * algorithms for multiple alignments: optimal alignments for several sequences and k-opt approximate alignments for large cases", "authors": [{"first": "T", "middle": [], "last": "Ikeda", "suffix": ""}, {"first": "H", "middle": [], "last": "Imai", "suffix": ""}], "year": 1999, "venue": "Theoret. Comput. Sci", "volume": "210", "issn": "", "pages": "341--374", "other_ids": {}}, "BIBREF16": {"ref_id": "b16", "title": "The maximum weight trace problem in multiple sequence alignment", "authors": [{"first": "J", "middle": ["D"], "last": "Kececioglu", "suffix": ""}], "year": 1993, "venue": "Proceedings of the Fourth Annual Symposium on Combinatorial Pattern Matching (CPM 2004)", "volume": "684", "issn": "", "pages": "106--119", "other_ids": {}}, "BIBREF17": {"ref_id": "b17", "title": "Improvement of the A * algorithm for multiple sequence alignment", "authors": [{"first": "H", "middle": [], "last": "Kobayashi", "suffix": ""}, {"first": "H", "middle": [], "last": "Imai", "suffix": ""}], "year": 1999, "venue": "Proceedings of the Genome Informatics Workshop", "volume": "", "issn": "", "pages": "120--130", "other_ids": {}}, "BIBREF18": {"ref_id": "b18", "title": "The practical use of the A * algorithm for exact multiple sequence alignment", "authors": [{"first": "M", "middle": [], "last": "Lermen", "suffix": ""}, {"first": "K", "middle": [], "last": "Reinert", "suffix": ""}], "year": 2000, "venue": "J. Comput. Biol", "volume": "7", "issn": "", "pages": "655--672", "other_ids": {}}, "BIBREF19": {"ref_id": "b19", "title": "Near optimal multiple alignment within a band in polynomial time", "authors": [{"first": "M", "middle": [], "last": "Li", "suffix": ""}, {"first": "B", "middle": [], "last": "Ma", "suffix": ""}, {"first": "L", "middle": [], "last": "Wang", "suffix": ""}], "year": 2000, "venue": "Proceedings of the Thirty Second Annual ACM Symposium on Theory of Computing", "volume": "", "issn": "", "pages": "425--434", "other_ids": {}}, "BIBREF20": {"ref_id": "b20", "title": "Comparative analysis of multiple protein-sequence alignment methods", "authors": [{"first": "M", "middle": ["A"], "last": "Mcclure", "suffix": ""}, {"first": "T", "middle": ["K"], "last": "Vasi", "suffix": ""}, {"first": "W", "middle": ["M"], "last": "Fitch", "suffix": ""}], "year": 1994, "venue": "Mol. Biol. Evol", "volume": "11", "issn": "", "pages": "571--592", "other_ids": {}}, "BIBREF21": {"ref_id": "b21", "title": "DIALIGN 2: improvement of the segment-to-segment approach to multiple sequence alignment", "authors": [{"first": "B", "middle": [], "last": "Morgenstern", "suffix": ""}], "year": 1999, "venue": "Bioinformatics", "volume": "15", "issn": "", "pages": "211--218", "other_ids": {}}, "BIBREF22": {"ref_id": "b22", "title": "Optimal alignment in linear space", "authors": [{"first": "E", "middle": ["W"], "last": "Myers", "suffix": ""}, {"first": "W", "middle": [], "last": "Miller", "suffix": ""}], "year": 1988, "venue": "Comput. Appl. Biosci", "volume": "4", "issn": "", "pages": "11--17", "other_ids": {}}, "BIBREF23": {"ref_id": "b23", "title": "Progressive multiple alignment with constraints", "authors": [{"first": "G", "middle": [], "last": "Myers", "suffix": ""}, {"first": "S", "middle": [], "last": "Selznick", "suffix": ""}, {"first": "Z", "middle": [], "last": "Zhang", "suffix": ""}, {"first": "W", "middle": [], "last": "Miller", "suffix": ""}], "year": 1996, "venue": "J. Comput. Biol", "volume": "3", "issn": "", "pages": "563--572", "other_ids": {}}, "BIBREF24": {"ref_id": "b24", "title": "Strategies for multiple sequence alignment", "authors": [{"first": "H", "middle": ["B"], "last": "Nicholas", "suffix": ""}, {"first": "A", "middle": ["J"], "last": "Ropelewski", "suffix": ""}, {"first": "D", "middle": ["W"], "last": "Deerfield", "suffix": ""}], "year": 2002, "venue": "Biotechniques", "volume": "32", "issn": "", "pages": "592--603", "other_ids": {}}, "BIBREF25": {"ref_id": "b25", "title": "Recent progresses in multiple sequence alignment: a survey", "authors": [{"first": "C", "middle": [], "last": "Notredame", "suffix": ""}], "year": 2002, "venue": "Pharmacogenomics", "volume": "3", "issn": "", "pages": "131--144", "other_ids": {}}, "BIBREF26": {"ref_id": "b26", "title": "T-Coffee: a novel method for fast and accurate multiple sequence alignment", "authors": [{"first": "C", "middle": [], "last": "Notredame", "suffix": ""}, {"first": "D", "middle": ["G"], "last": "Higgins", "suffix": ""}, {"first": "J", "middle": [], "last": "Heringa", "suffix": ""}], "year": 2000, "venue": "J. Mol. Biol", "volume": "302", "issn": "", "pages": "205--217", "other_ids": {}}, "BIBREF27": {"ref_id": "b27", "title": "Multiple alignment, communication cost, and graph matching", "authors": [{"first": "P", "middle": ["A"], "last": "Pevzner", "suffix": ""}], "year": 1992, "venue": "SIAM J. Appl. Math", "volume": "52", "issn": "", "pages": "1763--1779", "other_ids": {}}, "BIBREF28": {"ref_id": "b28", "title": "RNA pseudoknots", "authors": [{"first": "C", "middle": ["W A"], "last": "Pleij", "suffix": ""}], "year": 1994, "venue": "Curr. Opin. Struct. Biol", "volume": "4", "issn": "", "pages": "337--344", "other_ids": {}}, "BIBREF29": {"ref_id": "b29", "title": "Divide-andconquer multiple alignment with segment-based constraints", "authors": [{"first": "M", "middle": [], "last": "Sammeth", "suffix": ""}, {"first": "B", "middle": [], "last": "Morgenstern", "suffix": ""}, {"first": "J", "middle": [], "last": "Stoye", "suffix": ""}], "year": 2003, "venue": "Bioinformatics", "volume": "19", "issn": "", "pages": "189--195", "other_ids": {}}, "BIBREF30": {"ref_id": "b30", "title": "A workbench for multiple alignment construction and analysis", "authors": [{"first": "G", "middle": ["D"], "last": "Schuler", "suffix": ""}, {"first": "S", "middle": ["F"], "last": "Altschul", "suffix": ""}, {"first": "D", "middle": ["J"], "last": "Lipman", "suffix": ""}], "year": 1991, "venue": "Proteins", "volume": "9", "issn": "", "pages": "180--190", "other_ids": {}}, "BIBREF31": {"ref_id": "b31", "title": "Multiple sequence alignment with the divide-andconquer method", "authors": [{"first": "J", "middle": [], "last": "Stoye", "suffix": ""}], "year": 1998, "venue": "Gene", "volume": "211", "issn": "", "pages": "45--56", "other_ids": {}}, "BIBREF32": {"ref_id": "b32", "title": "DCA: an efficient implementation of the divide-and-conquer approach to simultaneous multiple sequence alignment", "authors": [{"first": "J", "middle": [], "last": "Stoye", "suffix": ""}, {"first": "V", "middle": [], "last": "Moulton", "suffix": ""}, {"first": "A", "middle": ["W M"], "last": "Dress", "suffix": ""}], "year": 1997, "venue": "Comput. Appl. Biosci", "volume": "13", "issn": "", "pages": "625--626", "other_ids": {}}, "BIBREF33": {"ref_id": "b33", "title": "Improving the divide-and-conquer approach to sum-of-pairs multiple sequence alignment", "authors": [{"first": "J", "middle": [], "last": "Stoye", "suffix": ""}, {"first": "S", "middle": ["W"], "last": "Perrey", "suffix": ""}, {"first": "A", "middle": ["W M"], "last": "Dress", "suffix": ""}], "year": 1997, "venue": "Appl. Math. Lett", "volume": "10", "issn": "", "pages": "67--73", "other_ids": {}}, "BIBREF34": {"ref_id": "b34", "title": "Constrained multiple sequence alignment tool development and its application to RNase family alignment", "authors": [{"first": "C", "middle": ["Y"], "last": "Tang", "suffix": ""}, {"first": "C", "middle": ["L"], "last": "Lu", "suffix": ""}, {"first": "M", "middle": ["D T"], "last": "Chang", "suffix": ""}, {"first": "Y", "middle": ["T"], "last": "Tsai", "suffix": ""}, {"first": "Y", "middle": ["J"], "last": "Sun", "suffix": ""}, {"first": "K", "middle": ["M"], "last": "Chao", "suffix": ""}, {"first": "J", "middle": ["M"], "last": "Chang", "suffix": ""}, {"first": "Y", "middle": ["H"], "last": "Chiou", "suffix": ""}, {"first": "C", "middle": ["M"], "last": "Wu", "suffix": ""}, {"first": "H", "middle": ["T"], "last": "Chang", "suffix": ""}, {"first": "W", "middle": ["I"], "last": "Chou", "suffix": ""}], "year": 2003, "venue": "J. Bioinform. Comput. Biol", "volume": "1", "issn": "", "pages": "267--287", "other_ids": {}}, "BIBREF35": {"ref_id": "b35", "title": "Multiple sequence alignment by a pairwise algorithm", "authors": [{"first": "W", "middle": ["R"], "last": "Taylor", "suffix": ""}], "year": 1987, "venue": "Comput. Appl. Biosci", "volume": "3", "issn": "", "pages": "81--87", "other_ids": {}}, "BIBREF36": {"ref_id": "b36", "title": "Motif-biased protein sequence alignment", "authors": [{"first": "W", "middle": ["R"], "last": "Taylor", "suffix": ""}], "year": 1994, "venue": "J. Comput. Biol", "volume": "1", "issn": "", "pages": "297--310", "other_ids": {}}, "BIBREF37": {"ref_id": "b37", "title": "CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position specific gap penalties, and weight matrix choice", "authors": [{"first": "J", "middle": ["D"], "last": "Thompson", "suffix": ""}, {"first": "D", "middle": ["G"], "last": "Higgs", "suffix": ""}, {"first": "T", "middle": ["J"], "last": "Gibson", "suffix": ""}], "year": 1994, "venue": "Nucleic Acids Res", "volume": "22", "issn": "", "pages": "4673--4680", "other_ids": {}}, "BIBREF38": {"ref_id": "b38", "title": "DbClustal: rapid and reliable global multiple alignments of protein sequences detected by database searches", "authors": [{"first": "J", "middle": ["D"], "last": "Thompson", "suffix": ""}, {"first": "F", "middle": [], "last": "Plewniak", "suffix": ""}, {"first": "J.-C", "middle": [], "last": "Thierry", "suffix": ""}, {"first": "O", "middle": [], "last": "Poch", "suffix": ""}], "year": 2000, "venue": "Nucleic Acids Res", "volume": "28", "issn": "", "pages": "2919--2926", "other_ids": {}}, "BIBREF39": {"ref_id": "b39", "title": "A general method for fast multiple sequence alignment", "authors": [{"first": "U", "middle": [], "last": "T\u00f6nges", "suffix": ""}, {"first": "S", "middle": ["W"], "last": "Perrey", "suffix": ""}, {"first": "J", "middle": [], "last": "Stoye", "suffix": ""}, {"first": "A", "middle": ["W M"], "last": "Dress", "suffix": ""}], "year": 1996, "venue": "Gene", "volume": "172", "issn": "", "pages": "33--41", "other_ids": {}}, "BIBREF40": {"ref_id": "b40", "title": "MuSiC: a tool for multiple sequence alignment with constraints", "authors": [{"first": "Y", "middle": ["T"], "last": "Tsai", "suffix": ""}, {"first": "Y", "middle": ["P"], "last": "Huang", "suffix": ""}, {"first": "C", "middle": ["T"], "last": "Yu", "suffix": ""}, {"first": "C", "middle": ["L"], "last": "Lu", "suffix": ""}], "year": 2004, "venue": "Bioinformatics", "volume": "", "issn": "", "pages": "", "other_ids": {}}, "BIBREF41": {"ref_id": "b41", "title": "On the complexity of multiple sequence alignment", "authors": [{"first": "L", "middle": [], "last": "Wang", "suffix": ""}, {"first": "T", "middle": [], "last": "Jiang", "suffix": ""}], "year": 1994, "venue": "J. Comput. Biol", "volume": "1", "issn": "", "pages": "337--348", "other_ids": {}}, "BIBREF42": {"ref_id": "b42", "title": "A phylogenetically conserved hairpin-type 39 untranslated region pseudoknot functions in coronavirus RNA replication", "authors": [{"first": "G", "middle": ["D"], "last": "Williams", "suffix": ""}, {"first": "R.-Y", "middle": [], "last": "Chang", "suffix": ""}, {"first": "D", "middle": ["A"], "last": "Brian", "suffix": ""}], "year": 1999, "venue": "J. Virol", "volume": "73", "issn": "", "pages": "8349--8355", "other_ids": {}}, "BIBREF43": {"ref_id": "b43", "title": "Efficient algorithms for constrained sequence alignment problems", "authors": [{"first": "C", "middle": ["T"], "last": "Yu", "suffix": ""}], "year": 2003, "venue": "", "volume": "", "issn": "", "pages": "", "other_ids": {}}}, "ref_entries": {"FIGREF0": {"text": "L D k (A i , B j ) denote the alignment of A i and B j with score M D k (i, j) that ends with a deletion pair (a i , \u2212). Let L be the portion of L D k (A i , B j ) before the last aligned pair (a i , \u2212). Then there are three possibilities when we consider the last aligned pair of L . Case 1: The last aligned pair of L is a substitution pair. Then the score of L is M S k (i \u2212 1, j) and (a i , \u2212) is charged by a gap-open penalty and a gap-extension penalty in M D k", "latex": null, "type": "figure"}, "FIGREF1": {"text": "The schematic diagram of four adjacent entries of G, where entry", "latex": null, "type": "figure"}, "FIGREF2": {"text": "The grid locations of E(k \u2212 1), E(k) and the values in V k\u22121 and V k when the entry (i, j , k) of G, marked with '?', is reached for the computation.", "latex": null, "type": "figure"}, "FIGREF3": {"text": "The partial display of the resulting CMSA of MuSiC-ME by aligning the sequences of SARS-TW1 3 -UTR with those of other five coronaviruses.", "latex": null, "type": "figure"}, "FIGREF4": {"text": "The partial display of the resulting MSA of Clustal W 1.82 by aligning the 3 -UTR sequences of six coronaviruses, where the bases not in the pseudoknots are marked with dots.", "latex": null, "type": "figure"}, "TABREF0": {"text": "the score of an optimal semi-constrained alignment L of A i and B j w.r.t. k (h) that begins with a band whose induced consensus is equal to suff(C k , \u03bb k \u2212 h). Note that the recurrences for computing matrices M k , M", "latex": null, "type": "table"}, "TABREF1": {"text": "The information of the tested families and their constraints", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Family </td><td>#SEQ </td><td>MAXSEQ </td><td>#CON </td><td>MAXCON\n</td></tr><tr><td>Protease </td><td>6 </td><td>123 </td><td>4 </td><td>1\n</td></tr><tr><td>Globin </td><td>6 </td><td>146 </td><td>7 </td><td>2\n</td></tr><tr><td>RNase </td><td>6 </td><td>185 </td><td>3 </td><td>1\n</td></tr><tr><td>Kinase \u2032</td><td>6 </td><td>353 </td><td>10 </td><td>3\n</td></tr><tr><td>CoV-3-UTR </td><td>6 </td><td>422 </td><td>12 </td><td>2\n</td></tr></table></body></html>"}, "TABREF2": {"text": "The", "latex": null, "type": "table", "html": "<html><body><table><tr><td>Family </td><td>#SEQ </td><td>MAXSEQ </td><td>#CON </td><td>MAXCON\n</td></tr><tr><td>Protease </td><td>6 </td><td>123 </td><td>4 </td><td>1\n</td></tr><tr><td>Globin </td><td>6 </td><td>146 </td><td>7 </td><td>2\n</td></tr><tr><td>RNase </td><td>6 </td><td>185 </td><td>3 </td><td>1\n</td></tr><tr><td>Kinase \u2032</td><td>6 </td><td>353 </td><td>10 </td><td>3\n</td></tr><tr><td>CoV-3-UTR </td><td>6 </td><td>422 </td><td>12 </td><td>2\n</td></tr></table></body></html>"}}, "back_matter": [{"text": "The authors would like to thank the anonymous referees for their constructive comments to the presentation of this paper. This work was supported in part by National Science Council of Republic of China under grant NSC93-2213-E-009-113.", "cite_spans": [], "ref_spans": [], "section": "ACKNOWLEDGEMENTS"}]}