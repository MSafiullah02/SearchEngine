{
    "paper_id": "26d0d89f55a03ae3837fe225fd2ed10f676e5805",
    "metadata": {
        "title": "Comparing Integer Linear Programming to SAT-Solving for Hard Problems in Computational and Systems Biology",
        "authors": [
            {
                "first": "Hannah",
                "middle": [],
                "last": "Brown",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "addrLine": "Davis 1 Shields Avenue",
                        "postCode": "95616",
                        "settlement": "Davis",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": "hsbrown@ucdavis.edu"
            },
            {
                "first": "Lei",
                "middle": [],
                "last": "Zuo",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "addrLine": "Davis 1 Shields Avenue",
                        "postCode": "95616",
                        "settlement": "Davis",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": "leizuo@ucdavis.edu"
            },
            {
                "first": "Dan",
                "middle": [],
                "last": "Gusfield",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "addrLine": "Davis 1 Shields Avenue",
                        "postCode": "95616",
                        "settlement": "Davis",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": "dmgusfield@ucdavis.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "It is useful to have general-purpose solution methods that can be applied to a wide range of problems, rather than relying on the development of clever, intricate algorithms for each specific problem. Integer Linear Programming is the most widely-used such generalpurpose solution method. It is successful in a wide range of problems. However, there are some problems in computational biology where integer linear programming has had only limited success. In this paper, we explore an alternate, general-purpose solution method: SAT-solving, i.e., constructing Boolean formulas in conjunctive normal form (CNF) that encode a problem instance, and using a SAT-solver to determine if the CNF formula is satisfiable or not. In three hard problems examined, we were very surprised to find the SAT-solving approach was dramatically better than the ILP approach in two problems; and a little slower, but more robust, in the third problem. We also re-examined and confirmed an earlier result on a fourth problem, using current ILP and SAT-solvers. These results should encourage further efforts to exploit SAT-solving in computational biology.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Integer (Linear) Programming, abbreviated \"ILP\", is a versatile modeling and optimization technique that has been increasingly used in computational and systems biology in non-traditional ways. ILP is often (but not always) very effective in solving instances of hard computational problems on realistic biological Thanks to NSF for supporting this research under the grant 1528234. Support for H.B. was from NSF Research Experiences for Undergraduates grant 1528234. Thanks also to Chase Maguire for his contributions at the start of this project, and thanks to the very helpful and in-depth conference reviews we received. data of current importance. See [8] for an in-depth discussion of ILP in computational and systems biology, illustrating many successes (and some failures) of the ILP approach in computational and systems biology.",
            "cite_spans": [
                {
                    "start": 657,
                    "end": 660,
                    "text": "[8]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Despite the many successes of ILP in computational and systems biology, in the testing of ILP formulations during the writing of [8] , we observed a few computational biology problems where the ILP approach was only moderately effective, or was almost completely ineffective. For such hard problems, it is of interest to try different well-developed, general, computational techniques. The most well-developed such technique involves formulating a computational problem as a Boolean formula in Conjunctive Normal Form (CNF), and using a SAT-solver to determine whether that CNF formula is satisfiable. We wrote programs to create CNF-formulations for four hard computational biology problems, and tested these using the widely-used SAT-solver, pLingeling [3] . We wanted to see if this SAT approach could solve problem instances that were difficult for the ILP approach, using the highly-regarded ILP solver created by Gurobi Optimization. We then did some additional testing using another highly-regarded SAT-solver, Glucose-Syrup, to check that our results were not just artifacts of using pLingeling.",
            "cite_spans": [
                {
                    "start": 129,
                    "end": 132,
                    "text": "[8]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 755,
                    "end": 758,
                    "text": "[3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Previous comparisons of ILP and SAT found problems (not from computational biology) where the ILP approach was highly efficient but the SAT approach was ineffective [11] . In contrast, two other comparisons (for problems in computational biology) showed that the SAT approach was much faster than the ILP approach [15] [16] [17] .",
            "cite_spans": [
                {
                    "start": 165,
                    "end": 169,
                    "text": "[11]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 314,
                    "end": 318,
                    "text": "[15]",
                    "ref_id": null
                },
                {
                    "start": 319,
                    "end": 323,
                    "text": "[16]",
                    "ref_id": null
                },
                {
                    "start": 324,
                    "end": 328,
                    "text": "[17]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this Paper. We report on the development of SAT formulations, and in-depth empirical comparisons of ILP and SAT-solving for three hard problems, where prior ILP approaches were much less effective than desired: protein folding under the HP model; transforming gene orders by reversals; and computing the History Bound on the number of recombinations needed to generate a given set of SNP sequences. We also re-implemented and confirmed an earlier published result on the use of SAT-solving for the problem of haplotyping by pure parsimony. All of the software we developed is freely available online, as are the SAT-solvers we used, pLingeling (mostly) and Glucose-Syrup. The ILP-solver we used, from Gurobi Optimization, is available with a free academic license.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Results. In the protein folding problem, the ILP approach was seen to be generally faster than the SAT approach, with some notable exceptions. But in the other two newly-examined problems (reversals and History Bound), the SAT approach was substantially superior to the ILP approach in terms of solution times, and in the avoidance of extreme behaviors that the ILP approach sometimes exhibits. Also, our reexamination of pure-parsimony haplotyping confirmed the results in [15, 16] , and found extreme cases where SAT solved in a practical amount of time, but the ILP approach made little progress towards a solution.",
            "cite_spans": [
                {
                    "start": 474,
                    "end": 478,
                    "text": "[15,",
                    "ref_id": null
                },
                {
                    "start": 479,
                    "end": 482,
                    "text": "16]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We examine each of these hard problems in the next sections. We start with the protein folding problem, presenting the full logic and details of the CNF formulas in order to illustrate the SAT approach. Space limits the full details of the CNF formulas in discussing the other three problems. These will be detailed in an expanded paper to be written.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Determining the three-dimensional structure of proteins, or learning some parts of the structure, are critical tasks in biochemistry, biophysics, computational biology, and systems biology. For computational effectiveness, an attractive simple model of globular protein folding, the HP model, was proposed by Dill [5] in 1995, and has been extensively explored since then. The model simplifies the twenty standard amino acids by dividing them into two groups: the hydrophobic (H) and the hydrophilic (P); that is, water-fearful and water-loving. Hence a protein sequence, based on an alphabet of size twenty, is reduced to a binary sequence (H or P). For the biological motivation for this model, see [8] .",
            "cite_spans": [
                {
                    "start": 314,
                    "end": 317,
                    "text": "[5]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 701,
                    "end": 704,
                    "text": "[8]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Protein Folding via the HP Model"
        },
        {
            "text": "A prototein 1 is a binary sequence that we embed on a two-dimensional grid, where each 1 encodes an H and each 0 encodes a P. A legal embedding of a prototein on the grid must satisfy the following rules:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "1. Each character in the sequence gets assigned to some point on the grid. 2. No character in the sequence gets assigned to more than one point on the grid. 3. Each point of the grid gets assigned at most one character in the sequence. 4. Two adjacent characters in the sequence must be placed on two points that are neighbors on the grid in either the horizontal or vertical direction, but not both.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "These four rules mean that the sequence must be embedded into the grid as a self-avoiding walk, without deforming the sequence.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "In an embedding of the sequence, we say that a potential contact exists between neighboring points j and m on the grid G if and only if a 1 is assigned to both points j and m of G. A potential contact (j, m) is a (real) contact if the 1s that are assigned to points j and m are not adjacent in the sequence. The central assumption in the HP model is that the most stable fold is one that maximizes the number of contacts (H-H bonds). This leads to:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "The 2-D Prototein Problem. Given a binary sequence S, find a legal embedding of the sequence in the 2-D grid, G, to maximize the number of contacts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "We define the offset as the number of adjacent positions in sequence S that both have character 1. Clearly, the number of contacts in an embedding is the number of potential contacts minus the offset. Since we can easily determine the offset given S, the problem of maximizing the number of contacts can be solved by maximizing the number of potential contacts, and that is the approach we take. The 2-D Prototein Problem has been naturally generalized to a 3-D grid, which better models real protein folding.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "ILP and SAT Approaches to the Prototein Problem. Previously [8, 21] , ILP formulations were developed to solve the 2-D and 3-D Prototein Problems, and empirical results were reported in [8, 21] . The ILP formulations directly solve the optimization version of the problem, while the SAT formulation can only implement a decision version. The maximum number of contacts is then obtained by solving a series of such SAT decision problems, changing the target each time.",
            "cite_spans": [
                {
                    "start": 60,
                    "end": 63,
                    "text": "[8,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 64,
                    "end": 67,
                    "text": "21]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 186,
                    "end": 189,
                    "text": "[8,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 190,
                    "end": 193,
                    "text": "21]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "The Logic for the SAT Formulation. Given a target number of contacts, the SAT formulation must ensure that binary sequence S is legally embedded into grid G; have logic to represent what is and isn't a potential contact; and have logic to count the number of potential contacts in the embedding. The resulting CNF formula will be satisfied if and only if there is a legal embedding where the number of potential contacts meets or exceeds the target number.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "The points on the grid we use are numbered from 1 to w 2 for the 2-D version of the problem, and from 1 to w 3 in the 3-D version. So, each point on the grid is indexed by a single number. Clearly, w can be set to n, but choosing a smaller diameter results in much faster computation. We will discuss this later.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Ensuring Legal Embeddings. To represent the conditions for a legal embedding, we use variables X i,j , where i is a character-position in S and j is a point in G.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "If variable X i,j is set true, then the character at position i in S is assigned to point j in G. There are four conditions that ensure a legal embedding (in both 2-D and 3-D) of a binary sequence S:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "1. Every character i \u2208 S must be assigned to some point j \u2208 G. The CNF formulas for this condition are shown in Eq. 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "2. No character-position i \u2208 S can be assigned to more than one point j \u2208 G. The CNF formulas for this condition are shown in Eq. 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "3. No point j \u2208 G can have more than one character-position i \u2208 S assigned to it. The CNF formulas for this condition are similar to those for condition 2, varying over i and i rather than j and j . 4. Every adjacent pair of character-positions i, i + 1 \u2208 S must be placed on adjacent points in G (diagonals are not adjacent). So, for each position i \u2208 S and point j \u2208 G, we need the CNF clause shown in Eq. 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "1\u2264j \u2264|G| j and j' are neighbors",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Grid Size. To limit the number of variables, we set the grid diameter w to 1+ n 4 for all values of n \u2265 12, and to n otherwise. Likewise, in the 3-D version, w is set to 2 + n 8 for all values of n \u2265 20 and to 2 + n 4 otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Identifying Potential Contacts. There are two conditions for a potential contact:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "1. A potential contact involves point j \u2208 G if and only if a character 1 is assigned to point j. The variable T j is set true if and only if this condition holds. The CNF formulas for this are omitted for lack of space. 2. A potential contact exists between points j and m on the grid if and only if a 1 is assigned to both points j and to a neighboring point m in G. The variable C j,m will be set to true if both T j and T m are set true. The CNF formulas for this are shown in Eq. 4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Counting Potential Contacts. It is not obvious how to use CNF formulas to count the number of potential contacts in an embedding, i.e., the number of C variables set true. To implement counting we use a non-trivial method detailed in [11] and originating in [2] , which, given a goal number of potential contacts, m, counts the number of C variables that are not set true and tests whether it is less than or equal to r, where r = 2|G| \u2212 m for the 2-D version and r = 3|G| \u2212 m for the 3-D version. The CNF formulas for this are shown in Eq. 5.",
            "cite_spans": [
                {
                    "start": 234,
                    "end": 238,
                    "text": "[11]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 258,
                    "end": 261,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "The b variables exist for all internal nodes in a binary tree with c = log 2 (r) levels. Each internal node is assigned t k = min(r, 2 c\u2212d ) b variables, where d is the depth of node k. The leaves are set to C, and b k i being set true means there are at least i C variables set false in the leaves that descend from k. Using this method requires adding O(|G|) b variables to the SAT implementation, which are not present in the ILP version, however-consistent with the ILP implementationthe number of variables required for the whole CNF formula remains O(n|G|).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Testing. Both real and random sequences were tested for both 2-D and 3-D. The random sequences were generated with two different distributions: one where the average proportion of 1s in the sequence was 2 3 (this matches the actual case of globular proteins); and one where the average proportion was 1 3 . The random sequences ranged in length from six to twenty-four characters long for 2-D and from six to sixteen characters long for 3-D. The same random sequences were used for both 2-D and 3-D and were only tested with Gurobi and pLingeling. Ten random sequences of each length from both distributions were generated for testing, so each length was tested with a total of twenty random sequences. The real sequences used are a subset of those described and used in [12] and ranged in length from six to twenty-nine for 2-D and from six to twenty-five for 3-D; all were tested using Gurobi, pLingeling, and Glucose-Syrup. All the sequences were tested five times in order to compare the variance in run times on the same sequence. The tests were done via a pipeline that generated the files for both the CNF and ILP files; passed the files to the SAT and ILP solvers; and recorded the number of contacts found and the time taken by each solver. All the tests were done using a 2018 Mac Mini with a 3.2 GHz i7 processor. The pipeline programs for both the 2-D and 3-D versions, along with the input sequences used can be found on GitHub. 2 Unlike Gurobi, the SAT-solvers can only report whether a target number of potential contacts is possible or not. Because of this, it was necessary to include a wrapper binary-search function which performs a modified binary search over the targets. The search starts with target 1 and doubles the target until a result of unsatisfiable is returned, then executes a normal binary search between that value and the last satisfiable value. The times for each run of the SAT-solver are recorded and aggregated in the end report, but the generation of the CNF formulas was not timed, as it is minimal, and not the subject of this study.",
            "cite_spans": [
                {
                    "start": 301,
                    "end": 304,
                    "text": "1 3",
                    "ref_id": null
                },
                {
                    "start": 771,
                    "end": 775,
                    "text": "[12]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1442,
                    "end": 1443,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Results. Overall, Gurobi performed better than both pLingeling and Glucose-Syrup, both achieving faster times to reach an optimal solution and having smaller files. Between the two SAT-solvers, pLingeling performed better than Glucose-Syrup. In the tests run on real sequences, Glucose-Syrup generally performed better on short sequences than pLingeling, but was outperformed by pLingeling for longer sequences in both the 2-D and 3-D versions. One counterpoint of importance is that there were some sequences where Gurobi took much longer than did either SAT-solver, 3 and there were fewer cases where pLingeling took a similar amount more time than Gurobi. 4 Thus, pLingeling exhibited somewhat greater robustness than did Gurobi. Although both the SAT and ILP formulations have O(n|G|) variables, it takes many more clauses and occurrences of un-negated and negated variables to describe the same problem using CNF than using ILP inequalities.",
            "cite_spans": [
                {
                    "start": 568,
                    "end": 569,
                    "text": "3",
                    "ref_id": null
                },
                {
                    "start": 659,
                    "end": 660,
                    "text": "4",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Comparison of SAT and ILP Run Times. The run times follow a trend that is similar to the trend for file sizes, with pLingeling and Glucose-Syrup generally taking longer than Gurobi for both 2-D and 3-D variants (see Fig. 1 ) and having a much higher variance per run than Gurobi. There was a small subset of problem instances that both SAT-solvers were able to solve much faster than Gurobi, but this was not the norm. For the 2-D version (with sequences between length 6 and length 29), pLingeling was able to reach a solution to most in less than 30 min, with none taking longer than three hours. Glucose-Syrup took at least twice as long as pLingeling on most of the real sequences longer than 24, but performed slightly better on shorter sequences. Gurobi had times under ten minutes for most sequences between length 6 and 27 in 2-D; however, at lengths 28 and 29 the times became much less consistent, ranging from under 10 min to more than 48 h. Due to space limitations, we only show three graphs, two for real data in 2-D and 3-D, and one for random data in 2-D.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 216,
                    "end": 222,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "For the 3-D version (with lengths ranging from 6 to 15), all solvers were generally able to reach a solution within an hour, with Gurobi usually being the fastest. However, unlike in the 2-D version, Gurobi's times stayed more consistent at each length than both SAT-solvers'. At lengths 16 and above, all solvers became less consistent, with times between 20 s and 16 h for pLingeling, between 2 h and more than 3 days for Glucose-Syrup, 5 and between 3 s and 1.6 h for Gurobi.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The HP Prototein Model and Folding Problem in 2-D."
        },
        {
            "text": "Gurobi generally performs better in terms of time, and the file sizes are always smaller. Although both SAT-solvers usually take longer than Gurobi on both 2-D and 3-D versions of the problem, there are (rarer) cases where Gurobi takes much longer than either on a particular sequence. Hence, if Gurobi seems to be taking much longer than the typical time for that length, it is worth trying pLingeling or Glucose-Syrup. 6 ",
            "cite_spans": [
                {
                    "start": 421,
                    "end": 422,
                    "text": "6",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion from our Exploration of the HP Problem."
        },
        {
            "text": "There are important biological phenomena that occur at a scale larger than individual nucleotides, e.g. at chromosomal or genomic scales. One such informative biological phenomenon is long chromosomal reversals (inversions), where the DNA in a long interval on a chromosome reverses direction. For example, if we represent each gene by a distinct integer, the interval with ten genes: 1 10 4 5 2 6 3 9 8 7 becomes: 1 10 6 2 5 4 3 9 8 7 when the interval containing 4 5 2 6 is reversed. Since genes can be separated by long distances on a chromosome, what seems like a small reversal of just four integers actually represents a very long chromosomal reversal. It is believed that long chromosomal reversals are much rarer, with longer periods of time between reversals, than are mutations of single nucleotides, so long chromosomal reversals allow us to look farther back into evolutionary history. So, what we are interested in is the order of the genes on the chromosome, and how that order changes over time. Then, following the principle of parsimony, the computational problem of interest is:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "The Sorting-by-Reversals Problem. Given two permutations, P 1 and P 2 , of the integers 1 to n, find the minimum number of interval reversals that transforms P 1 to P 2 . In the signed version of the problem, each integer in P 1 has a positive sign, and each integer in P 2 has either a positive or negative sign. Whenever an interval is reversed, the sign of each integer in the interval changes to the opposite sign. Then, the goal, as before, is to transform P 1 to the correctly signed P 2 using the minimum number of reversals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "A Hard Problem. There are no known algorithms to solve the sorting-by-reversals problem that are efficient in the worst-case sense, 7 and it is not obvious how to solve sorting-by-reversal problems in practice. It is even less obvious how one could efficiently prove that an optimal solution had been found, even if you had one. So, ILP formulations for this problem were previously created and examined in [10, 14, 23] , and an exposition of the ILP approach in [14] appears in [8] .",
            "cite_spans": [
                {
                    "start": 407,
                    "end": 411,
                    "text": "[10,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 412,
                    "end": 415,
                    "text": "14,",
                    "ref_id": null
                },
                {
                    "start": 416,
                    "end": 419,
                    "text": "23]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 463,
                    "end": 467,
                    "text": "[14]",
                    "ref_id": null
                },
                {
                    "start": 479,
                    "end": 482,
                    "text": "[8]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "ILP v. SAT. Although the ILP approach successfully solves many datasets, we previously found that the ILP approach becomes impractical (on a 4-core MacBook Pro) on permutations longer than around twelve. Therefore, we investigated how well the SAT approach handles the problem of sorting-by-reversals, both the unsigned and signed versions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "Two classic datasets were first examined. In the Turnips to Cabbage dataset [22] , with ten genes, the turnip genes were labeled in the natural order 1 through 10, so that the order of the analogous genes in Cabbage is 1 10 4 5 2 6 3 9 8 7.",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 80,
                    "text": "[22]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "Gurobi 8.1 solved the problem in fifteen seconds, and the SAT formulation was generated and solved by our program, do-unsigned, in five seconds. do-unsigned.py implements the SAT approach for a given instance of the reversal problem by creating a series of CNF formulas, each specifying a maximum allowed number of reversals. Each CNF formula is found to be satisfiable or unsatisfiable by the SAT-solver pLingeling.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "Note that the ILP time only includes the solution time by the ILP solver, excluding the time (usually quite small) to create the ILP formulation from the description of a problem instance. In contrast, the time for the SAT formulation also includes the time to generate (by do-unsigned.py) the CNF formulas used during the search for the minimum number of reversals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "In the Field Mustard to Black Mustard dataset, of length twelve, the ILP formulation was solved by Gurobi 8.1 in about 102 min, but earlier in only 33 min by Gurobi 8.0 (go figure!) . The SAT approach solved the reversal problem in about 3 min, 25 s.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 173,
                    "end": 181,
                    "text": "figure!)",
                    "ref_id": null
                }
            ],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "These tests indicate overall that the SAT approach is superior to the ILP approach. Results from the examination of random permutations of length up to eight (shown in Table 1 ) is consistent with these tests.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 168,
                    "end": 175,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "We also compared running times for the ILP and SAT approaches to the signed variant. There, the overall running times were longer for both approaches, but more interestingly, there were substantial differences in the times for the two approaches, shown in Table 2 , which show dramatic superiority of the SAT approach. Other Observations. Although we saw that the SAT approach was faster than the ILP approach-and sometimes dramatically so-on permutations of length up to twelve, we found that its range of practicality is not much greater than that of the ILP approach. Another interesting finding is that for a fixed permutation length, the speed of the ILP approach falls as the number of cycles in the permutation increases, while the speed of the SAT approach is essentially constant over those permutations. For example, for length seven permutations, the SAT approach takes about one-half second no matter what the permutation is, but the time for the ILP approach falls from three seconds for permutations with one cycle, to about one-half second for permutations with four cycles.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 256,
                    "end": 263,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "Software. All the software for the SAT approach to the reversal problem is available on GitHub. 8",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transforming Gene Order by Reversals"
        },
        {
            "text": "Genealogical and phylogenetic networks are graph-theoretic models of evolution that go beyond phylogenetic trees, incorporating non-treelike biological events such as meiotic recombination that occur in populations of individuals in a single species. The central algorithmic problems are to reconstruct plausible histories, with mutations, treelike events, and non-treelike events that generate a given set of observed genomic sequences, and to determine the minimum number of such biological events needed to derive the sequences. The problem of finding a genealogical network that reconstructs the observed sequences, M , using the fewest recombinations (denoted R min (M )), and at most one mutation per site, has been heavily studied in both population genetics and computational biology [7] . However, the best current algorithm takes superexponential time in worst case. Hence, there has been great interest in finding effective algorithms to compute good (high) lower bounds on R min (M ). Empirically, the History Bound is usually the highest lower bound of all the lower bounds studied (there are more than ten bounds that have been intensely studied). However, its computation, by dynamic programming [1] , examines all 2 n subsets of n input sequences, and hence becomes impractical as n increases. 9 In its most intense use, in a program called RecMin [20] , n is very large, but the number of sites, m, is generally under ten.",
            "cite_spans": [
                {
                    "start": 792,
                    "end": 795,
                    "text": "[7]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1211,
                    "end": 1214,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1310,
                    "end": 1311,
                    "text": "9",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1364,
                    "end": 1368,
                    "text": "[20]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "The Defining Algorithm for the History Bound. The History Bound was first defined procedurally, 10 based on an algorithm that computes a Candidate History Bound (CHB), given an n-by-m binary matrix M . In short, the CHB algorithm reduces M to the empty matrix by iterating three rules for removing rows or columns. In one rule (called the D t rule), the choice of row removal is arbitrary, so different executions of the algorithm, with the same input, can remove a different set of rows. The History Bound is defined as the minimum number of times rule D t is used, over all possible executions of Algorithm CHB. For a proof that the History Bound is a true lower bound on R min (M ), see [7] .",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 98,
                    "text": "10",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 690,
                    "end": 693,
                    "text": "[7]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "The History Bound, ILP and SAT. Previously, we developed three different ILP formulations to compute the History Bound [18] . None of these three ILP formulations was effective in empirical testing on data of current interest. Therefore, we developed a SAT approach for the History Bound, as follows.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 123,
                    "text": "[18]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "For any given target, t, our program creates a CNF formula that is satisfiable if and only if there is an execution of Algorithm CHB on the input M , which applies rule D t at most t times. The CNF formula encodes the three row and column removal rules of Algorithm CHB, with additional CNF clauses that \"count\" the number of times rule D t is used; and has another clause to forbid using it more than t times. Then pLingeling determines if that CNF formula is satisfiable or not. The History Bound is found by searching over the range of possible target values to find the smallest target where the associated CNF is satisfiable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "Results. When the target t is larger than the History Bound, 11 so that the associated CNF formula is satisfiable, pLingeling very efficiently finds a satisfying assignment. However, pLingeling has difficulty terminating when the CNF formula is not satisfiable. Space limits us to a few illustrative examples. For a matrix of dimension 60-by-8, the SAT approach determined that the History Bound is less than 11 in 45 s; less than 10 in 64 s; less than 9 in 31 s; less than 8 in 52 s; and less than 7 in 87 s. Then the test of whether the History Bound is less than 6 ran for 7,200 s without termination, at which point we killed the computation. In contrast, the ILP approach determined that the History Bound is less than 11 after 900 s, and less than 7 after 3,351 s; and that computation continued without termination until 18,000 s, when it was killed. Significantly, the ILP could only establish that the History Bound for this case is greater or equal to zero! So, the SAT approach found an execution of Algorithm CHB using the D t rule only six times, much faster than did the ILP approach. And it provided much stronger evidence than did the ILP computation, for concluding that the History Bound is six for that matrix.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "In a test with a matrix of dimension 30-by-60, the SAT approach determined that the History Bound is less than 30, 29, 28, and 27, in 21, 38, 26, and 63 s respectively. Then in trying to determine if the History Bound is less than 26, we terminated pLingeling after 480 s. In contrast, we allowed the ILP computation to run for 13,000 s at which point it has determined only that the History Bound was less than 30 and greater than zero! So, the SAT approach gave strong evidence that the History Bound is 26 for this matrix, while the ILP approach gave much less information, using much more time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "All of the software to create the ILP and CNF formulations for the History Bound is available on GitHub. 12",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The History Bound in Phylogenetic Networks"
        },
        {
            "text": "Very briefly, input consists of n sequences of length m, over a ternary alphabet {0, 1, 2}. Output consists of a set of binary sequences, H, of length m, where each input sequence, s, is associated with some pair of binary sequences, (h i , h j ) in H, which must satisfy the following conditions: At any position k in s, if the value of s is 0 or 1, then for both h i and h j , the value at position k must be identical to the value in s. However, if the value of s at position k is 2, then exactly one of h i or h j must have value 0, and the other must have value 1, at position k. When s has q positions with value 2, there are 2 q\u22121 possible binary sequences that satisfy those conditions. The Pure-Parsimony Haplotyping Problem is to find a smallest such set H, given the input. This minimization problem was first examined in [6] , where an exponential-size ILP formulation was developed. 13 That ILP formulation solves very quickly for instances where the formulation fits into main memory. However, rapid growth of the formulation size limits the size of the instances that can be handled. Later (in 2004 and 2006) , polynomial-sized ILP formulations were developed [4, 13] , but ILP solvers at that time were not able to solve problem instances of interest in a practical amount of time. Subsequently (in 2006), a SAT-formulation, based on the general ideas in [4, 13] and additional improvements, was developed in [15, 16] , and was shown to be highly effective. Those results used ILP and SAT-solvers that are much slower than current solvers. So, we re-implemented the ILP and SAT approaches 14 to see how the more modern SAT-solver, pLingeling, and the fastest current ILP-solver, Gurobi 9.0, handle this problem. The code for our implementation is available on GitHub. 15 Our new results confirm and extend the results from the older studies. Space limits the discussion to just one problem instance, of dimension 200-by-200, which is much larger than the instances examined in the earlier literature. In the SAT approach, using a first target of 87, pLingeling found a satisfying solution to the CNF formula in 1,525 s. With targets of 85 and 84, it found satisfying solutions in 5,700 and 8,521 s, respectively. Then, using a target of 83, pLingeling determined that the associated CNF formula was unsatisfiable, in 20,627 s. This established that the optimal value is 84. In contrast, using the ILP formulation for this problem instance, Gurobi initially found a feasible solution of size 134, and a lower bound of 31 (in 1,300 s), but then made no further progress in two more days of computation (when it was terminated).",
            "cite_spans": [
                {
                    "start": 833,
                    "end": 836,
                    "text": "[6]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 896,
                    "end": 898,
                    "text": "13",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1175,
                    "end": 1178,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1179,
                    "end": 1182,
                    "text": "13]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1371,
                    "end": 1374,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1375,
                    "end": 1378,
                    "text": "13]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1425,
                    "end": 1429,
                    "text": "[15,",
                    "ref_id": null
                },
                {
                    "start": 1430,
                    "end": 1433,
                    "text": "16]",
                    "ref_id": null
                },
                {
                    "start": 1784,
                    "end": 1786,
                    "text": "15",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 1099,
                    "end": 1123,
                    "text": "Later (in 2004 and 2006)",
                    "ref_id": null
                }
            ],
            "section": "Haplotyping by Pure Parsimony"
        },
        {
            "text": "While the ILP approach is becoming more widely used in computational biology, only a few studies have explored the SAT-solving approach. Our work shows that SAT-solving can be (but is not always) much more effective than ILP-solving for instances of hard problems in computational biology. 16 This gives us another powerful tool, which should be more widely used and incorporated into biological computation.",
            "cite_spans": [
                {
                    "start": 290,
                    "end": 292,
                    "text": "16",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Inference about recombination from haplotype data: lower bounds and recombination hotspots",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bafna",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bansal",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. Comput. Biol",
            "volume": "13",
            "issn": "",
            "pages": "501--521",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Efficient CNF encoding of Boolean cardinality constraints",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Bailleux",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Boufkhad",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "CP 2003",
            "volume": "2833",
            "issn": "",
            "pages": "108--122",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-45193-8_8"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Integer programming approaches to haplotype inference by pure parsimony",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Brown",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Harrower",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinform",
            "volume": "3",
            "issn": "2",
            "pages": "141--154",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Although our SAT implementation is more basic and naive than the one developed in [15",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "16",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "We reiterate, however, that the specific problems examined in this paper were chosen because they were known to be hard for ILP-solvers to handle. Therefore, these results do not contradict the more general conclusion",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Principles of protein folding -a perspective from simple exact models",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "A"
                    ],
                    "last": "Dill",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Protein Sci",
            "volume": "4",
            "issn": "",
            "pages": "561--602",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Haplotype inference by pure parsimony",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Baeza-Yates",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ch\u00e1vez",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "CPM 2003",
            "volume": "2676",
            "issn": "",
            "pages": "144--155",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-44888-8_11"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "ReCombinatorics: The Algorithmics of Ancestral Recombination Graphs and Explicit Phylogenetic Networks",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Integer Linear Programming in Computational and Systems Biology: An Entry-Level Text",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Transforming cabbage into turnip: polynomial algorithm for sorting signed permutations by reversals",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hannenhalli",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Pevzner",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Proceedings of the 27th ACM Symposium on the Theory of Computing",
            "volume": "",
            "issn": "",
            "pages": "178--189",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Genome rearrangement with ILP",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Hartmann",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Wieseke",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Sharan",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Middendorf",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bernt",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinform",
            "volume": "15",
            "issn": "5",
            "pages": "1585--1593",
            "other_ids": {
                "DOI": [
                    "10.1109/TCBB.2017.2708121"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "The Art of",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "E"
                    ],
                    "last": "Knuth",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Computer Programming. Fascicle 6: Satisfiability",
            "volume": "4",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Comprehensive evaluation of protein structure alignment methods: scoring by geometric measures",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kolodny",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Koehl",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Levitt",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "J. Mol. Biol",
            "volume": "346",
            "issn": "4",
            "pages": "1173--1188",
            "other_ids": {
                "DOI": [
                    "10.1016/j.jmb.2004.12.032"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Haplotyping populations by pure parsimony: complexity, exact and approximation algorithms",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Lancia",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Pinotti",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Rizzi",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "INFORMS J. Comput. Spec. Issue Comput. Biol",
            "volume": "16",
            "issn": "",
            "pages": "348--359",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "A unified integer programming model for genome rearrangement problems",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Lancia",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Rinaldi",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Serafini",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "IWBBIO 2015",
            "volume": "9043",
            "issn": "",
            "pages": "491--502",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-16483-0_48"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Efficient haplotype inference with Boolean satisfiability",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Lynce",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the Twenty-First AAAI Conference on Artificial Intelligence",
            "volume": "",
            "issn": "",
            "pages": "104--109",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "SAT in bioinformatics: making the case with haplotype inference",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Lynce",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Marques-Silva",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "SAT 2006",
            "volume": "4121",
            "issn": "",
            "pages": "136--141",
            "other_ids": {
                "DOI": [
                    "10.1007/11814948_16"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "PhISCS: a combinatorial approach for subperfect tumor phylogeny reconstruction via integrative use of single-cell and bulk sequencing data",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Malikic",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Optimization techniques for phylogenetics",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Matsieva",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "A resolution of the static formulation question for the problem of computing the history bound",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Matsieva",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kelk",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Whidden",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Bounds on the minimum number of recombination events in a sample history",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Myers",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "C"
                    ],
                    "last": "Griffiths",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Genetics",
            "volume": "163",
            "issn": "",
            "pages": "375--394",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "An integer programming model for protein structure prediction using the 3D-HP side chain model",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nunes",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Galvao",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lopes",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Moscato",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Berretta",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Discret. Appl. Math",
            "volume": "198",
            "issn": "",
            "pages": "206--214",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Plant mitochondrial DNA evolves rapidly in structure, but slowly in sequence",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Palmer",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Herbon",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "J. Mol. Evol",
            "volume": "27",
            "issn": "",
            "pages": "87--97",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Comparing genomes with rearrangements and segmental duplications",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Shao",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "M E"
                    ],
                    "last": "Moret",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Bioinformatics",
            "volume": "31",
            "issn": "12",
            "pages": "329--338",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF1": {
            "text": "Average SAT and ILP runtimes vs. sequence length for 2-D and 3-D embeddings. Note that the drop in times at lengths 12 and 20 for the 2-D and 3-D versions (respectively) is due to the choice of a smaller grid diameter",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Times (rounded to the nearest tenth of a second) taken by Gurobi and pLingeling with ten randomly generated unsigned sequences of length eight",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}