{
    "paper_id": "d695fd8696b44fdb691f603e9b4d46bb3d850af7",
    "metadata": {
        "title": "Context-Sensitive Fusion Grammars Are Universal",
        "authors": [
            {
                "first": "Aaron",
                "middle": [],
                "last": "Lye",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Bremen",
                    "location": {
                        "postBox": "P.O.Box 33 04 40",
                        "postCode": "28334",
                        "settlement": "Bremen",
                        "country": "Germany"
                    }
                },
                "email": "lye@math.uni-bremen.de"
            }
        ]
    },
    "abstract": [
        {
            "text": "Context-sensitive fusion grammars are a special case of context-dependent fusion grammars where a rule has only a single positive context condition instead of finite sets of positive and negative context conditions. They generate hypergraph languages from start hypergraphs via successive applications of context-sensitive fusion rules and multiplications of connected components, as well as a filtering mechanism to extract terminal hypergraphs from derived hypergraphs in a certain way. The application of a context-sensitive fusion rule consumes two complementarily labeled hyperedges and identifies corresponding attachment vertices provided that the context condition holds. In this paper, we show that the Post correspondence problem can be formulated very intuitively by such a grammar. Furthermore, we prove that these grammars can generate all recursively enumerable string languages (up to representation of strings as graphs) and are universal in this respect.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "In 2017 we introduced fusion grammars as generative devices on hypergraphs (cf. [2] ). They are motivated by the observation, that one encounters various fusion processes in various scientific fields like DNA computing, chemistry, tiling, fractal geometry, visual modeling and others. The common principle is that a few small entities may be copied and fused to produce more complicated entities. Besides hypergraph language generation they can be used to model and solve interesting decision problems, e.g., in [3] it is shown that the Hamiltonian path problem can be solved efficiently by a respective fusion grammar due to the massive parallelism in a way that mimics Adleman's famous experiment in DNA computing (cf. [1] ). In this paper, we show that the Post correspondence problem (PCP, cf. [6] ), which is well-known to be undecidable, can be expressed very intuitively by means of fusion and its solvability by using context-sensitive fusion rules. Hence, undeciability results carry over to context-sensitive fusion grammars. Recently, we showed that context-dependent fusion grammars (introduced in [4] ) are powerful enough to simulate Turing machines (cf. [5] ). In this paper, we show that one can do much better. We show that rules with a single positive context condition are sufficient. To prove this, a known result of formal language theory is used, which is, that each recursively enumerable string language is a (left) quotient of two linear languages. In our construction we employ the same recognition mechanism as the one for PCP. Throughout in the proofs we are actually operating on graphs. As graphs are a subclass of hypergraphs the results hold for the general case.",
            "cite_spans": [
                {
                    "start": 80,
                    "end": 83,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 512,
                    "end": 515,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 721,
                    "end": 724,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 798,
                    "end": 801,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1110,
                    "end": 1113,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1169,
                    "end": 1172,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The paper is organized as follows. In Sect. 2, basic notions and notations of hypergraphs are recalled. Section 3 introduces the notions of context-sensitive fusion grammars. In Sect. 4 we present a reduction of the Post correspondence problem to the membership and emptiness problem for context-sensitive fusion grammars. Afterwards, we prove that context-sensitive fusion grammars can generate all recursively enumerable string languages (up to representation) in Sect. 5. Section 6 concludes the paper pointing out some open problems.",
            "cite_spans": [
                {
                    "start": 184,
                    "end": 185,
                    "text": "4",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A hypergraph over a given label alphabet \u03a3 is a system H = (V, E, s, t, lab) where V is a finite set of vertices, E is a finite set of hyperedges, s, t : E \u2192 V * are two functions assigning to each hyperedge a sequence of sources and targets, respectively, and lab : E \u2192 \u03a3 is a function, called labeling. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Given H, H \u2208 H \u03a3 , a hypergraph morphism g : H \u2192 H consists of two mappings g V : V H \u2192 V H and g E :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We will use removals of the form (\u2205, E) below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "Let H \u2208 H \u03a3 and let att(e) be the set of source and target vertices for Given H, H \u2208 H \u03a3 , the disjoint union of H and H is denoted by H + H . It is defined by the disjoint union of the underlying sets (also denoted by +). The disjoint union of H with itself k times is denoted by k \u00b7 H. We use the multiplication of H defined by means of C(H) as follows. Let m : C(H) \u2192 N be a mapping, called multiplicity,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A string is represented by a simple path where the sequence of labels along the path equals the given string. Let \u03a3 be a label alphabet. Let w = x 1 . . . x n \u2208 \u03a3 * for n \u2265 1 and x i \u2208 \u03a3 for i = 1, . . . , n. Then the string graph of w is defined by",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The string graph of the empty string \u03bb, denoted by sg(\u03bb), is the discrete graph with a single node 0. Obviously, there is a one-toone correspondence between \u03a3 * and sg(\u03a3 * ) = {sg(w) | w \u2208 \u03a3 * }. For technical reasons, we need the extension of a string graph sg(w) for some w \u2208 \u03a3 * by a s-labeled edge bending from the begin node 0 to the end node n, where n is the length of w. The resulting graph is denoted by sg(w) s .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "In this section, we introduce context-sensitive fusion grammars. These grammars generate hypergraph languages from start hypergraphs via successive applications of context-sensitive fusion rules, multiplications of connected components, and a filtering mechanism. Such a rule is applicable if the positive contextcondition holds. Its application consumes the two hyperedges and fuses the sources of the one hyperedge with the sources of the other as well as the targets of the one with the targets of the other. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Context-Sensitive Fusion Grammars"
        },
        {
            "text": "H and called a direct derivation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "A context-sensitive fusion rule is a tuple csfr = (fr (A), c: H .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "Remark 1. 1. In this paper, we only make use of the case where every hyperedge has one source and one target vertex. Hence, fusion rules are of the form A A . The type is therefore omitted throughout the paper. 2. The applications of fr (A) and (fr (A), id) are equivalent. We use the first as an abbreviation for the latter. We call these rules context-free fusion rules.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "for each x \u2208 F where the morphism is uniquely defined by the labels and maps the vertices as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "Only reduce(a 1 ) is applicable because the other complementarily labeled edges do not share a common source vertex. The matching morphism g maps the edges labeled a 1 , a 1 , resp. in fr (a 1 ) to the a 1 -labeled (resp, a 1 -labeled) edges in G; vertices are mapped respectively:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "wards, no further context-sensitive fusion rule is applicable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "Given a finite hypergraph, the set of all possible successive fusions is finite as fusion rules never create anything. To overcome this limitation, arbitrary multiplications of disjoint components within derivations are allowed. The generated language consists of the terminal part of all resulting connected components that contain no fusion symbols and at least one marker symbol, where marker symbols are removed in the end. These marker symbols allow us to distinguish between wanted and unwanted terminal components. If for every A \u2208 F a rule in P exists and every rule is context-free, then all rules are specified F and CSFG is a fusion grammar as defined in [2] . P is obsolete.",
            "cite_spans": [
                {
                    "start": 666,
                    "end": 669,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Definition 1. F \u2286 \u03a3 is a fusion alphabet if it is accompanied by a complementary fusion alphabet"
        },
        {
            "text": "In this section, we model Post correspondence problems (PCPs) by means of context-sensitive fusion grammars in such a way that a PCP is solvable if the generated language of the corresponding grammar consists of a single vertex and that a PCP is not solvable if the language is empty. Therefore, it turns out that the emptiness problem and the membership problem for context-sensitive fusion grammars are undecidable. The Post correspondence problem is defined as follow. Given a finite set of pairs {(u 1 , v 1 ), (u 2 , v 2 ), . . . , (u k , v k )} with u i , v i \u2208 \u03a3 * for some finite alphabet \u03a3. Does there exist a sequence of indices i 1 \u00b7 \u00b7 \u00b7 i n with n > 0 such that u i1 \u00b7 \u00b7 \u00b7 u in = v i1 \u00b7 \u00b7 \u00b7 v in ? In terms of fusion, the pairs may be copied and fused in order to concatenate the strings. However, one needs a recognition mechanism to decide whether u i1 \u00b7 \u00b7 \u00b7 u in = v i1 \u00b7 \u00b7 \u00b7 v in or not. This recognition procedure is expressible by means of context-sensitive fusion. The proof of the theorem is based on the following lemmata.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Context-Sensitive Fusion Grammar for the Post Correspondence Problem"
        },
        {
            "text": "Let G = dsg(u 1 \u00b7 \u00b7 \u00b7 u n , u 1 \u00b7 \u00b7 \u00b7 u n ) be the hypergraph consisting of two string graphs sg(u 1 \u00b7 \u00b7 \u00b7 u n ) and sg(u 1 \u00b7 \u00b7 \u00b7 u n ) with u 1 , . . . , u n \u2208 \u03a3 where the first vertex of both string graphs is the same. i.e., Proof. Induction base: n = 0. dsg(\u03bb, \u03bb) = [1] because by definition sg(\u03bb) is the discrete graph [1] by construction of dsg these two vertices are identified yielding the discrete graph [1] . Hence, dsg(\u03bb, \u03bb) 0 =\u21d2 [1] . Induction step: Given G = dsg(u 1 \u00b7 \u00b7 \u00b7 u n+1 , u 1 \u00b7 \u00b7 \u00b7 u n+1 ). Then reduce(u 1 ) can be applied because by construction of dsg(u 1 \u00b7 \u00b7 \u00b7 u n+1 , u 1 \u00b7 \u00b7 \u00b7 u n+1 ) the two complementary u 1 -and u 1 -labeled hyperedges share a common source vertex yielding ",
            "cite_spans": [
                {
                    "start": 323,
                    "end": 326,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 412,
                    "end": 415,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 440,
                    "end": 443,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Proof. The statement follows directly from the fact that the two rules do not share fusion symbols such that they matches are hyperedge disjoint and that the context conditions of reduce(x) only requires a commonly shared source for the two hyperedges.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "be a derivation in CSFG(S). Then the two direct derivations can be interchanged yielding"
        },
        {
            "text": "Proof (of Theorem 1). Let S = {(u 1 , v 1 ), (u 2 , v 2 ), . . . , (u k , v k )}. Let i 1 \u00b7 \u00b7 \u00b7 i n be a solution to S, i.e., u i1 \u00b7 \u00b7 \u00b7 u in = v i1 \u00b7 \u00b7 \u00b7 v in . Let m 1 , . . . , m k be the number of occurrences of (u j , v j ) in the sequence except the first. Then there exists a derivation ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "be a derivation in CSFG(S). Then the two direct derivations can be interchanged yielding"
        },
        {
            "text": ". . i n is a solution to S; and (4) the two connected complementary strings graphs can be erased by successive applications of reduce(x) for suitable x due to Lemma 1. Hence, \u2022 \u2208 L(CSFG(S)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "be a derivation in CSFG(S). Then the two direct derivations can be interchanged yielding"
        },
        {
            "text": "Then there exists a derivation Z S * = X + \u00b5 for some hypergraph X. A \u03bc is the only connected component with marker in the start hypergraph, therefore, \u00b5 must stem from A \u03bc . The only possibility to get rid of the A-hyperedge without attaching a new one is the application of fr (A) to A \u03bc and some init(x 1 x 2 \u00b7 \u00b7 \u00b7 x w1 , y 1 y 2 \u00b7 \u00b7 \u00b7 y w2 ) with x j , y j \u2208 \u03a3 where the latter connected component is obtained from respective multiplications and the successive fusion wrt fr (A) to some init(u i1 , v i1 )+cont(u i2 , v i2 )+. . .+cont(u in , v in ) for some n and possibly applications of reduce(x) for suitable x. Due to Lemma 2 all the applications of reduce(x) can be shifted behind the applications of fr (A) and due to [2, Corollary 1] all the multiplications can be done as initial derivation step. To obtain \u00b5 the two connected complementary strings graphs must be erased by successive applications of reduce(x 1 ), . . . , reduce(x w1 ). If x 1 \u00b7 \u00b7 \u00b7 x w1 is a proper prefix of y 1 \u00b7 \u00b7 \u00b7 y w2 , i.e., y 1 \u00b7 \u00b7 \u00b7 y w2 = x 1 \u00b7 \u00b7 \u00b7 x w1 y w1+1 \u00b7 \u00b7 \u00b7 y w2 , then one gets \u00b5 y w1+1 . . . y w2 , and analogously if y 1 \u00b7 \u00b7 \u00b7 y w2 is a proper prefix of x 1 \u00b7 \u00b7 \u00b7 x w1 , then one gets \u00b5 x w2+1 . . . x w1 . This implies w 1 = w 2 and y i = x i for 1 \u2264 i \u2264 w 1 must hold. Because",
            "cite_spans": [
                {
                    "start": 729,
                    "end": 732,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 733,
                    "end": 745,
                    "text": "Corollary 1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Now let \u2022 \u2208 L(CSFG(S))."
        },
        {
            "text": "The second statement is a direct consequence of the first. Other connected components do not contribute to the language due to the lack of \u03bc-hyperedges.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now let \u2022 \u2208 L(CSFG(S))."
        },
        {
            "text": "In this section, we prove that context-sensitive fusion grammars can generate all recursively enumerable string languages. For every Chomsky grammar one can construct a corresponding context-sensitive fusion grammar such that the generated languages of the corresponding grammars coincide up to representation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Transformation of Chomsky Grammars into Context-Sensitive Fusion Grammars"
        },
        {
            "text": "is the corresponding context-sensitive fusion grammar where Schematic drawings of some connected components of the start hypergraph are depicted in Fig. 1 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 148,
                    "end": 154,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "Construction 2. Let G = (N, T, P, S) be a Chomsky grammar. Let"
        },
        {
            "text": "The proof is based on the following fact. We recall some details of the proof because we will refer to them in the proof of Theorem 2. Remark 3. L 0 = rev(rev(L 0 )) = rev(L(G)) = L = \\L P , where rev(L 0 ) = {r(w) | w \u2208 L 0 } where r(w) = x n \u00b7 \u00b7 \u00b7 x 1 for w = x 1 \u00b7 \u00b7 \u00b7 x n and G = (N, T, P, S) is a Chomsky grammar with L(G) = rev(L 0 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Construction 2. Let G = (N, T, P, S) be a Chomsky grammar. Let"
        },
        {
            "text": "The basic idea is that for each w \u2208 L(G) exists a derivation S = w 1 \u2192 w 2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 w n\u22121 \u2192 w n \u2192 w n+1 = w with w i = x i u i y i and w i+1 = x i v i y i where u i :: = v i \u2208 P for i = 1, . . . , n , i.e., S = x 1 u 1 y 1 \u2192 x 1 v 1 y 1 = x 2 u 2 y 2 \u2192 \u00b7 \u00b7 \u00b7 \u2192 x n\u22121 v n\u22121 y n\u22121 = x n u n y n \u2192 x n v n y n = w. L = captures the relation x i v i y i = x i+1 u i+1 y i+1 and L P captures the relation x i u i y i \u2192 x i v i y i . 1 L = and L P are linear. The following grammars generate them. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Construction 2. Let G = (N, T, P, S) be a Chomsky grammar. Let"
        },
        {
            "text": "Two derivations may be X 0 =\u21d2 aX 0 a =\u21d2 aAX 1 baa =\u21d2 aAbX 1 bbaa =\u21d2 aAbcX 2 cccbbaa =\u21d2 aAbcAX 3 bAacccbbaa =\u21d2 aAbcAccbAacccbbaa = d and Y 0 =\u21d2 Y 1 ccc =\u21d2 aY 1 accc =\u21d2 aAY 1 Aaccc =\u21d2 aAbY 1 bAaccc =\u21d2 aAbcAccbAaccc = z. Removing the prefix z from d yields bbaa.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Construction 2. Let G = (N, T, P, S) be a Chomsky grammar. Let"
        },
        {
            "text": "Every context-free string grammars can be transformed into fusion grammars generating the same language up to representation of strings as graphs as the following construction shows. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Construction 2. Let G = (N, T, P, S) be a Chomsky grammar. Let"
        },
        {
            "text": "Because only dsg(X 0 , Y 0 ) \u03bc contains a \u03bc-hyperedge this connected component is substantial for some derived connected component contributing to the generated language. W.l.o.g. one can assume that dsg(X 0 , Y 0 ) \u03bc is never multiplied due to the following reasoning. Let C be a connected component derivable from Z. Let # \u03bc : H \u03a3 \u2192 N be a mapping of hypergraphs over \u03a3 to the number of \u03bc-labeled hyperedges in the respective hypergraph. Then # \u03bc (C) \u2264 1, i.e., no two or more copies of dsg(X 0 , Y 0 ) \u03bc contribute to C as the following reasoning indicates. For each C \u2208 C(Z) # \u03bc (C) \u2264 1 by construction. For each C / \u2208 C(Z) assume Z *",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now, let X \u2208 L(CSFG(G)). Then there is a derivation"
        },
        {
            "text": "for some k, l \u2208 N where C 1 and C 2 are two connected components and # \u03bc (",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now, let X \u2208 L(CSFG(G)). Then there is a derivation"
        },
        {
            "text": "Further, r must be a context-free fusion rule because the positive context conditions of reduce(x) restrict that both hyperedges must be attached to a common source vertex which is not possible if C 1 and C 2 are two connected components. Let fr (A) be the applied context-free fusion rule, A \u2208 {Y 0 , Y 1 , X 1 , X 2 , X 3 , X 4 }. W.l.o.g. let A be the label of the hyperedge in C 1 and let A be the label of the hyperedge in C 2 . Furthermore, it is sufficient to analyze the case # \u03bc (C i ) = 1 for i = 1, 2. However, # \u03bc (C i ) = 1 implies that dsg(X 0 , Y 0 ) \u03bc contributes to C i but because the linear structure of the rules in P = and P P carries over to the connected components C 2 cannot contain both a \u03bc-and a A-labeled hyperedge. Hence, the assumption must be false.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now, let X \u2208 L(CSFG(G)). Then there is a derivation"
        },
        {
            "text": "The fusion rules wrt Y 0 , Y 1 , X 0 , X 1 , X 2 , X 3 are context free and thus one connected component or two connected components with two complementarily labeled hyperedges from this subset can be fused arbitrarily. This may produce connected components without markers where all the hyperedges labeled with Y 0 , Y 0 , Y 1 , . . . , X 3 , X 3 are fused. E.g. sg(xY 1 x) Y1 may be multiplied several times and all the complementary Y 1 -and Y 1 -hyperedges can be fused yielding two circles. However this connected component is not fusible to some other connected component because now it is only labeled with fusion symbols {N \u222a T \u222a {c}} but for these symbols the fusion is restricted to take only place if the two complementary hyperedges are attached to the same vertex. A similar argument can be applied to other cases wrt connected components with X i -hyperedges.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now, let X \u2208 L(CSFG(G)). Then there is a derivation"
        },
        {
            "text": "The direct derivations steps can be interchanged 3 in such a way that one gets a derivation of the following form: Hence, Y = sg(w 1 \u00b7 \u00b7 \u00b7 w m ) \u03bc . The linear structure of the connected components gives us w 1 \u00b7 \u00b7 \u00b7 w m \u2208 L(G).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Now, let X \u2208 L(CSFG(G)). Then there is a derivation"
        },
        {
            "text": "In this paper, we have continued the research on context-dependent fusion grammars. We have introduced context-sensitive fusion grammars and have showed that the Post correspondence problem can be formulated very intuitively by such a grammar. Afterwards, we have showed that every Chomsky grammar can be simulated by a corresponding context-sensitive fusion grammar. Hence, they can generate all recursively enumerable string languages (up to representation of strings as graphs). This improves the previous result presented in [5] showing that context-dependent fusion grammars (with positive and negative context-conditions) are another universal computing model. However, further research is needed including the following open question. Is it true, that fusion grammars without context-conditions are not universal? Are also only negative context conditions powerful enough to simulate Chomsky grammars? If so is also a single negative context-condition sufficient? One may also investigate fusion grammar with other regulations like priorities or regular expressions.",
            "cite_spans": [
                {
                    "start": 529,
                    "end": 532,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Molecular computation of solutions to combinatorial problems",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "M"
                    ],
                    "last": "Adleman",
                    "suffix": ""
                }
            ],
            "year": 1994,
            "venue": "Science",
            "volume": "266",
            "issn": "",
            "pages": "1021--1024",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Fusion grammars: a novel approach to the generation of graph languages",
            "authors": [
                {
                    "first": "H.-J",
                    "middle": [],
                    "last": "Kreowski",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kuske",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lye",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ICGT 2017",
            "volume": "10373",
            "issn": "",
            "pages": "90--105",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-61470-0_6"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Relating DNA computing and splitting/fusion grammars",
            "authors": [
                {
                    "first": "H.-J",
                    "middle": [],
                    "last": "Kreowski",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kuske",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lye",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ICGT 2019",
            "volume": "11629",
            "issn": "",
            "pages": "159--174",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-23611-3_10"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Transformation of petri nets into contextdependent fusion grammars",
            "authors": [
                {
                    "first": "H.-J",
                    "middle": [],
                    "last": "Kreowski",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kuske",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lye",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "LATA 2019",
            "volume": "11417",
            "issn": "",
            "pages": "246--258",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-13435-8_18"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Transformation of turing machines into context-dependent fusion grammars",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Lye",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Post-Proceedings of 10th International Workshop on Graph Computation Models",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.4204/EPTCS"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A variant of a recursively unsolvable problem",
            "authors": [
                {
                    "first": "E",
                    "middle": [
                        "L"
                    ],
                    "last": "Post",
                    "suffix": ""
                }
            ],
            "year": 1946,
            "venue": "Bull. Am. Math. Soc",
            "volume": "52",
            "issn": "",
            "pages": "264--269",
            "other_ids": {
                "DOI": [
                    "10.1090/s0002-9904-1946-08555-9"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "DNA Computing -New Computing Paradigms",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "P\u0203un",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Rozenberg",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-03563-4"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "att(e i ) for i = 1, . . . , n and w i = v i+1 for i = 1, . . . , n \u2212 1. A subgraph C of H is a connected component of H if it is connected and there is no larger connected subgraph, i.e., C \u2286 C \u2286 H and C connected implies C = C . The set of connected components of H is denoted by C(H).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "and lab fr (A) (e) = A and lab fr (A) (e) = A. The application of fr (A) to a hypergraph H \u2208 H \u03a3 proceeds according to the following steps: (1) Choose a matching hypergraph morphism g : fr (A) \u2192 H. (2) Remove the images of the two hyperedges of fr (A) yielding X = H \u2212 (\u2205, {g(e), g(e)}). (3) Fuse the corresponding source and target vertices of the removed hyperedges yielding the hypergraph H",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "the terminal hypergraph obtained by removing all hyperedges with labels in M from Y . Remark 2. Let CSFG = (Z, F, M, T, P ) be a context-sensitive fusion grammar.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "init(a, b) + cont(a, b) + A \u03bc . Then CSFG(S) = (Z S , F, {\u03bc}, \u2205, P ) is the to S corresponding context-sensitive fusion grammar. Theorem 1. 1. \u2022 \u2208 L(CSFG(S)) if and only if there exists a solution to S. 2. L(CSFG(S)) is either {\u2022} or \u2205. Corollary 1. The membership and the emptiness problem for context-sensitive fusion grammars are undecidable.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "by applying reduce(u 1 ), . . . , reduce(u n ), where [n + 1] denotes the discrete graph with n + 1 vertices and no edges.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "and m(c) = 0 otherwise; (2) the order in which the connected components are fused by applications of fr (A) does not matter; (",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Schematic drawings of some connected components of the start hypergraph of CSFG(G)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Any recursively enumerable string language L 0 is left quotient of two linear languages L P , L = , i.e., L 0 = L P \\L = = {x | y \u2208 L P \u2227 yx \u2208 L = } (cf.[7,  Theorem 3.13.]).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "{X 3 :: = cX 2 c, X 3 :: = cc}. Example 2. Let G = ({A}, {a.b}, {(A:: = aAb), (A:: = ab)}, A). Then",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Let G = (N, T, P, S) be a context-free string grammar. Then FG(G) = (sg \u03bc (S) + r\u2208P hgr(r), N, {\u03bc}, T ) with sg \u03bc (S) = \u00b5 S , hgr(r) = sg(u) A for r = (A:: = u) \u2208 P and \u03bc / \u2208 N \u222a T is the corresponding fusion grammar.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "The components of H = (V, E, s, t, lab) may also be denoted by V H , E H , s H , t H , and lab H respectively. The class of all hypergraphs over \u03a3 is denoted by H \u03a3 . Let H \u2208 H \u03a3 , and let \u2261 be an equivalence relation on V H . Then the fusion of the vertices in H with respect to \u2261 yields the (quotient) hypergraph H/\u2261 = (V H /\u2261, E H , s H/\u2261 , t H/\u2261 , lab H ) with the set of equivalence classes V H",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "is a hypergraph morphism with domain fr (A) mapping into a finite context C. The rule csfr is applicable to some hypergraph H via a matching morphism g : fr (A) \u2192 H if there exists a hypergraph morphism h : C \u2192 H such that h is injective on the set of hyperedges and h \u2022 c = g. If csfr is applicable to H via g, then the direct derivation H =\u21d2",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "is a finite set of terminal labels, and P is a finite set of context-sensitive fusion rules. A direct derivation H =\u21d2 H is either a context-sensitive fusion rule application H =\u21d2 csfr H for some csfr \u2208 P or a multiplication H =\u21d2 m m \u00b7 H for some multiplicity m : C(H) \u2192 N. A derivation H =\u21d2 H of length n \u2265 0 is a sequence of direct derivations H 0 =\u21d2 H 1 =\u21d2 . . . =\u21d2 H n with H = H 0 and H = H n . If the length does not matter, we may write H *",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Lemma 2. Let X 1 =\u21d2",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "some multiplicities m , m * with A \u2208 {Y 0 , Y 1 , X 0 , X 1 , X 2 , X 3 }",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We are grateful to Hans-J\u00f6rg Kreowski and Sabine Kuske for valuable discussions. We also thank the reviewers for their valuable comments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgment."
        },
        {
            "text": "Proof. 1. Each context-free string grammar G can be transformed into a hyperedge replacement grammar with connected right hand sides. Hence, the transformation of hyperedge replacement grammars into fusion grammars (cf. [2] ) can be applied yielding FG(G).",
            "cite_spans": [
                {
                    "start": 220,
                    "end": 223,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "annex"
        },
        {
            "text": "Remark 4. The connected components in the start hypergraphs of the contextsensitive fusion grammar in Construction 2 are hypergraph representation of the rules of the two linear string grammars (cf. Construction 3) slightly modified. The connected components in Z = are constructed for the linear rules in G = such that each symbol in N \u222a T \u222a {c} is complemented and for each T -symbol the primed copy is used instead. The connected components for the linear rules in G P containing X 0 and X 1 are constructed such that they contain fusion symbols left and terminal symbols right of the X i -labeled hyperedge. Again for each terminal symbol the primed copy is used instead. The other connected components use the standard construction and are therefore only fusion symbol labeled (replacing also terminal symbols by their primed copy).Proof (of Theorem 2). Let w \u2208 L(G). Then w \u2208 L = \\L P by Fact 1 and there are derivations in G = and G P with Y 0 * \u2192 u and X 0 * \u2192 uw with u = u 1 \u00b7 \u00b7 \u00b7 u n and w = w 1 \u00b7 \u00b7 \u00b7 w m . For each of these derivations exists by Lemma 3 a derivation in the corresponding fusion grammar (FG(G = ), FG(G P ), resp. where G = and G P are defined in Remark 3). Because the nonterminal alphabets of G = and G P are disjoint and the connected component dsg(X 0 , Y 0 ) \u03bc contains two hyperedges one labeled with each start symbol of the two linear string grammars there is a derivation . . . w 1 w m \u00b5 + [n]. . Consequently, sg(w 1 \u00b7 \u00b7 \u00b7 w m ) \u2208 L(CSFG(G)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proof by induction on the length of the derivation."
        }
    ]
}