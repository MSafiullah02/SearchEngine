{
    "paper_id": "PMC7242040",
    "metadata": {
        "title": "Exploring the Concept of Abstract State Machines for System Runtime Enforcement",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Elvinia",
                "middle": [],
                "last": "Riccobene",
                "suffix": "",
                "email": "elvinia.riccobene@unimi.it",
                "affiliation": {}
            },
            {
                "first": "Patrizia",
                "middle": [],
                "last": "Scandurra",
                "suffix": "",
                "email": "patrizia.scandurra@unibg.it",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Modern intelligent software systems, such as those employed in smart infrastructures using big data, AI and IoT technologies, are rapidly growing in complexity and scale, and many real usage scenarios might be impossible to reproduce and validate at design-time. To address this challenge, the Models@run.time research community [4] has identified a reference architecture to equip a software system with a model running in tandem with the system to address software runtime assurance. Similar ideas have been proliferating in other contexts, such as Digital twins in the manufacturing domain [11], and Living models [9] in the field of Computer Automated Multi-Paradigm Modelling.",
            "cite_spans": [
                {
                    "start": 330,
                    "end": 331,
                    "mention": "4",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 594,
                    "end": 596,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 618,
                    "end": 619,
                    "mention": "9",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Among the different approaches and techniques proposed in literature that exploit the concept of model@runtime, runtime enforcement [6] is a runtime verification method that focuses on steering system executions with the goal of preventing and reacting to misbehaviours and failures. Runtime enforcement techniques enforce the software system to run according to its specification, for example the specification of safety assertions that describe situations (states) or actions that must be avoided (e.g., a train must not open its doors when moving). When a new (input) event occurs that may change the state of the software system, the model, if available, is used to evaluate safety assertions and prevent the system change if it violates an assertion on the runtime model of the system. This enforcement mechanism can be, therefore, used for input sanitisation [6] to protect the system from its (untrusted) environment. All inputs to the system shall enter first the enforcement mechanism which filters out those that could harm the system or ensure that all the necessary inputs are provided to the system. While classical runtime verification approaches (like [2, 5] and [7] to name a few) generally focus on the oracle problem, namely assigning verdicts to a system execution, runtime enforcement focuses on ensuring the correctness of the sequence of events by possibly modifying or preventing the system execution [6].",
            "cite_spans": [
                {
                    "start": 133,
                    "end": 134,
                    "mention": "6",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 866,
                    "end": 867,
                    "mention": "6",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1168,
                    "end": 1169,
                    "mention": "2",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1171,
                    "end": 1172,
                    "mention": "5",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1179,
                    "end": 1180,
                    "mention": "7",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1425,
                    "end": 1426,
                    "mention": "6",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper we present some preliminary results of our work-in-progress investigation on the use of Abstract State Machines as models@run.time for runtime enforcement. In particular, we present the architecture of a runtime enforcement tool we have been developing within the ASMETA framework1 \u2013 a set of tools for the ASM formal method \u2013 to check safety assertions of software systems at runtime. This mechanism exploits the concept of executable ASM models and it is based on a new component, the AsmetaS@run.time, that simulates the ASM models in tandem with the real software systems. We also envision some real scenarios in the context of safety-critical systems where we are applying the ASM@run.time enforcement approach.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We here present a conceptual view of a runtime enforcement for input sanitisation [6] to protect the system from its (untrusted) environment. The proposed mechanism exploits the runtime simulator for ASMs, namely AsmetaS@run.time. This last tool was recently developed as part of the ASMETA toolset to allow the use of ASM models as runtime models. It supports simulation as-a-service features including model roll-back to the initial state after a failure of the model execution (e.g., invariant violations, inconsistent updates, ill-formed inputs, etc.) while processing an input event.",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 84,
                    "mention": "6",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Runtime Enforcement with AsmetaS@run.time",
            "ref_spans": []
        },
        {
            "text": "The intent of the proposed runtime enforcement mechanism is to evaluate safety assertions when there is a new (input) event that may change the state of the system and prevent the change if it violates an assertion on the ASM runtime model of the system. As shown in Fig. 1, every attempt (or only those considered critical) to change the system state is mediated by a process (the enforcer) that decides whether the change is safe. To make this decision (one per each observed event), the enforcer process evaluates the effect of the event on an ASM model of the behavior of the system (or a subpart of it dealing with the most critical requirements) that runs on-board the system as runtime model. If we are in a safe state (both the system and its runtime ASM model) and there is a new (input) event that may change this state, the enforcer performs first the state transfer on the ASM model (by feeding the input event to the ASM in terms of a monitored function value) and makes sure that the transition (that may take several machine steps \u2013 an ASM run) will take the ASM to a state without violating an invariant or generating an inconsistent update. If the ASM will produce a (safe) change of state, the enforcer confirms the state transfers also to the system, otherwise (the change is considered unsafe) it prevents the system to react to the event and a state rollback of the ASM model is performed to move it back to its previous (safe) state before the input event was processed. Therefore, the system is allowed to react to an event only when the model successfully checked the safety constraints for the event.\n",
            "cite_spans": [],
            "section": "Runtime Enforcement with AsmetaS@run.time",
            "ref_spans": [
                {
                    "start": 272,
                    "end": 273,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "We assume that there exists a catalog of safety assertions (expressed in any suitable language) describing all possible situations that may produce a violation of safety, and that these assertions have been expressed in the ASM runtime model in terms of ASM invariants. The catalog may be dynamically updated at runtime in case dangerous situations have not been foreseen at design time or because of unanticipated changes in the requirements when such changed requirements are added at runtime as effect of unanticipated adaptation (such as service-based applications plugging in new services and components discovered at runtime to improve quality of service). We assume that the invariants corresponding to the assertions added to the catalog dynamically are added to the ASM runtime model dynamically, as well.",
            "cite_spans": [],
            "section": "Runtime Enforcement with AsmetaS@run.time",
            "ref_spans": []
        },
        {
            "text": "The runtime enforcement technique could be useful to prevent the execution of unsafe commands in cyber physical systems where the environment is only partially observable [8], and, in general, in any safety-critical system, where the effects of not enforcing the safety assertions would lead to human hazards, as it happens for medical software [1]. We do not target hard real-time systems since these systems require dedicated solutions (e.g., real-time operating systems) and pose specific challenges.",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 173,
                    "mention": "8",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 346,
                    "end": 347,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Runtime Enforcement with AsmetaS@run.time",
            "ref_spans": []
        },
        {
            "text": "In this paper, we have presented our long-term vision of using the ASM executable models as formal support to the runtime enforcement technique to assure safe execution of a software system. Our short-term plan is to complete the implementation of the other components (the Assertion Catalog and the Assertion Enforcer) of the proposed runtime enforcement mechanism based on the new AsmetaS@run.time component. We also want to test its effective operation in the area of safety-critical systems, as for example those in the medical software domain.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        },
        {
            "text": "In the future, we plan to extend the ASM@run.time enforcement approach in the context of self-adaptive systems [3, 10]. Our long term goal is to develop a complete framework able to deal with requirements changes also affecting the model behavior, and therefore providing model adaptation features at runtime.",
            "cite_spans": [
                {
                    "start": 112,
                    "end": 113,
                    "mention": "3",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 115,
                    "end": 117,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "Fig. 1.: Runtime safety assertion enforcement by AsmetaS@run.time",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Analysis of safety-critical computer failures in medical devices",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Alemzadeh",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Kalbarczyk",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Iyer",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Raman",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "IEEE Secur. Priv.",
            "volume": "11",
            "issn": "4",
            "pages": "14-26",
            "other_ids": {
                "DOI": [
                    "10.1109/MSP.2013.49"
                ]
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "Digital twin-based smart production management and control framework for the complex product assembly shop-floor",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zhuang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Xiong",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Int. J. Adv. Manuf. Technol.",
            "volume": "96",
            "issn": "1",
            "pages": "1149-1163",
            "other_ids": {
                "DOI": [
                    "10.1007/s00170-018-1617-6"
                ]
            }
        },
        "BIBREF3": {
            "title": "CoMA: conformance monitoring of Java programs by abstract state machines",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Runtime Verification",
            "volume": "",
            "issn": "",
            "pages": "223-238",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Formal design and verification of self-adaptive systems with decentralized control",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Trans. Auton. Adapt. Syst.",
            "volume": "11",
            "issn": "4",
            "pages": "25:1-25:35",
            "other_ids": {
                "DOI": [
                    "10.1145/3019598"
                ]
            }
        },
        "BIBREF5": {
            "title": "Models@run.time: a guided tour of the state of the art and research challenges",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Bencomo",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "G\u00f6tz",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Song",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Softw. Syst. Model.",
            "volume": "18",
            "issn": "5",
            "pages": "3049-3082",
            "other_ids": {
                "DOI": [
                    "10.1007/s10270-018-00712-x"
                ]
            }
        },
        "BIBREF6": {
            "title": "Formal methods @ runtime",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Calinescu",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kikuchi",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Foundations of Computer Software. Modeling, Development, and Verification of Adaptive Systems",
            "volume": "",
            "issn": "",
            "pages": "122-135",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "Runtime failure prevention and reaction",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Falcone",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Mariani",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rollet",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Saha",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Lectures on Runtime Verification",
            "volume": "",
            "issn": "",
            "pages": "103-134",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Software monitoring through formal specification animation",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Liang",
                    "suffix": ""
                },
                {
                    "first": "JS",
                    "middle": [],
                    "last": "Dong",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sun",
                    "suffix": ""
                },
                {
                    "first": "WE",
                    "middle": [],
                    "last": "Wong",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "ISSE",
            "volume": "5",
            "issn": "4",
            "pages": "231-241",
            "other_ids": {
                "DOI": [
                    "10.1007/s11334-009-0096-1"
                ]
            }
        },
        "BIBREF9": {
            "title": "Runtime enforcement of cyber-physical systems",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pinisetty",
                    "suffix": ""
                },
                {
                    "first": "PS",
                    "middle": [],
                    "last": "Roop",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Smyth",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Allen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Tripakis",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "von Hanxleden",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Trans. Embed. Comput. Syst.",
            "volume": "16",
            "issn": "5s",
            "pages": "178:1-178:25",
            "other_ids": {
                "DOI": [
                    "10.1145/3126500"
                ]
            }
        },
        "BIBREF10": {
            "title": "A multi-paradigm modelling approach to live modelling",
            "authors": [
                {
                    "first": "YV",
                    "middle": [],
                    "last": "Tendeloo",
                    "suffix": ""
                },
                {
                    "first": "SV",
                    "middle": [],
                    "last": "Mierlo",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Vangheluwe",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Softw. Syst. Model.",
            "volume": "18",
            "issn": "5",
            "pages": "2821-2842",
            "other_ids": {
                "DOI": [
                    "10.1007/s10270-018-0700-7"
                ]
            }
        }
    }
}