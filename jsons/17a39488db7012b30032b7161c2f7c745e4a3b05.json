{
    "paper_id": "17a39488db7012b30032b7161c2f7c745e4a3b05",
    "metadata": {
        "title": "An XQuery Specification for Requests with Preferences on XML Databases",
        "authors": [
            {
                "first": "Maurice",
                "middle": [
                    "Tchoup\u00e9"
                ],
                "last": "Tchendji",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Dschang",
                    "location": {
                        "settlement": "Dschang",
                        "country": "Cameroon"
                    }
                },
                "email": "maurice.tchoupe@univ-dschang.org"
            },
            {
                "first": "Patrik",
                "middle": [
                    "Joslin"
                ],
                "last": "Kenfack",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Belgorod State Technological University",
                    "location": {
                        "settlement": "Belgorod",
                        "country": "Russia"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "An exact query is a query in which the user specifies precisely what to retrieve from a database (XML or relational database). For these queries only data that strictly respect all user's conditions is returned. XML documents are generally semi-structured. Due to the non-existence or lack of knowledge of the model of the document being queried, when exact queries are used, there is a high risk of obtaining an empty result (in the case of too specific queries) or too large (in the case of too vague queries). In contrast to exact queries, requests with preferences aim to return only the most relevant results in order to avoid empty or too important results as much as possible. To achieve this goal, requests with preferences generally consist of two parts: the first part is used to express strict constraints and the second part to express preferences or wishes. The satisfaction of both parts increases the relevance of the corresponding results. This paper presents XQuery preference, an extension of the XQuery language, that allows to express requests with preferences relating to both the values and the structure of an XML document. A representation model of such requests based on the Generalized Tree Pattern (GTP) model is also proposed in order to allow an evaluation of these requests through a tree pattern matching process. Integration of the proposed language in open source implementations of XQuery like BaseX, Berkeley DB XML, eXist-db, Galax and much more, will allow users to get much more relevant responses to their concerns.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "One of the consequences of the proliferation of online information today is data diversity. XML is widely used as a core technology for knowledge management within companies and the dissemination of data on the Web (such as product catalogues), as it allows semi-structured data to be organized and manipulated.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A collection of XML documents is considered to be a forest of trees with labelled nodes. To manipulate the data stored in XML and extract the relevant information in terms of structure and/or content, many query languages have been proposed such as XPath [6] and XQuery [7] . Indeed, these query languages take into account both the content and the structure of underlying documents, as it can completely change their relevance and adequacy with regard to the needs expressed by the user. However, it is important to note that in order to query a document using these languages, the user must a priori know its structure. This requirement is difficult to meet in an open environment such as the Web, where document structures are not always available. Thus, due to the non-existence or lack of knowledge of the model of the document being queried, the documents are queried almost blindly. Query writers in this context do so according to an imaginary document structure they believe to be that of the document. Such queries would generally return either no results (cases of too specific queries having little or no match with the content or structure of the document in question) or, in the extreme, too many results (case of too general queries intensively using wildcards).",
            "cite_spans": [
                {
                    "start": 255,
                    "end": 258,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 270,
                    "end": 273,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The problems of absence or very large number of results of a query have also emerged within the classical database community. Requests with preference aims to be a solution to this problem. Intuitively, a request with preferences specifies the user's wishes and consists of two parts specifying on the first one, the mandatory requirements called constraints and on the second part, the optional requirements called wishes or preferences. However, a result of a request with preferences must necessarily satisfy the first part and possibly the second; if there is at least one answer satisfying the first and second part of the query, only the answers satisfying both parts must be returned as a result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Some specific languages (generally extensions of SQL or XPath) have been proposed for the formulation of queries with preferences: SQLf [2] , Preference SQL [10] , Preferences Queries [5] , ... for relational databases (RBD), XPref [1] , Preference XPATH [9] , PrefSXPath [13] , ... for XML databases (XML BDs). Generally, proposed extensions of XPath language for importing the concept of preferences are only interested in either value based preferences [1, 9] or structure based preferences [13] . Our approach takes into account these two types of preferences in order to better satisfy user requirements.",
            "cite_spans": [
                {
                    "start": 136,
                    "end": 139,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 157,
                    "end": 161,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 184,
                    "end": 187,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 232,
                    "end": 235,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 255,
                    "end": 258,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 272,
                    "end": 276,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 456,
                    "end": 459,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 460,
                    "end": 462,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 494,
                    "end": 498,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The rest of this paper is organized as follows: Sect. 2 presents some concepts related to XML documents, queries languages and open source implementations, we detail our specifications by presenting in Sect. 3, a grammar for the language XQuery preference and the representation model. And we finally end with a conclusion and future work.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "An XML document is commonly considered as a tree where nodes are the elements or attribute names, and edges represent the child node's membership of the parent node and where leaves are the contents of the elements or attribute values. An XML database is a forest of XML document trees. The Fig. 2 illustrates an example of a tree representation of an XML document (Fig. 1) . The use of XML documents requires the ability to extract information and reformulate it for applications. Thus, there are many languages to retrieve information from a semi-structured document. Here we present the most popular: XPath and XQuery.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 291,
                    "end": 297,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 365,
                    "end": 373,
                    "text": "(Fig. 1)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "XML Document and Queries Languages"
        },
        {
            "text": "XPath allows to designate one or more nodes in an XML document, using path expressions. Thus, an XPath expression is a sequence of steps.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "XPath"
        },
        {
            "text": "[/]step 1 /step 2 /.../step n . An XPath step consists of an axis, a filter and a predicate (optional): axe :: filtre[predicat] The axis indicates a search direction. The most used axes are parent-child (represented by A/B) and descendant axis (A//B). The filter selects a node type. For example the expression A/B returns all elements B children of an element A. Predicates select content.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "XPath"
        },
        {
            "text": "XQuery [7] is the query language recommended by the W3C to extract information from many types of XML data sources. XQuery is the XML equivalent of SQL language, for retrieving data contained in relational databases and inherits the properties of several other languages. From XPath it uses the path expression syntax for addressing elements in XML documents. From SQL it takes up the idea of a series of clauses based on keywords that provide a model for data restructuring (the SQL SELECT-FROM-WHERE model). XQuery queries have several expression forms, the most famous is the FLWOR form. The acronym FLWOR comes from the reserved words of the language which make help to define the main clauses of this type of expression: For -Let -Where -Order By -Return.",
            "cite_spans": [
                {
                    "start": 7,
                    "end": 10,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "XQuery"
        },
        {
            "text": "Each clause in a FLWOR expression plays a particular role in the query and some of these clauses are optional. Thus, a FLWOR instruction consists of the following parts:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "XQuery"
        },
        {
            "text": "-For: iteration on an XML document part list -Let: allows the assignment of values to a variable -Order by: sorting results -Where: restriction clause (constraints) -Return: form of the expression to be returned An example of this type of request is given in Fig. 3 . This query select the email addresses and skills of people who have a Java skill level above 3 and have more than two years of experience. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 259,
                    "end": 265,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "XQuery"
        },
        {
            "text": "There are many open source implementations of XQuery. We present here a non-exhaustive list of them: XML queries (XPath or XQuery) to be evaluated on XML documents (trees), need to be represented in a model (a tree representation) in order to facilitate their evaluation. Therefore, evaluating the query is equivalent to apply the corresponding model to the XML tree trough a tree pattern matching process.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Open Source Implementations of XQuery"
        },
        {
            "text": "The concept of the generalized tree model (GTP) is introduced in [4] and allows to express more precisely the semantics of XQuery. The arcs of a GTP may be Parent-Child (PC), Ancestor-Descendant (AD) or optional. They are indicated by solid edges, double solid edges and dotted edges, respectively. A mandatory arc links an sub-expression corresponding to clauses FOR and WHERE with the rest of the query. An optional arc links an subexpression corresponding to clauses LET and RETURN with the rest of the query.",
            "cite_spans": [
                {
                    "start": 65,
                    "end": 68,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Generalized Tree Pattern (GTP)"
        },
        {
            "text": "A generalized tree pattern is a couple G = (T, F ) where T is a tree and F a Boolean formula such as.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1."
        },
        {
            "text": "-Each node in the tree T is labeled with different variables and has a group number. -To each arc of T is associated a pair of labels < x, m >, where x \u2208 {P C, AD} specifies the axis (parent-child and ancestor-descendant, respectively) and m \u2208 {mandatory, optional} specifies the arc's status. -F is a Boolean combination of predicates applicable to nodes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1."
        },
        {
            "text": "Zhimin Chen et al. [4] also propose an algrithm for translating an XQuery expression 1 in GTP. The request is put in a canonical form and is then parsed clause by clause while the GTP is progressively built up to the last clause, we invite you to read [4] for more details. The GTP is intended to be mapped (Pattern matching) to the XML tree.",
            "cite_spans": [
                {
                    "start": 19,
                    "end": 22,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 252,
                    "end": 255,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Definition 1."
        },
        {
            "text": "A Pattern Match of a GTP G = (G, F ) in a tree collection C is a subtree h partial: h : G \u2192 C such that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 2."
        },
        {
            "text": "-h contains at least group 0 of G. -h preserves the relational structure of G. This means that whenever h is defined on two nodes u, v and there is a PC arc (respectively AD) (u, v) in G, then h(v) is a son (respectively a descendant) of h(u). -h satisfies the Boolean formula F of G (Fig. 4) . ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 284,
                    "end": 292,
                    "text": "(Fig. 4)",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Definition 2."
        },
        {
            "text": "In order to take into account the two types of preferences, namely on values based and structure based, we propose an extension of XQuery at two levels: an extension of XPath language for the integration of structural preferences, through the use of the operator \"!\" introduced in [13] and the addition of a new clause (the Pref clause) for the expression of preferences on content.",
            "cite_spans": [
                {
                    "start": 281,
                    "end": 285,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "XQuery Preference: A Language for Expressing XQuery Requests with Preference"
        },
        {
            "text": "Based on the grammar given in [4] to describe a significant subset of the XQuery language, we consider the following grammar for XQuery preference expressions (Fig. 5) .",
            "cite_spans": [
                {
                    "start": 30,
                    "end": 33,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [
                {
                    "start": 159,
                    "end": 167,
                    "text": "(Fig. 5)",
                    "ref_id": null
                }
            ],
            "section": "Grammar of the Language XQuery Preference"
        },
        {
            "text": "For simplicity, we make other assumptions about our grammar as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 5. Syntax of XQuery preference expressions"
        },
        {
            "text": "-The atomic predicates allowed in the boolean formula \u03d5 are the integrated relop predicates (<, \u2264, >, \u2265, =, =) or the integrated predicate empty(F LW R). The operand of a relop predicate can be one of the following: constant c, XPath expression XP E, or agg(XP E), where agg is one of the integrated aggregate functions, namely, avg, count, min, max, or sum [4] . -The XPath expressions used are expressions extended by the operator \"!\" except for the Pref clause.",
            "cite_spans": [
                {
                    "start": 358,
                    "end": 361,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Fig. 5. Syntax of XQuery preference expressions"
        },
        {
            "text": "XPath language is a component of XQuery and is used to extract nodes from the XML document. This language therefore allows you to browse the structure of the document. We use the notation \"!\" (a unary operator) introduced by Tchoup\u00e9 et al. [13] for expressing preferences in an XPath (sub)path. For example, in the path Q 1 = /a/b!/c, the subpaths /a and /c represent the constraints, while /b represents a preference. Q 1 is interpreted as a request returning all occurrences c i of the node c such that the path from the root to c i must have an occurrence of a and possibly an occurrence of b. The occurrences c i candidates to be included in the solution are the sub-trees of the form /a i /b i /c i or /a i /c i . For simplification purposes, we assume that operator \"!\" can only be applied on a single node and not on an XPath subpath for example (a/b/c)!. In other words, this operator does not take into account parentheses. We introduce a new clause in the XQuery language: the Pref clause. A Boolean clause to define preferences (wishes) on results. Just like the clause Where, Pref will define the constraints on the values but with the only difference that, it will not accept an embedded XQuery expression.",
            "cite_spans": [
                {
                    "start": 240,
                    "end": 244,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Expression of Preferences on Values and Structure"
        },
        {
            "text": "In this way, requests for XQuery preference language are composed of two parts: one to express mandatory constraints (the Where clause), and the other to express preferences or wishes (the Pref clause). The language XQuery preference therefore follows the bipolar model. Thus, the answers satisfying constraints and wishes are returned in priority to the user. But if such answers do not exist then results that satisfy only the constraints are delivered. The example below shows an example of an XQuery request with preferences on values and structure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Expression of Preferences on Values and Structure"
        },
        {
            "text": "Let's consider a query in witch, a user is looking for a candidate with Java skills and at least a diploma level above 3. But would like this person to have at least two years of experience, and skills with the framework Sping-boot would be a plus. The user also wants the returnees to have filled in the information on their profiles.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 1. XQuery query with preference on values and structure:"
        },
        {
            "text": "In this example, the condition on Java skills and diploma level above 3 is a constraint while the condition on the number of years of experience and Spring-Boot skills is a wish whose satisfaction increase relevance of the associated result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 1. XQuery query with preference on values and structure:"
        },
        {
            "text": "The Fig. 6 illustrates how this request can be expressed in the language XQuery preference.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 4,
                    "end": 10,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Example 1. XQuery query with preference on values and structure:"
        },
        {
            "text": "For this request, people with only Java skills and a diploma level above 3 represent potential responses but are dominated by candidates who have in addition, an experience of more than 2 years and Spring-Boot skills. However, if no answer respects all the constraints of the Pref clause, only those that best integrate the user's preferences are returned: They are called undominated solutions. The operator \"!\" present in the XPath expression $p/prof ile!//name specifies that the person elements with a prof ile sub-element are preferred. For now, we have imposed certain restrictions on XQuery preference expressions. For example, we require that XPath paths defined in the clause Pref do not include a preference element for the simple reason that all these paths are already preferential since they appear in the pref clause. In the Sect. 2.4 we presented a model for XPath and XQuery queries. Indeed, these model considerably reduce the complexity of evaluating requests. In the following section, in the same vein we propose a query model for XQuery preference requests based on the GTP model of Chen Zhimin et al.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 1. XQuery query with preference on values and structure:"
        },
        {
            "text": "As previously stated, GTP model is used to represent exact XQuery queries. We adapt this model as follows for the representation of XQuery requests with preferences:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GTP Request with Preference"
        },
        {
            "text": "-to the GTP tree we add a new type of arc called preference arcs. A preference arc can be of the type AD (Ancestral-descending), PC (Parent-child) or PP (Preference Path). -the Boolean formula F verifying the predicates applicable to nodes is divided into two groups of formulas S and P:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GTP Request with Preference"
        },
        {
            "text": "\u2022 group S defines the mandatory constraints.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GTP Request with Preference"
        },
        {
            "text": "\u2022 and group P the preferential constraints (wishes). -A set of nodes forms a group if they are connected to each other by nonoptional or preferential relationships.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GTP Request with Preference"
        },
        {
            "text": "The Fig. 7 illustrates an example of a GTP request with preference (see Fig. 8 ), distinguishing between the different types of arcs to take preferences into account:",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 4,
                    "end": 10,
                    "text": "Fig. 7",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 72,
                    "end": 78,
                    "text": "Fig. 8",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "GTP Request with Preference"
        },
        {
            "text": "-The arcs preferences of type ancestor-descendant (APN). This type of arc allows to represent a structural preference between an element and its descendant for example a//b! -The arcs of type parent-child preferences (PPN) . For the representation of a structural preference between an element and its child for example a/b! -Finally, arcs of the type preference path (PP) for the representation of preferences on values. This type of arc will be generated for XPath expressions found in the Pref clause.",
            "cite_spans": [
                {
                    "start": 217,
                    "end": 222,
                    "text": "(PPN)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "GTP Request with Preference"
        },
        {
            "text": "The formula group S defines constraints on mandatory nodes while the group P defines constraints on preference nodes. All the nodes of the tree are part of the same group because they are all connected to each other by optional arcs or preference. More formally, a GTP with preference is defined as follows: -Each node in the tree T is labeled with a different variable and has a group number. -to each arc of T is associated a tag e, where e \u2208 {P C, AD, OP, P N, AP N, P P } \u2022 PC, AD: specify the parent-child and ancestor-descendant axis \u2022 PN, APN: specify respectively the parent-child preference and ancestordescendant preference axes. \u2022 OP, PP: specify the optional axes and preference path respectively. -F is a group of formula S and P specifying respectively a Boolean combination of predicates applicable to non-preferential nodes and to preferential nodes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "GTP Request with Preference"
        },
        {
            "text": "A node is said to be a preference if it is located at target of a preference arc. The model thus presented integrates the different elements for the representation of preferences in the GTPs. The GTP with preference is obtained by a parsing of the query XQuery preference as in [4] . The process for parsing a request is as follows: We have a global analysis environment ENV to manage information collected from the request analysis i.e The association variable name-nodes. The query is parsed clause by clause. We also use a help function buildT P Q(xp) where xp is an extended XPath expression 2 , which constructs part of GTP with preference from xp. This function is described as follows:",
            "cite_spans": [
                {
                    "start": 278,
                    "end": 281,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Definition 4."
        },
        {
            "text": "-Each time that xp starts with the built-in document function, a new GTP is added to ENV. -If xp begins with a variable, the node associated with this variable is searched for in the tree and the new part resulting from xp starts from it. -When xp contains the operator \"!\", The arcs associated with the nodes considered are of PN or APN type, depending on the axis (/ or // respectively) and the constraints linked to these nodes are placed in group P of the GTP formula.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4."
        },
        {
            "text": "During the analysis of a Pref clause, the arcs created are of type PP and the constraints linked to these nodes are placed in group P.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4."
        },
        {
            "text": "In this paper, we have made two major proposals: XQuery preference an extension of the XQuery language for the expression of requests with preferences which can relate to both the structure and the content; the GTP model with preference an extended version of the GTP model for the representation of XQuery preference queries; The examples given show that the proposed language is quite expressive and thus makes it possible to meet a variety of needs. We have carried out a study for the evaluation of GTPs requests with preference by an adaptation of the algorithm T wig 2 Stack [3] for the evaluation of exact GTPs requests. Due to the limitation of the number of pages in this paper, we could not describe it here, but it is accessible via the open repository on Github 3 . The results obtained are very interesting and show that we can extend the existing algorithms with a very small loss in performance but an improvement in terms of quality of the results delivered to users. Furthermore, this work serves as the foundation for a much larger body of work, which could be the subject of further study. Among which, integration and experimentation of XQuery preference in the presented open source sources implementations, an in-depth study of the nested XQuery preference queries and the search for the best algorithms for evaluating queries with preferences.",
            "cite_spans": [
                {
                    "start": 581,
                    "end": 584,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "XPref: a preference language for P3P",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Agrawal",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kiernan",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Srikant",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Comput. Netw",
            "volume": "48",
            "issn": "",
            "pages": "809--827",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "SQLf query functionality on top of a regular relational database management system",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bosc",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Pivert",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Studies in Fuzziness and Soft Computing",
            "volume": "39",
            "issn": "",
            "pages": "171--190",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-7908-1865-9_11"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Twig2stack: bottom-up processing of generalized-tree-pattern queries over XML documents",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tatemura",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Hsiung",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Agrawal",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Candan",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the 32nd International Conference on Very Large Data Bases",
            "volume": "",
            "issn": "",
            "pages": "283--294",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "From tree patterns to generalized tree patterns: on efficient evaluation of XQuery",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "V"
                    ],
                    "last": "Jagadish",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "V S"
                    ],
                    "last": "Lakshmanan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Paparizos",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Proceedings of the 29th International Conference on Very Large Data Bases (VLDB 2003)",
            "volume": "29",
            "issn": "",
            "pages": "237--248",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Preference formulas in relational queries",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Chomicki",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "ACM Trans. Database Syst",
            "volume": "28",
            "issn": "4",
            "pages": "427--466",
            "other_ids": {
                "DOI": [
                    "10.1145/958942.958946"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "XML path language (XPath) 2",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Consortium",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "XQuery 1.0: an XML query language",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Consortium",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Group's, I.S.: Implements the XQuery update facility; full-text support (since",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "U K"
                    ],
                    "last": "Database",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Preference XPATH: a query language for e-commerce",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Kie\u00dfling",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Hafenrichter",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Fischer",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Holland",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "427--440",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-57547-1_37"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "The preference SQL system -an overview",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Kie\u00dfling",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Endres",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Wenzel",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "IEEE Data Eng. Bull",
            "volume": "34",
            "issn": "",
            "pages": "11--18",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Galax: an XQuery implementation",
            "authors": [
                {
                    "first": "Mary",
                    "middle": [],
                    "last": "Fern\u00e0ndez",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "S"
                    ],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "The high-performance native XML database engine (since",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Meier",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "XPath bipolar queries and evaluation",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Tchoupe Tchendji",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Nguefack",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Revue Africaine de la Recherche en Informatique et Math\u00e9matiques Appliqu\u00e9es, Special issue CARI 2016",
            "volume": "27",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "XML document.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Tree representation of an XML document.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Example of an XQuery query",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Example of an XQuery expression and corresponding GTP query.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "An example of XQuery request with preference on structure and values",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Example of representation of a GTP request with preference Definition 3. A generalized tree pattern with preference is a couple G = (T, F ) where T is a tree and F a Boolean formula such as:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "XQuery preference request corresponding to the GTP with preference of theFig. 7",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "BaseX is a very light-weight, high-performance and scalable XML Database checking help to get it right. Being a complete solution, eXist-db tightly integrates with XForms for complex form development[12].-Galax is an open-source implementation of XQuery, the W3C XML Query Language. It includes several advanced extensions for XML updates, scripting, and distributed programming. Implemented in O'Caml, Galax comes with a state of the art compiler and optimizer. Most of Galax's architecture is formally documented, making it ideal for users interested in teaching XQuery, in building new language extensions, or developing new optimizations [11]. -Oracle Berkeley DB XML is an open source, embeddable XML database with XQuery-based access to documents stored in containers and indexed based on their content. Implemented in C, Oracle Berkeley DB XML is built on top of Oracle Berkeley DB and inherits its rich features and attributes.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}