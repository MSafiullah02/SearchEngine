{
    "paper_id": "PMC7206153",
    "metadata": {
        "title": "Learning Multigraph Node Embeddings Using Guided L\u00e9vy Flights",
        "authors": [
            {
                "first": "Hady",
                "middle": [
                    "W."
                ],
                "last": "Lauw",
                "suffix": "",
                "email": "hadywlauw@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Raymond",
                "middle": [
                    "Chi-Wing"
                ],
                "last": "Wong",
                "suffix": "",
                "email": "raywong@cse.ust.hk",
                "affiliation": {}
            },
            {
                "first": "Alexandros",
                "middle": [],
                "last": "Ntoulas",
                "suffix": "",
                "email": "antoulas@di.uoa.gr",
                "affiliation": {}
            },
            {
                "first": "Ee-Peng",
                "middle": [],
                "last": "Lim",
                "suffix": "",
                "email": "eplim@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "See-Kiong",
                "middle": [],
                "last": "Ng",
                "suffix": "",
                "email": "seekiong@nus.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Sinno",
                "middle": [
                    "Jialin"
                ],
                "last": "Pan",
                "suffix": "",
                "email": "sinnopan@ntu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Aman",
                "middle": [],
                "last": "Roy",
                "suffix": "",
                "email": "aman16011@iiitd.ac.in",
                "affiliation": {}
            },
            {
                "first": "Vinayak",
                "middle": [],
                "last": "Kumar",
                "suffix": "",
                "email": "vinayakk@iiitd.ac.in",
                "affiliation": {}
            },
            {
                "first": "Debdoot",
                "middle": [],
                "last": "Mukherjee",
                "suffix": "",
                "email": "debdoot@sharechat.co",
                "affiliation": {}
            },
            {
                "first": "Tanmoy",
                "middle": [],
                "last": "Chakraborty",
                "suffix": "",
                "email": "tanmoy@iiitd.ac.in",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Representation learning of networks has gained considerable attention in recent times [6, 7, 10, 13, 18, 19, 21, 22]. The goal of this body of research is to learn a low dimensional, dense representation for each node in a network while preserving structural information about the neighborhood of the node. These embeddings can then be used in a variety of downstream social network tasks such as link prediction, node clustering, multi-label classification of nodes, etc.",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 88,
                    "mention": "6",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 90,
                    "end": 91,
                    "mention": "7",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 93,
                    "end": 95,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 97,
                    "end": 99,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 101,
                    "end": 103,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 105,
                    "end": 107,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 109,
                    "end": 111,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 113,
                    "end": 115,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Majority of the research in network embedding are on networks where nodes share a single form of relationship. However, most real-world networks are multigraphs as multifaceted relationships are quite common between nodes. This is known as the multiplexity property [23] in social networks. For instance, a pair of users on a social network can be related through friendship, messaging, etc. In a scientific network, researchers can share a link by virtue of being co-authors on a paper or by citing each other\u2019s works. A high quality representation of a node in a multigraph should not only capture information about its neighboring nodes but also encode the relationships that exist with its neighbors. Hence, network embedding methods built for homogeneous networks must be extended to characterize the rich context present in multiple types of edges.",
            "cite_spans": [
                {
                    "start": 267,
                    "end": 269,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper, we propose a novel method, called Multigraph2Vec which is a random walk based node embedding method for multigraph. It employs a novel context sampling strategy, followed by the Skip-gram model to generate node embeddings. The employed random walker uses a novel strategy, called L\u00e9vy flight [8] to traverse through any node (without requiring an edge to traverse between nodes) in a single step, with its transition probabilities learned in a supervised fashion. Multigraph2Vec preserves multi-relational interaction among nodes via generating an (edge-)heterogeneous context.",
            "cite_spans": [
                {
                    "start": 308,
                    "end": 309,
                    "mention": "8",
                    "ref_id": "BIBREF23"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We show the efficiency of Multigraph2Vec via two downstream tasks - link prediction and multi-class node classification. In the former task, Multigraph2Vec outperforms several baselines \u2013 it beats the best baseline by 5.977% higher AUC score (averaged over all datasets and all layers). In the latter task, Multigraph2Vec outperforms the best baseline by 5.28% higher classification accuracy. We also deployed Multigraph2Vec for friend recommendation on Hike app.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In short, our major contributions are threefold:We propose Multigraph2Vec, a novel multigraph embedding technique that samples the neighborhood for each node via a \u201cL\u00e9vy flight\u201d random walk strategy, and learns the random walk transition probabilities in a supervised fashion, rather than treating them as hyperparameters.We perform a comprehensive analysis to show the superiority of Multigraph2Vec.We deployed Multigraph2Vec on a real-world system for friend recommendation.\n",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "For the purpose of reproducible research, we have made the codes and the datasets public at [20].",
            "cite_spans": [
                {
                    "start": 93,
                    "end": 95,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this section, we present a brief literature survey of the embedding methods developed for different types of networks.",
            "cite_spans": [],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Homogeneous Network Embedding: Representation learning for homogeneous networks has been studied extensively. DeepWalk [18] follows Skip-gram model [15], a two phase algorithm for learning node embedding. Node2Vec [7] employs a second order random walk governed by two parameters that control the breadth first search and depth first search nature of the random walker. LINE [21] learns the node embedding by preserving a certain measure of proximity among the nodes. Matrix factorization approaches such as spectral clustering [22] perform eigen decomposition on the normalized Laplacian matrix of a graph. Another body of work is built on Graph Convolutional Networks (GCN). [4] developed a variant of GCN based on spectral graph theory. [9] performed convolution in graph domain by aggregating information of neighboring nodes. [1] parameterized the context distribution function and used softmax attention to learn the importance of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k^{th}$$\\end{document} hop neighbors. Graph generative networks, on the other hand, aim to generate structures from data.",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 122,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 149,
                    "end": 151,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 215,
                    "end": 216,
                    "mention": "7",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 376,
                    "end": 378,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 529,
                    "end": 531,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 678,
                    "end": 679,
                    "mention": "4",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 741,
                    "end": 742,
                    "mention": "9",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 832,
                    "end": 833,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Heterogeneous Network Embedding: A heterogeneous information network (HIN) consists of multiple types of edges and nodes with only one edge connecting any two nodes. Metapath2vec [6] samples a heterogeneous context for a node using random walks guided by the predefined metapaths (a path consisting of a specific sequence of relationships/edge-types). [5] used the content and the link structure to generate important cues for creating a unified feature representation of the underlying network.",
            "cite_spans": [
                {
                    "start": 180,
                    "end": 181,
                    "mention": "6",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 353,
                    "end": 354,
                    "mention": "5",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Multidimensional Network Embedding: Despite its profound relevance in real-world scenario, limited attempts have been made to address multilayer/multidimensional embedding, compared to the vast amount of literature on simple graphs. MNE [25] generates a d-dimensional layer-specific embedding for each node by combining its d-dimensional base embedding (which remains common across layers), a transformation matrix (which is learned for each layer) and an s-dimensional auxiliary layer-specific embedding (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s\\,\\ll \\,d$$\\end{document}). [14] considered all the immediate neighbors (in each layer) of a node as its context and then employed a specific Skip-gram with a softmax taking into consideration node categories and layer information to obtain the embeddings for each node. PMNE [13] extends Node2Vec by introducing another parameter that allows the random walker to traverse across layers while sampling the context for each node. It does not learn this parameter, rather tunes it manually.",
            "cite_spans": [
                {
                    "start": 238,
                    "end": 240,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 805,
                    "end": 807,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1053,
                    "end": 1055,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "It is defined as a directed graph (directed, for the sake of generalization) \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G=(V,E,L)$$\\end{document}, where V is the set of vertices, L is the set of edge types and E is the set of triplets \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(v_i,v_j,l)$$\\end{document} representing an edge of type l directed from node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i$$\\end{document} to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_j$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i,v_j \\in V$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l \\in L$$\\end{document}. There can be multiple edges of different types between any two vertices.",
            "cite_spans": [],
            "section": "Definition 1 (Multigraph) ::: Problem Statement",
            "ref_spans": []
        },
        {
            "text": "Figure 1(a) shows a toy example of a multigraph. Nodes are assumed to be of same type. For the sake of better representation, we unfold a multigraph to a multidimensional network as shown in Fig. 1(b).\n",
            "cite_spans": [],
            "section": "Definition 1 (Multigraph) ::: Problem Statement",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 196,
                    "end": 197,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "It can be defined as a multilayer network1\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G=(V,E, L)$$\\end{document} having |L| layers or dimensions. V denotes a set of N unique nodes. A node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i \\in V$$\\end{document} in layer \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l\\in L$$\\end{document} is denoted by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i^l$$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1\\le i \\le N;\\ 1 \\le l \\le |L|$$\\end{document}. Each edge \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$E^{l}_{i,j}\\in E$$\\end{document} is a tuple \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(v_i,v_j,l)$$\\end{document} representing an edge of type l emanating from node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i^l$$\\end{document} to node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_j^l$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i,v_j\\in V$$\\end{document}. Essentially, G consists of a total of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|V| \\times |L|$$\\end{document} number of nodes. For simplicity, we assume that all nodes in V are present in all the layers. If a node is absent in a layer (i.e. no edge of type l connects to that node), we add the node as an isolated node in that layer.",
            "cite_spans": [],
            "section": "Definition 2 (Multidimensional Network) ::: Problem Statement",
            "ref_spans": []
        },
        {
            "text": "Given a multigraph \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G=(V,E,L)$$\\end{document}, our aim is to learn a low dimensional representation (embedding) for each node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i\\in V$$\\end{document}, i.e., \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X_{i} \\in R^{D}$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$D\\ll |V|$$\\end{document}.",
            "cite_spans": [],
            "section": "Definition 3 (Problem Statement) ::: Problem Statement",
            "ref_spans": []
        },
        {
            "text": "Skip-gram [16] has been utilised for learning node embeddings in multiple studies [6, 7, 25] by treating networks as documents and nodes as words. In order to obtain embedding for a target node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i$$\\end{document}, it maximizes the log likelihood of observing its neighborhood structure \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N(v_i)$$\\end{document} conditioned on its latent node embedding vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X_i$$\\end{document}, i.e.,1\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathop {\\arg \\max }\\limits _X \\sum \\limits _{v_{i}\\in V}\\log p(N(v_{i})|X_{i}) \\end{aligned}$$\\end{document}where, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X_{i}$$\\end{document} represents the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i^{th}$$\\end{document} row (D dimensional embedding vector for node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document}) of an \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N \\times D$$\\end{document} embedding matrix X. The neighborhood structure \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N(v_i)$$\\end{document} for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i$$\\end{document} is the result of a specific neighborhood sampling strategy, and its member nodes are the context nodes for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i$$\\end{document}. The likelihood of observing neighborhood structure \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N(v_{i})$$\\end{document} for node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} can be expressed as follows,2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\begin{aligned} p(N(v_{i})|X_{i})&= \\prod \\limits _{n_{j} \\in N(v_{i})}p(n_j|X_i) = \\prod \\limits _{n_{j} \\in N(v_{i})} \\frac{e^{(X_{j}\\cdot X_{i})}}{\\sum \\limits _{n=1}^{N} e^{(X_{n}\\cdot {X_i})}} \\end{aligned} \\end{aligned}$$\\end{document}The log likelihood of Eq. 2 becomes3\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\log (p(n_j|X_i))= \\log ({e^{(X_j\\cdot X_i)}})-\\log (\\sum \\limits _{n=1}^{N} e^{X_n \\cdot X_i}) \\end{aligned}$$\\end{document}The second term in Eq. 3 is computationally expensive for large networks and is thus approximated using negative sampling [16].4\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\log (p(n_{j}|X_{i}))= \\log ({\\sigma (X_{j}\\cdot X_{i}}))+\\sum \\limits _{m=1}^{M}\\log ( \\sigma (-X_{m}\\cdot X_{{i}})) \\end{aligned}$$\\end{document}where, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\sigma (x)=\\frac{1}{1+\\exp (-x)}$$\\end{document}, and M is the negative sample size. After plugging in this approximation, the final objective function takes the following form:5\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathop {\\arg \\max }\\limits _X \\sum \\limits _{v_{i}\\in V}\\sum \\limits _{n_{j} \\in N(v_{i})} (\\log (\\sigma (X_{{j}}\\cdot X_{{i}}))+ \\sum \\limits _{m=1}^{M}\\log ( \\sigma (-X_{{m}}\\cdot X_{i}))) \\end{aligned}$$\\end{document}The above objective function can be optimized using Stochastic Gradient Descent (SGD) algorithm.",
            "cite_spans": [
                {
                    "start": 11,
                    "end": 13,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 83,
                    "end": 84,
                    "mention": "6",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 86,
                    "end": 87,
                    "mention": "7",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 89,
                    "end": 91,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 5628,
                    "end": 5630,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Skip-Gram Model ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "We propose a novel neighborhood sampling strategy. We allow our random walker to jump to nodes that can be separated by any number of hops from the current node. We employ a random walk process, called \u2018L\u00e9vy flight\u2019 [8]. It does not require a direct edge between current and target nodes; thus it can hop over very large distance and visit far-off nodes effectively taking a \u2018flight\u2019 rather than a \u2018walk\u2019 within a single hop. Moreover, its ability to switch across layers preserves inter-layer interactions and thus produces an (edge-)heterogeneous context (see Fig. 1(c)).",
            "cite_spans": [
                {
                    "start": 217,
                    "end": 218,
                    "mention": "8",
                    "ref_id": "BIBREF23"
                }
            ],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": [
                {
                    "start": 567,
                    "end": 568,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Such a random walker, if used in an unsupervised fashion (for example, by letting it hop to any node from the current node with equal probability), can generate arbitrary contexts. This can be detrimental for the downstream prediction tasks. Thus, it is necessary to guide it in a principled fashion. In order to do this, we make its transition probabilities as a function of linear weighted combination of node attributes (which can be metadata/network-property based or a combination of two) and learn these weights subject to certain constraints, essentially converting the random walk guidance problem into a constrained optimization problem.",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "Random Walk in Multigraph2Vec: We modify the L\u00e9vy flight strategy in two ways. Firstly, our random walker at any step has only two possible steps to adopt as shown in Fig. 1(c). Secondly, the transition probabilities are a parameterized function of node attributes. It is calculated by taking inner product of weight vector with node-pair feature vector and then passing it through a non-linear function (in our case, sigmoid function), which maps it between 0 and 1. Formally, L\u00e9vy flight random walk strategy for multidimensional networks can be defined as follows.",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": [
                {
                    "start": 172,
                    "end": 173,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Given that the random walker is currently at node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_t = v_i^l$$\\end{document}, the probability of hopping to node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c_{t+1} = v_j^{l^{'}}$$\\end{document} is given by:\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ P(c_{t+1} = v_j^{l^{'}} | c_t = v_i^l ) = {\\left\\{ \\begin{array}{ll} \\frac{f(\\phi _l^{i,j})}{Z} &{} l=l^{'}, i\\ne j\\\\ \\frac{f(\\phi _{ll^{'}}^{i})}{Z} &{} l\\ne l^{'}, i = j\\\\ 0 &{} l\\ne l^{'}, i\\ne j \\\\ \\end{array}\\right. } $$\\end{document}where, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\phi _l^{i,j}= \\beta _{l}^\\intercal \\psi _{v_{i}^{l}v_{j}^{l}}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\phi _{ll^{'}}^{i} = \\beta _{ll^{'}}^\\intercal \\psi _{v_{i}^{l}v_{i}^{l^{'}}}$$\\end{document}.",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "\nf(x) is a strength function, defined as a function of a linear weighted combination of node-pair features (obtained by combining the attributes of the corresponding nodes in the node-pair). f(x) must be non-negative and differentiable. We choose it to be a sigmoid function.Z is a normalization constant.\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\psi _{v_{i}^{l}v_{j}^{l}}$$\\end{document} is a node-pair feature vector obtained by combining the attributes of corresponding nodes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{j}$$\\end{document} in layer l. It is utilized for hopping to nodes within the same layer. The node attributes can be derived from metadata (e.g., number of papers published by an author in different research areas) or from the network structure at layer l (e.g., degree, clustering coefficient, etc. at layer l). The difference between the attribute vectors of the two nodes can form the node-pair feature vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\psi _{v_{i}^{l}v_{j}^{l}}$$\\end{document}.\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\psi _{v_{i}^{l}v_{i}^{l^{'}}}$$\\end{document} is a node-pair feature vector obtained by concatenating together some centrality measure (like degree) of node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} in layers l and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l^{'}$$\\end{document}. It is utilized for hopping to same node in different layers.\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta ^{l}$$\\end{document} is a weight vector corresponding to transition probabilities in layer l.\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta ^{ll^{'}}$$\\end{document} is a weight vector corresponding to probability of switching from layer l to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l^{'}$$\\end{document}.Learning the Transition Probability: Multigraph2Vec learns the weight parameters \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} such that the random walker has a higher probability of hopping to one of the \u201chigh priority nodes\u201d (set H) than the \u201clow priority nodes\u201d (set L) from the current node [3]. This hopping behavior is enforced on the random walker w.r.t. a subset of nodes, referred to as S; each \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s\\in S$$\\end{document} represents a source node. S contains equal number of nodes from each layer sampled from the degree distribution at the corresponding layer. The learned weights are expected to generalize the behavior of the random walk for all the nodes in the network.",
            "cite_spans": [
                {
                    "start": 4664,
                    "end": 4665,
                    "mention": "3",
                    "ref_id": "BIBREF18"
                }
            ],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "There can be multiple ways of constructing H and L sets for a given source node s, denoted by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$H_s$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_s$$\\end{document} respectively. Multigraph2Vec constructs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$H_s$$\\end{document} by considering proximity and attribute similarity. Considering s to be a source node from layer l, a node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} satisfying at least one of the following three conditions w.r.t. s is eligible to be included in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$H_s$$\\end{document}: (i) the distance between \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} and s is less than or equal to k in layer l, (ii) the attribute similarity between s and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_i$$\\end{document} (based on cosine similarity) is more than a certain threshold \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\tau $$\\end{document} in layer l, (iii) if it is an alias of s in any layer. Remaining nodes in the layer to which s belongs, comprise the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_s$$\\end{document} set.",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "We use personalized PageRank scores to enforce this behavior on the random walker. The objective function becomes:6\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathop {\\arg \\min }\\limits _{\\beta } ||\\beta ||^{2} + \\lambda _1\\sum _{s \\in S}\\sum _{h_s \\in H_s, l_s \\in L_s}h(p_{l_s} - p_{h_s}) \\end{aligned}$$\\end{document}where, h is a loss function which penalizes the objective function if PageRank score of nodes in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$H_s$$\\end{document} becomes smaller than that of nodes in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_s$$\\end{document}. The loss function must be continuous and differentiable. We choose it to be Wilcoxon-Mann-Whitney (WMW) loss with width b.2\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} h(x)=\\frac{1}{1+\\exp (-x/b)} \\end{aligned}$$\\end{document}The PageRank scores are obtained from the following eigenvector equation: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ p^\\intercal = p^\\intercal Q $$\\end{document}, where, Q represents the random walk transition matrix and p represents the PageRank vector.",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "Upon Incorporating the restart probability, each element (u, v) of Q becomes:7\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} P^{'}(c_{t+1}=v|c_{t}=u) = (1-\\alpha )P(c_{t+1}=v|c_{t}=u) + \\alpha \\mathbf{1} \\end{aligned}$$\\end{document}where, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} is the restart probability, i.e., the probability of hopping back to s from any current node u. The cost function in Eq. 6 is optimized using L-BFGS algorithm [12]. The learned weights \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} are chosen such that the random walker at any current node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$v_{i}$$\\end{document} hops to nodes matching the traits of nodes in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$H_{v_{i}}$$\\end{document}, with a higher probability than the nodes matching the traits of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{v_{i}}$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 931,
                    "end": 933,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "Finally, multiple walks are simulated starting from each node in each layer for neighborhood sampling. While doing this, restart probabilities are not incorporated i.e., the transition probabilities \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P(c_{t+1}|c_{t})$$\\end{document} are used (and not \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P^{'}(c_{t+1}|c_{t})$$\\end{document}).",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "Brief Description of the Pseudocode: Algorithm 1 takes the graph G and node attributes as inputs and returns the embedding matrix X. The function LEARN_WEIGHTS (Line 13) takes the multigraph G and number of source nodes per layer \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$s_l$$\\end{document} as input. It first samples equal number of source nodes from each layer uniformly at random and then constructs the H and L sets corresponding to each source node. Finally it optimizes the objective function (Eq. 6) and returns the parameter vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document}. Then, the learned parameter vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} and the graph G along with all the node-pair feature vectors for each layer are taken as the input by the function BUILD_FINAL_TRANSITION_MATRIX (Line 27), and the final transition matrix Q to be used for generating the random walks is returned. The function RANDOM_WALKS (Line 37) takes in the final transition matrix Q along with number of walks and walk length as input and returns multiple random walks of fixed length starting from each node in each layer. The generated random walks are then passed into the SKIP_GRAM (Line 12) function that optimizes the objective function (Eq. 5) and returns the final learned D dimensional continuous embedding matrix X, which can further be used for any downstream tasks.",
            "cite_spans": [],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "Complexity Analysis: Learning \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document} is the most expensive task in Multigraph2Vec. To compute the loss (Eq. 6), for a source node we need to obtain personalized PageRank scores for each node in its corresponding H and L sets. We use power iteration method [3] for the same. In theory, PageRank computation takes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(N^{3})$$\\end{document}. However, in practice, it takes 5\u20136 iterations to get the personalized PageRank vector. Since we perform this operation for all the source nodes S, the overall time complexity per iteration becomes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {O}(|S|N^{3})$$\\end{document}. We observed that L-BFGS takes 15\u201320 iterations to converge and returns the optimal \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\beta $$\\end{document}.",
            "cite_spans": [
                {
                    "start": 542,
                    "end": 543,
                    "mention": "3",
                    "ref_id": "BIBREF18"
                }
            ],
            "section": "Neighborhood Sampling in Multigraph2Vec ::: Multigraph2Vec",
            "ref_spans": []
        },
        {
            "text": "We set the similarity threshold hyper-parameter \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\tau $$\\end{document} to 90%. A low similarity threshold value introduces a large number of common nodes in the set H of each source node, thereby reducing the uniqueness of set H (high priority node set) of each source node. All the baselines we consider uses logistic regression classifier. So, in order to maintain a fair ground for comparison we use logistic regression classifier as well. Table 1 describes the datasets used in this study.\n\n",
            "cite_spans": [],
            "section": "Experimental Setup ::: Evaluation",
            "ref_spans": [
                {
                    "start": 717,
                    "end": 718,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Experimental Setup ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "\n\n\n",
            "cite_spans": [],
            "section": "Experimental Setup ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "We evaluate the ability of Multigraph2Vec to predict the presence of a specific type of link between any two nodes given all other links between them. We pose it as a binary classification problem. Let us assume that we wish to evaluate the performance for layer l. We then proceed by splitting \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$tr\\%$$\\end{document} (training) and ts% (testing) of the edges (set as 75% and 25%, respectively in our experiments) in layer l into training set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$tr_{pos}$$\\end{document} and test set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ts_{pos}$$\\end{document} respectively, thereby obtaining positive class samples for training and testing. Similarly, we split the \u2018no edge/absent edges\u2019 in layer l into training set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$tr_{neg}$$\\end{document} and test set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ts_{neg}$$\\end{document}, thereby obtaining negative class samples for training and testing, respectively. We then learn the node embeddings on the training set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$tr=tr_{pos}\\cup tr_{neg}$$\\end{document}.",
            "cite_spans": [],
            "section": "Link Prediction ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "Once the node embeddings are learned, a d-dimensional edge representation for each edge in training and test sets is obtained by averaging the corresponding node embeddings. Due to real-world networks being sparse, the training set is highly imbalanced. It contains an overwhelming proportion of negative samples (no-edge) compared to that of positive samples. To remove class imbalance, we undersample the negative class by taking similar number of samples as that present in the positive class. We then train a logistic regression model on the training set (formed after removing class imbalance) and test the performance of the model on the test set. We repeat the experiments 50 times and report the average AUC score.",
            "cite_spans": [],
            "section": "Link Prediction ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "Baseline Methods: We compare Multigraph2Vec with single-layer methods, namely Node2Vec [7], LINE [21], and multi-layer methods, namely PMNE [13] and MNE [25]. We also compare against non-embedding methods like Jaccard Coefficient (JC) [11], Adamic-Adar (AA) [2], and common neighbor (CN) [17] based link prediction approaches.",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 89,
                    "mention": "7",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 98,
                    "end": 100,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 141,
                    "end": 143,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 154,
                    "end": 156,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 236,
                    "end": 238,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 259,
                    "end": 260,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 289,
                    "end": 291,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Link Prediction ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "Single-layer methods are not straightforwardly applicable to multidimensional networks and are also unable to capture multi-relation/interlayer interactions in the learned embeddings. For these methods, in order to obtain embeddings while evaluating for layer l, we only consider the training edges of layer l. Multi-layer methods (PMNE and MNE) are straightforward to apply in our setting, apart from the fact that these methods do not handle isolated nodes. For this, we terminate the random walk if it starts from or reaches an isolated node.",
            "cite_spans": [],
            "section": "Link Prediction ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "Parameter Sensitivity: We examine how different choices of embedding dimensions and node attributes (metadata based, network structure based and combination) affect the performance of Multigraph2Vec for link prediction. Figure 2 shows that with the increase of embedding dimension d, Multigraph2Vec performs consistently better. However, it performs the best if only network structure based attributes are used, rather than metadata based or their combination. Table 2 shows the performance of Multigraph2Vec with network structure based attributes keeping \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$d=128$$\\end{document}.",
            "cite_spans": [],
            "section": "Link Prediction ::: Evaluation",
            "ref_spans": [
                {
                    "start": 227,
                    "end": 228,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 467,
                    "end": 468,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "Comparative Analysis: Table 2 shows the performance of different embedding methods on four datasets (layer-wise). As expected, multilayer embedding methods (Multigraph2Vec, PMNE and MNE) outperform single-layer embedding methods (Node2Vec, LINE). The reason is that multilayer methods can capture the useful multi-relational interactions among nodes, while single-layer networks cannot. MNE turns out to be the best baseline. However, Multigraph2Vec outperforms MNE by 5.53%, 5.73%, 6.66% and 5.21% higher AUC (relative) on EU, Hike, Lazega and Publication datasets, respectively (averaged over the layers). From Fig. 2 it can be seen that when only network attributes are used AUC values are always higher than when either metadata attributes or both metadata and network attributes are used. This is because metadata features are redundant when combined with network properties, Hence together these features are actually losing information instead of gaining one. To support the fact we perform correlation analysis between every metadata and network properties features. We compute both linear (Pearson) as well as non linear (Spearman) coefficient on EU and System dataset because only they had metadata attributes. The mean linear correlation comes out to be 0.82 and 0.92 while the mean non linear correlation is 0.78 and 0.86 respectively on EU and Hike dataset. These values support the fact that network properties along with metadata properties causes redundancy which decreases the AUC-ROC score and hence network attributes alone gives best result.",
            "cite_spans": [],
            "section": "Link Prediction ::: Evaluation",
            "ref_spans": [
                {
                    "start": 618,
                    "end": 619,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 28,
                    "end": 29,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "In this setting, each node is assigned a label from a label set. The entire multigraph is used for unsupervised feature learning i.e., for learning the embedding of each node. Once the embeddings are learned, 75% nodes represented by their corresponding embeddings are used for training a multi-class classifier (here we use Logistic Regression classifier with one v/s rest approach). The remaining 25% nodes are used as test set. Multi-class node classification experiments are performed on the publication dataset only, since other datasets do not have node labels.",
            "cite_spans": [],
            "section": "Node Classification ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "Baseline Methods: We learn the embeddings using single-layer baseline methods \u2013 Node2Vec, LINE, on an aggregated network. A pair of nodes are connected if they have at least one edge between them in the original multigraph. Multi-layer baseline methods (PMNE and MNE) are trained on the entire multigraph itself.",
            "cite_spans": [],
            "section": "Node Classification ::: Evaluation",
            "ref_spans": []
        },
        {
            "text": "Comparative Analysis: Figure 3 shows the performance of different embedding methods on the publication dataset. Multigraph2Vec with an accuracy of 74.28% outperforms other multi-layer embedding methods, MNE (accuracy of 69%) and PMNE (accuracy of 68.53%); whereas, single-layer methods, Node2Vec and LINE could only achieve an accuracy of 60.54% and 55.31%, respectively.",
            "cite_spans": [],
            "section": "Node Classification ::: Evaluation",
            "ref_spans": [
                {
                    "start": 29,
                    "end": 30,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "In this paper, we proposed Multigraph2Vec, a novel multigraph embedding generation method, which allowed flights instead of walks and learns transition probabilities while concurrently preserving multi-relation interactions among nodes, in a principled fashion. We compared Multigraph2Vec with four state-of-the-art network embedding methods on four real-world datasets for the task of link prediction and multi-class node classification and observed significant improvement over these baselines. We also deployed Multigraph2Vec on Hike app for friend recommendation.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Summary of the datasets.\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Layer-specific performance of different competing methods in the task of link prediction on four datasets. The AUC score is reported after averaging the performance across 50 iterations. The results are reported with network-property based attributes, and the dimension of the embedding vector is set to 128.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: (a) A toy example of a multigraph representing a social network (e.g, Facebook) where nodes are users, and they are connected via at most three types of edges (red: friend, blue: follower, green: chat). It is not necessary that all pairs of nodes are always connected by three different edges. For example, nodes C and E are connected by only friendship link. But they do not follow each other and do not chat. (b) Each edge type mentioned in Fig (a) forms a layer/dimension in the corresponding multidimensional network. Node set remains same across layers, and each layer is homogeneous in terms of the edge type. (c) Illustration of the modified L\u00e9vy flight strategy on a multidimensional network. The figure shows the different elementary steps that the random walker can adopt. (Color figure onilne)",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Variation in the performance of Multigraph2Vec w.r.t. the increasing dimension of embedding and node attributes (metadata based or network-structure based) on link prediction. AUC scores averaged across layers are plotted on a log scale to elucidates mall differences in AUC values. Note that Lazega network does not have any metadata information of nodes.",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Accuracy obtained with different competing methods in multi-class node classification task on the Publication dataset. The accuracy is reported after averaging the performance across 50 iterations. The results are reported with network-property based attributes, and the dimension of the embedding vector is set to 128.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "The link-prediction problem for social networks",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Liben-Nowell",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Kleinberg",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "JASIST",
            "volume": "58",
            "issn": "7",
            "pages": "1019-1031",
            "other_ids": {
                "DOI": [
                    "10.1002/asi.20591"
                ]
            }
        },
        "BIBREF3": {
            "title": "On the limited memory bfgs method for large scale optimization",
            "authors": [
                {
                    "first": "DC",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Nocedal",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Math. Program.",
            "volume": "45",
            "issn": "3",
            "pages": "503-528",
            "other_ids": {
                "DOI": [
                    "10.1007/BF01589116"
                ]
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Clustering and preferential attachment in growing networks",
            "authors": [
                {
                    "first": "MEJ",
                    "middle": [],
                    "last": "Newman",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Phys. Rev. E",
            "volume": "64",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1103/PhysRevE.64.025102"
                ]
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Heterogeneous information network embedding for recommendation",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Shi",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Hu",
                    "suffix": ""
                },
                {
                    "first": "WX",
                    "middle": [],
                    "last": "Zhao",
                    "suffix": ""
                },
                {
                    "first": "SY",
                    "middle": [],
                    "last": "Philip",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE TKDE",
            "volume": "31",
            "issn": "2",
            "pages": "357-370",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "Friends and neighbors on the web",
            "authors": [
                {
                    "first": "LA",
                    "middle": [],
                    "last": "Adamic",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Adar",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Soc. Netw.",
            "volume": "25",
            "issn": "",
            "pages": "211-230",
            "other_ids": {
                "DOI": [
                    "10.1016/S0378-8733(03)00009-1"
                ]
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "Leveraging social media networks for classification",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Data Min. Knowl. Disc.",
            "volume": "23",
            "issn": "",
            "pages": "447-478",
            "other_ids": {
                "DOI": [
                    "10.1007/s10618-010-0210-x"
                ]
            }
        },
        "BIBREF15": {
            "title": "Multiplexity in adult friendships",
            "authors": [
                {
                    "first": "LM",
                    "middle": [],
                    "last": "Verbrugge",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Soc. Forces",
            "volume": "57",
            "issn": "4",
            "pages": "1286-1309",
            "other_ids": {
                "DOI": [
                    "10.2307/2577271"
                ]
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "L\u00e9vy random walks on multiplex networks",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Guo",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Cozzo",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Moreno",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Sci. Rep.",
            "volume": "6",
            "issn": "",
            "pages": "1-11",
            "other_ids": {
                "DOI": [
                    "10.1038/s41598-016-0001-8"
                ]
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}