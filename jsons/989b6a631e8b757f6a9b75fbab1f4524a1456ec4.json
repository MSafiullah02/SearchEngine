{
    "paper_id": "989b6a631e8b757f6a9b75fbab1f4524a1456ec4",
    "metadata": {
        "title": "OPTIMAL COVID-19 POOL TESTING WITH A PRIORI INFORMATION",
        "authors": [
            {
                "first": "Marc",
                "middle": [],
                "last": "Beunardeau",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "\u00c9ric",
                "middle": [],
                "last": "Brier",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "No\u00e9mie",
                "middle": [],
                "last": "Cartier",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Information Security Group",
                    "institution": "PSL Research University",
                    "location": {
                        "postCode": "75005",
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "Aisling",
                "middle": [],
                "last": "Connolly",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Information Security Group",
                    "institution": "PSL Research University",
                    "location": {
                        "postCode": "75005",
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "Nathana\u00ebl",
                "middle": [],
                "last": "Courant",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Information Security Group",
                    "institution": "PSL Research University",
                    "location": {
                        "postCode": "75005",
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "R\u00e9mi",
                "middle": [],
                "last": "G\u00e9raud-Stewart",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Information Security Group",
                    "institution": "PSL Research University",
                    "location": {
                        "postCode": "75005",
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "David",
                "middle": [],
                "last": "Naccache",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Information Security Group",
                    "institution": "PSL Research University",
                    "location": {
                        "postCode": "75005",
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            },
            {
                "first": "Ofer",
                "middle": [],
                "last": "Yifrach-Stav",
                "suffix": "",
                "affiliation": {
                    "laboratory": "Information Security Group",
                    "institution": "PSL Research University",
                    "location": {
                        "postCode": "75005",
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "As humanity struggles to contain the global infection, prophylactic actions are grandly slowed down by the shortage of testing kits. Governments have taken several measures to work around this shortage: the FDA has become more liberal on the approval of COVID-19 tests in the US. In the UK emergency measures allowed to increase the daily number of locally produced test kits to 100,000. China has recently launched a massive test manufacturing program. However, all those efforts are very insufficient and many poor countries are still under threat. A popular method for reducing the number of tests consists in pooling samples, i.e. mixing patient samples and testing the mixed samples once. If all the samples are negative, pooling succeeds at a unitary cost. However, if a single sample is positive, failure does not indicate which patient is infected. This paper describes how to optimally detect infected patients in pools, i.e. using a minimal number of tests to precisely identify them, given the a priori probabilities that each of the patients is healthy. Those probabilities can be estimated using questionnaires, supervised machine learning or clinical examinations. The resulting algorithms, which can be interpreted as informed divide-and-conquer strategies, are non-intuitive and quite surprising. They are patent-free. Co-authors are listed in alphabetical order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "1 Introduction and motivation",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "The current (Coronavirus Disease 2019) pandemic is rapidly spreading and significantly impacts healthcare systems. Stay-at-home and social distancing orders enforced in many countries are supporting the control of the disease's spread, while causing turmoil in the economic balance and in social structures [BBD + 20] . Rapid detection of cases and contacts is an essential component in controlling the spread of the pandemic. In the US, the current estimation is that at least 500,000 Covid-19 tests will need to be performed daily in order to successfully reopen the economy [LVLM20]",
            "cite_spans": [
                {
                    "start": 307,
                    "end": 317,
                    "text": "[BBD + 20]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Testing for COVID-19 infection"
        },
        {
            "text": "Unfortunately, as humanity attempts to limit the global COVID-19 infection, prophylactic actions are grandly slowed-down by the severe shortages of COVID-19 testing kits [BEF20].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Testing for COVID-19 infection"
        },
        {
            "text": "There are currently two types of tests for -Molecular diagnostic tests that detect the presence of SARS-COV-2 nucleic acids in human samples. A positive result of these tests indicates the presence of the virus in the body. -Serological diagnostic tests that identify antibodies (e.g., IgM, IgG) to SARS-COV-2 in clinical specimens [WKLT20] . Serological tests, also known as antibody tests, can be helpful in identifying not only those who are ill, but also those who have been infected, as antibodies are still present in their blood. This identification may be important for several reasons. First, this test can differentiate those who are immune to the virus and those who are still at risk. Secondly, identifying populations who have antibodies can facilitate research on the use of convalescent plasma in the development of a cure for [FA20].",
            "cite_spans": [
                {
                    "start": 332,
                    "end": 340,
                    "text": "[WKLT20]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Testing for COVID-19 infection"
        },
        {
            "text": "Work done when the author was with \u00c9NS and Ingenico Laboratories.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Testing for COVID-19 infection"
        },
        {
            "text": "As mentioned, both tests are in very short supply. Governments have taken several measures to work around this shortage: the FDA 4 has become more liberal on the approval of tests via the EUA (Emergency Use Authorization) [FA20] ; in the US and the UK there are attempts to boost the number of locally produced test kits to reach a throughput of 100,000 kits per day. Those efforts cannot, however, be followed by many countries and there remains entire swaths of Africa, Asia and Latin America that are under concrete threat.",
            "cite_spans": [
                {
                    "start": 222,
                    "end": 228,
                    "text": "[FA20]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Testing for COVID-19 infection"
        },
        {
            "text": "To optimize the use of available tests, reduce costs and save time, pool testing (or group testing) can be considered. The concept is credited to Dorfman [Dor43] who wished to test US servicemen for syphilis. In pool testing, multiple samples are mixed, and the resulting 'pool' is tested using the same amount of material or equipment that would have been required to test one individual sample. [Ste57, SG59] are important refinements of Durfman's work. However, when at least one sample in the pool is positive, then the pool test fails. This means that (at least) one sample in the pool is positive, but gives no information about which one. The most naive approach is then to re-test individually each sample, which can be costly and time consuming.",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 161,
                    "text": "[Dor43]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 397,
                    "end": 404,
                    "text": "[Ste57,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 405,
                    "end": 410,
                    "text": "SG59]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Pool testing"
        },
        {
            "text": "The area has seen numerous developments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pool testing"
        },
        {
            "text": "[AJS19] provides a recent survey of the topic and [boo93] is the reference book on the topic.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pool testing"
        },
        {
            "text": "It is important to distinguish between two types of pool tests: Adaptive tests where the tested samples depend on previously tested ones and Nonadaptive tests, where all the tests are planned in advance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pool testing"
        },
        {
            "text": "Pool tests are also classified as either probabilistic or combinatorial. In essence, probabilistic models assume a probability distribution and seek to optimize the average number of tests required to test all the patients. By opposition, combinatorial algorithms seek to minimize the worst-case number of tests when the probability distribution governing the infection is unknown.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pool testing"
        },
        {
            "text": "This paper deals with adaptive probabilistic tests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pool testing"
        },
        {
            "text": "Pool testing has already been used to screen large portions of the population in scarcely-infected areas (or as a best-effort measure, when test availability was low). Pool testing has been successfully used to identify viral diseases, such as HIV [NABB19] , ZIKA [BMBM17] , and INFLUENZA [VMW + 12]. In addition, Pool testing has been suggested as a screening method for routine HCV, HBV, and HIV -1 PCR donors for a blood-bank [RWS99] . In light of the recent pandemic and the urging need to test vast number of subjects, the idea of Pool testing is becoming more and more appealing.",
            "cite_spans": [
                {
                    "start": 248,
                    "end": 256,
                    "text": "[NABB19]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 264,
                    "end": 272,
                    "text": "[BMBM17]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 429,
                    "end": 436,
                    "text": "[RWS99]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Related Research"
        },
        {
            "text": "It is currently the official testing procedure in Israel [BAKS + 20], Germany, South Korea [Cw20] , and some US 5 [Haa20] and Indian 6 states 7 [Tod20]. Field research focusing on reducing the number of tests [FTO + 20, AWD20, GG20] did not analyse prior information strategies but instead provided simulation (or small sample) results showing the benefits of pool testing. In most cases, the existing literature only uses pooling as a way to screen the infection in an emerging context, not as a precise approach to identify which individuals are infected and which are not.",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 97,
                    "text": "[Cw20]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Related Research"
        },
        {
            "text": "We also note projects meant to reduce the amount of work required for pool testing: e.g. the Origami Assays [Woo20] Project, a collection of open source pool testing designs for standard 96 well plates. The Origami XL3 design tests 1120 patients in 94 assay wells.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Research"
        },
        {
            "text": "Yelin et al.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Research"
        },
        {
            "text": "[YAST + 20] demonstrated that pool testing can be used effectively to identify one positive SARS-COV-2 result within 32 samples, and possibly within 64 samples if the cycles are amplified, with an estimated false-negative rate of 10%. [T\u00e4u20] uses a strategy consisting in running 'cross batches', where the same individuals are tested several times but in different pools, which eventually leads to positive sample identification. The resulting approach ends up using more tests overall (since it tests every individual more than once) than the strategy proposed in this work and does not exploit prior information. Similarly, Sinnott-Armstrong et al. [SAKH20] suggested to identify low-risk individuals (i.e. asymptomatic and mild cases) and to test them as a pool using a matrix-based method, so as to reduce the number of tests required by up to eight-fold, depending on the prevalence.",
            "cite_spans": [
                {
                    "start": 235,
                    "end": 242,
                    "text": "[T\u00e4u20]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 653,
                    "end": 661,
                    "text": "[SAKH20]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Related Research"
        },
        {
            "text": "It is hence plausible to assume that a successful emergency application of the refined pool testing procedures described in this paper would improve the COVID-19 testing capacity significantly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Related Research"
        },
        {
            "text": "This paper departs from the above approaches by assuming the availability of extra information: the a priori probability that each given test is negative. In practice, we may either assume that such probabilities are given, estimated from patient trust metrics, or are learned from past COVID-19 tests. We assume in this work that these probabilities are known.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Our Contribution"
        },
        {
            "text": "We show that it is possible to find positive samples in an optimal way, i.e., by performing on average the minimum number of tests. This turns out to be faster than blind divide-and-conquer testing in the vast majority of settings.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Our Contribution"
        },
        {
            "text": "A concrete consequence of this research is the design of testing procedures that are faster and more cost-effective.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Our Contribution"
        },
        {
            "text": "Before introducing models and general formulae, let us provide the intuition behind our algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "Let us begin by considering the very small case of two samples. These can be tested individually or together, in a pool. Individual COVID-19 testing claims a minimum two units of work-check one sample, then check the other. Pool-checking them requires a minimum of one COVID-19 test. If it is highly probable that both samples are negative, then pool testing is interesting: If both samples are indeed negative, we can make a conclusion after one test and halve the COVID-19 test's cost. However, if that fails, we are nearly back to square one: One of these samples (at least) is positive, and we don't know which one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "In this paper, we identify when to check samples individually, and when to pool-check them insteadincluding all possible generalizations when there are more than 2 samples. We assume that the probability of a sample being positive is known to us in advance. The result is a testing 'metaprocedure' that offers the best alternative to sequential and individual testing.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "To demonstrate: the testing procedure that always works is to test every sample individually, one after the other: This gives the 'naive procedure', which always performs 2 COVID-19 tests, as illustrated in Figure 1 . In this representation, the numbers in parentheses indicate which samples are being tested at any given point. The leaves indicate which samples are negative (denoted 1) or positive (denoted 0), for instance the leaf 01 indicates that only the second sample is healthy. Note that the order in which each element is tested does not matter: There are thus 2 equivalent naive procedures, namely the one represented in Figure 1 , and the procedure obtained by switching the testing order of (1) and (2).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 207,
                    "end": 215,
                    "text": "Figure 1",
                    "ref_id": null
                },
                {
                    "start": 633,
                    "end": 641,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Intuition"
        },
        {
            "text": "Alternatively, we can leverage the possibility to test both samples together as the set {1, 2}. In this case, pooling the pair {1, 2} must be the first step: Indeed, testing {1, 2} after any other test would be redundant, and the definition of testing procedures prevents this from happening. If the test on {1, 2} is negative, both samples are negative and the procedure immediately yields the outcome 11. Otherwise, we must identify which of the samples 1 or 2 (or both) is responsible for the test's positiveness. There are thus two possible procedures, illustrated in Figure 2 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 572,
                    "end": 580,
                    "text": "Figure 2",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Intuition"
        },
        {
            "text": "Intuitively, the possibility that this procedure terminates early indicates that, in some situations at least, only one test is performed, and is thus less costly than the naive procedure. However, in some situations up to three tests can be performed, in which case it is more costly than the naive procedure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "(1)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "(2) 00 01",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "(2) 10 11 Figure 1 . The \"naive procedure\" for n = 2 consists in testing each entity separately and sequentially.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 10,
                    "end": 18,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Intuition"
        },
        {
            "text": "(1,2)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "(1)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "(2) Concretely, we can compute how many COVID-19 tests are performed on average by each approach, depending on the probability x 1 that the first sample is positive, and x 2 that the second is positive. To each procedure, naive, pool-left, pool-right, we associate the following polynomials representing the expected stopping time:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "It is possible to see analytically which of these polynomials evaluates to the smallest value as a function of (x 1 , x 2 ). Looking at Figure 3 , we use these expectations to define zones in [0, 1] 2 where each algorithm is optimal (i.e. the fastest on average). More precisely, the frontier between zones C and B has equation x 1 = x 2 , the frontier between A and B has equation x 2 = (x 1 \u2212 1)/(x 1 \u2212 2), the frontier between A and C has equation x 2 = (2x 1 \u2212 1)/(x 1 \u2212 1), and the three zones meet at x 1 = x 2 = (3 \u2212 \u221a 5)/2, a well-known cutoff value observed as early as 1960 [Ung60] . Having identified the zones, we can write an algorithm which, given x 1 and x 2 , identifies in which zone of Figure 3 (x 1 , x 2 ) lies, and then apply the corresponding optimal testing sequence. In the specific case illustrated above, three algorithms out of three were needed to define the zones; however, for any larger scenario, we will see that only a very small portion of the potential algorithms will be carefully selected.",
            "cite_spans": [
                {
                    "start": 584,
                    "end": 591,
                    "text": "[Ung60]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [
                {
                    "start": 136,
                    "end": 144,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 704,
                    "end": 712,
                    "text": "Figure 3",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Intuition"
        },
        {
            "text": "Our objective is to determine the zones, and the corresponding testing algorithms, for arbitrary n, so as to identify which samples in a set are negative and which are not, while minimizing the expected number of testing operations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Intuition"
        },
        {
            "text": "This section will formalize the notion of a testing procedure, and the cost thereof, so that the problem at hand can be mathematically described. We aim at the greatest generality, which leads us to introduce 'and-tests', a special case of which are samples that can be pool tested.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We consider a collection of n samples. Let [n] denote {1, . . . , n}, and \u2126 = P([n])\\{ / 0}, where P is the power set (ie. P(X) is the set of subsets of X).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Testing procedures"
        },
        {
            "text": "A test is a function \u03c6 : \u2126 \u2192 {0, 1}, that associates a bit to each subset of \u2126 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "We focus in this work on the following:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Definition 2 (And-Tests). An and-test \u03c6 : \u2126 \u2192 {0, 1} is a test satisfying the following property:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "In other terms, the result of an and-test on a set is exactly the logical and of the test results on individual members of that set.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Remark 1. Note that 'or-tests', where \u2227 is replaced by \u2228 in the definition, are exactly dual to our setting. 'xor-tests' can be defined as well but are not investigated here. Although theoretically interesting by their own right, we do not address the situation where both and-tests and or-tests are available, since we know of no concrete application where this is the case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Elements of \u2126 can be interpreted as n-bit strings, with the natural interpretation where the i-th bit indicates whether i belongs to the subset. We call selection an element of \u2126 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Definition 3 (Outcome). The outcome F \u03c6 (T ) of a test \u03c6 on T \u2208 \u2126 is the string of individual test results:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Our purpose is to determine the outcome of a given test \u03c6 , by minimizing in the expected number of queries to \u03c6 . Note that this minimal expectation is trivially upper bounded by n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Definition 4 (Splitting). Let T \u2208 \u2126 be a selection and \u03c6 be a test. Let S be a subset of \u2126 . The positive part of S with respect to T , denoted S T , is defined as the set",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "where the operation \u2227 is performed element-wise. This splits S into two. Similarly the complement S \u22a5 T = S \u2212 S T is called the negative part of S with respect to T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "We are interested in algorithms that find F \u03c6 . More precisely, we focus our attention on the following:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "Definition 5 (Testing procedure). A testing procedure is a binary tree T with labeled nodes and leaves, such that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "1. The leaves of T are in one-to-one correspondence with \u2126 in string representation; 2. Each node of T which is not a leaf has exactly two children, (S \u22a5 , S ), and is labeled (S, T ) where S \u2286 \u2126 and T \u2208 \u2126 , such that (a) S \u22a5 \u2229 S = / 0 (b) S \u22a5 S = S (c) S \u22a5 = S \u22a5 T and S = S T . Remark 2. It follows from the definition 5 that a testing procedure is always a finite binary tree, and that no useless calls to \u03c6 are performed. Indeed, doing so would result in an empty S for one of the children nodes. Furthermore, the root node has S = \u2126 . Consider a testing procedure T , defined as above. T describes the following algorithm. At each node (S, T ), perform the test \u03c6 on the selection T of samples. If \u03c6 (T ) = 0, go to the left child; otherwise go to the right child. Note that at each node of a testing procedure, only one invocation of \u03c6 is performed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Test)."
        },
        {
            "text": "The tree is finite and thus this algorithm reaches a leaf S final in a finite number of steps. By design,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interpreting and representing pooling procedures"
        },
        {
            "text": "Remark 3. From now on, we will fix \u03c6 and assume it implicitly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interpreting and representing pooling procedures"
        },
        {
            "text": "Remark 4. We represent a testing procedure graphically as follows: Nodes (in black) are labeled with T , whereas leaves (in blue) are labeled with S written as a binary string. This is illustrated in Figure 4 for n = 3.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 200,
                    "end": 208,
                    "text": "Figure 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Interpreting and representing pooling procedures"
        },
        {
            "text": "This representation makes it easy to understand how the algorithm unfolds and what are the outcomes: Starting from the root, each node tells us which entity is tested. If the test is positive, the right branch is taken, otherwise the left branch is taken. Leaves indicate which samples tested positive and which samples tested negative from now on.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interpreting and representing pooling procedures"
        },
        {
            "text": "Remark 5. The successive steps of a testing procedure can be seen as imposing new logical constraints. These constraints ought to be satisfiable (otherwise one set S is empty in the tree, which cannot happen). The formula at a leaf is maximal in the sense that any additional constraint would make the formula unsatisfiable. This alternative description in terms of satisfiability of Boolean clauses is in fact strictly equivalent to the one that we gave.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interpreting and representing pooling procedures"
        },
        {
            "text": "In that case, T is understood as a conjunction T [i]=1 t i , S is a proposition formed by a combination of terms t i , connectors \u2228 and \u2227, and possibly \u00ac. The root has S = . The left child of a node labeled (T, S) is labeled S \u22a5 T = S \u2227 (\u00acT ); while the right child is labeled S T = S \u2227 T . At each node and leaf, S must be satisfiable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interpreting and representing pooling procedures"
        },
        {
            "text": "To determine how efficient any given testing procedure is, we need to introduce a probability measure, and a metric that counts how many calls to \u03c6 are performed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "We consider the discrete probability space (\u2126 , Pr). The expected value of a random variable X is classically defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "Let T a testing procedure, and let S \u2208 \u2126 be one of its leaves. The length T (S) of T over S is the distance on the tree from the root of T to the leaf S. This corresponds to the number of tests required to find S if S is the outcome of \u03c6 . The expected length of a testing procedure T is defined naturally as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "It remains to specify the probabilities Pr(\u03c9), i.e. for any given binary string \u03c9, the probability that \u03c9 is the outcome.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "If the different tests are independent, we can answer this question directly with the following result:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "Then, \u2200\u03c9 \u2208 \u2126 , Pr(\u03c9) can be written as a product of monomials of degree 1 in x 1 , . . . , x n , where",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "Thus L T is a multivariate polynomial of degree n with integer coefficients.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "In fact, or-tests provide inherently independent tests. Therefore we will safely assume that the independence assumption holds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "Example 1. Let n = 5 and \u03c9 = 11101, then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "Remark 6. L T is uniquely determined as a polynomial by the integer vector of length 2 n defined by all its lengths: (T ) = ( T (0...0), . . . , T (1...1)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Probabilities on trees"
        },
        {
            "text": "We have now introduced everything necessary to state our goal mathematically. Our objective is to identify the best performing testing procedure T (i.e. having the smallest L T ) in a given situation, i.e. knowing Pr(\u03c9) for all \u03c9 \u2208 \u2126 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Optimal pool tests"
        },
        {
            "text": "We can now explain how to generate all the testing procedures for a given n \u2265 2. One straightforward method is to implement a generation algorithm based on the definition of a testing procedure. Algorithm 1 does so recursively by using a coroutine. The complete list of testing procedures is recovered by calling FindProcedure(\u2126 , \u2126 \\ { / 0}).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generating all procedures"
        },
        {
            "text": "Input: S \u2208 \u2126 , C \u2208 \u2126 . Output: A binary tree.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: FindProcedure"
        },
        {
            "text": "We implemented this algorithm (in Python, source code available upon request). The result of testing procedure generations for small values of n is summarized in Table 1 . The number of possible testing procedures grows very quickly with n. An informal description of Algorithm 1 is the following. Assuming that you have an unfinished procedure (i.e. nodes at the end of branches are not all leaves). For those nodes S, compute for each T the sets S T and S \u22a5 T . If either is empty, abort. Otherwise, create a new (unfinished) procedure, and launch recursively on nodes (not on leaves, which are such that S has size 1).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 162,
                    "end": 169,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Algorithm 1: FindProcedure"
        },
        {
            "text": "Algorithm 1 terminates because it only calls itself with strictly smaller arguments. We will discuss this algorithm further after describing some properties of the problem at hand.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1: FindProcedure"
        },
        {
            "text": "Once the optimality zones, and the corresponding testing procedures, have been identified, it is easy to write an algorithm which calls the best testing procedure in every scenario. At first sight, it may seem that nothing is gained from doing so -but as it turns out that only a handful of procedures need to be implemented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "This construction is captured by the following definition:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "Definition 6 (Metaprocedure). A metaprocedure M is a collection of pairs (Z i , T i ) such that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "1. Z i \u2286 [0, 1] n , Z i \u2229 Z j = / 0 whenever i = j and i Z i = [0, 1] n . 2. T i is a testing procedure and for any testing procedure T ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "A metaprocedure is interpreted as follows: Given x \u2208 [0, 1] n find the unique Z i that contains x and run the corresponding testing procedure T i . We extend the notion of expected length accordingly:L M = min i L T i \u2264 n.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "One way to find the metaprocedure for n, is to enumerate all the testing procedures using Algorithm 1, compute all expected lengths L T from the tree structure, and solve polynomial inequalities.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "Surprisingly, a vast majority of the procedures generated are nowhere optimal: This is illustrated in Table 2 . Furthermore, amongst the remaining procedures, there is a high level of symmetry. For instance, in the case n = 3, 8 procedures appear 6 times, 1 a procedure appears 3 times, and 1 procedure appears once. The only difference between the occurrences of these procedures -which explains why we count them several times -is the action of the symmetric group S 6 on the cube (see Appendix B for a complete description).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 102,
                    "end": 109,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Metaprocedures"
        },
        {
            "text": "The metaprocedure for n = 3 cuts the unit cube into 52 zones, which correspond to a highly symmetric and intricate partition, as illustrated in Figures 5, 6, and 7. An STL model was constructed and is available upon request. The large number of suboptimal procedures shows that the generate-then-eliminate approach quickly runs out of steam: Generating all procedures for n = 6 seems out of reach with Algorithm 1 8 . The number of zones, which corresponds to the number of procedures that are optimal in some situation, is on the contrary very reasonable. Proof. By induction on n: There are (n + 1) choices of a root node, P(n) choices for the left child, and P(n) choices for the right child. This gives the recurrence P(n + 1) = (n + 1)P(n) 2 , hence the result.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 144,
                    "end": 161,
                    "text": "Figures 5, 6, and",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Metaprocedures"
        },
        {
            "text": "This number grows rapidly and constitutes a lower bound for the total number of procedures (e.g. for n = 8 we have P(n) > 2 184 ). On the other hand, the naive procedure is the one with maximal multiplicity, which yields a crude upper bound C 2 k P(n) on the number of procedures, where C t is the t-th Catalan number defined by:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Metaprocedures"
        },
        {
            "text": "The zones can be determined by sampling precisely enough the probability space. Simple arguments about the regularity of polynomials guarantee that this procedure succeeds, when working with infinite numerical precision. In practice, although working with infinite precision is feasible (using rationals), we opted for floating-point numbers, which are faster. The consequence is that sometimes this lack of precision results in incorrect results on the zone borders -however this is easily improved by increasing the precision or checking manually that there is no sub-zone near the borders. 1  1  1  2  4  3  3  312  52  4  36585024  181  5 8.926 \u00b7 10 20 ? 6 2.242 \u00b7 10 55 ? Table 2 . Procedures and metaprocedures for some values of n. The number of zones for n = 5 and 6 cannot be determined in a reasonable time with the generate-then-eliminate approach.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 593,
                    "end": 642,
                    "text": "1  1  1  2  4  3  3  312  52  4  36585024  181  5",
                    "ref_id": "TABREF0"
                },
                {
                    "start": 677,
                    "end": 684,
                    "text": "Table 2",
                    "ref_id": null
                }
            ],
            "section": "Metaprocedures"
        },
        {
            "text": "We now focus on some of the properties exhibited by testing procedures, which allows a better understanding of the problem and interesting optimizations. This in effect can be used to prune early the generation of procedures, and write them in a more compact way by leveraging symmetries. We consider in this section a testing procedure T . Proof. First notice that for all T , T , and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "T . We will denote both by S bb T T . We have the following : If there exists k, T 1 , . . . , T k , and \u03b2 1 , . . . , \u03b2 k such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "(\u2126 )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Remark 7. Proposition 3 indicates that testing procedures are, in general, unbalanced binary trees: The only balanced procedure being the naive one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Lemma 4. If N is the naive procedure, then for any testing procedure T and for all x 1 , . . . , x n such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "In other terms {\u2200i \u2208 [n], 1 2 \u2264 x i \u2264 1} is contained in the naive procedure's optimality zone.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Proof. An immediate corollary of Proposition 3 is that for all i \u2208 [n], we have \u2202 x i L T (x 1 , . . . , x n ) \u2265 0, where \u2202 x i indicates the derivative with respect to the variable x i . Since the native procedure has a constant length, it suffices to show that it is optimal at the point { 1 2 , . . . , 1 2 }. Evaluating the length polynomials at this point gives",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Now remember that the naive procedure gives the only perfect tree. It suffices to show that unbalancing this tree in any way results in a longer sum in the equation above. Indeed, to unbalance the tree one needs to: -Remove two bottom-level leaves, turning their root node into a leaf -Turn one bottom-level leaf into a node -Attach two nodes to this newly-created leaf",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "The total impact on the sum of lengths is +1. Hence the naive algorithm is minimal at { 1 2 , . . . , 1 2 }, and therefore, in the region {\u2200i \u2208 [n], 1 2 \u2264 x i \u2264 1}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Remark 8. This also show that if we assume that the probabilities are supposed uniform (ie. we assume no a priori knowledge) the optimal procedure is the naive one. Therefore we can see that the gain for n = 3 is aprroximately 0, 34 since the optimal procedure in average gives 2, 66. In percentage the gain is 15%. If the probabilites are very low we have a gain of almost 2 which is 3 times faster. As expected it is much more interesting if we think that the samples have a good chance to be negative, which is the case in most real life scenarii.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Lemma 5. If the root has a test of cardinality one, then the same algorithms starting at both sons have same expected stopping time. This applies if the next test is also of cardinal one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Proof. Without loss of generality we can assume that the test is {1}. We have {0, 1} n {1} = {0b 2 \u00b7 \u00b7 \u00b7 b n |b 2 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n\u22121 } and {0, 1} n \u22a5 {1} = {1b 2 \u00b7 \u00b7 \u00b7 b n |b 2 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n\u22121 }. A test T that doesn't test 1 applied on those sets will give the same split for both, and the probability that the test answers yes or no is the same. This is also true for the sets and the tests T such that i is not in T for i in {1, . . . , k}. {0 k b 2 \u00b7 \u00b7 \u00b7 b n |b 2 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n\u2212k } and {01 k b 2 \u00b7 \u00b7 \u00b7 b n |b 2 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n\u2212k }. A test T such that there exists i in T {1, . . . , k} brings no information for the set of possibilities {01 k b 2 \u00b7 \u00b7 \u00b7 b n |b 2 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n\u2212k }, but testing this i is useless for the set {0 k b 2 \u00b7 \u00b7 \u00b7 b n |b 2 \u00b7 \u00b7 \u00b7 b n \u2208 {0, 1} n\u2212k }. So we can apply the test T \u2212 {1, . . . , k}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Corollary 1. If the root has a test of cardinal one, then an optimal algorithm can always apply the same test for the right and left child. If this test is also of cardinal one then the property is still true.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "This result helps in identifying redundant descriptions of testing procedures, and can be used to narrow down the generation, by skipping over obvious symmetries of the naive procedure (see Figure 8 ). To further accelerate generation we can only keep one representative of each algorithms that have the same expected length for all x i . Lemma 6. If a node labeled T 1 has two children that are both labeled T 2 , then we can interchange T 1 and T 2 without changing the testing procedure's expected length.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 190,
                    "end": 198,
                    "text": "Figure 8",
                    "ref_id": "FIGREF10"
                }
            ],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Yet another simple observation allows to reduce the set of subsets T at each step:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Lemma 7. Consider a node labeled (T, S ). Assume that there is i \u2208 [n] such that, for all S in S , i / \u2208 S. Then we can replace T by T \u222a {i}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Proof. We can easily see that S T = S T \u222a{i} and S \u22a5 T = S \u22a5 T \u222a{i} .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Finally we can leverage the fact that the solutions exhibit symmetries, which provides both a compact encoding of testing procedures, and an appreciable reduction in problem size.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Lemma 8. Let \u03c3 \u2208 S n be a permutation on n elements. If we apply \u03c3 to each node and leaf of T , which we can write \u03c3 (T ), then L \u03c3 (T ) (x 1 , . . . , x n ) = L T (\u03c3 (x 1 , . . . , x n )) .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Proof. Note that for any S \u2208 \u2126 and T \u2208 \u2126 \\ { / 0} we have \u03c3 S T = S \u03c3 (T ) and \u03c3 S \u22a5 T = S \u22a5 \u03c3 (T ) , where \u03c3 operates on each binary string. It follows that for any leaf S, T (S) becomes T (\u03c3 (S)) under the action of \u03c3 , hence the result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Lemma 9. Let S be a simplex of the hypercube, T a procedure, E = {\u03c3 (T )|\u03c3 \u2208 S n }, then there exists T 0 in E, such that for all x in S, T 1 in E we have",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Moreover we have for all \u03c3 in S n , x in \u03c3 (S),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "Remark 9. The last two propositions allow us to solve the problem on a simplex of the hypercube (of volume 1/n!) such as {p 1 , . . . , p n | 1 \u2265 p 1 \u00b7 \u00b7 \u00b7 \u2265 p n \u2265 0}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Pruning the generation tree"
        },
        {
            "text": "We examine the following problem: Find the testing procedure T for a given k \u2264 n, (p i 1 , . . . , p i k ) \u2208 [0, 1] n , and a selection P \u2286 2 [k] that satisfies:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "This can be computed using a dynamic programming technique, by examining the outcome of each possible test that is the root node of the testing procedure T , which gives Algorithm 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "The same dynamic programming algorithm can also be used to compute the number of testing procedures (including those leading to duplicate polynomials) that exist in a given dimension. It is actually even easier, since there is a huge number of symmetries that can be exploited to count. 9",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "Definition 7 (Decided point). We say that x is a decided point for S a set of selections if either of the following is true:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "In the first case, we will say that x is a positive decided point, and a negative decided point in the second case.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "We denote by D + S the set of positive decided points of S , D \u2212 S its set of negative decided points, and D S = D + S \u222a D \u2212 S its set of decided points.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "Algorithm 2: FindOptimal",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "Output: The optimal testing procedure T at point (p 1 , . . . , p k ) which satisfies S T = S .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "1. if k == 0 then return the naive algorithm 2. if |D S | > 0 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "R \u2190 {{r 1 , . . . , r p } | {u r 1 , . . . , u r p } \u222a D + S } 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "T \u2190 FindOptimal ( , (p u 1 , . . . , p u ), R) 6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "replace {t 1 , . . . ,t r } by {u t 1 , . . . , u t r } in T 7.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "replace { 1 , . . . , r } by {u 1 , . . . , u r } \u222a D + S in T 8. else 9 Indeed, we can apply the algorithm to an even higher dimension than our solution to the given point problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Best testing procedure at a point"
        },
        {
            "text": "if S \u22a5 = / 0 or S = / 0 then continue 14.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "T \u22a5 \u2190 FindOptimal(k, (p 1 , . . . , p k ), S \u22a5 ) 15.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "T \u2190 FindOptimal(k, (p 1 , . . . , p k ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 2,
                    "end": 37,
                    "text": "\u2190 FindOptimal(k, (p 1 , . . . , p k",
                    "ref_id": null
                }
            ],
            "section": "9."
        },
        {
            "text": "return the best algorithm in W at point (p 1 , . . . , p n )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "Counting the number of algorithms in a given dimension works the same way; the only difference is that there is no need to look at the probabilities, and thus, the resulting Algorithm 3 does fewer recursive calls and is faster. 10",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "Algorithm 3: CountAlgorithms",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "Output: The number of testing procedures which satisfy S T = S .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "c \u2190 CountAlgorithms(k, (p 1 , . . . , p k ), S ) 13.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "9."
        },
        {
            "text": "c \u2190 c + c c \u22a5 14. return c 7 Enumerating procedures for n = 3 All the procedures for n = 3 that are optimal at some point, up to symmetries, are represented in Figure 9 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 160,
                    "end": 168,
                    "text": "Figure 9",
                    "ref_id": "FIGREF11"
                }
            ],
            "section": "9."
        },
        {
            "text": "We have introduced the question of optimal pool testing with a priori probabilities, where one is given a set of samples and must determine in the least average number of operations which samples are negative, and which are not. We formalized this problem and pointed out several interesting combinatorial and algebraic properties that speed up the computation of an optimal sequence of operations -which we call a metaprocedure. We determined the exact solution for up to 4 samples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion and open questions"
        },
        {
            "text": "For larger values, our approach requires too many computation to be tractable, and thus an exact solution is out of reach; however we gave several heuristic algorithms that scale well. We showed that these heuristics are sub-optimal in all cases, but they always do better than standard screening. The existence of a polynomial-time algorithm that finds optimal metaprocedures for large value of n is an open question -although there is probably more hope in finding better heuristics. An alternative would be to modify our generation algorithm to kill branches when the resulting expected lengths are all worse than some already-known procedure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion and open questions"
        },
        {
            "text": "Once the metaprocedure for a given n is known, which only needs to be computed once, implementation is straightforward and only invokes a handful of (automatically generated) cases. 10 We are not aware of a closed-form formula providing the same values as this algorithm. Finally, in our model we do not consider false positives and false negatives. In other words, tests are assumed to be 100% accurate. Integrating in the model false positive and false negative probabilities is an interesting research challenge.",
            "cite_spans": [
                {
                    "start": 182,
                    "end": 184,
                    "text": "10",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Conclusion and open questions"
        },
        {
            "text": "Besides the performance gain resulting from implementing metaprocedures for sample testing, the very general framework allows for applications in medical and engineering tests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion and open questions"
        },
        {
            "text": "The approach consisting in generating many candidates, only to select a few, is wasteful. In fact, for large values of n (even from 10), generating all the candidates is beyond reach, despite the optimizations we described.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Approximation heuristics"
        },
        {
            "text": "Instead, one would like to obtain the optimal testing procedure directly. It is a somewhat simpler problem, and we can find the solution by improving on our generation-then-selection algorithm (see Appendix 6). However if we wish to address larger values of n, we must relax the constraints and use the heuristic algorithms described below, which achieve near-optimal results. This would be usefull in real life scenarii for COVID-19 tests since we would like to test hundreds or more samples to have real gain.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Approximation heuristics"
        },
        {
            "text": "We first associate a 'cost' to each outcome S, and set of outcomes S : Intuitively, we give higher gains to subsets T on which testing gives more information. Note that, if a call to \u03c6 doesn't give any information (i.e. S T or S \u22a5 T is empty), then gain(T, S) = 0. This heuristic provides us with a greedy algorithm that is straightforward to implement. For given values x 1 , . . . , x n we thus obtain a testing procedure T H .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "Testing the heuristic. We compared numerically T H to the metaprocedure found by exhaustion in the case n = 3. The comparison consists in sampling points at random, and computing the sample mean of each algorithm's length on this input. The heuristic procedure gives a mean of 2.666, which underperform the optimal procedure (2.661) by only 1%.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "Counter-example to optimality. In some cases, the heuristic procedure behaves very differently from the metaprocedure. For instance, for n = 3, x 1 = 0.01, x 2 = 0.17, x 3 = 0.51, the metaprocedure yields a tree which has an expected length of 1.889. The heuristic however produces a tree which has expected length 1.96. Both trees are represented in Figure 10 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 351,
                    "end": 360,
                    "text": "Figure 10",
                    "ref_id": "FIGREF15"
                }
            ],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "Beyond their different lengths, the main difference between the two procedures of Figure 10 begin at the third node. At that node the set S is the same, namely To understand this difference, first notice that besides 010 and 011, all leaves are associated to a very low probability. The heuristic fails to capture that by choosing T = {1, 3} early, it could later rule out the leaf 010 in one step and 011 in two. There does not seem to be a simple greedy way to detect this early on. (1,2,3)",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 82,
                    "end": 91,
                    "text": "Figure 10",
                    "ref_id": "FIGREF15"
                }
            ],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "(1,2)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "(1)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "(3) The optimal procedure has expected length 1.889, as compared to 1.96 for the heuristic procedure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.1 Information-Based Heuristic"
        },
        {
            "text": "Another approach is to use small metaprocedures on subsets of the complete problem. Concretely, given n samples to test, place them at random into k-tuples (from some small value k, e.g. 5). Then apply the k-metaprocedure on these tuples. While sub-optimal, this approach does not yield worst results than the naive procedure.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "In cases where it makes sense to assume that all the x i are equal, then we may even recursively use the metaprocedures, i.e. the metaprocedures to be run are themselves places into k-tuples, etc. Using lazy evaluation, only the necessary tests are performed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "B Equivalences and symmetries for n = 3 A procedure can undergo a transformation that leaves its expected length unchanged. Such transformations are called equivalences. On the other hand, Lemma 8 shows that some transformations operate a permutation \u03c3 on the variables x i -such transformations are called symmetries.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "Equivalences and symmetries are responsible for a large part of the combinatorial explosion observed when generating all procedures. By focusing on procedures up to symmetry, we can thus describe the complete set in a more compact way and attempt a first classification.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "In the following representations (Figures 11, 12 , and 13), blue indicates a fixed part, and red indicate a part undergoing some permutation. Double-headed arrows indicate that swapping nodes is possible. The number of symmetries obtained by such an operation is indicated under the curly brace below. Figure 11 . Trees representation with a grouping by one element on the root. For a fixed element, we have 2 2 possible permutations. Since we have 4 patterns, we get 2 2 \u00d7 4 possible permutations for one grouping. Hence, we finally have 2 2 \u00d7 4 \u00d7 3 for all possible groupings by one element.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 33,
                    "end": 48,
                    "text": "(Figures 11, 12",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 302,
                    "end": 311,
                    "text": "Figure 11",
                    "ref_id": null
                }
            ],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "(1,2)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "(1) Figure 12 . Tree representations with a grouping by two elements on the root. For 10 fixed elements, we have 2 possible permutations, for 2 fixed elements, we have 2 possible permutations, and for 2 possible permutations, we have 6 possible permutations. Hence, we finally have 2 \u00d7 10 + 4 \u00d7 2 + 6 \u00d7 2 for all possible groupings by two elements.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 4,
                    "end": 13,
                    "text": "Figure 12",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "(1,2,3)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "(1)(2)(3) (1,2,3)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A.2 Pairing heuristic"
        },
        {
            "text": "All permutations with g = 2 (3) Figure 13 . Trees representation with a grouping by three elements on the root. For a fixed element at the upper left corner side, we have 2 2 possible permutations. For the upper right corner side, we get 2 2 . We replace the subroot of the fixed trees and get (2 2 + 2 2 ) \u00d7 3. We also have the 40 \u00d7 3 trees from the grouping of two (g = 2). Hence, we have 40 \u00d7 3 + (2 2 + 2 2 ) \u00d7 3",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 32,
                    "end": 41,
                    "text": "Figure 13",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "A.2 Pairing heuristic"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Group testing: an information theory perspective",
            "authors": [
                {
                    "first": "Matthew",
                    "middle": [],
                    "last": "Aldridge",
                    "suffix": ""
                },
                {
                    "first": "Oliver",
                    "middle": [],
                    "last": "Johnson",
                    "suffix": ""
                },
                {
                    "first": "Jonathan",
                    "middle": [],
                    "last": "Scarlett",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A Comprehensive Strategy to Lower Number of COVID-19 Tests",
            "authors": [
                {
                    "first": "Assif",
                    "middle": [],
                    "last": "Assad",
                    "suffix": ""
                },
                {
                    "first": "Ahmad",
                    "middle": [],
                    "last": "Muzafar",
                    "suffix": ""
                },
                {
                    "first": "Kusum",
                    "middle": [],
                    "last": "Wani",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Deep",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Maayan Salton, and Yotam Drier. Pooled rna extraction and pcr assay for efficient sars-cov-2 detection. medRxiv",
            "authors": [
                {
                    "first": "Agnes",
                    "middle": [],
                    "last": "Baks + 20. Roni Ben-Ami",
                    "suffix": ""
                },
                {
                    "first": "Matan",
                    "middle": [],
                    "last": "Klochendler",
                    "suffix": ""
                },
                {
                    "first": "Tal",
                    "middle": [],
                    "last": "Seidel",
                    "suffix": ""
                },
                {
                    "first": "Ori",
                    "middle": [],
                    "last": "Sido",
                    "suffix": ""
                },
                {
                    "first": "Moran",
                    "middle": [],
                    "last": "Gurel-Gurevich",
                    "suffix": ""
                },
                {
                    "first": "Eran",
                    "middle": [],
                    "last": "Yassour",
                    "suffix": ""
                },
                {
                    "first": "Gil",
                    "middle": [],
                    "last": "Meshorer",
                    "suffix": ""
                },
                {
                    "first": "Irit",
                    "middle": [],
                    "last": "Benedek",
                    "suffix": ""
                },
                {
                    "first": "Esther",
                    "middle": [],
                    "last": "Fogel",
                    "suffix": ""
                },
                {
                    "first": "Asaf",
                    "middle": [],
                    "last": "Oiknine-Djian",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Gertler",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "The unprecedented stock market reaction to COVID-19",
            "authors": [
                {
                    "first": "",
                    "middle": [
                        "Scott"
                    ],
                    "last": "Bbd + 20",
                    "suffix": ""
                },
                {
                    "first": "Nicholas",
                    "middle": [],
                    "last": "Baker",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Bloom",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Steven",
                    "suffix": ""
                },
                {
                    "first": "Kyle",
                    "middle": [],
                    "last": "Davis",
                    "suffix": ""
                },
                {
                    "first": "Marco",
                    "middle": [],
                    "last": "Kost",
                    "suffix": ""
                },
                {
                    "first": "Tasaneeya",
                    "middle": [],
                    "last": "Sammon",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Viratyosin",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "COVID Economics: Vetted and Real-Time Papers",
            "volume": "1",
            "issn": "3",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "CNN Investigates: Coroners worry COVID-19 test shortages could lead to uncounted deaths",
            "authors": [
                {
                    "first": "Melanie",
                    "middle": [
                        "Hicken"
                    ],
                    "last": "",
                    "suffix": ""
                },
                {
                    "first": "Blake",
                    "middle": [],
                    "last": "Ellis",
                    "suffix": ""
                },
                {
                    "first": "Ashley",
                    "middle": [],
                    "last": "Fantz",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Zika virus and blood transfusion: the experience of french polynesia",
            "authors": [
                {
                    "first": "Damien",
                    "middle": [],
                    "last": "Bierlaire",
                    "suffix": ""
                },
                {
                    "first": "Sylvie",
                    "middle": [],
                    "last": "Mauguin",
                    "suffix": ""
                },
                {
                    "first": "Julien",
                    "middle": [],
                    "last": "Broult",
                    "suffix": ""
                },
                {
                    "first": "Didier",
                    "middle": [],
                    "last": "Musso",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "2017. boo93. Combinatorial group testing and its applications",
            "volume": "57",
            "issn": "",
            "pages": "729--733",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Verified 'sample pooling' introduced to prevent herd infection in S",
            "authors": [
                {
                    "first": "Lim",
                    "middle": [],
                    "last": "Chang-Won",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "FA20. Food and Drug Administration. Coronavirus (COVID-19) Update: serological test validation and education efforts",
            "authors": [
                {
                    "first": "Robert",
                    "middle": [],
                    "last": "Dorfman",
                    "suffix": ""
                }
            ],
            "year": 1943,
            "venue": "The Annals of Mathematical Statistics",
            "volume": "14",
            "issn": "4",
            "pages": "436--440",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Optimizing RT-PCR detection of SARS-COV-2 for developing countries using pool testing. medRxiv, 2020. GG20. Christian Gollier and Olivier Gossner",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Fto + 20",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Mauricio",
                    "suffix": ""
                },
                {
                    "first": "Juan",
                    "middle": [
                        "P"
                    ],
                    "last": "Farfan",
                    "suffix": ""
                },
                {
                    "first": "Miguel",
                    "middle": [],
                    "last": "Torres",
                    "suffix": ""
                },
                {
                    "first": "Mauricio",
                    "middle": [],
                    "last": "Oryan",
                    "suffix": ""
                },
                {
                    "first": "Pablo",
                    "middle": [],
                    "last": "Olivares",
                    "suffix": ""
                },
                {
                    "first": "Carolina",
                    "middle": [],
                    "last": "Gallardo",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Salas",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "COVID Economics",
            "volume": "1",
            "issn": "2",
            "pages": "32--42",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Ricketts provides update on coronavirus testing -3KMTV",
            "authors": [
                {
                    "first": "Matthew",
                    "middle": [],
                    "last": "Haave",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "At Least 500,000 Tests Needed Per Day to Reopen Economy",
            "authors": [],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A methodology for deriving the sensitivity of pooled testing, based on viral load progression and pooling dilution",
            "authors": [
                {
                    "first": "Hrayer",
                    "middle": [],
                    "last": "Ngoc T Nguyen",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Aprahamian",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Ebru",
                    "suffix": ""
                },
                {
                    "first": "Douglas",
                    "middle": [
                        "R"
                    ],
                    "last": "Bish",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Bish",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Journal of translational medicine",
            "volume": "17",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Feasibility and efficacy of routine pcr screening of blood donations for hepatitis c virus, hepatitis b virus, and hiv-1 in a blood-bank setting",
            "authors": [
                {
                    "first": "Willi",
                    "middle": [
                        "Kurt"
                    ],
                    "last": "Roth",
                    "suffix": ""
                },
                {
                    "first": "Marijke",
                    "middle": [],
                    "last": "Weber",
                    "suffix": ""
                },
                {
                    "first": "Erhard",
                    "middle": [],
                    "last": "Seifried",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "The Lancet",
            "volume": "353",
            "issn": "9150",
            "pages": "359--363",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Evaluation of group testing for SARS-COV-2 RNA. medRxiv",
            "authors": [
                {
                    "first": "Nasa",
                    "middle": [],
                    "last": "Sinnott-Armstrong",
                    "suffix": ""
                },
                {
                    "first": "Daniel",
                    "middle": [],
                    "last": "Klein",
                    "suffix": ""
                },
                {
                    "first": "Brendan",
                    "middle": [],
                    "last": "Hickey",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Group testing to eliminate efficiently all defectives in a binomial sample",
            "authors": [
                {
                    "first": "Milton",
                    "middle": [],
                    "last": "Sobel",
                    "suffix": ""
                },
                {
                    "first": "Phyllis",
                    "middle": [
                        "A"
                    ],
                    "last": "Groll",
                    "suffix": ""
                }
            ],
            "year": 1959,
            "venue": "Bell System Technical Journal",
            "volume": "38",
            "issn": "5",
            "pages": "1179--1252",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "On the detection of defective members of large populations",
            "authors": [
                {
                    "first": "Andrew",
                    "middle": [],
                    "last": "Sterrett",
                    "suffix": ""
                }
            ],
            "year": 1957,
            "venue": "The Annals of Mathematical Statistics",
            "volume": "28",
            "issn": "4",
            "pages": "1033--1036",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Rapid, large-scale, and effective detection of COVID-19 via non-adaptive testing. bioRxiv, 2020. Tod20. India Today. Centre allows COVID-19 pool testing, plasma therapy in Maharashtra",
            "authors": [
                {
                    "first": "Matthias",
                    "middle": [],
                    "last": "T\u00e4ufer",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "The cutoff point for group testing",
            "authors": [
                {
                    "first": "Peter",
                    "middle": [],
                    "last": "Ungar",
                    "suffix": ""
                }
            ],
            "year": 1960,
            "venue": "Comm. Pure Appl. Math",
            "volume": "13",
            "issn": "1",
            "pages": "49--54",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Pooling nasopharyngeal/throat swab specimens to increase testing capacity for influenza viruses by pcr",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Vmw + 12",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Tam",
                    "suffix": ""
                },
                {
                    "first": "Joseph",
                    "middle": [],
                    "last": "Van",
                    "suffix": ""
                },
                {
                    "first": "David",
                    "middle": [
                        "M"
                    ],
                    "last": "Miller",
                    "suffix": ""
                },
                {
                    "first": "Erik",
                    "middle": [],
                    "last": "Warshauer",
                    "suffix": ""
                },
                {
                    "first": "Daniel",
                    "middle": [],
                    "last": "Reisdorf",
                    "suffix": ""
                },
                {
                    "first": "Rosemary",
                    "middle": [],
                    "last": "Jernigan",
                    "suffix": ""
                },
                {
                    "first": "Peter",
                    "middle": [
                        "A"
                    ],
                    "last": "Humes",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Shult",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Journal of Clinical Microbiology",
            "volume": "50",
            "issn": "3",
            "pages": "891--896",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Combination of RT-qPCR testing and clinical features for diagnosis of COVID-19 facilitates management of SARS-COV-2 outbreak",
            "authors": [
                {
                    "first": "Yishan",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "Hanyujie",
                    "middle": [],
                    "last": "Kang",
                    "suffix": ""
                },
                {
                    "first": "Xuefeng",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "Zhaohui",
                    "middle": [],
                    "last": "Tong",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Journal of medical virology",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Evaluation of COVID-19 RT-qPCR test in multi-sample pools. medRxiv",
            "authors": [
                {
                    "first": "Noga",
                    "middle": [],
                    "last": "Yast + 20. Idan Yelin",
                    "suffix": ""
                },
                {
                    "first": "Einat",
                    "middle": [],
                    "last": "Aharony",
                    "suffix": ""
                },
                {
                    "first": "Amir",
                    "middle": [],
                    "last": "Shaer-Tamar",
                    "suffix": ""
                },
                {
                    "first": "Esther",
                    "middle": [],
                    "last": "Argoetti",
                    "suffix": ""
                },
                {
                    "first": "Dina",
                    "middle": [],
                    "last": "Messer",
                    "suffix": ""
                },
                {
                    "first": "Einat",
                    "middle": [],
                    "last": "Berenbaum",
                    "suffix": ""
                },
                {
                    "first": "Areen",
                    "middle": [],
                    "last": "Shafran",
                    "suffix": ""
                },
                {
                    "first": "Nagam",
                    "middle": [],
                    "last": "Kuzli",
                    "suffix": ""
                },
                {
                    "first": "Tamar",
                    "middle": [],
                    "last": "Gandali",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Hashimshony",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Two pooling testing procedures having (1, 2) as root.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Optimality zones for n = 2. A : naive procedure; B : pooling procedure (right); C : pooling procedure (left).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Graphical representation of a testing procedure. The collection is [3] = {1, 2, 3}, \u2126 = {{1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}, the initial set of selections is S = \u2126 . Only the T labels are written on nodes. Only the S labels are written for leaves.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Slices of the cube decomposition for the n = 3 metaprocedure, each colour corresponds to a different strategy, which is optimal at this position. The slices are taken orthogonally to the cube's main diagonal, with the origin at the center of each picture. Each color corresponds to a procedure. The symmetries are particularly visible.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Number of naive procedures). Let n \u2265 1,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Slices through the cube at the z = 0.17 (left) and the z = 0.33 (right) planes, showing the metaprocedure's rich structure. Each colour corresponds to a different strategy, which is optimal at this position. The origin is at the top left.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "A 3D visualisation of the cube. Left: exterior, where it is visible that each face has the same decomposition as the 2D problem; Middle: with the naive algorithm region slightly removed, showing that it accounts for slightly less than half of the total volume; Right: exploded view of the 52 substructures (looking from (\u22121, \u22121, \u22121)).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Let B 0 and B 1 be two binary strings of size n, that only differ by one bit (i.e. B 0 [i] = 0 and B 1 [i] = 1 for some i). Then T (B 0 ) \u2264 T (B 1 ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Naive algorithm, where the order of tests are unimportant in the left and right branches.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Optimal procedures (without permutations) for each zone when n = 3.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "cost(S, S ) = f (S, S ) + g(S, S ) f (S, S ) = #{i \u2208 [n] s.t. s[i] = 1 and \u2203S \u2208 S , S [i] = 0} g(S, S ) = 1 if \u2203i \u2208 {i \u2208 [n] s.t. S[i] = 0}, \u2203S \u2208 S , S [i] = 1 0 otherwiseThis function approximates the smallest integer n such that there exists n calls to \u03c6 with arguments T 1 , . . . , T n , and \u03b2 1 , . . . , \u03b2 n in {\u22a5, } with S \u03b2 1 ,...,\u03b2 n T 1 \u00b7\u00b7\u00b7T n = {S}. This function is used to define a 'gain' function evaluating how much information is gathered when performing a test knowing the set of outcomes: gain(T, S ) = \u2211",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "{010, 011, 100, 101, 110, 111}, but the two procedures settle for a different T : The metaprocedure splits S, with T = {1, 3}, into S \u22a5 T = {010} and S T = {011, 100, 101, 110, 111}; while the heuristic chooses T = {1} instead, and gets S \u22a5 T = {010, 011} and S T = {100, 101, 110, 111}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF15": {
            "text": "The optimal metaprocedure tree (left), and heuristic metaprocedure (right) for the same point x = (0.01, 0.17, 0.51).",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Generation results for some small n",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}