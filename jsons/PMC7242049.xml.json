{
    "paper_id": "PMC7242049",
    "metadata": {
        "title": "ProB and Jupyter for Logic, Set Theory, Theoretical Computer Science and Formal Methods",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "David",
                "middle": [],
                "last": "Gele\u00dfus",
                "suffix": "",
                "email": "dagel101@hhu.de",
                "affiliation": {}
            },
            {
                "first": "Michael",
                "middle": [],
                "last": "Leuschel",
                "suffix": "",
                "email": "michael.leuschel@hhu.de",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "The computational notebook concept has recently become popular in teaching and research, as it allows mixing executable code with rich text descriptions and graphical visualizations. We present a tool which enables B and other formal methods to be used in computational notebooks. Such notebooks have many applications, from teaching formal methods to documenting formal models or generating executable reference documents. Given the foundations of B in set theory and logic, and given that the Unicode syntax of B is identical to or very close to standard mathematical notation, our tool can also be used to produce notebooks for teaching mathematical foundations in general or theoretical computer science in particular. Given that our tool is based on the ProB tool, the notebooks also provide convenient access to its constraint solver.",
            "cite_spans": [],
            "section": "Introduction and Motivation",
            "ref_spans": []
        },
        {
            "text": "Architecture. Jupyter Notebook [4] is a cross-platform computational notebook interface implemented in Python with a web-based frontend. Originally it was developed under the name IPython Notebook and only supported Python-based notebooks, but it has since been extended to allow using languages other than Python. Support for each language is provided by a Jupyter kernel: a language-specific backend that receives input from Jupyter Notebook, processes it using the target language, and returns the results to Jupyter. Jupyter communicates with kernels using a language-agnostic protocol, which allows implementing kernels in languages other than Python. In the case of ProB, the kernel was implemented in Java, as ProB provides a high-level Java API [1], and there is an existing Java implementation of the Jupyter kernel protocol by the jupyter-jvm-basekernel project [7].",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 33,
                    "mention": "4",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 754,
                    "end": 755,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 873,
                    "end": 874,
                    "mention": "7",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "The Jupyter Notebook web interface can also be extended using JavaScript-based plugins. This capability was used to implement syntax highlighting for B.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Interacting with B. At its core, the ProB Jupyter kernel is a simple REPL. It accepts standalone B expressions and predicates as input, which are evaluated or solved using ProB. The results are output as\n\nformulas and rendered by Jupyter Notebook, as shown in the following screenshot:",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Markup cells can be used to provide documentation for the evaluation cells:",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Many ProB features can be accessed using notebook commands. For example, prefixing a B expression with the command :table displays the result as a table, which is useful for viewing complex values, such as sets of tuples. Additional commands include :prettyprint to pretty-print a predicate without evaluating it, :type to display an expression\u2019s static type, and :solve to solve a predicate using ProB\u2019s various solver backends (such as Kodkod or Z3).",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "To load a B machine, the B code can be input directly into a notebook cell, which allows for quick testing and prototyping of short machines. When written this way, the entire B machine needs to be placed in a single notebook cell (it is currently not possible to insert text cells in the middle of the machine), and it cannot refine, extend, or otherwise reference other machines. It is also possible to load external machine files using the :load command, which is more convenient for larger machines, and also supports loading machines that reference other machine files.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "The loaded machine can be animated, using the :exec command to execute operations or events. While a machine is loaded, the input is evaluated in the current state of the animator, meaning that the loaded machine\u2019s constants and variables can be used in expressions and predicates. Additional commands such as :check and :browse are provided to examine the current state of invariants, assertions and operations. It is also possible to exercise ProB\u2019s model checker.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "ProB\u2019s state visualisation features can be called using the :show and :dot commands, which can for example be used to visualise the current machine state or the animator\u2019s state space. The visualisation results are displayed directly in the notebook as raster or SVG images.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Jupyter Notebook\u2019s advanced code editing features, such as syntax highlighting and code completion, are also supported by the ProB kernel. Both regular B syntax and custom commands are highlighted, and completion is provided for B keywords, variable names, command names and parameters, etc. The \u201cinspect\u201d feature (accessed using Shift+Tab) provides quick access to command help directly inside the notebook interface.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Working with Notebooks. The ProB Jupyter kernel only handles the actual evaluation of the code in the notebook. Jupyter Notebook provides all other parts of the system: including the web frontend responsible for editing notebooks and rendering the kernel\u2019s outputs, and the file format used when saving notebooks.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Using the nbconvert tool provided by Jupyter, B notebook files can be converted to a variety of standard formats, including HTML,\n\n, and PDF. This allows distributing notebooks in a format that can be viewed without Jupyter Notebook, although the resulting files cannot be edited and re-executed like the original notebook.",
            "cite_spans": [],
            "section": "Jupyter Kernel for B",
            "ref_spans": []
        },
        {
            "text": "Industrial. As B notebooks can load and animate external machine files, they can be used to document the behavior of existing models. This is conceptually similar to a trace file, with the advantage that notebooks can include not just operation execution steps, but also explanatory text and evaluation/visualisation calls to demonstrate specific aspects of the machine\u2019s state.",
            "cite_spans": [],
            "section": "Applications",
            "ref_spans": []
        },
        {
            "text": "Some of ProB\u2019s own documentation is currently being converted from static documentation pages to B notebooks. The Modelling Examples section, e.g., contains pages which start with an introductory text, usually describing a short logic puzzle or part of a real-world use case of ProB, followed by B code fragments modelling the problem in B and explanations of how ProB can be used to visualize, verify or solve the model. The notebook format is well-suited for this kind of documentation: the code in notebooks can be directly executed by the user and the respective visualisation features can be called directly from the notebook. Below is part of the documentation of ProB\u2019s external functions. This documentation is automatically up-to-date and users can experiment themselves with the various external functions before integrating them into their models:",
            "cite_spans": [],
            "section": "Applications",
            "ref_spans": []
        },
        {
            "text": "Teaching. In the context of teaching the B language as well as theoretical computer science in general, B notebooks can be used as a format for writing lecture notes and worksheets.",
            "cite_spans": [],
            "section": "Applications",
            "ref_spans": []
        },
        {
            "text": "Lecture notes involving B expressions or machines can be written and distributed as notebooks, allowing students to execute the code for themselves and experiment with modifications. Due to its foundations in set theory, the B language can also be used to express many general theoretical computer science concepts, such as finite automata. These concepts can be demonstrated using B notebooks, taking advantage of the\n\noutput and graph visualisation capabilities to display the results in a format familiar to students.",
            "cite_spans": [],
            "section": "Applications",
            "ref_spans": []
        },
        {
            "text": "B notebooks can also be used as a format for exercise sheets. Students are provided with a notebook that contains the exercise text and possibly some initial code. They can solve the exercises directly in the notebook and turn in the finished notebook file with their solutions. The nbgrader [9] extension for Jupyter provides support for writing exercise sheet notebooks: it allows marking cells with exercise text as read-only, and cells with solutions so they are removed when the exercises are distributed to students. The extension also assists with grading and also enables automated verification of solutions.",
            "cite_spans": [
                {
                    "start": 293,
                    "end": 294,
                    "mention": "9",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Applications",
            "ref_spans": []
        },
        {
            "text": "A formal model is usually derived from a natural language requirements document. A big issue is that of keeping the formal model and natural language in sync. A related issue is that of traceability, tracing natural language requirements to the formal model. In that setting the idea of literate programming [5], mixing the natural language documentation with the program, is appealing. The Z language [8] has always allowed literate programming by interleaving\n\ncommands with Z constructs. A similar capability for the B language is provided by ProB\u2019s\n\nmode [6]. In comparison, the ProB Jupyter kernel focuses more on interactivity. Individual cells of a B notebook can be quickly edited and re-rendered/evaluated, whereas the ProB\n\nmode can only render the entire document at once. However, the ability to write\n\ncode directly offers more flexibility in terms of formatting and layout, compared to a B notebook converted to\n\nor PDF using nbconvert.",
            "cite_spans": [
                {
                    "start": 309,
                    "end": 310,
                    "mention": "5",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 403,
                    "end": 404,
                    "mention": "8",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 560,
                    "end": 561,
                    "mention": "6",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Conclusion, Related and Future Work",
            "ref_spans": []
        },
        {
            "text": "An open-source Jupyter kernel for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\textsc {TLA}^{+}$$\\end{document} [3] is available. Its feature set is similar to the basic features of the ProB Jupyter kernel: it supports evaluation of standalone \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\textsc {TLA}^{+}$$\\end{document} expressions, as well as loading and checking of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\textsc {TLA}^{+}$$\\end{document} models using the TLC model checker.",
            "cite_spans": [
                {
                    "start": 338,
                    "end": 339,
                    "mention": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Conclusion, Related and Future Work",
            "ref_spans": []
        },
        {
            "text": "A previous attempt at implementing a notebook-like interface for B was the ProB worksheet interface [2]. Its design and goals were very similar to our work, but the implementation provided its own custom web UI, server, and file format, mainly because extensible notebook implementations like Jupyter were not available at the time (2012\u20132013). In comparison, using Jupyter as a base significantly reduces the required implementation and maintenance work, and allows B notebooks to benefit from existing tooling for Jupyter, such as nbconvert and nbgrader.",
            "cite_spans": [
                {
                    "start": 101,
                    "end": 102,
                    "mention": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Conclusion, Related and Future Work",
            "ref_spans": []
        },
        {
            "text": "In summary, this new tool provides a notebook interface to a variety of state-based formal methods. Along with some extensions of ProB itself, such as allowing Greek letters or subscripts in identifiers, it is also of use for applications in teaching of discrete mathematics or theoretical computer science.",
            "cite_spans": [],
            "section": "Conclusion, Related and Future Work",
            "ref_spans": []
        },
        {
            "text": "Our tool is available for download at:https://gitlab.cs.uni-duesseldorf.de/general/stups/prob2-jupyter-kernel\n",
            "cite_spans": [],
            "section": "Conclusion, Related and Future Work",
            "ref_spans": []
        }
    ],
    "ref_entries": {},
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Literate programming",
            "authors": [
                {
                    "first": "DE",
                    "middle": [],
                    "last": "Knuth",
                    "suffix": ""
                }
            ],
            "year": 1984,
            "venue": "Comput. J.",
            "volume": "27",
            "issn": "2",
            "pages": "97-111",
            "other_ids": {
                "DOI": [
                    "10.1093/comjnl/27.2.97"
                ]
            }
        },
        "BIBREF5": {
            "title": "Formal model-based constraint solving and document generation",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Leuschel",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Formal Methods: Foundations and Applications",
            "volume": "",
            "issn": "",
            "pages": "3-20",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [
                {
                    "first": "JM",
                    "middle": [],
                    "last": "Spivey",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "The Z Notation: A Reference Manual",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}