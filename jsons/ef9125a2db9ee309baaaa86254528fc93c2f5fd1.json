{
    "paper_id": "ef9125a2db9ee309baaaa86254528fc93c2f5fd1",
    "metadata": {
        "title": "A Compressed Sensing Approach to Group-testing for COVID-19 Detection",
        "authors": [
            {
                "first": "Sabyasachi",
                "middle": [],
                "last": "Ghosh",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Rishi",
                "middle": [],
                "last": "Agarwal",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Mohammad",
                "middle": [
                    "Ali"
                ],
                "last": "Rehan",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Shreya",
                "middle": [],
                "last": "Pathak",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Pratyush",
                "middle": [],
                "last": "Agrawal",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Yash",
                "middle": [],
                "last": "Gupta",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Sarthak",
                "middle": [],
                "last": "Consul",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Nimay",
                "middle": [],
                "last": "Gupta",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Ritika",
                "middle": [],
                "last": "Goyal",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Ajit",
                "middle": [],
                "last": "Rajwade",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Manoj",
                "middle": [],
                "last": "Gopalkrishnan",
                "suffix": "",
                "affiliation": {},
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "We propose Tapestry, a novel approach to pooled testing with application to COVID-19 testing with quantitative Polymerase Chain Reaction (PCR) that can result in shorter testing time and conservation of reagents and testing kits. Tapestry combines ideas from compressed sensing and combinatorial group testing with a novel noise model for PCR. Unlike Boolean group testing algorithms, the input is a quantitative readout from each test, and the output is a list of viral loads for each sample. While other pooling techniques require a second confirmatory assay, Tapestry obtains individual sample-level results in a single round of testing. When testing n samples with t tests, as many as k = O(t/ log n) infected samples can be identified at clinically-acceptable false positive and false negative rates. This makes Tapestry viable even at prevalence rates as high as 10%. Tapestry has been validated in simulations as well as in wet lab experiments with oligomers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The coronavirus disease of 2019 (COVID-19) crisis has led to widespread lockdowns in several countries, and has had a major negative impact on the economy. Early identification of infected individuals can enable quarantining of the individuals and thus control the spread of the disease. Infected individuals are often asymptomatic for many days. Widespread testing with the RT-PCR (reverse transcription polymerase chain reaction) method can help identify the infected individuals. However, widespread testing is not an available option in many countries due to constraints on resources such as time, basic equipment, skilled manpower and reagents.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The current low rate of COVID-19 infection in the world population means that most samples tested are not infected, so that most tests are wasted on uninfected samples. Group testing is a process of pooling together samples of n different people into multiple pools, and testing the pools instead of each individual sample. A negative result on the mixture implies that all n samples were negative. This saves a huge amount of testing resources, especially with low infection rates. Group testing for medical applications has a long history dating back to the 1940s when it was proposed for testing of blood samples for syphilis [1] . Simple group testing schemes have already been applied in the field by several research labs [2, 3, 4] for COVID-19 testing.",
            "cite_spans": [
                {
                    "start": 629,
                    "end": 632,
                    "text": "[1]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Simple group testing schemes require pooling of samples and a second round of RNA extraction for all samples in positive pools. This second round of RNA extraction can increase the time to result and be laborious to perform in laboratories where the RNA extraction process is done manually. In situations where the result needs to be delivered fast or a second round of RNA extraction must be avoided, these schemes are less attractive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Tapestry has a number of salient features which we enumerate below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The organization of the paper is as follows. We first present a brief overview of the RT-PCR method in Sec. 2. The precise mathematical definition of the computational problem being solved in this paper is then put forth in Sec. 3.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We describe traditional and CS-based group-testing algorithms for this problem in Sec. 3.2, 3.3 and 3.4. The sensing matrix design problem is described in Sec. 3.5. Results on synthetic data are presented in Sec. 4. This is followed by results on a limited amount of data from lab experiments performed with oligomers to mock the clinical situation as closely as possible. In Sec. 5, we compare our work to two recent related approaches. We conclude in Sec. 6 with a glance through different scenarios where our work could be deployed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In the RT-PCR method [9] , a sample is collected from a patient from a biological matrix that would with high likelihood contain copies of the virus should the patient be infected. For COVID-19, nasal swabs are most common, but other biological matrices like saliva, oropharyngeal swab, bronchial lavage, stool, blood sample, etc may also be collected in certain cases. The sample is then dispersed into a liquid medium. The RNA molecules of the virus present in this liquid medium are converted into complementary DNA (cDNA) via a process called reverse transcription. DNA fragments called primers complementary to cDNA from the viral genome are then added. They attach themselves to specific sections of the cDNA from the viral genome if the virus is present in the sample. The cDNA of these specific viral genes then undergoes a process of exponential amplification in an RT-PCR machine. Here, they are put through several cycles of alternate heating and cooling in the presence of Taq polymerase and appropriate reagents. This triggers the creation of many new identical copies of specific portions of the target DNA, roughly doubling in number with every cycle of heating and cooling. The reaction volume contains sequence-specific fluorescent markers which report on the total amount of amplified DNA of the appropriate sequence. The resulting fluorescence is measured, and the increase can be observed on a computer screen in real time. The time when the amount of fluorescence exceeds the threshold level is known as the threshold cycle C t , and is a quantitative readout from the experiment. A smaller C t indicates greater number of copies of the virus. Usually C t takes values anywhere between 16 to 32 cycles in real experiments. PCR can detect even single molecules. A single molecule typically would have C t value of around 37 cycles or so, but there can be wide variation. The test takes about 3-4 hours to run.",
            "cite_spans": [
                {
                    "start": 21,
                    "end": 24,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "RT-PCR Method"
        },
        {
            "text": "3 Testing Methods",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RT-PCR Method"
        },
        {
            "text": "Let x denote a vector of n elements where x i is the viral load (or virus concentration) of the i th person. Throughout this paper we assume that only one sample per person is extracted. Hence x contains the viral loads corresponding to n different people. Due to the low infection rate for COVID-19 as yet, x is considered to be a sparse vector with at the most k \u226a n positive-valued elements. Note that x i = 0 implies that the i th person is not infected. In nonadaptive group testing, small and equal volumes of the samples of a subset of these n people are pooled together according to a sensing or pooling matrix A = (A ji ) m\u00d7n whose entries are either 0 or 1. The viral loads of the pools will be given by:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Statement of the Computational Problem"
        },
        {
            "text": "where A ji = 1 if a portion of the sample of i th person is included in the j th pool. In all, some m < n pools are created and individually tested using RT-PCR, so that 1 \u2264 j \u2264 m. We now have the following relationship:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Statement of the Computational Problem"
        },
        {
            "text": "where z is the m-element vector of viral loads in the mixtures, and A denotes a m \u00d7 n binary 'pooling matrix' (also referred to as a 'sensing matrix' in compressed sensing literature). In particular, z j = A j x where A j is the j th row of A and placing the two vectors adjacent to each other denotes matrix multiplication of the row vector with the colum vector x. Note that each positive RT-PCR test will yield a noisy version of z j , which we refer to as y j . The relation between the 'clean' and noisy versions is given as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Statement of the Computational Problem"
        },
        {
            "text": "where e j \u223c N (0, \u03c3 2 ) and q \u2208 (0, 1) are system-specific constants. The factor (1 + q) ej reflects the stochasticity in the growth of the numbers of DNA molecules during PCR. Here \u03c3 is known and constant. We have found that a number around .1 is typical. For q, we find a number around .95 to be typical. Equivalently for positive tests, we have:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Statement of the Computational Problem"
        },
        {
            "text": "In case of negative tests, y j as well as z j are 0-valued, and no logarithms need be computed. The core computational problem is to estimate x given y and A. It should be noted that though we have treated each element of x to be a fixed quantity, it is in reality a random variable of the form x i \u223c Poisson(\u03bb i ) where \u03bb i \u2265 0. If matrix A contains only ones and zeros, this implies that z j \u223c Poisson(A j x), making use of the fact that the sum of Poisson random variables is also a Poisson random variable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Statement of the Computational Problem"
        },
        {
            "text": "Combinatorial Orthogonal Matching Pursuit (COMP) is a Boolean nonadaptive group testing method. Here one uses the simple idea that if a mixture y j tests negative then any sample x i for which A ji = 1 must be negative. In other words, all samples contributing to a mixture that tests negative must be negative (or non-infected). The other samples are all considered to be positive. This algorithm guarantees that there are no 'false negatives'. However it can produce a very large number of 'false positives'. For example, a sample x k will be falsely reported to be positive if every mixture y j it is part of also contains at least one (other) genuinely positive sample. The COMP algorithm is largely insensitive to noise. Moreover a small variant of it can also produce a list of 'sure positives', after identifying the sure negatives. This happens when a positive mixture y j contains only one sample x i , not counting the other samples which were declared sure negatives in the earlier step 1 . The performance guarantees for COMP have been analyzed in [8] and show that COMP requires ek(1 + \u03b4) log n tests for an error probability less than n \u2212\u03b4 . This analysis has been extended to include the case of noisy test results as well [8] . However COMP can result in a large number of false positives, and it also does not predict viral loads.",
            "cite_spans": [
                {
                    "start": 1060,
                    "end": 1063,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1238,
                    "end": 1241,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Combinatorial Group-Testing"
        },
        {
            "text": "Group testing is intimately related to the field of compressed sensing (CS) [10] , which has emerged as a significant sub-area of signal and image processing [5] . In compressed sensing, an image or a signal x with n elements, is directly acquired in compressed format via m linear measurements of the form y = Ax + \u03b7. Here, the measurement vector y has m elements, and A is a matrix of size m \u00d7 n, and \u03b7 is a vector of noise values. If x is a sparse vector with k \u226a n non-zero entries, and A obeys the so-called restricted isometry property (RIP), then exact recovery of x from y, A is possible [11] if \u03b7 = 0. In the case of measurement noise, the recovery of x produces a solution that is provably close to the original x. A typical recovery problem P0 consists of optimizing the following cost function:",
            "cite_spans": [
                {
                    "start": 76,
                    "end": 80,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 158,
                    "end": 161,
                    "text": "[5]",
                    "ref_id": null
                },
                {
                    "start": 596,
                    "end": 600,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "where \u03b5 is an upper bound (possibly a high probability upper bound) on \u03b7 2 , and x 0 is the number of non-zero elements in x. In the absence of noise, a unique and exact solution to this problem is possible with as few as 2k measurements in y if x has k non-zero elements [11] . Unfortunately, this optimization problem P0 is NP-Hard and the algorithm requires brute-force subset enumeration. Instead, the following problem P1 (often termed 'Basis Pursuit Denoising' or BPDN) is solved in practice:",
            "cite_spans": [
                {
                    "start": 272,
                    "end": 276,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "P1 is a convex optimization problem which yields the same solution as the earlier problem (with similar conditions on x, A) at significantly lower computational cost, albeit with O(k log n) measurements (i.e. typically greater than 2k) [5, 11] . The order k restricted isometry constant (RIC) of a matrix A is defined as the smallest constant \u03b4 k , for which the following relationship holds for all k-sparse vectors x (i.e. all vectors with at the most k non-zero entries):",
            "cite_spans": [
                {
                    "start": 236,
                    "end": 239,
                    "text": "[5,",
                    "ref_id": null
                },
                {
                    "start": 240,
                    "end": 243,
                    "text": "11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "The matrix A is said to obey the order k restricted isometry property if \u03b4 k is close to 1. This property essentially implies that no k-sparse vector (other than the zero vector) can lie in the null-space of A. Unique recovery of ksparse signals requires that no 2k-sparse vector lies in the nullspace of A [11] . A matrix A which obeys RIP of order 2k satisfies this property. It has been proved that matrices with entries randomly and independently drawn from distributions such as Rademacher or Gaussian, obey the RIP of order k with high probability [12] , provided they have at least O(k log n) rows. The solution to the optimization problems P0 and P1 in Eqns. 5 and 6 respectively, are provably robust to noise [5] , and the recovery error worsens with increase in noise magnitude. The error bounds for P0 in Eqn. 5 are of the form, for solutionx [13] :",
            "cite_spans": [
                {
                    "start": 307,
                    "end": 311,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 554,
                    "end": 558,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 718,
                    "end": 721,
                    "text": "[5]",
                    "ref_id": null
                },
                {
                    "start": 854,
                    "end": 858,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "whereas those for P1 in Eqn. 6 have the form [13] :",
            "cite_spans": [
                {
                    "start": 45,
                    "end": 49,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "x \u2212x 2 \u2264 \u03b5C(\u03b4 2k ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "Here C(\u03b4 2k ) is a monotonically increasing function of \u03b4 2k \u2208 (0, 1) and has a small value in practice. Over the years, a variety of different techniques for compressive recovery have been proposed. We use some of these for our experiments in Sec. 3.4. These algorithms use different forms of sparsity and incorporate different types of constraints on the solution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Compressed Sensing for Pooled Testing"
        },
        {
            "text": "Our approach toward group-testing for COVID-19 involves a two-stage procedure 2 . In the first stage, we apply the COMP algorithm described in Sec. 3.2, to identify the sure negatives (if any) in x to form a set X . Let Y be the set of zero-valued measurements in y (i.e. negative tests). Moreover, we defineX ,\u0232 as the complement-sets of X , Y respectively. Also, let y\u0232 be the vector of m \u2212 |Y| measurements which yielded a positive result. Let xX be the vector of n \u2212 |X | samples, which does not include the |X | surely negative samples. Let AX ,\u0232 be the submatrix of A, having size (m \u2212 |Y|) \u00d7 (n \u2212 |X |), which excludes rows corresponding to zero-valued measurements in y and columns corresponding to negative elements in x. In the second stage, we apply a CS algorithm to recover xX from y\u0232 , AX ,\u0232 . To avoid symbol clutter, we henceforth just stick to the notation y, x, A, even though they respectively refer to y\u0232 , xX , AX ,\u0232 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "Note that the CS stage following COMP is very important for the following reasons:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "1. COMP typically produces a large number of false positives. The CS algorithms help reduce the number of false positives as we shall see in later sections.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "2. COMP does not estimate viral loads, unlike CS algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "3. In fact, unlike CS algorithms, COMP treats the measurements in y as also being binary, thus discarding a lot of useful information.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "However, the COMP algorithm prior to applying the CS algorithm is also very important for the following reasons:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "1. It identifies the sure negatives in x from the negative measurements in y. Therefore, it effectively reduces the size of the problem to be solved by the CS step from (m, n) to (m \u2212 |Y|, n \u2212 X |).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "2. It can be seen from Eqn. 4, that the multiplicative noise we have in y is essentially heteroscedastic. This is because the 0-valued measurements in y are noiseless, and the others are noisy. In such a case, direct application of CS algorithms without the preceding COMP step will be fraught with challenges. It is instead easier to discard the obvious negatives before applying the CS step.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "For CS recovery, we employ the following algorithms: the non-negative LASSO (NN-LASSO), orthogonal matching pursuit (OMP), and Sparse Bayesian Learning (SBL). For problems of small size, we also apply a brute force search algorithm to solve problem P0 from Eqn. 5 combinatorially.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CS and Traditional GT Combined"
        },
        {
            "text": "The LASSO (least absolute shrinkage and selection operator) is a penalized version of the constrained problem P1 in Eqn. 6. It is widely used in statistics and signal processing, and seeks to minimize the following cost function:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Non-negative LASSO (NN-LASSO)"
        },
        {
            "text": "Here \u03bb is a regularization parameter which imposes sparsity in x. The LASSO has rigorous theoretical guarantees for recovery of x as well as recovery of the support of x (i.e. recovery of the set of non-zero indices of x). We refer the reader to chapter 11 of [14] for the relevant theorems. Given the non-negative nature of x, we implement a variant of LASSO with a non-negativity constraint, leading to the following optimization problem:",
            "cite_spans": [
                {
                    "start": 260,
                    "end": 264,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "The Non-negative LASSO (NN-LASSO)"
        },
        {
            "text": "Selection of \u03bb: There are criteria defined in [14] for selection of \u03bb under iid Gaussian noise, so as to guarantee statistical consistency. However, in practice, cross-validation (CV) can be used for optimal choice of \u03bb. For this, the measurements in y are divided into two randomly chosen disjoint sets: one for reconstruction (R) and the other for validation (V). The NN-LASSO is executed independently on multiple values of \u03bb from a candidate set \u039b. For each \u03bb value, an estimatex \u03bb is produced using measurements only from R, and the CV error v e (\u03bb) := i\u2208V (y i \u2212 A ix \u03bb ) 2 is computed. The value of \u03bb which yields the least value of v e (\u03bb) is chosen, and an estimate of x is obtained by executing LASSO on all measurements from R \u222a V. If V is large enough, then v e (\u03bb) is shown to be a good estimate of the actual error x \u2212x \u03bb 2 , as has been shown for Gaussian noise [15] . Nonetheless, it should be noted that CV is a method of choice for parameter selection in CS even under a variety of other noise models such as Poisson [16] , etc, and we have experimentally observed that it works well even in the case of our noise model in Eqn. 4. However, in this particular application, we may potentially deal with situations where m and n are small, for example m = 16, n = 40. In such a scenario, CV will yield unstable results since |V| will be very small. In such a case, one resorts to the so-called 'discrepancy principle' (DP) [17] . As per our noise model in Eqn. 4, the expected value of R(y, Ax) := log y \u2212 log Ax 2 should be close to \u03c3 log(1 + q) \u221a m. Moreover, its variance is quite small and independent of m. Hence, as per the discrepancy principle, we seek to find \u03bb \u2208 \u039b such that |R(y, Ax \u03bb )\u2212\u03c3 log(1+q) \u221a m| is minimized. Previous work in [18] has employed such a technique in the context of image deblurring under Poisson-Gaussian noise with a square-root based data-fidelity term of the form y + 3/8 \u2212 Ax \u03bb + 3/8 2 .",
            "cite_spans": [
                {
                    "start": 46,
                    "end": 50,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 877,
                    "end": 881,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1035,
                    "end": 1039,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1438,
                    "end": 1442,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1760,
                    "end": 1764,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "The Non-negative LASSO (NN-LASSO)"
        },
        {
            "text": "Orthogonal Matching Pursuit (OMP) [19] is a greedy approximation algorithm to solve the optimization problem in Eqn. 5. Rigorous theoretical guarantees for OMP have been established in [20] . OMP proceeds by maintaining a set H of 'selected coefficients' in x corresponding to columns of A.In each round a column of A is picked greedily, based on the criterion of maximum absolute correlation with a residual vector r := y \u2212 k\u2208H A kxk . Each time a column is picked, all the coefficients extracted so far (i.e. in set H) are updated. This is done by computing the orthogonal projection of y onto the subspace spanned by the columns in H. The OMP algorithm can be quite expensive computationally. Moreover, in order to maintain non-negativity of x, the orthogonal projection step would require the solution of a non-negative least squares problem, further adding to computational costs. However, a fast implementation of a non-negative version of OMP (NN-OMP) has been developed in [21] , which is the implementation we adopt here. For the choice of \u03b5 in Eqn. 5, we can use CV or DP as described in Sec. 3.4.1.",
            "cite_spans": [
                {
                    "start": 34,
                    "end": 38,
                    "text": "[19]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 185,
                    "end": 189,
                    "text": "[20]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 981,
                    "end": 985,
                    "text": "[21]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Non-negative Orthogonal Matching Pursuit (NNOMP)"
        },
        {
            "text": "Sparse Bayesian Learning (SBL) [22, 23] is a non-convex optimization algorithm based on Expectation-Maximization (EM) that has empirically shown superior reconstruction performance to most other CS algorithms with manageable computation cost [24] . In SBL, we consider the case of Gaussian noise in y and a Gaussian prior on elements of x, leading to:",
            "cite_spans": [
                {
                    "start": 31,
                    "end": 35,
                    "text": "[22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 36,
                    "end": 39,
                    "text": "23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 242,
                    "end": 246,
                    "text": "[24]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Sparse Bayesian Learning (SBL)"
        },
        {
            "text": "Since both x and \u03d5 (the vector of the {\u03d5 i } n i=1 values) are unknown, the optimization for these quantities can be performed using an EM algorithm. In the following, we shall denote \u03a6 := diag(\u03d5). Moreover, we shall use the notation \u03a6 (l) for the estimate of \u03a6 in the l th iteration. The E-step of the EM algorithm here involves computing Q(\u03a6|\u03a6 l ) := E x|y;\u03a6 (l) log p(y, x; \u03a6). It is to be noted that the posterior distribution p(x|y; \u03a6 (l) ) has the form N (\u00b5, \u03a3) where \u00b5 = \u03a3A T y/\u03c3 2 and \u03a3 = (A T A/\u03c3 2 + (\u03a6 (l) ) \u22121 ) \u22121 . The M-step involves maximization of Q(\u03a6|\u03a6 (l) ), leading to the update \u03a6 (l+1) = diag(\u00b5 2 i + \u03a3 ii ). The E-step and M-step are executed alternately until convergence. Convergence to a fixed-point is guaranteed, though the fixed point may or may not be a local minimum. However, all local minima are guaranteed to produce sparse solutions for x (even in the presence of noise) because most of the \u03d5 i values shrink towards 0. The SBL procedure can also be modified to dynamically update \u03c3 2 , the Gaussian noise variance, if it is unknown. All these results can be found in [23] . Unlike NN-LASSO or OMP, the SBL algorithm from [23] expressly requires Gaussian noise. However we use it as is in this paper for the simplicity it affords, and choose the standard deviation of the noise (required for the SBL updates) simply via CV or DP as described in Sec. 3.4.1. Unlike NNOMP or NNLASSO, there is no explicit non-negativity constraint imposed in the basic SBL algorithm. In our implementation, the non-negativity is simply imposed at the end of the optimization by setting to 0 any negative-valued elements in \u00b5, though more principled, albeit more computationally heavy, approached can be adopted [25] .",
            "cite_spans": [
                {
                    "start": 1103,
                    "end": 1107,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 1157,
                    "end": 1161,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 1727,
                    "end": 1731,
                    "text": "[25]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "Sparse Bayesian Learning (SBL)"
        },
        {
            "text": "The sensing matrix A must obey some properties specific to this application such as being non-negative. For ease of pipetting, it is desirable that the entries of A be binary, where A ji = 0 indicates that sample i did not contribute to pool j, and A ji = 1 indicates that a fixed unit volume of sample i was pipetted into pool j. Also for ease of pipetting including saving pipetting time, it is desirable that A be sparse. This additionally ensures that not too many samples contribute to a pool, and that a single sample does not contribute to too many pools. The former is important because typically the volume of sample that is added in a PCR reaction is fixed. Increasing pool size means each sample contributes a smaller fraction of that volume. This leads to dilution which manifests as a shift of the C t value towards larger numbers. If care is not taken in this regard, this can affect the power of PCR to discriminate between positive and negative samples. The latter is important because contribution of one sample to a large number of pools could lead to depletion of sample.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "The Restricted Isometry Property (RIP) of sensing matrices is a sufficient condition for good CS recovery as described in Sec. 3.3. However the matrices which obey the aforementioned physical constraints are not guaranteed to obey RIP. Instead, we consider sensing matrices which are adjacency matrices of expander graphs. A left-regular bipartite graph G((V I , V O ), E \u2286 V I \u00d7 V O ) with degree of each vertex in V I being d, is said to be a (k, 1 \u2212 \u03b1) expander graph for some integer k > 0 and some real-valued \u03b1 \u2208 (0, 1), if for every subset S \u2286 V I with |S| \u2264 k, we have |N (S)| \u2265 (1 \u2212 \u03b1)d|S|. Here N (S) denotes the union set of neighbors of all nodes in S. Intuitively a bipartite graph is an expander if every 'not too large' subset has a 'large' boundary. It can be proved that a randomly generated left-regular bipartite graph is an expander, with high probability [26] . Moreover, it has been shown in [6] that the adjacency matrix A of a (k, 1 \u2212 \u03b1) expander graph obeys the RIP-1 property (a version of the RIP, but with \u2113 1 norm). That is, for any k-sparse vector x, the following relationship holds if A obeys the RIP-1 property of order k:",
            "cite_spans": [
                {
                    "start": 876,
                    "end": 880,
                    "text": "[26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 914,
                    "end": 917,
                    "text": "[6]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "This property again implies that the null-space of A cannot contain vectors that are 'too sparse' (apart from the zero-vector). This summarizes the motivation behind the use of expanders in compressive recovery of sparse vectors, and also in group testing. Although randomly generated left-regular bipartite graphs are expanders, we would need to verify whether a particular such graph is a good expander, and prove theorems for it. In the application at hand, this can prove to be a critical limitation since matrices of various sizes may have to be served, depending on the number of samples arriving in that batch at the testing centre, and the number of tests available to be performed. Hence, we have chosen to employ deterministic procedures to design such matrices, based on objects from combinatorial design theory known as Kirkman triples [27] . Generalizations of these kind of objects under the name of the 'social golfer problem' is an active area of research.",
            "cite_spans": [
                {
                    "start": 848,
                    "end": 852,
                    "text": "[27]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "We first recall Kirkman triple systems which are Steiner triple systems with an extra property. Steiner triple systems consist of n = m 2 /3 column vectors of length m with entries either 0 or 1 such that each column has exactly three 1s, and no two columns have dot product more than 1 [28] . If the sum of columns from i to i + m/3 \u2212 1 equals 1 \u2208 R m for every i \u2261 1 modulo m/3 then the Steiner triple system is called a Kirkman triple system [27] .",
            "cite_spans": [
                {
                    "start": 287,
                    "end": 291,
                    "text": "[28]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 445,
                    "end": 449,
                    "text": "[27]",
                    "ref_id": "BIBREF26"
                }
            ],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "Kirkman triple systems have many nice combinatorial properties that make them ideally suited for our application. The most obvious is that they are sparse matrices since each column has only three 1s. The dot product between two columns being at most 1 ensures that no two samples participate in more than one test together. This has favourable consequences in terms of placing an upper bound on the mutual coherence of the matrix, defined as:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "where A i refers to the i th column of A. Matrices with lower \u00b5(A) values have lower values of worst case upper bounds on the reconstruction error [29] . These bounds are looser than those based on the RIC that we saw in previous sections. However, unlike the RIC, the mutual coherence is efficiently computable. Another benefit is that the Kirkman matrix bipartite graph of samples and tests has high girth, i.e., the smallest cycle in the graph has large diameter. Hence the graph is locally treelike, and has good expansion properties. As a result, the RIP-1 property holds and the matrix has good reconstruction properties under compressed sensing.",
            "cite_spans": [
                {
                    "start": 147,
                    "end": 151,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "A practical benefit of Kirkman triples that is not shared by Steiner triples is that Kirkman triples can be served for number of samples far less than n = m 2 /3 while keeping pools balanced. In fact, we can choose n to be any integer multiple of m/3, and ensure that every pool gets the same number of samples. This allows us to characterize the properties of the full Kirkman matrix, and use that analysis to predict how it will behave in the clinical situation where the pooling matrix to be served may require very specific values of m, n depending on the prevalence rate.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "As mentioned earlier, the mutual coherence is efficient to compute and optimize over. Hence, there is a large body of literature on designing CS matrices by minimizing \u00b5(A) w.r.t. A, for example [30] . We followed such a procedure for designing sensing matrices for some of our experimental results in Sec. 4.2. For this, we follow simulated annealing to update the entries of A, starting with an initial condition where A is a random binary matrix. For synthetic experiments, we compared such matrices with random matrices, biregular random sparse graphs, and Kirkman matrices. We found that matrices of Kirkman triples perform very well empirically in the regime of sizes we are interested in, and hence the results are reported using only Kirkman or Steiner triple matrices.",
            "cite_spans": [
                {
                    "start": 195,
                    "end": 199,
                    "text": "[30]",
                    "ref_id": "BIBREF29"
                }
            ],
            "ref_spans": [],
            "section": "Sensing Matrix Design"
        },
        {
            "text": "In the class of 'adaptive group testing' techniques, the n samples are distributed into two or more groups, each of smaller size, and the smaller groups are then individually tested. In one particular adaptive method called generalized binary splitting (GBS) [31] , this procedure is repeated (in a binary search fashion) until a single infected sample is identified. This requires O(log n) sequential tests, where each test requires mixing up to n/2 samples. This sample is then discarded, and the entire procedure is performed on the remaining n \u2212 1 samples. Such a procedure does not introduce any false negatives, and does not require prior knowledge of the number of infected samples k. It requires a total of only O(k log n) tests, if k is the number of infected samples. However such a multi-stage method is impractical to be deployed due to its sequential nature, since each RT-PCR stage requires nearly 3-4 hours. Moreover, each mixture that is tested contains contributions from as many as O(n) samples, which can lead to significant dilution or may be difficult to implement in the lab. Hence in this work, we do not pursue this particular approach further. Such an approach may be very useful if each individual test had a quick turn-around time.",
            "cite_spans": [
                {
                    "start": 259,
                    "end": 263,
                    "text": "[31]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [],
            "section": "Generalized Binary Search Techniques"
        },
        {
            "text": "In this section, we show a suite of experimental results on synthetic data as well as on real data.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "Signal/Measurement Generation: For the case of synthetic data, we generated signal vectors x of dimension n = 105, with varying levels of sparsity. In all cases, m = 45 noisy measurements in y were simulated following the noise 00,0.00 0.0,0.0 26.0,6.3 1.00,0.00 0.71,0.07 1.00,0.00 0.0,0.0 62.8,14.6 1.00,0.00 0.93,0.02  20 1.00,0.00 0.0,0.0 31.9,7.8 1.00,0.00 0.62,0.09 1.00,0.00 0.0,0.0 91.2,17.7 1.00,0 .00 0.90,0.02 Table 1 \u221a \u03bb/\u03bb = 1/ \u221a \u03bb which becomes smaller and smaller as \u03bb increases. Kirkman triple sensing matrices were used in these experiments for generating the measurements. The recovery algorithms were tested on Q = 100 randomly generated signals. The different signals had different supports, and the magnitudes of the non-zero elements were uniformly randomly generated in the range [1, 1000] .",
            "cite_spans": [
                {
                    "start": 802,
                    "end": 805,
                    "text": "[1,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 806,
                    "end": 811,
                    "text": "1000]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 228,
                    "end": 406,
                    "text": "00,0.00 0.0,0.0 26.0,6.3 1.00,0.00 0.71,0.07 1.00,0.00 0.0,0.0 62.8,14.6 1.00,0.00 0.93,0.02  20 1.00,0.00 0.0,0.0 31.9,7.8 1.00,0.00 0.62,0.09 1.00,0.00 0.0,0.0 91.2,17.7 1.00,0",
                    "ref_id": null
                },
                {
                    "start": 421,
                    "end": 428,
                    "text": "Table 1",
                    "ref_id": null
                }
            ],
            "section": "Results on Synthetic Data"
        },
        {
            "text": "Algorithms tested: The following algorithms were compared:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results on Synthetic Data"
        },
        {
            "text": "1. COMP (see Table 1) 2. COMP followed by NN-LASSO (see Table 2) 3. COMP followed by SBL (see Table 3) 4. COMP followed by NN-OMP (see Table 4) 5. COMP-BF, i.e. COMP followed by brute-force search, only for small sample sizes (see Tables 5 and 7) Comparison Criteria: In the following,x denotes the estimate of x. Most numerical algorithms do not produce vectors that are exactly sparse, due to issues such as choice of convergence criterion. Instead, the recovered signals contain many entries which have a tiny magnitude. Since in this application, support recovery is of paramount importance (to identify which samples in x were infected), we employ the following post-processing step: All entries inx whose magnitude falls below a threshold \u03c4 := 0.02 \u00d7 x min are set to zero, yielding a vectorx. Here x min refers to the least possible value of the viral load, and this can be obtained offline from practical experiments (even on single samples). In these synthetic experiments, we simply set x min := 1. The various algorithms were compared with respect to the following criteria: It should be noted that all algorithms were evaluated on 100 randomly generated sparse signals, given the same sensing matrix. The average value as well as standard deviation of all quality measures (over the 100 signals) are reported in the Tables 1, 2 , 3, 4, 5, 7. A comparison of Table 1 to Tables 2, 3 , 4, 5, 7 indicates that COMP followed by NN-LASSO/SBL/NNOMP/NN-BF significantly reduces the false positives at the cost of a rare false negative. The RMSE is also significantly improved, since COMP does not estimate viral loads. We note that the experimental results reported in these tables are quite encouraging, since these experiments are challenging due to small m and fairly large k, n, albeit with testing on synthetic data. Brute-force method: We refer to COMP-BF as a method where we apply COMP followed by a brute-force search to solve problem P0 in Eqn. 5. This is computationally feasible only if C(n, k) is 'reasonable' (note that the effective n is often reduced after application of COMP), and so we employ it only for small-sized matrices. The method essentially enumerates all possible supports of x which have size k. For each such candidate support set Z, the following cost function is minimized using the fmincon routine of MATLAB which implements an interior-point optimizer 3 :",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 13,
                    "end": 21,
                    "text": "Table 1)",
                    "ref_id": null
                },
                {
                    "start": 56,
                    "end": 64,
                    "text": "Table 2)",
                    "ref_id": null
                },
                {
                    "start": 94,
                    "end": 102,
                    "text": "Table 3)",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 135,
                    "end": 143,
                    "text": "Table 4)",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 231,
                    "end": 246,
                    "text": "Tables 5 and 7)",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 1328,
                    "end": 1339,
                    "text": "Tables 1, 2",
                    "ref_id": null
                },
                {
                    "start": 1370,
                    "end": 1392,
                    "text": "Table 1 to Tables 2, 3",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Results on Synthetic Data"
        },
        {
            "text": "Results with the COMP-BF method are shown in Table 5 . The special advantage of the brute-force method is that it requires only m = 2k mixtures, which is often less than O(k log n). However, such a method requires prior knowledge of k, or an estimate thereof. We employ a method to estimate k directly from y, A. This is described in Sec. 4.3. The results in Table 5 assume that the exact k was known, or that the estimator predicted the exact k. However, we observed that the estimator from Sec. 4.3 can sometimes over-estimate k. Hence, we also present results with COMP-BF where the brute-force search assumed that the sparsity was (over-estimated to be) k + 1 instead of k. These are shown in Table 7 . A comparison of Tables 5 and 7 shows that RMSE deteriorates if k is incorrectly estimated. However there is no adverse effect on the number of false negatives, and only a small adverse effect on the number of false positives. Comparison with Dorfman Pooling: We also performed a comparison of our algorithms with the popular two-stage Dorfman pooling method (an adaptive method), with regard to the number of tests required. In the first stage of the Dorfman pooling technique, the n samples are divided into n/k pools, each of size \u221a nk. Each of these n/k pools are tested, and a negative result leads to all members of that pool being considered negative (i.e. non-infected). However, the pools that are tested positive are passed onto a second stage, where all members of those pools are individually tested. The comparison w.r.t. the number of tests is shown in Table 6 , assuming (a) that the number of infected samples k is known in advance, and (b) that the k infected samples are distributed across pools (a worst case situation). Comparisons of Tables 1, 2, 3, 4 with the two-stage Dorfman pooling method in 6 show that our methods require much fewer tests, albeit with a slight increase in number of false negatives. Moreover, all our methods are single-stage methods unlike the Dorfman method which requires two stages of testing. If the value of k is unknown, which will usually be the case on the field, then the method from Sec. 4.3 can be used.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 45,
                    "end": 52,
                    "text": "Table 5",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 359,
                    "end": 366,
                    "text": "Table 5",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 697,
                    "end": 704,
                    "text": "Table 7",
                    "ref_id": "TABREF7"
                },
                {
                    "start": 723,
                    "end": 737,
                    "text": "Tables 5 and 7",
                    "ref_id": "TABREF4"
                },
                {
                    "start": 1573,
                    "end": 1580,
                    "text": "Table 6",
                    "ref_id": "TABREF5"
                }
            ],
            "section": "Results on Synthetic Data"
        },
        {
            "text": "We acquired real data in the form of test results on pooled samples from two labs: one at the National Center of Biological Sciences (NCBS) in India, and the other at the Wyss Institute at the Harvard Medical School, USA. In both cases, viral RNA was artificially injected into k of the n samples where k \u226a n. From these n samples, a total of m mixtures were created. For the datasets obtained from NCBS that we experimented with, we had m = 16, n = 40, k \u2208 {1, 2, 3, 4}. For the data from the Wyss Institute, we had m = 24, n = 60, k = 3. The results for all these datasets are presented in Table 8 . The pooling matrices in both cases were obtained by performing a simulated annealing procedure to minimize the mutual coherence (see Sec. 3.5), starting with a random sparse binary matrix as initial condition. We see that the CS algorithms reduce the false positives, albeit with an introduction of occasional false negatives for higher values of k. We also refer the reader to our work in [32] for a more in-depth description of results on real experimental data.",
            "cite_spans": [
                {
                    "start": 992,
                    "end": 996,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [
                {
                    "start": 592,
                    "end": 599,
                    "text": "Table 8",
                    "ref_id": "TABREF8"
                }
            ],
            "section": "Results on Real Data"
        },
        {
            "text": "CS algorithms require O(k log n) measurements for successful recovery assuming RIP-1 4 or RIP-2 properties of the sensing matrix. However, in practice k is always unknown, which leads to the question as to how many measurements are needed as a minimum for a particular problem instance. To address this, we adopt the technique from [34] to estimate k on the fly from the compressive measurements. This technique does not require signal recovery for estimating k. The relative error in the estimate of k is shown to be O( log m/m) [35] , which diminishes as m increases (irrespective of the true k). The advantage of this estimate of k is that it can drive the COMP-BF algorithm, as well as act as an indicator of whether there exist any false negatives.",
            "cite_spans": [
                {
                    "start": 332,
                    "end": 336,
                    "text": "[34]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 530,
                    "end": 534,
                    "text": "[35]",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "Estimation of number of infected samples"
        },
        {
            "text": "There exists very little literature on applying CS for COVID-19 testing. While preparing this manuscript, we came across two references on arxiv: [36] and [37] . Both these references adopt a nonadaptive CS based approach. However compared to them, our work is different in the following ways (also see [32] ):",
            "cite_spans": [
                {
                    "start": 146,
                    "end": 150,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 155,
                    "end": 159,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 303,
                    "end": 307,
                    "text": "[32]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Relation to Previous Work"
        },
        {
            "text": "1. Real/Synthetic data: The work in [36] is largely theoretical, whereas our work as well as that in [37] have tested results on real data. 2. Noise model : Our work uses the physically-derived noise model in Eqn. 4 (as opposed to only Gaussian noise). This noise model is not considered in [36, 37] .",
            "cite_spans": [
                {
                    "start": 36,
                    "end": 40,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 101,
                    "end": 105,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 291,
                    "end": 295,
                    "text": "[36,",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 296,
                    "end": 299,
                    "text": "37]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [],
            "section": "Relation to Previous Work"
        },
        {
            "text": "3. Algorithms: The work in [36] adopts the BPDN technique (i.e P1 from Eqn. 6) as well as the brute-force search method for reconstruction. The work in [37] uses the LASSO, albeit without explicit imposition of a non-negativity constraint. On the other hand, we use the LASSO with a non-negative constraint, the brute-force method, as well as other techniques such as SBL and NNOMP, all in combination with COMP. The work in [36] assumes knowledge of the (Gaussian) noise variance for selection of \u03b5 in the estimator in Eqn. 6, whereas we use cross-validation for all our estimators. The technique in [37] uses a slightly different form of cross-validation for selection of the regularization parameter in LASSO.",
            "cite_spans": [
                {
                    "start": 27,
                    "end": 31,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 152,
                    "end": 156,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 425,
                    "end": 429,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 601,
                    "end": 605,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [],
            "section": "Relation to Previous Work"
        },
        {
            "text": "Sensing matrix design: [36] use randomly generated expander graphs, whereas we use Kirkman triple matrices. The work in [37] uses randomly generated sparse Bernoulli matrices or Reed-Solomon codes. Each sample in our matrix participates in 3 pools as opposed to 6 pools as used in [37] which is advantageous from the point of view of pipetting time. ",
            "cite_spans": [
                {
                    "start": 23,
                    "end": 27,
                    "text": "[36]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 120,
                    "end": 124,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 281,
                    "end": 285,
                    "text": "[37]",
                    "ref_id": "BIBREF36"
                }
            ],
            "ref_spans": [],
            "section": "4."
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Sparsity estimation: Our work uses an explicit sparsity estimator and does not rely on any assumption regarding the prevalence rate",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "3%) of samples with 48 tests, with an average number of false positives that was less than 2.75, and an average number of false negatives that was less than 0.33. On synthetic simulations with their 48 \u00d7 384 Reed-Solomon code based matrix (released by the authors) for a total of 100 x vectors with \u2113 0 norm of 5 using COMP-NNLASSO, we obtained 1.51 false positives and 0.02 false negatives on an average with a standard deviation of 1.439 and 0.14 respectively. Using COMP-SBL instead of COMP-NNLASSO with all other settings remaining the same, we obtained 1.4 false positives and 0.0 false negatives on an average with a standard deviation of 1.6 and 0.1 respectively. As such",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "The detection of defective members of large populations",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Dorfman",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "The Annals of Mathematical Statistics",
            "volume": "14",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Covid-19 screening and testing",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "An introduction to compressive sampling",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Candes",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Wakin",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "IEEE Signal Processing Magazine",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Combining geometry and combinatorics: A unified approach to sparse signal recovery",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Berinde",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "C"
                    ],
                    "last": "Gilbert",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Indyk",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Karloff",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Strauss",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "46th Annual Allerton Conference on Communication, Control, and Computing",
            "volume": "",
            "issn": "",
            "pages": "798--805",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Viral dynamics in mild and severe cases of covid-19",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "L.-M",
                    "middle": [],
                    "last": "Yan",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wan",
                    "suffix": ""
                },
                {
                    "first": "T.-X",
                    "middle": [],
                    "last": "Xiang",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Le",
                    "suffix": ""
                },
                {
                    "first": "J.-M",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Peiris",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "L M"
                    ],
                    "last": "Poon",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "The Lancet Infectious Diseases",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Non-adaptive probabilistic group testing with noisy measurements: Near-optimal bounds with efficient algorithms",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "L"
                    ],
                    "last": "Chan",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "H"
                    ],
                    "last": "Che",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Jaggi",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Saligrama",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "49th Annual Allerton Conference on Communication, Control, and Computing",
            "volume": "",
            "issn": "",
            "pages": "1832--1839",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "How is the COVID-19 virus detected using real time RT-PCR",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Jawerth",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Group testing and sparse signal recovery",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gilbert",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Iwen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Strauss",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Asilomar Conference on Signals, Systems and Computers",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "The restricted isometry property and its implications for compressive sensing",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Candes",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Comptes Rendus Mathematiques",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A simple proof of the restricted isometry property for random matrices",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Baraniuk",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Davenport",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Devore",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Wakin",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Constr Approx",
            "volume": "28",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Introduction to compressed sensing",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Davenport",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Duarte",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Eldar",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Kutyniok",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Statistical Learning with Sparsity: The LASSO and Generalizations",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Hastie",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Tibshirani",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Wainwright",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "On the theoretical analysis of cross validation in compressive sensing",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "T"
                    ],
                    "last": "Boufounos",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Gu",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ICASSP",
            "volume": "",
            "issn": "",
            "pages": "3370--3374",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Minimax optimal convex methods for Poisson inverse problems under lq-ball sparsity",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Raskutti",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE Trans. Information Theory",
            "volume": "64",
            "issn": "8",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Morozov's discrepancy principle and tikhonov-type functionals",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bonesky",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Inverse Problems",
            "volume": "25",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Variance-stabilization-based compressive inversion under Poisson or Poisson-Gaussian noise with analytical bounds",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Bohra",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Garg",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "S"
                    ],
                    "last": "Gurumoorthy",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rajwade",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Inverse Problems",
            "volume": "35",
            "issn": "10",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Orthogonal matching pursuit: recursive function approximation with application to wavelet decomposition",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Pati",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Rezaiifar",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Krishnaprasad",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "Asilomar Conf. On Signals, Systems and Computing",
            "volume": "",
            "issn": "",
            "pages": "40--44",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Orthogonal matching pursuit for sparse signal recovery with noise",
            "authors": [
                {
                    "first": "T",
                    "middle": [
                        "T"
                    ],
                    "last": "Cai",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "IEEE Transactions on Information Theory",
            "volume": "57",
            "issn": "7",
            "pages": "4680--4688",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Fast non-negative orthogonal matching pursuit",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Yaghoobi",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Davies",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "IEEE Signal Processing Letters",
            "volume": "22",
            "issn": "9",
            "pages": "1229--1233",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Sparse Bayesian learning and the relevance vector machine",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Tipping",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Journal of Machine Learning Research",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Sparse Bayesian learning for basis selection",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Wipf",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "D"
                    ],
                    "last": "Rao",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "IEEE Trans. Signal Processing",
            "volume": "52",
            "issn": "8",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "A review of sparse recovery algorithms",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Crespo Marques",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Maciel",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Naviner",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cai",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE Access",
            "volume": "7",
            "issn": "",
            "pages": "1300--1322",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Rectified gaussian scale mixtures and the sparse non-negative least squares problem",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Nalci",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Fedorov",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Al-Shoukairi",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "T"
                    ],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "D"
                    ],
                    "last": "Rao",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE Transactions on Signal Processing",
            "volume": "66",
            "issn": "12",
            "pages": "3124--3139",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "A fast noniterative algorithm for compressive sensing using binary measurement matrices",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Lotfi",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vidyasagar",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "IEEE Transactions on Signal Processing",
            "volume": "66",
            "issn": "15",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Kirkman's schoolgirl problem",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Steiner triple systems",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Stable restoration and separation of approximately sparse signals",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Studer",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Baraniuk",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Applied and Computational Harmonic Analysis",
            "volume": "37",
            "issn": "1",
            "pages": "12--35",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "On optimization of the measurement matrix for compresive sensing",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Abdoghasemi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ferdowsi",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Makkiabadi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Sanei",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Combinatorial group testing and its applications",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Du",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "K"
                    ],
                    "last": "Hwang",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Hwang",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Tapestry: A single-round smart pooling technique for covid-19 testing",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ghosh",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Rajwade",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Krishna",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Gopalkrishnan",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "E"
                    ],
                    "last": "Schaus",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Chakravarthy",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Varahan",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Appu",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Ramakrishnan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Ch",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jindal",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bhupathi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gupta",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Jain",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Agarwal",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pathak",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Rehan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Consul",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Gupta",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Gupta",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Agarwal",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Goyal",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Sagar",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Ramakrishnan",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Krishna",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Yin",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Palakodeti",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gopalkrishnan",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Deterministic matrices matching the compressed sensing phase transitions of gaussian random matrices",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Monajemi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Jafarpour",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Gavish",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Donoho",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "",
            "volume": "110",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "On the fly estimation of the sparsity degree in compressed sensing using sparse sensing matrices",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bioglio",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bianchi",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Magli",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "ICASSP",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Sparsity estimation from compressive projections via sparse random matrices",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Ravazzi",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Fosson",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bianchi",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Magli",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "EURASIP J. Adv. Signal Process",
            "volume": "56",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Low-cost and high-throughput testing of covid-19 viruses and antibodies via compressed sensing: System concepts and computational experiments",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Yi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Mudumbai",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Efficient high throughput SARS-CoV-2 testing to detect asymptomatic carriers",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Shental",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Levy",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Skorniakov",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Wuvshet",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Shemer-Avni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Porgador",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Hertz",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1101/2020.04.14"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF1": {
            "text": ": Performance of COMP (on synthetic data) for 45 \u00d7 105 and 93 \u00d7 961 Kirkman triple matrices. For each criterion, mean and standard deviation values are reported, across 100 signals. model in Eqn. 4 with \u03c3 2 = 0.1. The Poisson nature of the elements of x in Eqn. 4 was ignored. This approximation was based on the principle that if X \u223c Poisson(\u03bb), then Std. Dev.(X)/E(X) =",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "1. RMSE := x \u2212x 2 / x 2 2. Number of false positives (fp) := |{i : x i = 0,x i > 0}| 3. Number of false negatives (fn) := |{i : x i > 0,x i = 0}| 4. Sensitivity (also called Recall or True Positive rate) := ratio of number of correctly detected positives to the number of actual positives 5. Specificity (also called True Negative Rate) := ratio of number of correctly detected negatives to the number of actual negatives.",
            "latex": null,
            "type": "figure"
        },
        "TABREF2": {
            "text": "Performance of COMP followed by SBL (on synthetic data) for 45\u00d7105 and 93\u00d7961 Kirkman triple matrices. For each criterion, mean and standard deviation values are reported, across 100 signals.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Performance of COMP followed by NN-OMP (both on synthetic data) for 45 \u00d7 105 and 93 \u00d7 961 Kirkman triple matrices. For each criterion, mean and standard deviation values are reported, across 100 signals.",
            "latex": null,
            "type": "table"
        },
        "TABREF4": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF5": {
            "text": "",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "Method k RMSE #false neg. #false pos. sens. spec.",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Performance of COMP followed by brute-force search (COMP-BF) to solve P0 (Eqn. 5) for 16 \u00d7 40 Steiner triple matrices, with different values of k, assuming that the sparsity value was estimated to be k + 1. Results for both methods are reported on synthetic data.",
            "latex": null,
            "type": "table"
        },
        "TABREF8": {
            "text": "Results of lab experiments with each algorithm",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We have designed an Android app named Byom Smart Testing to make our Tapestry protocol easy to deploy in the future. The app can be accessed at the following link: https://drive.google.com/file/d/1tfrzKfbewVqwOOKhpCb1WplMfsUfAOe0/view?usp=sharing. We are also sharing our code and some amount of data at the link below: https://github.com/atoms-to-intelligence/tapestry. Future work: Future work will involve extensive testing on real data, and extensive implementation of a variety of algorithms for sensing matrix design as well as signal recovery, keeping in mind the accurate statistical noise model.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Outputs:"
        }
    ]
}