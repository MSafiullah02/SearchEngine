{
    "paper_id": "PMC7206162",
    "metadata": {
        "title": "SLGAT: Soft Labels Guided Graph Attention Networks",
        "authors": [
            {
                "first": "Hady",
                "middle": [
                    "W."
                ],
                "last": "Lauw",
                "suffix": "",
                "email": "hadywlauw@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Raymond",
                "middle": [
                    "Chi-Wing"
                ],
                "last": "Wong",
                "suffix": "",
                "email": "raywong@cse.ust.hk",
                "affiliation": {}
            },
            {
                "first": "Alexandros",
                "middle": [],
                "last": "Ntoulas",
                "suffix": "",
                "email": "antoulas@di.uoa.gr",
                "affiliation": {}
            },
            {
                "first": "Ee-Peng",
                "middle": [],
                "last": "Lim",
                "suffix": "",
                "email": "eplim@smu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "See-Kiong",
                "middle": [],
                "last": "Ng",
                "suffix": "",
                "email": "seekiong@nus.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Sinno",
                "middle": [
                    "Jialin"
                ],
                "last": "Pan",
                "suffix": "",
                "email": "sinnopan@ntu.edu.sg",
                "affiliation": {}
            },
            {
                "first": "Yubin",
                "middle": [],
                "last": "Wang",
                "suffix": "",
                "email": "wangyubin@iie.ac.cn",
                "affiliation": {}
            },
            {
                "first": "Zhenyu",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "email": "zhangzhenyu1996@iie.ac.cn",
                "affiliation": {}
            },
            {
                "first": "Tingwen",
                "middle": [],
                "last": "Liu",
                "suffix": "",
                "email": "liutingwen@iie.ac.cn",
                "affiliation": {}
            },
            {
                "first": "Li",
                "middle": [],
                "last": "Guo",
                "suffix": "",
                "email": "guoli@iie.ac.cn",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "In recent years, graph convolutional neural networks (GCNs) [26], which can learn from graph-structured data, have attracted much attention. The general approach with GCNs is to learn node representations by passing, transforming, and aggregating node features across the graph. The generated node representations can then be used as input to a prediction layer for various downstream tasks, such as node classification [12], graph classification [30], link prediction [17] and social recommendation [19].",
            "cite_spans": [
                {
                    "start": 61,
                    "end": 63,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 421,
                    "end": 423,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 448,
                    "end": 450,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 470,
                    "end": 472,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 501,
                    "end": 503,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Graph attention networks (GAT) [23], which is one of the most representative GCNs, learns the weights for neighborhood aggregation via self-attention mechanism [22] and achieves promising performance on semi-supervised node classification problem. The model is expected to learn to pay more attention to the important neighbors. It calculates important scores between connected nodes based solely on the node representations. However, the label information of nodes is usually overlooked. Besides, the cluster assumption [3] for semi-supervised learning states that the decision boundary should lie in regions of low density. It means aggregating the features from the nodes with different classes could reduce the generalization performance of the model. This motivates us to introduce label information to improve the performance of node classification in the following two aspects: (1) We introduce soft labels to guide the feature aggregation for generating discriminative node embeddings for classification. (2) We use SLGAT to predict pseudo labels for unlabeled nodes and further train SLGAT on the composition of labeled and pseudo labeled nodes. In this way, SLGAT can benefit from unlabeled data.",
            "cite_spans": [
                {
                    "start": 32,
                    "end": 34,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 161,
                    "end": 163,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 522,
                    "end": 523,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper, we propose soft labels guided attention networks (SLGAT) for semi-supervised node representation learning. The learning process consists of two main steps. First, SLGAT aggregates the features of neighbors using convolutional networks and predicts soft labels for each node based on the learned embeddings. And then, it uses soft labels to guide the feature aggregation via attention mechanism. Unlike the prior graph attention networks, SLGAT allows paying more attention to the features closely related to the central node labels. The weights for neighborhood aggregation learned by a feedforward neural network based on both label information of central nodes and features of neighboring nodes, which can lead to learning more discriminative node representations for classification.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We further propose a self-training based optimization method to improve the generalization performance of SLGAT using unlabeled data. Specifically, we first pre-train SLGAT on labeled nodes using standard cross-entropy loss. Then we generate pseudo labels for unlabeled nodes using SLGAT. Next, for each iteration, we train SLGAT using a combined cross-entropy loss on both labeled nodes and pseudo labeled nodes, and then generate new pseudo labels for further training. In this way, SLGAT can benefit from unlabeled data by minimizing the entropy of predictions on unlabeled nodes.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We conduct extensive experiments on semi-supervised node classification to evaluate our proposed model. And experimental results on several datasets show that SLGAT achieves state-of-the-art performance. The source code of this paper can be obtained from https://github.com/jadbin/SLGAT.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Graph-Based Semi-supervised Learning. A large number of methods for semi-supervised learning using graph representations have been proposed in recent years, most of which can be divided into two categories: graph regularization-based methods and graph embedding-based methods. Different graph regularization-based approaches can have different variants of the regularization term. And graph Laplacian regularizer is most commonly used in previous studies including label propagation [32], local and global consistency regularization [31], manifold regularization [1] and deep semi-supervised embedding [25]. Recently, graph embedding-based methods inspired by the skip-gram model [14] has attracted much attention. DeepWalk [16] samples node sequences via uniform random walks on the network, and then learns embeddings via the prediction of the local neighborhood of nodes. Afterward, a large number of works including LINE [21] and node2vec [8] extend DeepWalk with more sophisticated random walk schemes. For such embedding based methods, a two-step pipeline including embedding learning and semi-supervised training is required where each step has to be optimized separately. Planetoid [29] alleviates this by incorporating label information into the process of learning embeddings.",
            "cite_spans": [
                {
                    "start": 484,
                    "end": 486,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 534,
                    "end": 536,
                    "mention": "31",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 564,
                    "end": 565,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 603,
                    "end": 605,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 681,
                    "end": 683,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 725,
                    "end": 727,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 926,
                    "end": 928,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 944,
                    "end": 945,
                    "mention": "8",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 1191,
                    "end": 1193,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Graph Convolutional Neural Networks. Recently, graph convolutional neural networks (GCNs) [26] have been successfully applied in many applications. Existing GCNs are often categorized as spectral methods and non-spectral methods. Spectral methods define graph convolution based on the spectral graph theory. The early studies [2, 10] developed convolution operation based graph Fourier transformation. Defferrard et al. [4] used polynomial spectral filters to reduce the computational cost. Kipf & Welling [12] then simplified the previous method by using a linear filter to operate one-hop neighboring nodes. Wu et al. [27] used graph wavelet to implement localized convolution. Xu et al. [27] used a heat kernel to enhance low-frequency filters and enforce smoothness in the signal variation on the graph. Along with spectral graph convolution, define the graph convolution in the spatial domain was also investigated by many researchers. GraphSAGE [9] performs various aggregators such as mean-pooling over a fixed-size neighborhood of each node. Monti et al. [15] provided a unified framework that generalized various GCNs. GraphsGAN [5] generates fake samples and trains generator-classifier networks in the adversarial learning setting. Instead of fixed weight for aggregation, graph attention networks (GAT) [23] adopts attention mechanisms to learn the relative weights between two connected nodes. Wang et al. [24] generalized GAT to learn representations of heterogeneous networks using meta-paths. Shortest Path Graph Attention Network (SPAGAN) to explore high-order path-based attentions.",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 93,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 327,
                    "end": 328,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 330,
                    "end": 332,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 421,
                    "end": 422,
                    "mention": "4",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 507,
                    "end": 509,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 621,
                    "end": 623,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 691,
                    "end": 693,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 952,
                    "end": 953,
                    "mention": "9",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 1064,
                    "end": 1066,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1139,
                    "end": 1140,
                    "mention": "5",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 1316,
                    "end": 1318,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1420,
                    "end": 1422,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Our method is based on spatial graph convolution. Unlike the existing graph attention networks, we introduce soft labels to guide the feature aggregation of neighboring nodes. And experiments show that this can further improve the semi-supervised classification performance.",
            "cite_spans": [],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "In this paper, we focus on the problem of semi-supervised node classification. Many other applications can be reformulated into this fundamental problem. Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G = (V, E)$$\\end{document} be a graph, in which V is a set of nodes, E is a set of edges. Each node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u \\in V$$\\end{document} has a attribute vector \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {x}}_u$$\\end{document}. Given a few labeled nodes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_L \\in V$$\\end{document}, where each node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$u \\in V_L$$\\end{document} is associated with a label \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {y}}_u \\in Y$$\\end{document}, the goal is to predict the labels for the remaining unlabeled nodes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$V_U = V \\setminus V_L$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Problem Definition",
            "ref_spans": []
        },
        {
            "text": "In the initial phase, we need to first predict the pseudo labels for each node based on node features \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {x}}$$\\end{document}. The pseudo labels can be soft (a continuous distribution) or hard (a one-hot distribution). In practice, we observe that soft labels are usually more stable than hard labels, especially when the model has low prediction accuracy. Since the labels predicted by the model are not absolutely correct, the error from hard labels may propagate to the inference on other labels and hurt the performance. While using soft labels can alleviate this problem.",
            "cite_spans": [],
            "section": "Soft Labels Generation ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "We use a multi-layer graph convolutional network [12] to aggregate the features of neighboring nodes. The layer-wise propagation rule of feature convolution is as follows:1\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{\\mathrm {f}}^{(l+1)} = \\sigma \\left( \\widetilde{D}^{-\\frac{1}{2}}\\widetilde{A}\\widetilde{D}^{-\\frac{1}{2}}\\varvec{\\mathrm f}^{(l)}W^{(l)}_f\\right) \\end{aligned}$$\\end{document}Here, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\widetilde{A} = A + I$$\\end{document} is the adjacency matrix with added self-connections. I is the identity matrix, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\widetilde{D}_{ii}=\\sum _j \\widetilde{A}_{ij}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W^{(l)}_f \\in \\mathbb {R}^{d^{(l)}_f \\times d^{(l+1)}_f}$$\\end{document} is a layer-specific trainable transformation matrix. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\sigma \\left( \\cdot \\right) $$\\end{document} denotes an activation function such as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${\\mathrm {ReLU}}(\\cdot ) = {\\mathrm {max}}(0, \\cdot )$$\\end{document}. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {f}}^{(l)} \\in \\mathbb {R}^{|V| \\times d^{(l)}_f}$$\\end{document} denotes the hidden representations of nodes in the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l^{\\mathrm {th}}$$\\end{document} layer. The representations of nodes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {f}}^{(l+1)}$$\\end{document} are obtained by aggregating information from the features of their neighborhoods \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {f}}^{(l)}$$\\end{document}. Initially, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {f}}^{(0)} = \\varvec{\\mathrm {x}}$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 50,
                    "end": 52,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Soft Labels Generation ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "After going through L layers of feature convolution, we predict the soft labels for each node u based on the output embeddings of nodes:2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{ \\widehat{\\mathrm {y}}}_u = {\\mathrm {softmax}}\\left( {\\varvec{\\mathrm {f}}^{(L)}_{u}}\\right) \\end{aligned}$$\\end{document}\n",
            "cite_spans": [],
            "section": "Soft Labels Generation ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "Now we will present how to leverage the previous generated soft labels for each node to guide the feature aggregation via attention mechanism. The attention network consists of several stacked layers. In each layer, we first aggregate the label information of neighboring nodes. Then we learn the weights for neighborhood aggregation based on both aggregated label information of central nodes and feature embeddings of neighboring nodes.",
            "cite_spans": [],
            "section": "Soft Labels Guided Attention ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "We use a label convolution unit to aggregate the label information of neighboring nodes, and the layer-wise propagation rule is as follows:3\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{\\mathrm {g}}^{(l+1)} = \\sigma \\left( \\widetilde{D}^{-\\frac{1}{2}}\\widetilde{A}\\widetilde{D}^{-\\frac{1}{2}}\\varvec{\\mathrm {g}}^{(l)}W^{(l)}_g\\right) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W^{(l)}_g \\in \\mathbb {R}^{d^{(l)}_g \\times d^{(l+1)}_g}$$\\end{document} is a layer-specific trainable transformation matrix, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm g}^{(l)} \\in \\mathbb {R}^{|V| \\times d^{(l)}_g}$$\\end{document} denotes the hidden representations the label information of nodes. The label information \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {g}}^{(l+1)}$$\\end{document} are obtained by aggregating from the label information \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {g}}^{(l)}$$\\end{document} of neighboring nodes. Initially, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {g}}^{(0)} = {\\mathrm {softmax}}\\left( \\varvec{\\mathrm {f}}^{(L)} \\right) $$\\end{document} according to Eq. 2.",
            "cite_spans": [],
            "section": "Soft Labels Guided Attention ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "Then we use the aggregated label information to guide the feature aggregation via attention mechanism. Unlike the prior graph attention networks [23, 28], we use label information as guidance to learn the weights of neighboring nodes for feature aggregation. We enforce the model to pay more attention to the features closely related to the labels of the central nodes.",
            "cite_spans": [
                {
                    "start": 146,
                    "end": 148,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 150,
                    "end": 152,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Soft Labels Guided Attention ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "A single-layer feedforward neural network is applied to calculate the attention scores between connected nodes based on the central node label information \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {g}}^{(l+1)}$$\\end{document} and the neighboring node features \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {h}}^{(l)}$$\\end{document}:4\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} a_{ij} = {\\mathrm {tanh}}\\left( {\\varvec{\\mathrm {a}}^{(l)}}^{\\top } \\left[ W^{(l)}_t\\varvec{\\mathrm {g}}^{(l+1)}_i \\Vert W^{(l)}_h \\varvec{\\mathrm h}^{(l)}_j\\right] \\right) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {a}}^{(l)} \\in \\mathbb {R}^{2d^{(l+1)}_h} $$\\end{document} is a layer-specific attention vector, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W^{(l)}_t \\in \\mathbb {R}^{d^{(l+1)}_h \\times d^{(l+1)}_g} $$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$W^{(l)}_h \\in \\mathbb {R}^{d^{(l+1)}_h \\times d^{(l)}_h}$$\\end{document} are layer-specific trainable transformation matrices, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varvec{\\mathrm {h}}^{(l)} \\in \\mathbb {R}^{|V| \\times d^{(l)}_h}$$\\end{document} denotes the hidden representations of node features. \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\cdot ^{\\top }$$\\end{document} represents transposition and || is the concatenation operation. Then we obtain the attention weights by normalizing the attention scores with the softmax function:5\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\alpha _{ij} = \\frac{{\\mathrm {exp}}\\left( a_{ij} \\right) }{\\sum _{k \\in N_i}{\\mathrm {exp}}\\left( a_{ik} \\right) } \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N_i$$\\end{document} is the neighborhood of node i in the graph. Then, the embedding of node i can be aggregated by the projected features of neighbors with the corresponding coefficients as follows:6\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{\\mathrm {h}}^{(l+1)}_i = \\sigma \\left( \\sum _{j \\in N_i} \\alpha _{ij} W^{(l)}_h \\varvec{\\mathrm {h}}^{(l)}_j\\right) \\end{aligned}$$\\end{document}Finally, we can achieve better predictions for the labels of each node u by replacing the Eq. 2 as follows:7\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{ \\widehat{\\mathrm {y}}}_u = {\\mathrm {softmax}}\\left( {\\varvec{\\mathrm {f}}^{(L)}_{u}} \\oplus {\\varvec{\\mathrm {h}}^{(L)}_{u}}\\right) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\oplus $$\\end{document} is the mean-pooling aggregator.",
            "cite_spans": [],
            "section": "Soft Labels Guided Attention ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "Grandvalet & Bengio [7] argued that adding an extra loss to minimize the entropy of predictions on unlabeled data can further improve the generalization performance for semi-supervised learning. Thus we estimate pseudo labels for unlabeled nodes based on the learned node representations, and develop a self-training based optimization method to train SLGAT on both labeled and pseudo labeled nodes. Int this way, SLGAT can further benefit from the unlabeled data.",
            "cite_spans": [
                {
                    "start": 21,
                    "end": 22,
                    "mention": "7",
                    "ref_id": "BIBREF29"
                }
            ],
            "section": "Self-training Based Optimization ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "For semi-supervised node classification, we can minimize the cross-entropy loss over all labeled nodes between the ground-truth and the prediction:8\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathcal {L}_{sup} = - \\frac{1}{\\left| V_L\\right| } \\sum _{i \\in V_L} \\sum ^C_{j=1} \\varvec{\\mathrm {y}}_{ij} \\cdot \\log \\varvec{ \\widehat{\\mathrm {y}}}_{ij} \\end{aligned}$$\\end{document}where C is the number of classes.",
            "cite_spans": [],
            "section": "Self-training Based Optimization ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "To achieve training on the composition of labeled and unlabeled nodes, we first estimate the labels of unlabeled nodes using the learned node embeddings as follows:9\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\varvec{ \\widetilde{\\mathrm {y}}}_u = {\\mathrm {softmax}}\\left( \\frac{{\\varvec{\\mathrm {f}}^{(L)}_{u}} \\oplus {\\varvec{\\mathrm {h}}^{(L)}_{u}}}{\\tau }\\right) \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\tau $$\\end{document} is an annealing parameter. We can set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\tau $$\\end{document} to a small value (e.g. 0.1) to further reduce the entropy of pseudo labels. Then the loss for minimizing the entropy of predictions on unlabeled data can be defined as:10\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathcal {L}_{unsup} = - \\frac{1}{\\left| V_U\\right| } \\sum _{i \\in V_U} \\sum ^C_{j=1} \\varvec{ \\widetilde{\\mathrm {y}}}_{ij} \\cdot \\log \\varvec{ \\widehat{\\mathrm {y}}}_{ij} \\end{aligned}$$\\end{document}The joint objective function is defined as a weighted linear combination of the loss on labeled nodes and unlabeled nodes:11\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} \\mathcal {L} = \\mathcal {L}_{sup} + \\lambda \\mathcal {L}_{unsup} \\end{aligned}$$\\end{document}where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\lambda $$\\end{document} is a weight balance factor.\n",
            "cite_spans": [],
            "section": "Self-training Based Optimization ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "We give a self-training based method to train SLGAT which is listed in Algorithm. 1. The inputs to the algorithm are both labeled and unlabeled nodes. We first use labeled nodes to pre-train the model using cross-entropy loss. Then we use the model to generate pseudo labels on unlabeled nodes. Afterward, we train the model by minimizing the combined cross-entropy loss on both labeled and unlabeled nodes. Finally, we iteratively generate new pseudo labels and further train the model.",
            "cite_spans": [],
            "section": "Self-training Based Optimization ::: Proposed Model: SLGAT",
            "ref_spans": []
        },
        {
            "text": "We follow existing studies [12, 23, 29] and use three standard citation network benchmark datasets for evaluation, including Cora, Citeseer and Pubmed. In all these datasets, the nodes represent documents and edges are citation links. Node features correspond to elements of a bag-of-words representation of a document. Class labels correspond to research areas and each node has a class label. In each dataset, 20 nodes from each class are treated as labeled data. The statistics of datasets are summarized in Table 1.\n",
            "cite_spans": [
                {
                    "start": 28,
                    "end": 30,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 32,
                    "end": 34,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 36,
                    "end": 38,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Datasets ::: Experiments",
            "ref_spans": [
                {
                    "start": 517,
                    "end": 518,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "We compare against several traditional graph-based semi-supervised classification methods, including manifold regularization (ManiReg) [1], semi-supervised embedding (SemiEmb) [25], label propagation (LP) [32], graph embeddings (DeepWalk) [16], iterative classification algorithm (ICA) [13] and Planetoid [29].",
            "cite_spans": [
                {
                    "start": 136,
                    "end": 137,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 177,
                    "end": 179,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 206,
                    "end": 208,
                    "mention": "32",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 240,
                    "end": 242,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 287,
                    "end": 289,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 306,
                    "end": 308,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Baselines ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "Furthermore, since graph neural networks are proved to be effective for semi-supervised classification, we also compare with several state-of-arts graph neural networks including ChebyNet [4], MoNet [15], graph convolutional networks (GCN) [12], graph attention networks (GAT) [23], graph wavelet neural network (GWNN) [27], shortest path graph attention network (SPAGAN) [28] and graph convolutional networks using heat kernel (GraphHeat) [27].",
            "cite_spans": [
                {
                    "start": 189,
                    "end": 190,
                    "mention": "4",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 200,
                    "end": 202,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 241,
                    "end": 243,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 278,
                    "end": 280,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 320,
                    "end": 322,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 373,
                    "end": 375,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 441,
                    "end": 443,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                }
            ],
            "section": "Baselines ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "We train a two-layer SLGAT model for semi-supervised node classification and evaluate the performance using prediction accuracy. The partition of datasets is the same as the previous studies [12, 23, 29] with an additional validation set of 500 labeled samples to determine hyper-parameters.",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 194,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 196,
                    "end": 198,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 200,
                    "end": 202,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Experimental Settings ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "Weights are initialized following Glorot and Bengio [6]. We adopt the Adam optimizer [11] for parameter optimization with initial learning rate as 0.05 and weight decay as 0.0005. We set the hidden layer size of features as 32 for Cora and Citeseer and 16 for Pubmed. We set the hidden layer size of soft labels as 16 for Cora and Citeseer and 8 for Pubmed. We apply dropout [20] with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p = 0.5$$\\end{document} to both layers inputs, as well as to the normalized attention coefficients. The proper setting of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\lambda $$\\end{document} in Eq. 11 affects the semi-supervised classification performance. If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\lambda $$\\end{document} is too large, it disturbs training for labeled nodes. Whereas if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\lambda $$\\end{document} is too small, we cannot benefit from unlabeled data. In our experiments, we set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\lambda = 1$$\\end{document}. We anticipate the results can be further improved by using sophisticated scheduling strategies such as deterministic annealing [7], and we leave it as future work. Furthermore, inspired by dropout [20], we ignore the loss in Eq. 10 with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p = 0.5$$\\end{document} during training to prevent overfitting on pseudo labeled nodes.",
            "cite_spans": [
                {
                    "start": 53,
                    "end": 54,
                    "mention": "6",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 86,
                    "end": 88,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 376,
                    "end": 378,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 2298,
                    "end": 2299,
                    "mention": "7",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 2368,
                    "end": 2370,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Experimental Settings ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "We now validate the effectiveness of SLGAT on semi-supervised node classification task. Following the previous studies [12, 23, 29], we use the classification accuracy metric for quantitative evaluation. Experimental results are summarized in Table 2. We present the mean classification accuracy (with standard deviation) of our method over 100 runs. And we reuse the results already reported in [5, 12, 23, 27, 28] for baselines.\n",
            "cite_spans": [
                {
                    "start": 120,
                    "end": 122,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 124,
                    "end": 126,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 128,
                    "end": 130,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 397,
                    "end": 398,
                    "mention": "5",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 400,
                    "end": 402,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 404,
                    "end": 406,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 408,
                    "end": 410,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 412,
                    "end": 414,
                    "mention": "28",
                    "ref_id": "BIBREF20"
                }
            ],
            "section": "Semi-supervised Node Classification ::: Experiments",
            "ref_spans": [
                {
                    "start": 249,
                    "end": 250,
                    "mention": "2",
                    "ref_id": "TABREF1"
                }
            ]
        },
        {
            "text": "We can observe that our SLGAT achieves consistently better performance than all baselines. When directly compared to GAT, SLGAT gains 1.0%, 2.3% and 3.2% improvements for Cora, Citeseer and Pubmed respectively. The performance gain is from two folds. First, SLGAT uses soft labels to guide the feature aggregation of neighboring nodes. This indeed leads to more discriminative node representations. Second, SLGAT is trained on both labeled and pseudo labeled nodes using our proposed self-training based optimization method. SLGAT benefits from unlabeled data by minimizing the entropy of predictions on unlabeled nodes.",
            "cite_spans": [],
            "section": "Semi-supervised Node Classification ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "Following Shchur et al. [18], we also further validate the effectiveness and robustness of SLGAT on random data splits. We created 10 random splits of the Cora, Citeseer, Pubmed with the same size of training, validation, test sets as the standard split from Yang et al. [29]. We compare SLGAT with other most related competitive baselines including GCN [12] and GAT [23] on those random data splits.1 We run each method with 10 random seeds on each data split and report the overall mean accuracy in Table 3. We can observe that SLGAT consistently outperforms GCN and GAT on all datasets. This proves the effectiveness and robustness of SLGAT.\n",
            "cite_spans": [
                {
                    "start": 25,
                    "end": 27,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 272,
                    "end": 274,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 355,
                    "end": 357,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 368,
                    "end": 370,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "Classification Results on Random Data Splits ::: Experiments",
            "ref_spans": [
                {
                    "start": 507,
                    "end": 508,
                    "mention": "3",
                    "ref_id": "TABREF2"
                }
            ]
        },
        {
            "text": "In this section, we conduct an ablation study to investigate the effectiveness of our proposed soft label guided attention mechanism and the self-training based optimization method for SLGAT. We compare several variants of SLGAT on node classification, and the results are reported in Table 4.\n",
            "cite_spans": [],
            "section": "Ablation Study ::: Experiments",
            "ref_spans": [
                {
                    "start": 291,
                    "end": 292,
                    "mention": "4",
                    "ref_id": "TABREF3"
                }
            ]
        },
        {
            "text": "We observe that SLGAT has better performance than the methods without soft labels guided attention in most cases. This demonstrates that using soft labels to guide the neighboring nodes aggregation is effective for generating better node embeddings. Note that attention mechanism seems has little contribution to performance on Pubmed when using self-training. The reason behind such phenomenon is still under investigation, we presume that it is due to the label sparsity of Pubmed.2 The similar phenomenon is reported in [23] that GAT has little improvement on Pubmed compared to GCN.",
            "cite_spans": [
                {
                    "start": 524,
                    "end": 526,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "Ablation Study ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "We also observe that SLGAT significantly outperforms all the methods without self-training. This indicates that our proposed self-training based optimization method is much effective to improve the generalization performance of the model for semi-supervised classification.",
            "cite_spans": [],
            "section": "Ablation Study ::: Experiments",
            "ref_spans": []
        },
        {
            "text": "In this work, we propose SLGAT for semi-supervised node representation learning. SLGAT uses soft labels to guide the feature aggregation of neighboring nodes for generating discriminative node representations. A self-training based optimization method is proposed to train SLGAT on both labeled data and pseudo labeled data, which is effective to improve the generalization performance of SLGAT. Experimental results demonstrate that our SLGAT achieves state-of-the-art performance on several semi-supervised node classification benchmarks. One direction of the future work is to make SLGAT going deeper to capture the features of long-range neighbors. This perhaps helps to improve performance on the dataset with sparse labels.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: The Statistics of Datasets.\n",
            "type": "table"
        },
        "TABREF1": {
            "text": "Table 2.: Semi-supervised node classification accuracies (%).\n",
            "type": "table"
        },
        "TABREF2": {
            "text": "Table 3.: Classification results on random data splits (%).\n",
            "type": "table"
        },
        "TABREF3": {
            "text": "Table 4.: Ablation study results of node classification (%).\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: The overall architecture of SLGAT.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Manifold regularization: a geometric framework for learning from labeled and unlabeled examples",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Belkin",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Niyogi",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Sindhwani",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. Mach. Learn. Res.",
            "volume": "7",
            "issn": "",
            "pages": "2399-2434",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Dropout: a simple way to prevent neural networks from overfitting",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Srivastava",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Hinton",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Krizhevsky",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Sutskever",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Salakhutdinov",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "J. Mach. Learn. Res.",
            "volume": "15",
            "issn": "1",
            "pages": "1929-1958",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "Deep learning via semi-supervised embedding",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Weston",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Ratle",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Mobahi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Collobert",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Neural Networks: Tricks of the Trade",
            "volume": "",
            "issn": "",
            "pages": "639-655",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF27": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF28": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF29": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF30": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF31": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}