{
    "paper_id": "e8270c976e88630695cf1f7c4f4473d4ccd5e520",
    "metadata": {
        "title": "Heuristics for Reversal Distance Between Genomes with Duplicated Genes",
        "authors": [
            {
                "first": "Gabriel",
                "middle": [],
                "last": "Siqueira",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Campinas",
                        "country": "Brazil"
                    }
                },
                "email": "gabriel.siqueira@students.ic.unicamp.br"
            },
            {
                "first": "Klairton",
                "middle": [],
                "last": "Lima Brito",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Campinas",
                        "country": "Brazil"
                    }
                },
                "email": ""
            },
            {
                "first": "Ulisses",
                "middle": [],
                "last": "Dias",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Limeira",
                        "country": "Brazil"
                    }
                },
                "email": "ulisses@ft.unicamp.br"
            },
            {
                "first": "Zanoni",
                "middle": [],
                "last": "Dias",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Campinas",
                        "country": "Brazil"
                    }
                },
                "email": "zanoni@ic.unicamp.br"
            }
        ]
    },
    "abstract": [
        {
            "text": "In comparative genomics, one goal is to find similarities between genomes of different organisms. Comparisons using genome features like genes, gene order, and regulatory sequences are carried out with this purpose in mind.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Genome rearrangements are mutational events that affect large extensions of the genome. They are responsible for creating extant species with conserved genes in different positions across genomes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Close species-from an evolutionary point of view-tend to have the same set of genes or share most of them. When we consider gene order to compare two genomes, it is possible to use a parsimony criterion to estimate how close the species are. We are interested in the shortest sequence of genome rearrangements capable of transforming one genome into the other, which is named rearrangement distance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Reversal is one of the most studied genome rearrangements events. This event acts in a segment of the genome, inverting the position and possibly the orientation of genes in it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "When the genome has no gene repetition, a common approach is to map it as a permutation such that each element represents a conserved block.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "When genomes have replicated genes, this mapping is usually performed using strings. The number of replicas depends on the organisms being compared, but in many scenarios, it tends to be small. In this work, we study the reversal distance between genomes with duplicated genes considering that the orientation of genes is unknown. We present three heuristics that use techniques like genetic algorithms and local search. We conduct experiments using a database of simulated genomes and compared our results with other algorithms from the literature.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The question that naturally arises when comparing the genomes of two organisms is how to estimate the sequence of mutational events that have occurred during evolution to transform one genome into another, or at least estimate the evolutionary distance between these genomes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A way of estimating the evolutionary distance is to use a parsimony criterion and to compute a minimum sequence of events that transforms one genome into another. When large-scale mutational events are considered, the so-called genome rearrangements, this distance is called rearrangement distance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A genome can be represented in different ways [6] . When the genome is treated as an ordered sequence of genes, it is possible to find scenarios where certain genes have multiple copies. In this case, it is common to adopt a representation in the form of a string, such that each character is associated with a specific gene. If each gene occurs only once, we can associate an integer number for each one and the representation is given in the form of a permutation. In both cases (string or permutation), if the orientation of the genes is known, a positive or negative sign is assigned to each element and the representation is called signed (signed string and signed permutation). Otherwise, the sign is omitted and the representation is called unsigned (unsigned string and unsigned permutation).",
            "cite_spans": [
                {
                    "start": 46,
                    "end": 49,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Reversal is a rearrangement event that breaks a chromosome at two locations and reassembles the middle piece in the reversed order. Several rearrangement problems considering only reversals were investigated over time [1] [2] [3] 8, 11] . When representing genomes as permutations, the goal is to determine the minimum number of reversals needed to sort any permutation.",
            "cite_spans": [
                {
                    "start": 218,
                    "end": 221,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 222,
                    "end": 225,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 226,
                    "end": 229,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 230,
                    "end": 232,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 233,
                    "end": 236,
                    "text": "11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this case, we have the Sorting Signed Permutations by Reversals and Sorting Unsigned Permutations by Reversals problems. The former is solvable in polynomial time [8] , whereas the latter is NP-hard [3] . The best algorithm for the latter has an approximation factor of 1.375 [2] .",
            "cite_spans": [
                {
                    "start": 166,
                    "end": 169,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 202,
                    "end": 205,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 279,
                    "end": 282,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In genomes with replicated genes, when we have the same number of replicas of each gene in both genomes, the goal is to determine the minimum number of reversals needed to transform one genome into another.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The Reversal Distance for Unsigned Strings problem is NP-hard even if we consider a binary alphabet [5] . A binary alphabet means that all genes are replicas of just two types, so the genome can be mapped using only two values (e.g.",
            "cite_spans": [
                {
                    "start": 100,
                    "end": 103,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Unlike Sorting Signed Permutations by Reversals problem which has an exact polynomial-time algorithm, the Reversal Distance for Signed Strings problem is NP-hard [15] . Chen et al. [4] proved that Reversal Distance for Signed Strings is NP-hard even if we consider the simplest case where at most two replicas are allowed for each gene (duplicated genes). The authors also showed that the Reversal Distance for Signed Strings and the Minimum Common String Partition (MCSP) problems are related. The Reversal Distance for Unsigned Strings and Reverse MCSP [11] problems are also related. Based on this information, an approximation algorithm for the Reversal Distance in Signed and Unsigned Strings problems were presented with a factor of \u0398(k), where k represents the maximum number of copies of a character in the strings given as input to the algorithms [12] .",
            "cite_spans": [
                {
                    "start": 162,
                    "end": 166,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 181,
                    "end": 184,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 555,
                    "end": 559,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 856,
                    "end": 860,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "{0,1})."
        },
        {
            "text": "In this paper, we investigate the Reversal Distance for Unsigned Strings problem considering duplicated genes. We propose three heuristics based on different techniques, and to verify the behavior of our heuristics we have created a database that simulates different scenarios. Our results were compared with others from the literature [4] .",
            "cite_spans": [
                {
                    "start": 336,
                    "end": 339,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "{0,1})."
        },
        {
            "text": "This manuscript is organized as follows. Section 2 provides definitions that are used throughout the paper. Section 3 describes the heuristics. Section 4 shows the experimental results, and Sect. 5 concludes the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "{0,1})."
        },
        {
            "text": "A genome G is represented by a string S, where each character in S corresponds to a gene or block of genes in G. An alphabet \u03a3 S is the set of distinct characters of S. We denote by S i the i-th character in S, and by |S| the number of characters. We represent genome rearrangement events as operations applied to strings. This way, a rearrangement event \u03c1 applied to a string S is denoted as S \u2022 \u03c1. Definition 6. A reversal \u03c1(i, j), with 1 \u2264 i < j \u2264 |S|, is an operation that inverts the order of elements in a segment of the string S. From now on, we refer to the reversal distance only by distance. This work deals with balanced strings S such that occ(S) \u2264 2. Every genome with multiple copies of a gene can be mapped into a string. We step forward and map the string into a permutation. To do that, we keep the characters without duplicates untouched and map each replica of duplicated characters into new values.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "Assuming two replicas of a character \u03b1, there are two possible mappings of \u03b1 into new values \u03b1 and \u03b1 . The mapping of all duplicated characters in S is represented by a vector m with size |dup(S)|. In m we place the value 0 or 1 to indicate for each duplicated character which of the two possible maps will be used. If the value associated with the character \u03b1 in m is 0, the first and the second occurrences will be replaced by \u03b1 and \u03b1 , respectively. Otherwise, the first and second occurrences will be mapped as \u03b1 and \u03b1 , respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "We denote by m \u03b1 the chosen map of the duplicate character \u03b1 in m and by S m the permutation generated by mapping S according to m. Example 11. We obtain S m , S v , and S z from S using maps m, v, and z, respectively. Note that (m, v) and (v, z) are neighbors, but (m, z) are not.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "Although the task that models genomes as permutations does not allow duplicated genes, we can perform a mapping of the strings into permutations by assigning new values to replicas. We base our heuristics on the fact that if we obtain two permutations S m and P p from two strings S and P using the maps m and p, respectively, then the sequence of reversals that turns S m into P p also transforms S into P . Therefore, d(S, P ) \u2264 d(S m , P p ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristic Approaches"
        },
        {
            "text": "Note that, there exist maps such that d(S, P ) = d(S m , P p ). Such maps could be derived from a shortest sequence of reversals transforming S in P.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Heuristic Approaches"
        },
        {
            "text": "A sequence of reversals transforming S m into P p and S into P . To find the distance between two strings we must find the map of the strings in the permutations with the smallest distance. We use as a distance estimator for the Sorting Unsigned Permutations by Reversals problem an approximation algorithm with factor 2 developed by Kececioglu and Sankoff [10] , which we will call KS95. We chose this algorithm because its results in practice are good and its execution time is fast, which serves our purpose of creating simple heuristics that provide solutions in a fast way. However, another much more complicated algorithm with a better approximation ratio is known [2] .",
            "cite_spans": [
                {
                    "start": 357,
                    "end": 361,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 671,
                    "end": 674,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Example 12."
        },
        {
            "text": "Our heuristics share a common goal: find a map of strings into permutations that results in a good solution. Sections 3.1, 3.2, and 3.3 present heuristics using Random Maps, Local Search, and Genetic Algorithms, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Example 12."
        },
        {
            "text": "This heuristic randomly generates several maps of the source string into permutations, and a single random map of the target string. After that, the heuristic estimates the distance between each source permutation and the target permutation using KS95. In the end, the heuristic selects the solution with smallest distance. In case of a tie, the heuristic selects one of the best solutions randomly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Random Maps (RM)"
        },
        {
            "text": "The inputs are the strings S and P , and a parameter r \u2208 N that define the total number of random maps for the source string. The random maps are generated as follows: for each position of the map, the values 0 and 1 are assigned with same probability. Initially, the target string P is mapped into a permutation P p using a random map p. Next, r random maps of the source string S are generated and stored in a set M. For each map m \u2208 M, the distance between the permutations S m and P p is computed using KS95. The result for S and P is the shortest distance between the permutations. Figure 1 shows a simulation of the heuristic for S = ( 3 2 1 2 4 3 4) and P = (1 3 4 2 2 4 3). The heuristic finds that d(S, P ) \u2264 d(S m , P p ) \u2264 4. The random mapping process described in this heuristic will be used as subroutines by other heuristics.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 587,
                    "end": 595,
                    "text": "Figure 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Random Maps (RM)"
        },
        {
            "text": "This heuristic enhances the Random Maps by generating maps through local search technique and not exclusively in a random way. The idea is to create new maps by selecting some of the current ones to have their neighborhoods explored.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Local Search (LS)"
        },
        {
            "text": "Inputs are strings S and P , and the parameters r, c, l \u2208 N. Parameters r, c, and l determine the total number of maps that will be created, the number of maps randomly generated, and the maximum number of neighbors explored in each local search, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Local Search (LS)"
        },
        {
            "text": "Initially, the heuristic behaves like the Random Maps heuristic: (i) the target string P is mapped into a permutation P p using a random map p, and (ii) a set M is generated with c random maps of the source string S into permutations. Note that M is composed of only c randomly generated maps, but this set must contain r distinct maps. To generate r \u2212 c maps the heuristic performs a local search on the best solutions found so far as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Local Search (LS)"
        },
        {
            "text": "1. In each iteration, the heuristic ranks the maps using the algorithm KS95. 2. The heuristic selects the best map and explores up to l neighbor maps, adding them to M. This process ends when the set M has r distinct maps. 3. The heuristic keeps a list of the maps that have already been explored. Thus, it ensures that a map is explored only once. This behavior is important to explore the neighborhood of other maps that are also good.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Local Search (LS)"
        },
        {
            "text": "Note that a map created through local search in one iteration can have the neighborhood explored in future iterations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Local Search (LS)"
        },
        {
            "text": "Similarly to Random Maps heuristic, the result for the distance between the strings S and P is the shortest distance calculated between the permutations resulting from maps in M and the permutation P p . Adopting the parameter l = 2, the heuristic chooses the maps n and n to add into M, filling the set with r = 5 distinct maps. In that case, the heuristic finds that d(S, P ) \u2264 d(S n , P p ) \u2264 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Local Search (LS)"
        },
        {
            "text": "This heuristic is modeled using Genetic Algorithm metaheuristic [13] to generate the maps. This meta-heuristic is widely used on combinatorial optimization problems [9, 14] and has already been used in problems of genome rearrangement [7] .",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 68,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 165,
                    "end": 168,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 169,
                    "end": 172,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 235,
                    "end": 238,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "A genetic algorithm is a search heuristic inspired by the theory of evolution. It uses features like mutations, inheritance of parents characteristics, and selection of fittest individuals for reproduction, to name a few.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "The inputs are the strings S and P , and the parameters c, k, r, t m , t c \u2208 N. The parameter c is the initial population size, k is the number of individuals selected in a given population, and r is the total number of maps created for the source string. The parameters t m and t c are used in the mutations and crossovers, respectively. The population size, in each generation, is 5k 2 . Once r is reached, the algorithm stops and the best result so far is returned.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "We describe our genetic algorithm considering five features: initial population, fitness function, selection, crossover, and mutation. Figure 3 shows a flowchart of the interactions between each phase to obtain a solution using the genetic algorithm technique. We developed a heuristic where each individual in the population is represented by the mapping of the source string S into a permutation. We also used a single random map p of the target string P into a permutation P p .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 135,
                    "end": 143,
                    "text": "Figure 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "-Initial Population: is generated c random maps of the source string S into distinct permutations. The process of generating random maps is the same as that used in the Random Maps heuristic.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "-Fitness Function: each individual receives a score based on a fitness function. The fitness function assigns a score to an individual m of the population as follows: m score = 1 d(S m ,P p )+1 , such that d(S m , P p ) is computed using the KS95 algorithm. Maps that result in solutions with smaller number of reversals receive higher scores and tend to transmit their characteristics to future generations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "-Selection: at this stage, the top k highest scored individuals are selected to the next generation, and the others are discarded. In cases of ties, the heuristic arbitrarily selects the required number of individuals among the tied ones. -Crossover: at this phase, the population has the k highest scored individuals.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "To perform the re-population, individuals are arbitrarily paired for crossovers. Given two maps m and m with x = dup(S) = dup(P ) bits, the crossover generates a new individual with t c bits randomly selected from m and the remaining x \u2212 t c from m . The heuristic repeats this process until r maps are generated. Afterwards, the individual m with the highest score is selected to obtain a solution computing the distance between S m and P p using the KS95 algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Genetic Algorithm (GA)"
        },
        {
            "text": "We present our test methodology and the results obtained by our heuristics. In the end, we compare our results with others from the literature.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "Our database comprises 10 sets of 1000 pairs of strings (source and target). Each set has strings of different sizes ranging from 100 to 1000 in intervals of 100. Strings have 25% of duplicated characters, so |dup(S)| = |S| 4 . Each pair of source and target strings was created as follows: we randomly distributed the values {1, 2, . . . , 3|S| 4 , 1, 2, . . . , |S| 4 } to create the source string S, and we applied a total of |S| 4 random reversals (the parameters i and j being chosen randomly) to generate the target string P .",
            "cite_spans": [
                {
                    "start": 341,
                    "end": 345,
                    "text": "3|S|",
                    "ref_id": null
                },
                {
                    "start": 364,
                    "end": 369,
                    "text": "|S| 4",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Database"
        },
        {
            "text": "Random Maps, Local Search, and Genetic Algorithm heuristics share a common r parameter, which represents the total number of maps that are generated. This parameter should have the same number set for us to be able to compare the heuristics. In other words, heuristics must explore the same number of maps, so we may estimate the gain of each model in choosing good maps to investigate. We assigned r = 10|S| for each source string S during the experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Model Tuning"
        },
        {
            "text": "Other ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Model Tuning"
        },
        {
            "text": "For comparison purposes, we implemented the Kolman and Wale\u0144 algorithm [12] (called HS) and an adaptation of the SOAR algorithm [4] . This adaptation was performed to consider the Reverse MCSP [11] instead of MCSP problem [4] in order to address the unsigned version of the Reversal Distance for Strings problem.",
            "cite_spans": [
                {
                    "start": 71,
                    "end": 75,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 128,
                    "end": 131,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 193,
                    "end": 197,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 222,
                    "end": 225,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "The abbreviations RM, LS, and GA refer to Random Maps, Local Search, and Genetic Algorithm heuristics, respectively. Table 1 shows the average distance provided by the heuristics, HS, and SOAR using our database as input.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 117,
                    "end": 124,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Results"
        },
        {
            "text": "The OP column shows the number of random reversals used to create each instance. The line (DEE avg ) represents the average distance estimation error. For an instance (S, P ), the distance estimation error is calculated as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": ", such that D H is the distance estimation for the instance (S, P ) computed by our heuristics and SOAR algorithm. The distance estimation error shows, as a percentage of the number of reversals applied to create the instance, From the results, we can see that although the HS algorithm guarantees an approximation to the solution by a multiplicative factor \u0398(k), in practice, the results of the other algorithms were better. This result was probably caused by the fact that the constant associated with function \u0398(k) has a high value.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "Genetic Algorithm (GA) and Local Search (LS) are better than SOAR and RM in all sets, which clearly indicates that the more sophisticated rules added in GA and LS succeed. On average, these strategies provide values very close to the number of reversals applied to generate the instances. This can be evidenced by observing the average distance estimation error (DEE avg ) which, considering all instances, shows GA and LS heuristics with a percentage of 2.88% and 3.87%, respectively. We also can note that GA generates the best distance estimator (closest to OP) for all sets tested.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "The heuristics LS and GA presented a far better performance than the previous know methods for estimate the evolutionary distance between genomes with duplicated genes, considering the reversal event.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "We also performed tests with different values for the parameter r ranging from 5|S| up to 50|S|, but the best trade-off between solution quality and runtime was observed adopting r = 10|S|.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "We presented three heuristics for the Reversal Distance for Unsigned Strings with Duplicated Genes problem. We performed experiments with a database created to simulate genomes with different characteristics. We compared the results obtained by our heuristics with results from the literature. The comparison shows that our heuristic based on local search and genetic algorithms techniques tend to produce very good solutions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "As future works, we plan to extend the heuristics by considering other genome rearrangement events (e.g., transposition, insertion, and deletion), other metaheuristics, and by investigating the problem having more than two copies for each character.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "A very elementary presentation of the Hannenhalli-Pevzner theory",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bergeron",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Discrete Appl. Math",
            "volume": "146",
            "issn": "2",
            "pages": "134--145",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "1.375-Approximation algorithm for sorting by reversals",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Berman",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hannenhalli",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Karpinski",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "ESA 2002",
            "volume": "2461",
            "issn": "",
            "pages": "200--210",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-45749-6_21"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Sorting permutations by reversals and Eulerian cycle decompositions",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Caprara",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "SIAM J. Discrete Math",
            "volume": "12",
            "issn": "1",
            "pages": "91--110",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Assignment of orthologous genes via genome rearrangement",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Fu",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Nan",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zhong",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Lonardi",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinform",
            "volume": "2",
            "issn": "4",
            "pages": "302--315",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Sorting strings by reversals and by transpositions",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "A"
                    ],
                    "last": "Christie",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "W"
                    ],
                    "last": "Irving",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "SIAM J. Discrete Math",
            "volume": "14",
            "issn": "2",
            "pages": "193--206",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Combinatorics of genome rearrangements",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Fertin",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Labarre",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Rusu",
                    "suffix": ""
                },
                {
                    "first": "\u00c9",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Vialette",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Computational Molecular Biology",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Ancestral genome inference using a genetic algorithm approach",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Gao",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Yang",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "PLOS ONE",
            "volume": "8",
            "issn": "5",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Transforming cabbage into turnip: polynomial algorithm for sorting signed permutations by reversals",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hannenhalli",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "A"
                    ],
                    "last": "Pevzner",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "J. ACM",
            "volume": "46",
            "issn": "1",
            "pages": "1--27",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Parallel genetic algorithms applied to the traveling salesman problem",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Jog",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Suh",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Van Gucht",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "SIAM J. Optimization",
            "volume": "1",
            "issn": "",
            "pages": "515--529",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Exact and approximation algorithms for sorting by reversals, with application to genome rearrangement",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "D"
                    ],
                    "last": "Kececioglu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sankoff",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Algorithmica",
            "volume": "13",
            "issn": "",
            "pages": "180--210",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Approximating reversal distance for strings with bounded number of duplicates",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Kolman",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wale\u0144",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Discrete Appl. Math",
            "volume": "155",
            "issn": "3",
            "pages": "327--336",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Reversal distance for strings with duplicates: linear time approximation using hitting set",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Kolman",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Wale\u0144",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "WAOA 2006",
            "volume": "4368",
            "issn": "",
            "pages": "279--289",
            "other_ids": {
                "DOI": [
                    "10.1007/11970125_22"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "An Introduction to Genetic Algorithms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Mitchell",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "A genetic algorithm for the flexible jobshop scheduling problem",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Pezzella",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Morganti",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ciaschetti",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Comput. Oper. Res",
            "volume": "35",
            "issn": "10",
            "pages": "3202--3212",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Reversals and transpositions over finite alphabets",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "J"
                    ],
                    "last": "Radcliffe",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "D"
                    ],
                    "last": "Scott",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "L"
                    ],
                    "last": "Wilmer",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "SIAM J. Discrete Math",
            "volume": "19",
            "issn": "1",
            "pages": "224--244",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "A string S and some information we retrieve from it. , \u03a3 S = {1, 2, 3, 4, 5}, |S| = 7, S 3 = 1 , S 5 = 4.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "The occurrence of a character \u03b1 in a given string S, denoted by occ(\u03b1, S), represents the number of copies of \u03b1 in S. The greatest occurrence of a character in S is denoted by occ(S) = max \u03b1\u2208\u03a3S (occ(\u03b1, S)).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "We denote by dup(S) the set of duplicated characters of S, i.e. the characters that appear exactly twice in S. Therefore, dup(S) = {\u03b1 : occ(\u03b1, S) = 2, \u2200\u03b1 \u2208 S}.In Example 1, we have occ(S) = 2, and dup(S) = {4, 5}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "A pair of strings S and P are balanced if they have the same alphabet (\u03a3 S = \u03a3 P = \u03a3) and the occurrence of each character is the same for both strings. Therefore, occ(\u03b1, S) = occ(\u03b1, P ), \u2200 \u03b1 \u2208 \u03a3.Example 5. Consider three strings S, P , and Q. Observe that S and P are balanced while S and Q are not, since the occurrences of character 1 in the strings S and Q are different (occ(1, S) = occ(1, Q)). \u03a3 S = \u03a3 P = \u03a3 Q",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": ". A reversal \u03c1(2, 4) applied on a string S. Given two strings S and P , the reversal distance between S and P , denoted by d(S, P ), is the size of a shortest sequence of reversals capable of transforming S into P .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "A map m being applied to a string S and the permutation S m obtained. Given a string S and two maps m and v. We say that m and v are neighbors if they differ by exactly one duplicated character map. In other words, \u2203\u03b1 \u2208 dup(S) : m \u03b1 = v \u03b1 and m \u03b2 = v \u03b2 , \u2200 \u03b2 =\u03b1 .",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "d(S m , P p ) \u2264 5 d(S m , P p ) \u2264 5 d(S m , P p )",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Example of random maps heuristic with r = 3.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "d(S n , P p ) \u2264 3 d(S o , P p ) \u2264 5 d(S n , P p ) \u2264 5 d(S m , P p ) \u2264 7 d(S n , P p )",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Example of local search heuristic with r = 5, c = 3, and l = 2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "illustrates this heuristic in a pair of strings S = (3 2 1 2 4 3 4 1) and P = (1 3 4 2 1 2 4 3). The initial set M = {m, n, o} is compose of 3 randomly generated maps. From M, the map n is selected to have the neighborhood explored. Set N = {n , n , n } represents all neighboring maps of n that are not yet in M.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Flowchart of genetic algorithm phases.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "Maps m and m of a string S = (Mutation: after crossover, each of the k individuals selected from the past generation gives rise to a new individual by inverting the values of t m bits chosen randomly. Example 14. A map n generated by a mutation in a map m of a string S",
            "latex": null,
            "type": "figure"
        },
        "FIGREF14": {
            "text": "parameters of Local Search and Genetic Algorithm heuristics were selected using a grid search. For Local Search heuristic parameters c and l, we swept through the set {10, 20, ..., 100}. For the Genetic Algorithm heuristic, k was investigated in {10, 20, ..., 100}, c in {10, 20, ..., 100}, t m in {1, 2, ..., 10}, and t c in { 0.1d , 0.2d , ..., d}, where d = |dup(S)| = |dup(P )|. The grid search was performed in the sets of strings of sizes 400, 500, and 600. We obtained the following parameters: -Local Search: c = 90 and l = 30; -Genetic Algorithm: c = 90, k = 50, t m = 2, and t c = 0.4d .",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Results provided by our heuristics and by SOAR.how far the heuristics and SOAR algorithm have distanced from OP, either for more or less.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}