{
    "paper_id": "2c32f61959e0bc0921666c10e5a4e5ca5a87f5bf",
    "metadata": {
        "title": "Assessing Centrality Without Knowing Connections Supplemental Materials A Non-Private Multi-Party Protocol",
        "authors": [
            {
                "first": "Leyla",
                "middle": [],
                "last": "Roohi",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Melbourne",
                    "location": {
                        "settlement": "VIC",
                        "country": "Australia"
                    }
                },
                "email": "leyla.roohi@unimelb.edu.au"
            },
            {
                "first": "]",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Melbourne",
                    "location": {
                        "settlement": "VIC",
                        "country": "Australia"
                    }
                },
                "email": ""
            },
            {
                "first": "Benjamin",
                "middle": [
                    "I P"
                ],
                "last": "Rubinstein",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "The University of Melbourne",
                    "location": {
                        "settlement": "VIC",
                        "country": "Australia"
                    }
                },
                "email": "benjamin.rubinstein@unimelb.edu.au"
            }
        ]
    },
    "abstract": [
        {
            "text": "We first show how different parties can compute EBC without preserving privacy, but with special attention to efficiency (so as to improve on a na\u00efve application of the two-party protocol of [2]).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "A party \u03b2 that contains a node j can always count the number of 2-step paths through j, but it doesn't know which of the nodes adjacent to j are in the ego-network of a (except in some special cases). So in order for \u03b2 to count the number of 2-paths in a's ego network that pass through j, we require each other party \u03b1 to tell \u03b2 which of its nodes are neighbours of a. This is denoted by R \u03b1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Recall that N a denotes the ego network of a anywhere in the graph (not including a since the graph has no self-loops). Figure 1 summarises the following protocol.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 120,
                    "end": 128,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Protocol 1 All parties execute in parallel, waiting until they have received all messages from one step before commencing the next step. Party \u03b1 proceeds as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "i.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "[EgoNetwork] \u03b1 broadcasts to every party the set R \u03b1 of neighbours of a contained within \u03b1; ii.",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "[PathCount] For all nodes i, j \u2208 \u03b2\u2208A R \u03b2 s.t. i < j, party \u03b1 computes T i,j \u03b1 , the number of 2-paths from i to j where the intermediate point k \u2208 R \u03b1 (irrespective of whether i, j are directly connected). It sends T i,j \u03b1 to the part\u0177 \u03b2 for which i \u2208 V\u03b2; iii. [ReciprocateAndSum] For every i \u2208 R \u03b1 and all j > i, \u03b1 computes the total number of 2-paths between i, j provided these nodes are disconnected: it sums T i,j \u03b2 for all \u03b2 \u2208 A. It then sets S \u03b1 to be the reciprocal of this sum and broadcasts this value to all parties; iv. \u03b1 completes the computation of EBC(a) as \u03b1\u2208A S \u03b1 .",
            "cite_spans": [
                {
                    "start": 261,
                    "end": 280,
                    "text": "[ReciprocateAndSum]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Participants can easily tell when to move on to the next step. At the end of",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Step ii, party \u03b1 should have received T i,j \u03b2 , from each other party\u03b2, for each node i \u2208 R * \u03b1 , and each j \u2208 \u222a \u03b2\u2208A R \u03b2 with j > i. By the end of Step iii it should have received a broadcast value from all other parties. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": ""
        },
        {
            "text": "Now consider how the privacy of edges can be compromised in the first three steps of Protocol 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B Privacy Disclosure"
        },
        {
            "text": "i. When R \u03b1 is broadcast in Step i, other parties learn directly of all edges incident to a in \u03b1. ii. When T ij \u03b1 is sent to\u03b2 in",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B Privacy Disclosure"
        },
        {
            "text": "Step ii, it reveals information about edges outside\u03b2. A worst case occurs for node i when there is only one node k \u2208 \u03b1 connected to it. Then T ij \u03b1 reveals the existence of edge j, k for all j > i. iii. When \u03b1 broadcasts S \u03b1 , it reveals the connection status of edges within \u03b1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B Privacy Disclosure"
        },
        {
            "text": "In the worst case when there is just two nodes i and j in \u03b1, an edge between them can change S \u03b1 from a non zero value to zero.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B Privacy Disclosure"
        },
        {
            "text": "Observe that since the V \u03b1 form a disjoint partition of V , that for any",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C Proof of Proposition 1"
        },
        {
            "text": "Combining this with the independence of the concurrent executions of Subse-tRelease, we have that the joint density over their releases corresponds to",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C Proof of Proposition 1"
        },
        {
            "text": "Due to uniqueness of probability density normalisation, this proves the result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "C Proof of Proposition 1"
        },
        {
            "text": "Algorithm PrivatePathCount is executed by all parties; the output of these computations is broadcast to other parties. As we need to preserve the privacy of each party's edges individually, we consider one (arbitrary) party \u03b1 \u2208 A. The output of \u03b1 is a vector of the counts of all 2-paths connecting i,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D Proof of Lemma 2"
        },
        {
            "text": "Adding or removing an edge from E \u03b1 = \u03b2\u2208A E \u03b1,\u03b2 , can worst-case change 2|R A | elements of \u03b1's counts by one each. To see this, consider a very highly-connected node k and the deletion of {i, k} for any i: this reduces the counts for paths joining i, j for all j \u2208 R A . Likewise if i were also within party \u03b1 and were highly connected then the edge removal would also reduce counts for paths joining k, j for all j \u2208 R A . This proves that the sensitivity for part \u03b1 running PrivatePathCount is 2|R A | irrespective of party \u03b1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "D Proof of Lemma 2"
        },
        {
            "text": "Once again we apply post-processing to previously sanitized outputs R \u03b2 , T \u03b2 . Consider any party \u03b1 \u2208 A and the effect of removing/adding an edge incident to a node of \u03b1. At worst this will result in the condition {i, j} / \u2208 E \u03b1 of line 6 of Algorithm 2, evaluating differently-for at most one pair {i, j}. That is, the non-private sum of reciprocals S \u03b1 can be affected by the addition/removal of a single term ( max{0, T } + 1) \u22121 . Such a term is upper bounded by the reciprocal of lower bound on max{0, T } + 1 \u2265 1. That is, the sensitivity, irrespective of executing party \u03b1, is 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "E Proof of Lemma 3"
        },
        {
            "text": "Lemma 4 (Lemma 7 of [1] ) Consider a centralised party running SubsetRelease with budget > 0, quality function q(\u00b7) on R . For t > 0 let S t = {R : q(R) > q(R ) \u2212 t}, and let \u00b5 be the uniform probability mass function on P(V \u2212 ). Then Pr(S 2t ) \u2264 exp(\u2212 t)\u00b5(S 2t )/\u00b5(S t ).",
            "cite_spans": [
                {
                    "start": 20,
                    "end": 23,
                    "text": "[1]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "F Lemma 4"
        },
        {
            "text": "Lemma 5 For any R \u2286 V \u2212 we may bound the additive EBC error from using R instead of non-private R according to the quality function applied to the random release:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G Lemma 5"
        },
        {
            "text": "Let T ij , T ij 1 denote the number of 2-paths connecting i, j within node-sets R and R respectively. Our goal is to upper bound the quantity:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G.1 Proof of Lemma 5"
        },
        {
            "text": "following from the triangle inequality and collection of terms with shared endpoint nodes i, j. By cases: only when both end points are elements of the intersection R \u2229 R is there a pair of matching EBC terms. Otherwise at least one (or both) end-point nodes sit outside R or R respectively-in which case there is only one EBC term for the corresponding node set.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G.1 Proof of Lemma 5"
        },
        {
            "text": "We can see that both types of summand are bounded above by unity. For in the second case, for any i, j \u2208 R ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G.1 Proof of Lemma 5"
        },
        {
            "text": "since T ij \u2265 1 since there is always a path through egonode a. The same holds for the case of i, j \u2208 R by definition. And in the first case of i, j \u2208 R \u2229 R , we have that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G.1 Proof of Lemma 5"
        },
        {
            "text": "Therefore it follows that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G.1 Proof of Lemma 5"
        },
        {
            "text": "where the first equality follows by enumerating the i, j pairs being counted as all those within R or R provided that both nodes do not reside in separate set differences R\\R and R \\R. This completes the result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "G.1 Proof of Lemma 5"
        },
        {
            "text": "The claim follows from Lemma 4 combined with Proposition 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "H Proof of Corollary1"
        },
        {
            "text": "We begin by defining two events of interest on R \u2208 P (V \u2212 ) for any s > 0 to be chosen later: S s that our (centralised by Proposition 1) exponential mechanism achieves near-optimality, and T s that the resulting EBC is near optimal. Rewriting the event S s defined in Lemma 4, usingq(R) = |V | \u2212 q(R) andq(R ) = 0, we have that S s = {R :q(R) \u2264 s} , which holds w.p. at least 1 \u2212 exp(\u2212 s/2)2 \u2212|V \u2212 | . Next define",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I Proof of Theorem 2"
        },
        {
            "text": "By Lemma 5 we have that |EBC \u2212EBC 1 | \u2264 1 2 (q(R)+|R |) 2 . And since (a+b) 2 /2 is increasing in a \u2208 R for b \u2265 0, event S s implies then that |EBC \u2212 EBC 1 | \u2264 1 2 (s + |R |) 2 and so S s \u2286 T s and Pr(T s ) \u2265 Pr(S s ). Provided that t > |R | 2 /2, taking s = \u221a 2t \u2212 |R | > 0 this completes the result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "I Proof of Theorem 2"
        },
        {
            "text": "Consider a very sparse graph on nodes |V | > 10, and consider a true ego network R with cardinality represented as a fraction \u03b1 \u2208 [0, 1] of |V | i.e., |R | = \u03b1|V |.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "J Analysis for Remark 2"
        },
        {
            "text": "Let us now invoke the theorem with error bound t taken to be a multiplier \u03b3 > 1 of EBC-yielding a relative error bound of |EBC \u2212 EBC 1 |/EBC \u2264 \u03b3. For very sparse graphs, EBC can arbitrarily approach |R | 2 \u2264 |R | 2 /2 for \u03b3 bounded away from zero and large |V |. Thus setting t = \u03b3|R | 2 /2 corresponds to relative error \u03b3 which is meaningful for \u03b3 not much larger than 1 (corresponding to private EBC within the same order of magnitude as non-private EBC). Next we wish to set the confidence 1 \u2212 \u03b4 to be very close to unity e.g., \u03b4 = 2 \u221210 corresponds to confidence exceeding 99.9%. With these choices, we set the confidence in Theorem 2 to 1 \u2212 \u03b4 and solve for the privacy budget required for SubsetRelease:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "J Analysis for Remark 2"
        },
        {
            "text": "\u2265 3 log e 2 (\u03b3 \u2212 1)\u03b1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "J Analysis for Remark 2"
        },
        {
            "text": "We rephrase the forward-pass algorithm from [2] as a generic subset release mechanism through Algorithms 1, 2 and 3.",
            "cite_spans": [
                {
                    "start": 44,
                    "end": 47,
                    "text": "[2]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "K Precise algorithms"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Input: public set V , private subset R \u2286 V",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "return R Algorithm 2 InverseTransformSampler Input: cardinality |V |; > 0 // Compute log-space PDF of I 1: p0 \u2190\u2212 \u2212|V | log 1 + exp 2 2: for i \u2208",
            "authors": [
                {
                    "first": ";",
                    "middle": [],
                    "last": "I \u2190\u2212 Inversetransformsampler",
                    "suffix": ""
                },
                {
                    "first": "; V",
                    "middle": [],
                    "last": "|v | ; : R \u2190\u2212 Pickandflipsampler",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Mechanism design via differential privacy",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Mcsherry",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Talwar",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "FOCS'07",
            "volume": "",
            "issn": "",
            "pages": "94--103",
            "other_ids": {
                "DOI": [
                    "10.1109/focs.2007.66"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Differentially-private two-party egocentric betweenness centrality",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Roohi",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "I P"
                    ],
                    "last": "Rubinstein",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Teague",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "The 38th Annual IEEE International Conference on Computer Communications. INFOCOM",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {},
    "back_matter": [
        {
            "text": "if Vj \u2208 R then 5:R \u2190\u2212 R\\{Vj} 6: else 7:R \u2190\u2212 R \u222a {Vj} 8:end if 9: end for 10: return R",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 3 PickAndFlipSampler"
        }
    ]
}