{
    "paper_id": "64da240d834ad271f8500244a663824560f74ee8",
    "metadata": {
        "title": "Limited Two-Way Deterministic Finite Automata with Advice",
        "authors": [
            {
                "first": "Ahmet",
                "middle": [
                    "Bilal"
                ],
                "last": "U\u00e7an",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Bogazici University",
                    "location": {
                        "settlement": "Istanbul",
                        "country": "Turkey"
                    }
                },
                "email": "ahmet.ucan@boun.edu.tr"
            }
        ]
    },
    "abstract": [
        {
            "text": "External assistance in the form of strings called advice is given to an automaton in order to make it a non-uniform model of computation. Automata with advice are then examined to better understand the limitations imposed by uniformity, which is a typical property shared by all feasible computational models. The main contribution of this paper is to introduce and investigate an extension of the model introduced by K\u00fc\u00e7\u00fck et al. [6] . The model is called circular deterministic finite automaton with advice tape (cdfat). In this model the input head is allowed to pass over input multiple times. The number of allowed passes over the input, which is typically a function of input length, is considered as a resource besides the advice amount. The results proved for the model include a hierarchy for cdfat with real-time heads, simulation of 1w/1w cdfat by 1w/rt cdfat, lower bounds of resources provided to a cdfat in order to make it powerful enough to recognize any language, utilizable advice limit regardless of the allowed pass limit, a relation between utilizable pass limit and advice limit, and some closure properties.",
            "cite_spans": [
                {
                    "start": 431,
                    "end": 434,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Advised computation, where external trusted assistance is provided to a machine to help it for computational tasks, was introduced by Karp and Lipton [4] in 1982. Damm and Holzer [1] considered giving advice to restricted versions of Turing machines. Recent work on finite automata with advice include the papers of Yamakami [8] [9] [10] [11] , Tadaki et al. [7] , Freivalds et al. [3] , K\u00fc\u00e7\u00fck et al. [6] and\u010euri\u0161 et al. [2] . Today, there are many different models in literature, partly because of the several options available for a machine to access its advice. However, all such models share some common properties. There is an advice function, which maps input lengths to advice strings and not needed to be computable. Advice strings are composed of characters from an advice alphabet. The machine has to use the same advice string when operating on inputs of the same length. We investigate the class of languages recognized by a machine when it consults some advice function having some bounded growing rate. We then play with that upper bound to see what happens to the aforementioned class. An advised automaton takes advantage of an advice string by reading the character under the advice head and choosing appropriate transition from its transition function accordingly. So the same machine may recognize different languages using different advice functions.",
            "cite_spans": [
                {
                    "start": 150,
                    "end": 153,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 163,
                    "end": 167,
                    "text": "Damm",
                    "ref_id": null
                },
                {
                    "start": 179,
                    "end": 182,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 325,
                    "end": 328,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 329,
                    "end": 332,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 333,
                    "end": 337,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 338,
                    "end": 342,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 359,
                    "end": 362,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 382,
                    "end": 385,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 401,
                    "end": 404,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 421,
                    "end": 424,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We focus on the advice tape model introduced by K\u00fc\u00e7\u00fck et al. in [6] . Since that model becomes extremely powerful (able to recognize all languages) when allowed to use a 2-way input head, and is remarkably limited for the 1-way head case, [2, Theorem 2] , [6, Theorem 13], we examine a limited version of two-way input access.",
            "cite_spans": [
                {
                    "start": 64,
                    "end": 67,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 239,
                    "end": 242,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 243,
                    "end": 253,
                    "text": "Theorem 2]",
                    "ref_id": null
                },
                {
                    "start": 256,
                    "end": 259,
                    "text": "[6,",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Some common terminology to be used in this paper are as follows: n denotes input length, M denotes an automaton, L denotes a language, h denotes an advice function, w denotes a string, \u03a3 denotes input alphabet, \u0393 denotes advice alphabet, means any, ALL denotes the set of all languages, and |w| c denotes the number of occurrences of character c in string w.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Here are some definitions of concepts that will be used in our discussion, Definition 1 [6] . w 1 \u2261 L,n,k w 2 \u21d0\u21d2 w 1 ,",
            "cite_spans": [
                {
                    "start": 88,
                    "end": 91,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We call L R a prefixsensitive language for relation family R. Definition 3. We call L a prefix-sensitive language iff there exists a relation family R such that L R is a prefix-sensitive language for relation family R.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We defined this model and decided to work on it because the model seems to provide a smooth passage from one-way input head to two-way input head. The name of the new model is circular deterministic finite automaton with advice tape (cdfat) which may have real-time or 1-way input and advice heads (4 possible versions). Circular machines read their input circularly, that is, when the input endmarker has seen and the next transition dictates machine to move its input head to right, the input head immediately returns to the beginning position. Advice head is not allowed to perform such a move.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Our Model"
        },
        {
            "text": "Note that when restricted to a single pass on input, this model is exactly the same with the standard deterministic finite automaton with advice tapes model (except the two-way input head version) introduced by K\u00fc\u00e7\u00fck et al. [6] .",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 227,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Our Model"
        },
        {
            "text": "A circular deterministic finite automaton is a 9-tuple (Q, \u03a3, \u0393, T I , T A , \u03b4, q 0 , q acc , q rej ) where (i) Q is a finite set of internal states, (ii) \u03a3 is a finite set of symbols called the input alphabet that does not contain the endmarker symbol, $, such that $ / \u2208 \u03a3 and \u03a3 = \u03a3 \u222a {$}, (iii) \u0393 is a finite set of symbols called advice alphabet that does not contain the endmarker symbol, $, such that $ / \u2208 \u0393 and \u0393 = \u0393 \u222a {$}, (iv) T I \u2208 {{S, R}, {R}} represents the set of allowed input head movements where S and R means stay-put and right respectively, (v) T A \u2208 {{S, R}, {R}} represents the set of allowed advice head movements where S and R means stay-put and right respectively, (vi) q 0 \u2208 Q is the initial state on which the execution begins, (vii) q acc \u2208 Q is the accept state on which the execution halts and accepts, (viii) q rej \u2208 Q is the reject state on which the execution halts and rejects,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "implies that when the automaton is in state q 1 \u2208 Q and it scans \u03c3 \u2208 \u03a3 on its input tape and \u03b3 \u2208 \u0393 on its advice tape, a transition occurs which changes the state of the automaton to q 2 \u2208 Q, meanwhile moving the input and advice tape heads in the directions specified respectively by t I \u2208 T I and t A \u2208 T A , A cdfat M = (Q, \u03a3, \u0393, T I , T A , \u03b4, q 0 , q acc , q rej ) is said to accept (reject) a string x \u2208 \u03a3 * with the help of an advice string a \u2208 \u0393 * if and only if M , when started at its initial state q 0 with x$ on the input tape and a$ on the advice tape and while the tape heads scan the first symbols, reaches the accepting (rejecting) state, q acc (q rej ), by changing states and moving the input and advice tape heads as specified by its transition function, \u03b4.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "A language L defined on the alphabet \u03a3, is said to be recognized by such a cdfat A language L is said to be recognized by a cdfat, M, using O(g(n))-length advice if there exists an advice function h with the following properties:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "-|h(n)| \u2208 O(g(n)), and -M recognizes L with the help of h(n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "A language L is said to be recognized by a cdfat, M, using f (n) passes over the input if and only if during the execution of any input of length n, transitions of the form \u03b4( , $, ) = ( , R, ) are used at most f (n) times in total.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Note that it is not allowed for a cdfat to have a transition of the form \u03b4( , , $) = ( , , R), however, there can be transitions \u03b4( , $, ) = ( , R, ). The endmarker of the input is for informing the machine. It may be a different model if we omit it, for the sake of backward compatibility we continue to use it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "For the notational purposes, L{rt \u2212 f (n)} denotes the set of languages recognized by cdfat with real-time heads, (n + 1)f (n) length advice and f (n) passes. When a head is allowed to stay-put on its tape, we use a different notation. For instance L{1 \u2212 [f (n)]/g(n)} denotes the set of languages recognized by cdfat with 1-way input head and real-time advice head, using g(n) length advice and f (n) passes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition"
        },
        {
            "text": "Proof. Assume that for some language L it holds that for all k \u2208 N, there exists n \u2208 N such that \u2261 L,n,k has |\u03a3| k equivalence classes. Let f be a function which maps any k \u2208 N to an n so that \u2261 L,n,k has |\u03a3| k equivalence classes. Define an infinite family of relations",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. A language L is prefix-sensitive if and only if for all"
        },
        {
            "text": "Because if there were no such y for some x 0 and x 1 , then x 0 \u2261 L,f (k),k x 1 would be true and the number of equivalence classes would not be |\u03a3| k . According to the Definition 2, we concluded that L is prefix-sensitive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. A language L is prefix-sensitive if and only if for all"
        },
        {
            "text": "For the other direction, let L be a prefix-sensitive language. According to the Definition 2,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. A language L is prefix-sensitive if and only if for all"
        },
        {
            "text": "Because if the number of equivalence classes of \u2261 L,k+f (k),k is less than |\u03a3| k for some k, then there would be two strings x 0 and x 1 such that",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. A language L is prefix-sensitive if and only if for all"
        },
        {
            "text": "Proof. Let h(n) = w 1 c 1 w 2 c 2 . . . w |\u03a3| n c \u03a3 n where each w i is a distinct input word of length n and each c i / \u2208 \u03a3 is either the accept or the reject symbol. Devise a machine M such that, it tries to match the input word and advice character by character in real-time execution. If a mismatch occurs while trying to match the input word, machine M will advance its input head until it is at the beginning position again. Note that the advice head will be at the first character of the next word on advice at the end of this process. Then it tries to match the next word and so on. At some point matching ends with success, that is, machine M will see the endmarker of input while trying to match the characters. At that point it will accept or reject the string depending on which c i character it is seeing on the advice.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. A language L is prefix-sensitive if and only if for all"
        },
        {
            "text": "Proof. The idea is that for any given machine M , one can devise a new machine M such that M uses k times less passes than M for all n and for an arbitrary k \u2208 N, and still recognizes the same language with the help of some other advice function. Let us group the passes of machine M so that i th group consists of passes from (i \u2212 1)k + 1 to ik. With a single pass, machine M simulates a group of k passes of M . First pass simulates the first group and second pass simulates the second group and so on. Since M does not know which state to begin with a pass without knowing the result of the previous one, it simulates all possibilities and remembers the final state of the previous group of passes using again its states. Therefore the size of the state set of M is s ks+1 where s is the number of states of M .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "The new advice function h is a compressed version of the old one. Let \u0393 be the new advice alphabet whose symbols represent the k permutations of the symbols of \u0393 . |\u0393 | = |\u0393 | k holds. Let |h (n)| = |h(n)|/k for all n > 0. Note that without loss of generality we assume that |h(n)| is an integer multiple of k. We prepare the new advice strings so that h (1) represents all strings from h(1) to h(k), h (2) represents all strings from h(k + 1) to h(2k) and so on.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "Proof. Let M 1 , M 2 be machines recognizing L 1 , L 2 with the help of advice functions h 1 , h 2 respectively. Let M 3 be the machine which is claimed to recognize the concatenation language L 1 L 2 with the help of advice function h 3 . The idea is to predict the words w 1 \u2208 L 1 and w 2 \u2208 L 2 such that w 1 w 2 is the input word. Machine M 3 doesn't know from where to divide the input, so it just tries all the possibilities. We replace the advice characters whose locations correspond to the last character of the first portion of the input with their marked versions in order to inform the machine M 3 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "In the first pass over the input, machine M 3 first simulates M 1 on the first portion of the input and stores the last internal state of that execution. Then it simulates M 2 on the rest of the input and stores the last state of that execution too. Then it begins the second pass simulating M 1 again but this time starting from the last saved state of that thread and when it completes, M 3 will update the last state of the thread and so on. Throughout the execution of M 3 , two separate threads of execution are simulated at the same time. At the end of at most f (n) passes, if both threads end with accepting their respective sub-inputs, M 3 accepts the input. Otherwise, M 3 continues the computation with a different division of the input. Note that, given an input word of length n, there are n + 1 different pairs of words such that their concatenation is the input word. At the end of at most (n + 1)f (n) passes, if no division works, M 3 rejects the input. According to the Theorem 3, asymptotic rate of the passes is the important part so nf (n) passes can do the same job.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "Note that we should double the old advice alphabet size and introduce marked versions of the old symbols in order to mark the position of input separation on the advice h 3 . Also note that advice string h 3 (n) will be an interleaved version of the h 1 (k) and h 2 (n \u2212 k) concatenated for all k \u2208 [0, n] Z . Proof. Let s = |Q| and let Q = {q 1 , q 2 , . . . q s\u22122 } be the set of all states except the accept and reject states. Let \u03b1 w,i : Q \u2192 Q be a mapping which maps the internal state of machine when input head is for the first time on the first character of w and advice head is at the i th position to the internal state of machine when input head is for the first time on the first character right after the w. Besides its parameters w and i, this mapping depends on the content of the advice and transition function of the machine. Here we consider a single machine working on inputs of the same length n therefore the mapping depends only on its parameters.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "Consider execution of a real-time circular machine on two different inputs of length n, namely w 1 z and w 2 z. If we can find two words w 1 and w 2 such that \u03b1 w1,i = \u03b1 w2,i for all i \u2208 {1, 1 + (n + 1), . . . 1 + (f (n) \u2212 1)(n + 1)} then the two inputs must have the same fate for all z.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "Given a single i, there are less than s s distinct functions \u03b1 w,i . Considering all f (n) functions mentioned above for a word w, there are less than (s s ) f (n) different permutations. Assuming that the number of equivalence classes of relation \u2261 L,n,k is greater than (s s ) f (n) for some k and n, there would be two words w 1",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "and w 2 such that they are in different equivalence classes and have all the same mappings. This is a contradiction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 3. For any function"
        },
        {
            "text": "Proof. Consider the language family L \u03c1 = {w \u03c1(|w|) | w \u2208 \u03a3 * , \u03c1 : N \u2192 N}. Note that \u03c1 is assumed to be a non-decreasing function and the input length n = |w|\u03c1(|w|). Inputs consist of repetitions of a substring w. Define \u03c6(m\u03c1(m)) = m for all m \u2208 N + . Depending on the choice of \u03c1, \u03c6(n) \u2208 \u03c9(1) \u2229 O(n). We will give three lemmas. Two of them show a hierarchy for the range \u03c9(1) \u2229 O(n) and the last one is to put the \u0398(1) in.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 5. Let f (n), g(n) \u2208 O(n) and f (n) \u2208 o(g(n)). Then"
        },
        {
            "text": "Since given the input length n and the function \u03c1 we can deduct the period of input, we can check a position of the repeating substring w for each pass. Therefore our machine will need |w| = \u03c6(n) many passes. The advice strings are of the form (parentheses are meta-characters),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. L \u03c1 \u2208 L{rt \u2212 \u03c6(n)}."
        },
        {
            "text": "Our machine will first search for the first 1 on advice tape and when it has been found, the machine saves the corresponding input character in its states and continue searching for the next 1. When it sees the next 1 it checks the corresponding input character with the one it saved before. If they mismatch input is rejected. The machine then continue searching for 1s and do the same checking till the end of the first pass. It then start with the second pass and do the same procedure again, checking the equality of next character position in substring w. If the endmarker of advice is reached, input is accepted.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. L \u03c1 \u2208 L{rt \u2212 \u03c6(n)}."
        },
        {
            "text": "Proof. Let M 1 , M 2 be machines recognizing languages L 1 , L 2 with the help of advice functions h 1 and h 2 respectively. Devise a new advice function,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. L \u03c1 \u2208 L{rt \u2212 \u03c6(n)}."
        },
        {
            "text": "for all n where # is a brand new advice character that occurs nowhere else. Let M 3 be the machine recognizing the union language with the help of h 3 . Machine M 3 first simulates the M 1 and during this simulation it treats the # character in advice as an endmarker. When this simulation ends, which may take at most f (n) passes over the input, M 3 stores the result in its states and start simulating M 2 after adjusting its heads to proper positions, that is input head to the beginning and advice head to the next character after #. After at most f (n) passes over the input, it completes the execution and store the result in its states. In this way it may end up in 4 different states for 4 possible acceptance status of M 1 and M 2 . Via combining some of those states into the accept state and the rest into the reject state; union, intersection or difference of L 1 and L 2 are all recognizable.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 2. L \u03c1 \u2208 L{rt \u2212 \u03c6(n)}."
        },
        {
            "text": "Proof. The proof is an easy modification of the proof given by\u010euri\u0161 et al. for [2, Theorem 3] .",
            "cite_spans": [
                {
                    "start": 79,
                    "end": 82,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 83,
                    "end": 93,
                    "text": "Theorem 3]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Theorem 7. For any function"
        },
        {
            "text": "Proof. Consider the execution of an s-state cdfat with one-way heads. Pausing the advice head, passing on the input more than s times forces the machine to enter an infinite loop. Thus, a machine must advance its advice head before that threshold. Therefore at most sg(n) passes are possible for an execution which eventually halts.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 8. For any function"
        },
        {
            "text": "For any functions f, g :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9."
        },
        {
            "text": "Proof. It is possible to simulate the one-way advice head with real-time advice head using additional advice. The idea is to replicate each advice character (n+1)f (n) times and use separator characters # to mark the transition locations. That is, for all n,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9."
        },
        {
            "text": "where c i \u2208 \u0393 for all i \u2208 {1, 2 . . . k} and the c $ is a new advice character which is for repeating the endmarker (it is not allowed to have more than one real endmarker character). When the new machine reads c $ on h , it behaves exactly like the old machine seeing endmarker on h.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9."
        },
        {
            "text": "Instead of stay-putting advice head in old machine, let it move right one step in new machine. Instead of moving advice head one step in old machine, enter a subprogram which takes advice head to the next # character in new machine.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9."
        },
        {
            "text": "This trick works because a cdfat with one-way heads must forward its advice head within (n + 1)f (n) computational steps. This is because without loss of generality we can assume at least one head is moving in each step and of course input head can move at most (n + 1)f (n) times in an execution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 9."
        },
        {
            "text": "It is already known that dfat with 2-way input head is equal in power with the prefix advice model when provided with constant advice [5, Theorem 3.8 ]. Since our model is sandwiched in between the 2-way input model and advice prefix model when it comes to power, we deduce that",
            "cite_spans": [
                {
                    "start": 134,
                    "end": 137,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 138,
                    "end": 149,
                    "text": "Theorem 3.8",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Therefore an interesting question to ask is what is the minimum advice for which more passes over input enlarges the class of languages recognized. K\u00fc\u00e7\u00fck and others showed that when provided with polynomial advice, 2-way input head is more powerful than 1-way head [6, Theorem 14] . We proved a stronger result and gave an ultimate answer to the aforementioned question. It turns out that even 2 passes over input is more powerful than a single pass when the machine is provided with an increasing advice.",
            "cite_spans": [
                {
                    "start": 265,
                    "end": 268,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 269,
                    "end": 280,
                    "text": "Theorem 14]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Theorem 10. Let f : N \u2192 N be any function in \u03c9 (1) .",
            "cite_spans": [
                {
                    "start": 47,
                    "end": 50,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Proof. Consider the language family L \u03c1 = {w|w \u2208 {1, 2, 3} * , |w| 1 = |w| 2 = \u03c1(|w|)}. The following two lemmas establish the proof. classes, [6, Lemma 6] . It can be shown that for all n, there exists k \u2264 n such that \u2261 L\u03c1,n,k has \u0398(\u03c1 2 (n)) equivalence classes. Since \u03c1(n) \u2208 \u03c9(1) =\u21d2 \u03c1(n) \u2208 o(\u03c1 2 (n)), we conclude that",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 146,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 147,
                    "end": 155,
                    "text": "Lemma 6]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Proof. The idea is to devise a machine which in first pass counts the character 1 and in second pass counts the character 2. Let L 1 = {w|w \u2208 {1, 2, 3} * , |w| 1 = \u03c1(|w|)} and L 2 = {w|w \u2208 {1, 2, 3} * , |w| 2 = \u03c1(|w|)}. Observe that L 1 or L 2 can easily be recognized by a cdfat with a single pass. In order to recognize L 1 for instance, let h(n) = 1 \u03c1(n) be the advice function, then consider a machine which stay-puts its advice head when it sees a character other than 1 on its input and advances its advice head when it sees 1 on input. It will accept a string iff both endmarkers are read at the same time. L 2 can be recognized similarly. Since",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Then for all n and for all k smaller than n, \u2261 L,n,k has 2 O(g(n) log g(n)) equivalence classes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Proof. Define a configuration c i of a machine to be the pair of internal state and advice position. Define a non-stopping configuration c = (q, m) of a machine to be any configuration where q is a state other than accept and reject states. Let C = {c 1 , c 2 , . . . , c (s\u22122)(g(n)+1) } be the set of all non-stopping configurations for a machine and for input length n (s = |Q|). Without loss of generality assume our machines always end their execution when input head is on the endmarker. Let w be a substring of input (not containing the endmarker) and let \u03b1 w : C \u2192 C be a mapping which maps the configuration of machine when the first character of word w is read first time on input tape to the configuration of machine when the character right after the word w is read first time on input tape. Function \u03b1 depends on transition function of the machine, the specific word w being processed and the advice content. We focus on a single machine and inputs of the same length n, therefore in our case \u03b1 depends only on w.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "Consider execution of a circular machine on two different inputs of length n, namely w 1 z and w 2 z. Both inputs start execution at the initial configuration and after each pass they start with a new configuration. If we can find two words w 1 and w 2 such that \u03b1 w1 = \u03b1 w2 then the two inputs w 1 z and w 2 z must have the same fate for all z.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "There are less than 2sg(n) 2sg(n) distinct functions \u03b1. Assuming that the number of equivalence classes of \u2261 L,n,k is greater than 2sg(n) 2sg(n) for some k and n, there would be two words w 1 , w 2 in two different equivalence classes such that they have the same mapping. This is a contradiction. [6] given access to unlimited advice. According to Theorem 5, a prefix-sensitive language is in L{rt \u2212 f (n)} no matter how slow f (n) grows. However we know from\u010euri\u0161 et al. [2, Theorem 2] that no prefix-sensitive language is in L{1 \u2212 [1] ",
            "cite_spans": [
                {
                    "start": 298,
                    "end": 301,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 473,
                    "end": 476,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 477,
                    "end": 487,
                    "text": "Theorem 2]",
                    "ref_id": null
                },
                {
                    "start": 534,
                    "end": 537,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "On the other hand, as stated in proof of Lemma 6, the language L = {w|w \u2208 {1, 2, 3} * , |w| 1 = \u03c1(|w|)} can be easily recognized by a machine with one-way heads, given access to \u0398(\u03c1(n)) length advice. It is easy to see that for all n, there exists k such that \u2261 L\u03c1,n,k has \u0398(\u03c1(n)) equivalence classes. When the \u03c1(n) is selected to be linear in n, according to Lemma 1, L / \u2208 L{rt \u2212 f (n)}. Therefore",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "An interesting question to ask is what is the minimum advice or pass needed in order for a model to recognize any language. We can show some lower bounds using Lemmas 1 and 7. P AL is the language of even palindromes. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. For any function"
        },
        {
            "text": "We showed that cdfat with real-time heads can utilize up to linearly many passes over input. We showed that with exponential pass, the real-time machine can recognize any language. However we do not know if the machine can utilize more than linear passes. There may be a clever algorithm for recognizing any language with linear passes. We showed that even the most powerful version of the cdfat, that is the one having one-way input and advice heads, cannot recognize some languages when there is not enough advice (a nearly linear bound). However we are not aware of an algorithm for this machine which uses less than exponential resources to recognize any language. It would be nice to know the minimum amount of resources needed to recognize any language.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions and Open Questions"
        },
        {
            "text": "We compared the class of languages recognized by single pass deterministic finite automaton with one-way heads and unlimited advice with the growing class of languages recognized by a real-time cdfat as we allow more passes over input. Since we know that the former class is bigger than the latter when we allow only constant amount of pass over input and the reverse is true when we allow exponential passes over input, we wonder how that growing takes place and is there any pass limit for which the two classes are equal. It turned out that this is not the case. As long as the allowed pass limit is not constant and sub-logarithmic, two classes are not subsets of each other. However we do not know exactly when the latter class encompasses the former one.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions and Open Questions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Automata that take advice",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Damm",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Holzer",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "MFCS 1995",
            "volume": "969",
            "issn": "",
            "pages": "149--158",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-60246-1_121"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Determinism and nondeterminism in finite automata with advice",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "\u010euri\u0161",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Korba\u0161",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kr\u00e1lovi\u010d",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Kr\u00e1lovi\u010d",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Adventures Between Lower Bounds and Higher Altitudes",
            "volume": "11011",
            "issn": "",
            "pages": "3--16",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-98355-4_1"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Amount of nonconstructivity in deterministic finite automata. Theoret",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Freivalds",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Comput. Sci",
            "volume": "411",
            "issn": "",
            "pages": "3436--3443",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2010.05.038"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Turing machines that take advice",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Karp",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Lipton",
                    "suffix": ""
                }
            ],
            "year": 1982,
            "venue": "Enseign. Math",
            "volume": "28",
            "issn": "",
            "pages": "191--209",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Finite and small-space automata with advice",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "K\u00fc\u00e7\u00fck",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Finite automata with advice tapes",
            "authors": [
                {
                    "first": "U",
                    "middle": [],
                    "last": "K\u00fc\u00e7\u00fck",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "C C"
                    ],
                    "last": "Say",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Yakary\u0131lmaz",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "DLT 2013",
            "volume": "7907",
            "issn": "",
            "pages": "301--312",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-38771-5_27"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Theory of one-tape linear-time turing machines",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Tadaki",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Yamakami",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C H"
                    ],
                    "last": "Lin",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Theoret. Comput. Sci",
            "volume": "411",
            "issn": "1",
            "pages": "22--43",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2009.08.031"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Swapping lemmas for regular and context-free languages with advice",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Yamakami",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "The roles of advice to one-tape linear-time turing machines and finite automata",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Yamakami",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Int. J. Found. Comput. Sci",
            "volume": "21",
            "issn": "6",
            "pages": "941--962",
            "other_ids": {
                "DOI": [
                    "10.1142/S0129054110007659"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Immunity and pseudorandomness of context-free languages. Theoret",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Yamakami",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Comput. Sci",
            "volume": "412",
            "issn": "45",
            "pages": "6432--6450",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2011.07.013"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "One-way reversible and quantum finite automata with advice",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Yamakami",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "LATA 2012",
            "volume": "7183",
            "issn": "",
            "pages": "526--537",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "M with the help of an advice function h : N \u2192 \u0393 * if and only if -L = {x | M accepts x with the help of h(|x|)}, and -L = {x | M rejects x with the help of h(|x|)}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "L{rt \u2212 poly} is closed under concatenation. Lemma 1. Let L \u2208 L{rt \u2212 f (n)}. Then for all n and for all k smaller than n, \u2261 L,n,k has 2 O(f (n)) equivalence classes.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "L \u03c1 / \u2208 L{1 \u2212 [1]/1 \u2212 [O(\u03c1(n))]}.Proof. K\u00fc\u00e7\u00fck et al. proved that for any advice length function f , if L \u2208 L{1 \u2212 [1]/1 \u2212 [f (n)]}, then for all n and all k \u2264 n, \u2261 L,n,k has O(f (n)) equivalence",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Let f (n) \u2208 \u03c9(1) \u2229 o(log n). Then the classes L{rt \u2212 f (n)} and L{1 \u2212 [1]/1 \u2212 [ ]} are incomparable. Proof. Recall that L{1 \u2212 [1]/1 \u2212 [ ]} is nothing but our way of notating the class of languages recognized by the model introduced by K\u00fc\u00e7\u00fck et al. in",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Corollary 4. g(n) log g(n) \u2208 o(n) =\u21d2 P AL / \u2208 L{1 \u2212 [f (n)]/1 \u2212 [g(n)]}. Corollary 5. f (n) \u2208 o(n) =\u21d2 P AL / \u2208 L{rt \u2212 f (n)}.",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgements. Thanks to Prof. Cem Say who have helped editing the paper and correcting my mistakes and to my family for their constant support and love.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}