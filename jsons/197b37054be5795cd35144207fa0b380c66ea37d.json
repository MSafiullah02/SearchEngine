{
    "paper_id": "197b37054be5795cd35144207fa0b380c66ea37d",
    "metadata": {
        "title": "The Power of Programs over Monoids in J",
        "authors": [
            {
                "first": "Nathan",
                "middle": [],
                "last": "Grosshans",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "PSL University",
                    "location": {
                        "settlement": "Paris",
                        "country": "France"
                    }
                },
                "email": "nathan.grosshans@polytechnique.edu"
            }
        ]
    },
    "abstract": [
        {
            "text": "The model of programs over (finite) monoids, introduced by Barrington and Th\u00e9rien, gives an interesting way to characterise the circuit complexity class NC 1 and its subclasses and showcases deep connections with algebraic automata theory. In this article, we investigate the computational power of programs over monoids in J, a small variety of finite aperiodic monoids. First, we give a fine hierarchy within the class of languages recognised by programs over monoids from J, based on the length of programs but also some parametrisation of J. Second, and most importantly, we make progress in understanding what regular languages can be recognised by programs over monoids in J. We show that those programs actually can recognise all languages from a class of restricted dot-depth one languages, using a non-trivial trick, and conjecture that this class suffices to characterise the regular languages recognised by programs over monoids in J.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "In computational complexity theory, many hard still open questions concern relationships between complexity classes that are expected to be quite small in comparison to the mainstream complexity class P of tractable languages. One of the smallest such classes is NC 1 , the class of languages decided by Boolean circuits of polynomial length, logarithmic depth and bounded fan-in, a relevant and meaningful class, that has many characterisations but whose internal structure still mostly is a mystery. Indeed, among its most important subclasses, we count AC 0 , CC 0 and ACC 0 : all of them are conjectured to be different from each other and strictly within NC 1 , but despite many efforts for several decades, this could only be proved for the first of those classes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In the late eighties, Barrington and Th\u00e9rien [3] , building on Barrington's celebrated theorem [2] , gave an interesting viewpoint on those conjectures, relying on algebraic automata theory. They defined the notion of a program over a monoid M : a sequence of instructions (i, f ), associating through function f some element of M to the letter at position i in the input of fixed length. In that way, the program outputs an element of M for every input word, by multiplying out the elements given by the instructions for that word; acceptance or rejection then depends on that outputted element. A language of words of arbitrary length is consequently recognised in a non-uniform fashion, by a sequence of programs over some fixed monoid, one for each possible input length; when that sequence is of polynomial length, it is said that the monoid p-recognises that language. Barrington and Th\u00e9rien's discovery is that NC 1 and almost all of its significant subclasses can each be exactly characterised by p-recognition over monoids taken from some suitably chosen variety of finite monoids (a class of finite monoids closed under basic operations on monoids). For instance, NC 1 , AC 0 , CC 0 and ACC 0 correspond exactly to p-recognition by, respectively, finite monoids, finite aperiodic monoids, finite solvable groups and finite solvable monoids. Understanding the internal structure of NC 1 thus becomes a matter of understanding what finite monoids from some particular variety are able to p-recognise.",
            "cite_spans": [
                {
                    "start": 45,
                    "end": 48,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 95,
                    "end": 98,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 875,
                    "end": 889,
                    "text": "Barrington and",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "It soon became clear that regular languages play a central role in understanding p-recognition: McKenzie, P\u00e9ladeau and Th\u00e9rien indeed observed [12] that finite monoids from a variety V and a variety W p-recognise the same languages if and only if they p-recognise the same regular languages. Otherwise stated, most conjectures about the internal structure of NC 1 can be reformulated as a statement about where one or several regular languages lie within that structure. This is why a line of previous works got interested into various notions of tameness, capturing the fact that for a given variety of finite monoids, p-recognition does not offer much more power than classical morphism-recognition when it comes to regular languages (see [8, 10, 11, 13, 14, [20] [21] [22] ). This paper is a contribution to an ongoing study of what regular languages can be p-recognised by monoids taken from \"small\" varieties, started with the author's Ph.D. thesis [7] . In a previous paper by the author with McKenzie and Segoufin [8] , a novel notion of tameness was introduced and shown for the \"small\" variety of finite aperiodic monoids DA. This allowed them to characterise the class of regular languages p-recognised by monoids from DA as those recognised by so called quasi-DA morphisms and represented a first small step towards a new proof that the variety A of finite aperiodic monoids is tame. This is a statement equivalent to Furst's, Saxe's, Sipser's [6] and Ajtai's [1] well-known lower bound result about AC 0 . In [8] , the authors also observed that, while DA \"behaves well\" with respect to p-recognition of regular languages, the variety J, a subclass of DA, does, in contrast, \"behave badly\" in the sense that monoids from J do p-recognise regular languages that are not recognised by quasi-J morphisms. Now, J is a well-studied and fundamental variety in algebraic automata theory (see, e.g., [15, 16] ), corresponding through classical morphism-recognition to the class of regular languages in which membership depends on the presence or absence of a finite set of words as subwords. This paper is a contribution to the understanding of the power of programs over monoids in J, a knowledge that certainly does not bring us closer to a new proof of the tameness of A (as we are dealing with a strict subvariety of DA), but that is motivated by the importance of J in algebraic automata theory and the unexpected power of programs over monoids in J. The results we present in this article are twofold: first, we exhibit a fine hierarchy within the class of languages p-recognised by monoids from J, depending on the length of those programs and on a parametrisation of J; second, we show that a whole class of regular languages, that form a subclass of dot-depth one languages [15] , are p-recognised by monoids from J while, in general, they are not recognised by any quasi-J morphism. This class roughly corresponds to dot-depth one languages where detection of a given factor does work only when it does not appear too often as a subword. We actually even conjecture that this class of languages with additional positional modular counting (that is, letters can be differentiated according to their position modulo some fixed number) corresponds exactly to all those p-recognised by monoids in J, a statement that is interesting in itself for algebraic automata theory.",
            "cite_spans": [
                {
                    "start": 143,
                    "end": 147,
                    "text": "[12]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 741,
                    "end": 744,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 745,
                    "end": 748,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 749,
                    "end": 752,
                    "text": "11,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 753,
                    "end": 756,
                    "text": "13,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 757,
                    "end": 760,
                    "text": "14,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 761,
                    "end": 765,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 766,
                    "end": 770,
                    "text": "[21]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 771,
                    "end": 775,
                    "text": "[22]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 954,
                    "end": 957,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1021,
                    "end": 1024,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1455,
                    "end": 1458,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1471,
                    "end": 1474,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1521,
                    "end": 1524,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1904,
                    "end": 1908,
                    "text": "[15,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1909,
                    "end": 1912,
                    "text": "16]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 2787,
                    "end": 2791,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Organisation of the Paper. Following the present introduction, Sect. 2 is dedicated to the necessary preliminaries. In Sect. 3, we present the results about the fine hierarchy and in Sect. 4 we expose the results concerning the regular languages p-recognised by monoids from J. Section 5 gives a short conclusion.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Note. This article is based on unpublished parts of the author's Ph.D. thesis [7] .",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 81,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We assume the reader is familiar with the basics of formal language theory, semigroup theory and recognition by morphisms, that we might designate by classical recognition; for those, we only specify some things and refer the reader to the two classical references of the domain by Eilenberg [4, 5] and Pin [16] .",
            "cite_spans": [
                {
                    "start": 292,
                    "end": 295,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 296,
                    "end": 298,
                    "text": "5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 307,
                    "end": 311,
                    "text": "[16]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "General Notations and Conventions. Let i, j \u2208 N. We shall denote by [[i, j] ] the set of all n \u2208 N verifying i \u2264 n \u2264 j. We shall also denote by [i] the set [ [1, i] ]. Given some set E, we shall denote by P(E) the powerset of E. All our alphabets and words will always be finite; the empty word will be denoted by \u03b5.",
            "cite_spans": [
                {
                    "start": 68,
                    "end": 75,
                    "text": "[[i, j]",
                    "ref_id": null
                },
                {
                    "start": 158,
                    "end": 164,
                    "text": "[1, i]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "Varieties and Languages. A variety of monoids is a class of finite monoids closed under submonoids, Cartesian product and morphic images. A variety of semigroups is defined similarly. When dealing with varieties, we consider only finite monoids and semigroups, each having an idempotent power, a smallest \u03c9 \u2208 N >0 such that x \u03c9 = x 2\u03c9 for any element x. To give an example, the variety of finite aperiodic monoids, denoted by A, contains all finite monoids M such that, given \u03c9 its idempotent power,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "To each variety V of monoids or semigroups we associate the class L(V) of languages such that, respectively, their syntactic monoid or semigroup belongs to V. For instance, L(A) is well-known to be the class of star-free languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "Quasi V Languages. If S is a semigroup we denote by S 1 the monoid S if S is already a monoid and S \u222a {1} otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "The following definitions are taken from [17] . Let \u03d5 be a surjective morphism from \u03a3 * to a finite monoid M . For all k consider the subset \u03d5(\u03a3 k ) of M (where \u03a3 k is the set of words over \u03a3 of length k). As M is finite there is a k such that \u03d5(\u03a3 2k ) = \u03d5(\u03a3 k ). This implies that \u03d5(\u03a3 k ) is a semigroup. The semigroup given by the smallest such k is called the stable semigroup of \u03d5. If S is the stable semigroup of \u03d5, S 1 is called the stable monoid of \u03d5. If V is a variety of monoids or semigroups, then we shall denote by QV the class of such surjective morphisms whose stable monoid or semigroup, respectively, is in V and by L(QV) the class of languages whose syntactic morphism is in QV.",
            "cite_spans": [
                {
                    "start": 41,
                    "end": 45,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "Programs over Monoids. Programs over monoids form a non-uniform model of computation, first defined by Barrington and Th\u00e9rien [3] , extending Barrington's permutation branching program model [2] . Let M be a finite monoid and \u03a3 an alphabet. A program P over M on \u03a3 n is a finite sequence of instructions of the",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 129,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 191,
                    "end": 194,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "The length of P , denoted by |P |, is the number of its instructions. The program P defines a function from \u03a3 n to M as follows. On input w \u2208 \u03a3 n , each instruction (i, f ) outputs the monoid element f (w i ). A sequence of instructions then yields a sequence of elements of M and their product is the output P (w) of the program. A language L \u2286 \u03a3 n is consequently recognised by P whenever there exists",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "A language L over \u03a3 is recognised by a sequence of programs (P n ) n\u2208N over some finite monoid M if for each n, the program P n is on \u03a3 n and recognises",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "For s : N \u2192 N and V a variety of monoids, we denote by P(V, s(n)) the class of languages recognised by sequences of programs over monoids in V of length at most s(n). The class P(V) = k\u2208N P V, n k is then the class of languages p-recognised by a monoid in V, i.e. recognised by sequences of programs over monoids in V of polynomial length.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "The following is an important property of P(V).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Various Mathematical Materials"
        },
        {
            "text": "Given two alphabets \u03a3 and \u0393 , a \u0393 -program on \u03a3 n for n \u2208 N is defined just like a program over some finite monoid M on \u03a3 n , except that instructions output letters from \u0393 and thus that the program outputs words over \u0393 . Let now L \u2286 \u03a3 * and K \u2286 \u0393 * . We say that L program-reduces to K if and only if there exists a sequence (\u03a8 n ) n\u2208N of \u0393 -programs (the program-reduction) such that \u03a8 n is on \u03a3 n and L =n = \u03a8 \u22121 n (K =|\u03a8n| ) for each n \u2208 N. The following proposition shows closure of P(V) also under program-reductions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 1 ([12, Corollary 3.5]). Let V be a variety of monoids, then P(V) is closed under Boolean operations."
        },
        {
            "text": "Proposition 2 ([7, Proposition 3.3.12 and Corollary 3.4.3]). Let \u03a3 and \u0393 be two alphabets. Let V be a variety of monoids. Given K \u2286 \u0393 * in P(V, s(n)) for s : N \u2192 N and L \u2286 \u03a3 * from which there exists a program-reduction to K of length t(n), for t : N \u2192 N, we have that L \u2208 P(V, s(t(n))). In particular, when K is recognised (classically) by a monoid in V, we have that L \u2208 P(V, t(n)).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Proposition 1 ([12, Corollary 3.5]). Let V be a variety of monoids, then P(V) is closed under Boolean operations."
        },
        {
            "text": "We won't introduce any of the proposed notions of tameness but will only state that the main consequence for a variety of monoids V to be tame in the sense of [8] is that P(V) \u2229 Reg \u2286 L(QV). This consequence has far-reaching implications from a computational-complexity-theoretic standpoint when P(V) happens to be equal to a circuit complexity class. For instance, tameness for A implies that P(A) \u2229 Reg \u2286 L(QA), which is equivalent to the fact that AC 0 does not contain the language MOD m of words over {0, 1} containing a number of 1s not divisible by m for any m \u2208 N, m\u2265 2 (a central result in complexity theory [1, 6] ).",
            "cite_spans": [
                {
                    "start": 159,
                    "end": 162,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 617,
                    "end": 620,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 621,
                    "end": 623,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Tameness and the Variety J"
        },
        {
            "text": "Let us now define the variety of monoids J. A finite monoid M of idempotent power \u03c9 belongs to J if and only if (xy) \u03c9 = (xy) \u03c9 x = y(xy) \u03c9 for all x, y \u2208 M . It is a strict subvariety of the variety DA, containing all finite monoids M of idempotent power \u03c9 such that (xy) \u03c9 = (xy) \u03c9 x(xy) \u03c9 for all x, y \u2208 M , itself a strict subvariety of A. The variety J is a \"small\" one, well within A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tameness and the Variety J"
        },
        {
            "text": "We now give some specific definitions and results about J that we will use, based essentially on [9] , but also on [16, Chapter 4, Section 1].",
            "cite_spans": [
                {
                    "start": 97,
                    "end": 100,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Tameness and the Variety J"
        },
        {
            "text": "For some alphabet \u03a3 and each k \u2208 N, let us define the equivalence relation \u223c k on \u03a3 * by u \u223c k v if and only if u and v have the same set of k-subwords (subwords of length at most k), for all u, v \u2208 \u03a3 * . The relation \u223c k is a congruence of finite index on \u03a3 * . For an alphabet \u03a3 and a word u \u2208 \u03a3 * , we shall write u \u03a3 * for the language of all words over \u03a3 having u as a subword. In the following, we consider that has precedence over \u222a and \u2229 (but of course not over concatenation). We define the class of piecewise testable languages PT as the class of regular languages such that for every alphabet \u03a3, we associate to \u03a3 * the set PT (\u03a3 * ) of all languages over \u03a3 that are Boolean combinations of languages of the form u \u03a3 * where u \u2208 \u03a3 * . In fact, PT (\u03a3 * ) is the set of languages over \u03a3 equal to a union of \u223c k -classes for some k \u2208 N (see [18] ). Simon showed [18] that a language is piecewise testable if and only if its syntactic monoid is in J, i.e. PT = L(J).",
            "cite_spans": [
                {
                    "start": 849,
                    "end": 853,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 870,
                    "end": 874,
                    "text": "[18]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "Tameness and the Variety J"
        },
        {
            "text": "We can define a hierarchy of piecewise testable languages in a natural way. For k \u2208 N, let the class of k-piecewise testable languages PT k be the class of regular languages such that for every alphabet \u03a3, we associate to \u03a3 * the set PT k (\u03a3 * ) of all languages over \u03a3 that are Boolean combinations of languages of the form u \u03a3 * where u \u2208 \u03a3 * with |u| \u2264 k. We then have that PT k (\u03a3 * ) is the set of languages over \u03a3 equal to a union of \u223c k -classes. Let us define J k the inclusion-wise smallest variety of monoids containing the quotients of \u03a3 * by \u223c k for any alphabet \u03a3: we have that a language is k-piecewise testable if and only if its syntactic monoid belongs to J k , i.e. PT k = L(J k ). (See [9, Section 3].)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Tameness and the Variety J"
        },
        {
            "text": "The first part of our investigation of the computational power of programs over monoids in J concerns the influence of the length of programs on their computational capabilities.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fine Hierarchy"
        },
        {
            "text": "We say two programs over a same monoid on the same set of input words are equivalent if and only if they recognise the same languages. Tesson and Th\u00e9rien proved in [23] that for any monoid M in DA, there exists some k \u2208 N such that for any alphabet \u03a3 there is a constant c \u2208 N >0 verifying that any program over M on \u03a3 n for n \u2208 N is equivalent to a program over M on \u03a3 n of length at most c \u00b7 n k . Since J \u2282 DA, any monoid in J does also have this property. However, this does not imply that there exists some k \u2208 N working for all monoids in J, i.e. that P(J) collapses to P J, n k .",
            "cite_spans": [
                {
                    "start": 164,
                    "end": 168,
                    "text": "[23]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [],
            "section": "Fine Hierarchy"
        },
        {
            "text": "In this section, we show on the one hand that, as for DA, while P(J, s(n)) collapses to P(J) for any super-polynomial function s : N \u2192 N, there does not exist any k \u2208 N such that P(J) collapses to P J, n k ; and on the other hand that P(J k ) does optimally collapse to P J k , n k/2 for each k \u2208 N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fine Hierarchy"
        },
        {
            "text": "Given k, n \u2208 N, we say that \u03c3 is a k-selector over n if \u03c3 is a function of P([n]) [n] k that associates a subset of [n] to each vector in [n] k . For any sequence \u0394 = (\u03c3 n ) n\u2208N such that \u03c3 n is a k-selector over n for each n \u2208 N-a sequence we will call a sequence of k-selectors-, we set L \u0394 = n\u2208N K n,\u03c3n , where for each n \u2208 N, the language K n,\u03c3n is the set of words over {0, 1} of length (k + 1) \u00b7 n that can be decomposed into k + 1 consecutive blocks u (1) , u (2) , . . . , u (k) , v of n letters where the first k blocks each contain 1 exactly once and uniquely define a vector \u03c1 in [n] k , where for all i \u2208 [k], \u03c1 i is given by the position of the only 1 in u (i) (i.e. u (i) \u03c1i = 1) and v is such that there exists j \u2208 \u03c3 n (\u03c1) verifying that v j is 1. Observe that for any k-selector \u03c3 0 over 0, we have K 0,\u03c30 = \u2205.",
            "cite_spans": [
                {
                    "start": 459,
                    "end": 462,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 467,
                    "end": 470,
                    "text": "(2)",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Strict Hierarchy"
        },
        {
            "text": "We now proceed similarly to what has been done in Subsection 5.1 in [8] to show, on one hand, that for all k \u2208 N, there is a monoid M k in J 2k+1 such that for any sequence of k-selectors \u0394, the language L \u0394 is recognised by a sequence of programs over M k of length at most n k+1 ; and, on the other hand, that for all k \u2208 N there is a sequence of k-selectors \u0394 such that for any finite monoid M and any sequence of programs (P n ) n\u2208N over M of length at most n k , the language L \u0394 is not recognised by (P n ) n\u2208N .",
            "cite_spans": [
                {
                    "start": 68,
                    "end": 71,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Strict Hierarchy"
        },
        {
            "text": "We obtain the following proposition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Strict Hierarchy"
        },
        {
            "text": "Proposition 3. For all k \u2208 N, we have P J, n k \u2282 P J, n k+1 . More precisely, for all k \u2208 N and d \u2208 N, d \u2264 k 2 \u2212 1, we have P J k , n d \u2282 P J k , n d+1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Strict Hierarchy"
        },
        {
            "text": "Looking at Proposition 3, it looks at first glance rather strange that, for each k \u2208 N, we can only prove strictness of the hierarchy inside P(J k ) up to exponent k 2 . We now show, in a way similar to Subsection 5.2 in [8] , that in fact P(J k ) does collapse to P J k , n k/2 for all k \u2208 N, showing Proposition 3 to be optimal in some sense. Proposition 4. Let k \u2208 N. Let M \u2208 J k and \u03a3 be an alphabet. Then there exists a constant c \u2208 N >0 such that any program over M on \u03a3 n for n \u2208 N is equivalent to a program over M on \u03a3 n of length at most c \u00b7 n k/2 .",
            "cite_spans": [
                {
                    "start": 221,
                    "end": 224,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Collapse"
        },
        {
            "text": "In particular, P(J k ) = P J k , n k/2 for all k \u2208 N.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Collapse"
        },
        {
            "text": "The second part of our investigation of the computational power of programs over monoids in J is dedicated to understanding exactly what regular languages can be p-recognised by monoids in J.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Regular Languages in P(J)"
        },
        {
            "text": "It is shown in [8] that P(J) \u2229 Reg L(QJ), thus giving an example of a wellknown subvariety of A for which p-recognition allows to do unexpected things when recognising a regular language. How far does this unexpected power go?",
            "cite_spans": [
                {
                    "start": 15,
                    "end": 18,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "The first thing to notice is that, though none of them is in L(QJ), all languages of the form \u03a3 * u and u\u03a3 * for \u03a3 an alphabet and u \u2208 \u03a3 + are in P(J). Indeed, each of them can be recognised by a sequence of constant-length programs over the syntactic monoid of u \u03a3 * : for every input length, just output the image, through the syntactic morphism of u \u03a3 * , of the word made of the |u| first or last letters. So, informally stated, programs over monoids in J can check for some constant-length beginning or ending of their input words.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "But they can do much more. Indeed, the language (a+b) * ac + does not belong to L(QJ) (compute the stable monoid), yet it is in P(J). The crucial insight is that it can be program-reduced in linear length to the piecewise testable language of all words over {a, b, c} having ca as a subword but not the subwords cca, caa and cb by using the following trick (that we shall call \"feedback-sweeping\") for input length n \u2208 N: read the input letters in the order 2, 1, 3, 2, 4, 3, 5, 4, . . . , n, n\u2212 1, output the letters read. This has already been observed in [8, Proposition 5] .",
            "cite_spans": [
                {
                    "start": 558,
                    "end": 561,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 562,
                    "end": 576,
                    "text": "Proposition 5]",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "Using variants of the \"feedback-sweeping\" reading technique, we can prove that the phenomenon just described is not an isolated case. Lemma 2. The languages (a + b) * ac + , (a + b) * ac + a(a + b) * , c + a(a + b) * ac + , (a + b) * bac + and (a + b) * ac + (a + b) * ac + do all belong to P(J) \\ L(QJ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "Hence, we are tempted to say that there are \"much more\" regular languages in P(J) than just those in L(QJ), even though it is not clear to us whether L(QJ) \u2286 P(J) or not. But can we show any upper bound on P(J) \u2229 Reg? It turns out that we can, relying on two known results.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "First, since J \u2286 DA, we have P(J) \u2286 P(DA), so Theorem 6 in [8] , that states P(DA) \u2229 Reg = L(QDA), implies that P(J) \u2229 Reg \u2286 L(QDA).",
            "cite_spans": [
                {
                    "start": 59,
                    "end": 62,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "Second, let us define an important superclass of the class of piecewise testable languages. Let \u03a3 be an alphabet and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ); we define [u 1 , . . . , u k ] = \u03a3 * u 1 \u03a3 * \u00b7 \u00b7 \u00b7 \u03a3 * u k \u03a3 * . The class of dot-depth one languages is the class of Boolean combinations of languages of the form \u03a3 * u, u\u03a3 * and [u 1 , . . . , u k ] for \u03a3 an alphabet, k \u2208 N >0 and u, u 1 , . . . , u k \u2208 \u03a3 + . The inclusion-wise smallest variety of semigroups containing all syntactic semigroups of dot-depth one languages is denoted by J * D and verifies that L(J * D) is exactly the class of dot-depth one languages. (See [11, 15, 19] .) It has been shown in [11, Corollary 8] that P(J * D) \u2229 Reg = L(Q(J * D)) (if we extend the program-over-monoid formalism in the obvious way to finite semigroups). Now, we have J \u2286 J * D, so that P(J) \u2286 P(J * D) and hence P(J) \u2229 Reg \u2286 L(Q (J  *  D) ).",
            "cite_spans": [
                {
                    "start": 630,
                    "end": 634,
                    "text": "[11,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 635,
                    "end": 638,
                    "text": "15,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 639,
                    "end": 642,
                    "text": "19]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 667,
                    "end": 671,
                    "text": "[11,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 672,
                    "end": 684,
                    "text": "Corollary 8]",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 884,
                    "end": 893,
                    "text": "(J  *  D)",
                    "ref_id": null
                }
            ],
            "section": "Non-tameness of J"
        },
        {
            "text": "To summarise, we have the following. *  D) ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 37,
                    "end": 42,
                    "text": "*  D)",
                    "ref_id": null
                }
            ],
            "section": "Non-tameness of J"
        },
        {
            "text": "In fact, we conjecture that the inverse inclusion does also hold. *  D) ).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 66,
                    "end": 71,
                    "text": "*  D)",
                    "ref_id": null
                }
            ],
            "section": "Non-tameness of J"
        },
        {
            "text": "Why do we think this should be true? Though, for a given alphabet \u03a3, we cannot decide whether some word u \u2208 \u03a3 + of length at least 2 appears as a factor of any given word w in \u03a3 * with programs over monoids in J (because \u03a3 * u\u03a3 * / \u2208 L(QDA)), Lemma 2 and the possibilities offered by the \"feedback-sweeping\" technique give the impression that we can do it when we are guaranteed that u appears at most a fixed number of times in w, which seems somehow to be what dot-depth one languages become when restricted to belong to L(QDA). This intuition motivates the definition of threshold dot-depth one languages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Non-tameness of J"
        },
        {
            "text": "The idea behind the definition of threshold dot-depth one languages is that we take the basic building blocks of dot-depth one languages, of the form [u 1 , . . . , u k ] for an alphabet \u03a3, for k \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + , and restrict them so that, given l \u2208 N >0 , membership of a word does really depend on the presence of a given word u i as a factor if and only if it appears less than l times as a subword. Definition 1. Let \u03a3 be an alphabet. For all u \u2208 \u03a3 + and l \u2208 N >0 , we define [u] l to be the language of words over \u03a3 containing u l as a subword or u as a factor, i.e. [u] l = \u03a3 * u\u03a3 * \u222a u l \u03a3 * . Then, for all u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N, k \u2265 2) and l \u2208 N >0 , we define [u 1 , . . . ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Threshold Dot-Depth One Languages"
        },
        {
            "text": "Obviously, for each \u03a3 an alphabet, k \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + , the language [u 1 , . . . , u k ] 1 equals u 1 \u00b7 \u00b7 \u00b7 u k \u03a3 * . Over {a, b, c}, the language [ab, c] 3 contains all words containing a letter c verifying that in the prefix up to that letter, ababab appears as a subword or ab appears as a factor. Finally, the lan-",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Threshold Dot-Depth One Languages"
        },
        {
            "text": "We then define a threshold dot-depth one language as any Boolean combination of languages of the form \u03a3 * u, u\u03a3 * and [u 1 , . . . , u k ] l for \u03a3 an alphabet, for k, l \u2208 N >0 and u, u 1 , . . . , u k \u2208 \u03a3 + .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Threshold Dot-Depth One Languages"
        },
        {
            "text": "Confirming the intuition briefly given above, the technique of \"feedbacksweeping\" can indeed be pushed further to prove that the whole class of threshold dot-depth one languages is contained in P(J), and we dedicate the remainder of this section to prove it. Concerning Conjecture 1, our intuition leads us to believe that, in fact, the class of threshold dot-depth one languages with additional positional modular counting is exactly L(QDA) \u2229 L(Q(J * D)). We simply refer the interested reader to Section 5.4 of the author's Ph.D. thesis [7] , that contains a partial result supporting this belief, too technical and long to be presented here.",
            "cite_spans": [
                {
                    "start": 539,
                    "end": 542,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Threshold Dot-Depth One Languages"
        },
        {
            "text": "Let us now move on to the proof of the following theorem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Threshold Dot-Depth One Languages"
        },
        {
            "text": "As P(J) is closed under Boolean operations (Proposition 1), our goal is to prove, given an alphabet \u03a3, given l \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ), that [u 1 , . . . , u k ] l is in P(J); the case of \u03a3 * u and u\u03a3 * for u \u2208 \u03a3 + is easily handled (see the discussion at the beginning of Subsect. 4.1). To do this, we need to put [u 1 , . . . , u k ] l in some normal form. It is readily seen that [u 1 , . . . ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. Every threshold dot-depth one language belongs to P(J)."
        },
        {
            "text": "Definition 2. Let \u03a3 be an alphabet.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. Every threshold dot-depth one language belongs to P(J)."
        },
        {
            "text": "Building directly a sequence of programs over a monoid in J that decides L (l) (u1,q1) \u00b7 \u00b7 \u00b7 L (l) (u k ,q k ) for some alphabet \u03a3 and q 1 , . . . , q k \u2208 {1, l} seems however tricky. We need to split things further by controlling precisely how many times each u i for i \u2208 [k] appears in the right place when it does less than l times. To do this, we consider, for each \u03b1 \u2208 [l] k , the language R \u03b1 l (u 1 , . . . , u k ) defined below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. Every threshold dot-depth one language belongs to P(J)."
        },
        {
            "text": "Now, for a given \u03b1 \u2208 [l] k , we are interested in the words of R \u03b1 l (u 1 , . . . , u k ) such that for each i \u2208 [k] verifying \u03b1 i < l, the word u i indeed appears as a factor in the right place. We thus introduce a last language S \u03b1 l (u 1 , . . . , u k ) defined as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. Every threshold dot-depth one language belongs to P(J)."
        },
        {
            "text": "For all u 1 , . . . ,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "We now have the normal form we were looking for to prove Theorem 1: [u 1 , . . . , u k ] l is equal to the union, over all \u03b1 \u2208 [l] k , of the intersection of R \u03b1 l (u 1 , . . . , u k ) and S \u03b1 l (u 1 , . . . , u k ). Though rather intuitive, the correctness of this decomposition is not so straightforward to prove and, actually, we can only prove it when for each i \u2208 [k], the letters in u i are all distinct. Lemma 3. Let \u03a3 be an alphabet, l \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ) such that for each i \u2208 [k], the letters in u i are all distinct. Then, q1,...,q k \u2208{1,l}",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "Our goal now is to prove, given an alphabet \u03a3, given l \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ) such that for each i \u2208 [k], the letters in u i are all distinct, that for any \u03b1 \u2208 [l] k , the language R \u03b1 l (u 1 , . . . , u k ) \u2229 S \u03b1 l (u 1 , . . . , u k ) is in P(J); closure of P(J) under union (Proposition 1) consequently entails that [u 1 , . . . , u k ] l \u2208 P(J). The way R \u03b1 l (u 1 , . . . , u k ) and S \u03b1 l (u 1 , . . . , u k ) are defined allows us to reason as follows. For each i \u2208 [k] verifying \u03b1 i < l, let L i be the language of words w over \u03a3 containing x i,1 u i \u03b1i x i,2 as a subword but not x i,1 u i \u03b1i+1 x i,2 and such that w = y 1 u i y 2 with y 1 \u2208 x i,1 \u03a3 * and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": ",\u03b1i<l L i does belong to P(J) by closure of P(J) under intersection, Proposition 1. The lemma that follows, the main lemma in the proof of Theorem 1, exactly shows this. The proof crucially uses the \"feedback sweeping\" technique, but note that we actually don't know how to prove it when we do not enforce that for each i \u2208 [k], the letters in u i are all distinct.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "Lemma 4. Let \u03a3 be an alphabet and u \u2208 \u03a3 + such that its letters are all distinct. For all \u03b1 \u2208 N >0 and x 1 , x 2 \u2208 \u03a3 * , we have",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "Proof (Sketch). Let \u03a3 be an alphabet and u \u2208 \u03a3 + such that its letters are all distinct. Let \u03b1 \u2208 N >0 and x 1 , x 2 \u2208 \u03a3 * . We let",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "If |u| = 1, the lemma follows trivially because L is piecewise testable and hence belongs to L(J), so we assume |u| > 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "For each letter a \u2208 \u03a3, we shall use 2 |u| \u2212 1 distinct decorated letters of the form a (i) for some i \u2208 [[0, 2 |u| \u2212 2]], using the convention that a (0) = a; of course, for two distinct letters a, b \u2208 \u03a3, we have that a (i) and b (j) are distinct for all i, j \u2208 [[0, 2 |u| \u2212 2]]. We denote by A the alphabet of these decorated letters. The main idea of the proof is, for a given input length n \u2208 N, to build an A-program \u03a8 n over \u03a3 n such that, given an input word w \u2208 \u03a3 n , it first ouputs the |u| \u2212 1 first letters of w and then, for each i going from |u| to n, outputs w i , followed by w (1) i\u22121 \u00b7 \u00b7 \u00b7 w (|u|\u22121) i\u2212|u|+1 (a \"sweep\" of |u| \u2212 1 letters backwards down to position i \u2212 |u| + 1, decorating the letters incrementally) and finally by w (|u|) i\u2212|u|+2 \u00b7 \u00b7 \u00b7 w (2|u|\u22122) i (a \"sweep\" forwards up to position i, continuing the incremental decoration of the letters). The idea behind this way of rearranging and decorating letters is that, given an input word w \u2208 \u03a3 n , as long as we make sure that w and thus \u03a8 n (w) do contain x 1 u \u03b1 x 2 as a subword but not x 1 u \u03b1+1 x 2 , then \u03a8 n (w) can be decomposed as \u03a8 n (w) = y 1 zy 2 where y 1 \u2208 x 1 \u03a3 * , y 2 \u2208 x 2 \u03a3 * , and |y 1 | , |y 2 | are minimal, with z containing u \u03b2 u (1) |u|\u22121 \u00b7 \u00b7 \u00b7 u (|u|\u22121) 1 u (|u|) 2 \u00b7 \u00b7 \u00b7 u (2|u|\u22122) |u| u \u03b1\u2212\u03b2 as a subword for some \u03b2 \u2208 [\u03b1] if and only if w \u2208 (x 1 \u03a3 * )u(x 2 \u03a3 * ). This means we can check whether w \u2208 L by testing whether w belongs to some fixed piecewise testable language over A.",
            "cite_spans": [
                {
                    "start": 592,
                    "end": 595,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 749,
                    "end": 754,
                    "text": "(|u|)",
                    "ref_id": null
                },
                {
                    "start": 1233,
                    "end": 1236,
                    "text": "(1)",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "As explained before stating the previous lemma, we can now use it to prove the result we were aiming for. Proposition 6. Let \u03a3 be an alphabet, l \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ) such that for each i \u2208 [k], the letters in u i are all distinct. For all \u03b1 \u2208 [l] k , we have R \u03b1 l (u 1 , . . . , u k ) \u2229 S \u03b1 l (u 1 , . . . , u k ) \u2208 P(J). We thus derive the awaited corollary. However, what we really want to obtain is that [u 1 , . . . , u k ] l \u2208 P(J) without putting any restriction on the u i 's. But, in fact, to remove the constraint that the letters must be all distinct in each of the u i 's, we simply have to decorate each of the input letters with its position minus 1 modulo a big enough d \u2208 N >0 . This finally leads to the following proposition.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "Proposition 7. Let \u03a3 be an alphabet, l \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ). Then [u 1 , . . . , u k ] l \u2208 P(J).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "This finishes to prove Theorem 1 by closure of P(J) under Boolean combinations (Proposition 1) and by the discussion at the beginning of Subsect. 4.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4. Let \u03a3 be an alphabet."
        },
        {
            "text": "Although P(J) is very small compared to AC 0 , we have shown that programs over monoids in J are an interesting subject of study in that they allow to do quite unexpected things. The \"feedback-sweeping\" technique allows one to detect presence of a factor thanks to such programs as long as this factor does not appear too often as a subword: this is the basic principle behind threshold dot-depth one languages, that our article shows to belong wholly to P(J).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "Whether threshold dot-depth one languages with additional positional modular counting do correspond exactly to the languages in L(QDA) \u2229 L(Q(J * D)) seems to be a challenging question, that we leave open. In his Ph.D. thesis [7] , the author proved that all strongly unambiguous monomials (the basic building blocks in L(DA)) that are imposed to belong to L(J * D) at the same time are in fact threshold dot-depth one languages. However, the proof looks much too complex and technical to be extended to, say, all languages in L(DA) \u2229 L(J * D). New techniques are probably needed, and we might conclude by saying that proving (or disproving) this conjecture could be a nice research goal in algebraic automata theory.",
            "cite_spans": [
                {
                    "start": 225,
                    "end": 228,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "\u03a3 1 1 -formulae on finite structures",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ajtai",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "Ann. Pure Appl. Logic",
            "volume": "24",
            "issn": "1",
            "pages": "1--48",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Bounded-width polynomial-size branching programs recognize exactly those languages in NC 1",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "A M"
                    ],
                    "last": "Barrington",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "J. Comput. Syst. Sci",
            "volume": "38",
            "issn": "1",
            "pages": "150--164",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Finite monoids and the fine structure of NC 1",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "A M"
                    ],
                    "last": "Barrington",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": 1988,
            "venue": "J. ACM",
            "volume": "35",
            "issn": "4",
            "pages": "941--952",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Automata, Languages, and Machines",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Eilenberg",
                    "suffix": ""
                }
            ],
            "year": 1974,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Automata, Languages, and Machines",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Eilenberg",
                    "suffix": ""
                }
            ],
            "year": 1976,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Parity, circuits, and the polynomial-time hierarchy",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Furst",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "B"
                    ],
                    "last": "Saxe",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sipser",
                    "suffix": ""
                }
            ],
            "year": 1984,
            "venue": "Math. Syst. Theory",
            "volume": "17",
            "issn": "1",
            "pages": "13--27",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "The limits of Ne\u010diporuk's method and the power of programs over monoids taken from small varieties of finite monoids",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Grosshans",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "The power of programs over monoids in DA",
            "authors": [
                {
                    "first": "N",
                    "middle": [],
                    "last": "Grosshans",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Mckenzie",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Segoufin",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "MFCS 2017",
            "volume": "2",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Hierarchies of piecewise testable languages",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Kl\u00edma",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pol\u00e1k",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Int. J. Found. Comput. Sci",
            "volume": "21",
            "issn": "4",
            "pages": "517--533",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "An algebraic point of view on the Crane Beach property",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lautemann",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Tesson",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "CSL 2006",
            "volume": "4207",
            "issn": "",
            "pages": "426--440",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Programs over semigroups of dot-depth one",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Maciel",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "P\u00e9ladeau",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Theor. Comput. Sci",
            "volume": "245",
            "issn": "1",
            "pages": "135--148",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "NC 1 : the automata-theoretic viewpoint",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Mckenzie",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "P\u00e9ladeau",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Comput. Complex",
            "volume": "1",
            "issn": "",
            "pages": "330--359",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Classes de circuits bool\u00e9ens et vari\u00e9t\u00e9s de mono\u00efdes",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "P\u00e9ladeau",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Finite semigroup varieties defined by programs",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "P\u00e9ladeau",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Straubing",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Theor. Comput. Sci",
            "volume": "180",
            "issn": "1-2",
            "pages": "325--339",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "The dot-depth hierarchy, 45 years later",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pin",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "The Role of Theory in Computer Science -Essays Dedicated to Janusz Brzozowski",
            "volume": "",
            "issn": "",
            "pages": "177--202",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Varieties of Formal Languages",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pin",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Some results on C-varieties",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pin",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Straubing",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "ITA",
            "volume": "39",
            "issn": "1",
            "pages": "239--262",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Piecewise testable events",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Simon",
                    "suffix": ""
                }
            ],
            "year": 1975,
            "venue": "GI-Fachtagung 1975",
            "volume": "33",
            "issn": "",
            "pages": "214--222",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-07407-4_23"
                ]
            }
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Finite semigroup varieties of the form V * D",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Straubing",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "J. Pure Appl. Algebra",
            "volume": "36",
            "issn": "",
            "pages": "53--94",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "When can one finite monoid simulate another?",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Straubing",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Birget",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Margolis",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Meakin",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Algorithmic Problems in Groups and Semigroups",
            "volume": "",
            "issn": "",
            "pages": "267--288",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-4612-1388-8_15"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Languages defined with modular counting quantifiers",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Straubing",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Inf. Comput",
            "volume": "166",
            "issn": "2",
            "pages": "112--132",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Computational complexity questions related to finite monoids and semigroups",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Tesson",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "The computing power of programs over finite monoids",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Tesson",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Th\u00e9rien",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "J. Autom. Lang. Comb",
            "volume": "7",
            "issn": "2",
            "pages": "247--258",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "P(J) \u2229 Reg \u2286 L(QDA) \u2229 L(Q(J",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "P(J) \u2229 Reg = L(QDA) \u2229 L(Q(J",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Let \u03a3 be an alphabet, l \u2208 N >0 and u 1 , . . . , u k \u2208 \u03a3 + (k \u2208 N >0 ) such that for each i \u2208 [k], the letters in u i are all distinct. Then, [u 1 , . . . , u k ] l \u2208 P(J).",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgements. The author thanks the anonymous referees for their helpful comments and suggestions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}