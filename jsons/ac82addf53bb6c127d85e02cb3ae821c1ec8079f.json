{
    "paper_id": "ac82addf53bb6c127d85e02cb3ae821c1ec8079f",
    "metadata": {
        "title": "FlowRec: Prototyping Session-Based Recommender Systems in Streaming Mode",
        "authors": [
            {
                "first": "Dimitris",
                "middle": [],
                "last": "Paraschakis",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Malm\u00f6 University",
                    "location": {
                        "addrLine": "Nordenski\u00f6ldsgatan 1",
                        "postCode": "211 19",
                        "settlement": "Malm\u00f6",
                        "country": "Sweden"
                    }
                },
                "email": "dimitris.paraschakis@mau.se"
            },
            {
                "first": "B",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Malm\u00f6 University",
                    "location": {
                        "addrLine": "Nordenski\u00f6ldsgatan 1",
                        "postCode": "211 19",
                        "settlement": "Malm\u00f6",
                        "country": "Sweden"
                    }
                },
                "email": ""
            },
            {
                "first": "Bengt",
                "middle": [
                    "J"
                ],
                "last": "Nilsson",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Malm\u00f6 University",
                    "location": {
                        "addrLine": "Nordenski\u00f6ldsgatan 1",
                        "postCode": "211 19",
                        "settlement": "Malm\u00f6",
                        "country": "Sweden"
                    }
                },
                "email": "bengt.nilsson.ts@mau.se"
            }
        ]
    },
    "abstract": [
        {
            "text": "Despite the increasing interest towards session-based and streaming recommender systems, there is still a lack of publicly available evaluation frameworks supporting both these paradigms. To address the gap, we propose FlowRec -an extension of the streaming framework Scikit-Multiflow, which opens plentiful possibilities for prototyping recommender systems operating on sessionized data streams, thanks to the underlying collection of incremental learners and support for realtime performance tracking. We describe the extended functionalities of the adapted prequential evaluation protocol, and develop a competitive recommendation algorithm on top of Scikit-Multiflow's implementation of a Hoeffding Tree. We compare our algorithm to other known baselines for the next-item prediction task across three different domains.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "In the past few years, the RecSys community has witnessed a paradigm shift from the traditional matrix completion problem to sequential session-based recommendations [9, 15] . The latter approach is dominated by neural methods that are often evaluated in an online manner, i.e. when the events of a session are sequentially revealed and predicted one-by-one. However, these systems are still trained in batches on large chunks of recorded data [7, 15, 19] . To better approximate realworld scenarios with severe cold-start and concept drifts, streaming recommender systems [3, 18, 20] have been designed for incremental online learning from continuous data streams in the context of limited memory/runtime, and anytime prediction [17] . However, most of them address the conventional rather than session-based recommendation problem [6] . Bridging the gap between sessionbased and streaming recommender systems has been recently attempted [6, 9] , marking an emerging research direction of a high practical value.",
            "cite_spans": [
                {
                    "start": 166,
                    "end": 169,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 170,
                    "end": 173,
                    "text": "15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 444,
                    "end": 447,
                    "text": "[7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 448,
                    "end": 451,
                    "text": "15,",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 452,
                    "end": 455,
                    "text": "19]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 573,
                    "end": 576,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 577,
                    "end": 580,
                    "text": "18,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 581,
                    "end": 584,
                    "text": "20]",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 730,
                    "end": 734,
                    "text": "[17]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 833,
                    "end": 836,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 939,
                    "end": 942,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 943,
                    "end": 945,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Presently, only a few publicly available benchmarking frameworks for streaming recommendations exist. Some of them have been designed for a specific application domain [9, 16] , while others lack native support for session data [5, 11] . Scikit-Multiflow [14] has recently been released as a generalpurpose Python framework for stream mining, offering a variety of stream learners, change detectors, and evaluation methods. To facilitate the research on streaming session-based recommendations, we propose FlowRec 1 -an extension of Scikit-Multiflow for rapid prototyping of recommender systems. The proposed framework currently contains several stream-oriented recommenders and metrics for prequential evaluation. Additionally, we demonstrate a principled way of exposing a recommendation interface to an underlying stream learner class of Scikit-Multiflow (namely, a Hoeffding Tree). We show that the resulting recommender system has remarkable performance against established baselines. FlowRec's functionality is detailed in the next section.",
            "cite_spans": [
                {
                    "start": 168,
                    "end": 171,
                    "text": "[9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 172,
                    "end": 175,
                    "text": "16]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 228,
                    "end": 231,
                    "text": "[5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 232,
                    "end": 235,
                    "text": "11]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 255,
                    "end": 259,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The framework consists of three main entities: a stream, an evaluator, and a model. This section describes the interplay between these entities.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "FlowRec"
        },
        {
            "text": "Consider a stream D of (overlapping) user sessions S = s 1 , . . . , s |S| (Fig. 1) . A session represents an ordered sequence of events of the form (X, y), where X is a feature vector describing the context for item y. As a bare minimum, X contains the session identifier for the item. Other common features are timestamp and event type (e.g. click, purchase, etc.). The scope of our study is limited to the context of collaborative filtering, which relaxes the assumption of item metadata in feature vectors (technically, any feature can be encoded as a part of X).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 75,
                    "end": 83,
                    "text": "(Fig. 1)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Problem Setting"
        },
        {
            "text": "At each time step t = 1, . . . , T , the stream provides a sample (X, y). Based on the information in X, the model is asked to generate a list of N prediction\u015d Y = (\u0177 1 , . . . ,\u0177 N ) in an attempt to correctly guess the hidden item y. This corresponds to the next-item prediction task in the RecSys literature [15] . In practice, only certain features of X are retained for the prediction part, such as the current session identifier, and possibly the timestamp of the event. After the prediction, the entire feature vector X together with the label y are revealed to the model, allowing it to make an incremental update. This iterative, supervised 'test-then-train' methodology is known as prequential evaluation [20] (Fig. 2) .",
            "cite_spans": [
                {
                    "start": 311,
                    "end": 315,
                    "text": "[15]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 715,
                    "end": 719,
                    "text": "[20]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [
                {
                    "start": 720,
                    "end": 728,
                    "text": "(Fig. 2)",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Problem Setting"
        },
        {
            "text": "In our framework, each processed sample (X, y) is added to the sliding window of the last n observations, which we refer to as observation window (depicted as the green box in Fig. 1 ). Although its use is not required in the ordinary stream learning, it can ease the development of session-based models by providing a snapshot of the recent session data on demand. The size of the window must be chosen in consideration of the system's memory and runtime constraints.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 176,
                    "end": 182,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Problem Setting"
        },
        {
            "text": "FlowRec implements several evaluation metrics, two of which are commonly used for next-item prediction [6, 7, 13, 19] , namely recall (a.k.a. hitrate) and mean reciprocal rank (MRR). Recall measures the average number of successful predictions, whereas MRR measures their average reciprocal ranking, i.e.:",
            "cite_spans": [
                {
                    "start": 103,
                    "end": 106,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 107,
                    "end": 109,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 110,
                    "end": 113,
                    "text": "13,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 114,
                    "end": 117,
                    "text": "19]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Metrics"
        },
        {
            "text": "The framework keeps two sets of measurements: (a) global, where the running average of each metric is calculated from all the past data; and (b) sliding, where the average is taken over a sliding window of recent events that we call the evaluation window (purple box in Fig. 1 ). The sizes of evaluation and observation windows are user-adjustable, offering flexibility in simulation setups. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 270,
                    "end": 276,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Metrics"
        },
        {
            "text": "The basic workflow for measuring recall using prequential evaluation is presented in Algorithm 1. The complete functionality of Scikit-Multiflow's prequential evaluator is provided in its official documentation 2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "FlowRec introduces the following additional parameters 3 for the evaluator:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "-Indices of data columns holding session, timestamp, and event type identifiers. The last two columns are optional, and allow for time-aware and event-specific training and/or evaluation. -Stream-related configurations, such as the size of the observation window, and the number of events to skip from the start of the stream.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "-Recommendation-specific settings, such as the size of the recommendation list, and the event types that trigger recommendation requests. There are also flags for enabling/disabling reminders and repeated recommendations. Reminders are recommendations of items that were visited earlier by the user, whereas repeated recommendations are those that were already given earlier to the user. if y \u2208 top N (\u0176 ) then 10:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "rm \u2190 rm + 1 11:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "n \u2190 n + 1 12:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "for all m \u2208 M do 13:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "m.partial fit(X, y) 14:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "W.add(X, y) 15: return rm/n, \u2200m \u2208 M The size of the evaluation window (as well as other settings) are covered by the original parameter list of the EvaluatePrequential class in Scikit-Multiflow. Note that the stream provides samples in the order as they appear in the dataset. The last column of the dataset should always contain the item identifiers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation"
        },
        {
            "text": "Prototyping incremental session-based recommendation models in FlowRec is straightforward. First, a streaming model is built by extending the BaseSKMObject class of Scikit-Multiflow with the appropriate mixin. It is natural to treat the recommendation task as a multi-class classification problem, where each class corresponds to an item. Hence, the suitable mixin for this type of problems is ClassifierMixin 4 . What remains is to implement the following abstract methods: partial fit(X, y) -Incrementally train a stream model. predict(X) -Generate top-N predictions for the target's class. predict proba(X) -Calculate the probabilities of a sample pertaining to each of the available classes (implementing this method is optional).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prototyping"
        },
        {
            "text": "Every stream model developed in FlowRec has access to useful shared resources, such as observation window, current session vector, and item catalog.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prototyping"
        },
        {
            "text": "Presently, FlowRec contains the following streaming models for session-based recommendations:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Session-Based Streaming Models"
        },
        {
            "text": "Rule-Based Models. The first three models are rule-based recommenders that capture one-to-one relationships between items. These methods rely on the very last item of a session to make their predictions for the next item. Despite their simplicity, rule-based models have proven surprisingly effective in the domains of music and e-commerce [13] , and have very low computational complexity. We briefly outline these methods below (refer to [13] for details).",
            "cite_spans": [
                {
                    "start": 340,
                    "end": 344,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 440,
                    "end": 444,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Session-Based Streaming Models"
        },
        {
            "text": "The rules are derived from co-occurrences of two items in a session (e.g. 'those-who-bought-also-bought'). A co-occurrence forms rules in both directions, i.e. y t \u2194 y t , t = t . Markov Chains (MC). The rules are derived from a first-order Markov Chain, describing the transition probability between items that appear in two contiguous events in a session, i.e. y t \u2192 y t+1 . Sequential Rules (SR). The rules are derived from sequential patterns between two items in a session, but not necessarily in successive events, i.e. y t \u2192 y t , t > t. The sequential association is assigned the weight 1/(t \u2212 t).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Association Rules (AR)."
        },
        {
            "text": "In FlowRec, the above algorithms can be made event-specific by providing event column index. For instance, predictors of type purchase \u2194 purchase, click \u2192 purchase, etc. can be useful in e-commerce applications as components of an ensemble recommender [2] .",
            "cite_spans": [
                {
                    "start": 252,
                    "end": 255,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Association Rules (AR)."
        },
        {
            "text": "Session kNN. This is a specialized version of the k-Nearest Neighbors (kNN) algorithm that operates on session data. It is a strong baseline with performance comparable to that of certain deep neural methods [8, 13] . Being model-free, the algorithm is incremental by nature. S-kNN recommends items from other user sessions that are similar to the current session (a.k.a. neighbors). Given the active session S, the score of the candidate item\u0177 is calculated as follows:",
            "cite_spans": [
                {
                    "start": 208,
                    "end": 211,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 212,
                    "end": 215,
                    "text": "13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Association Rules (AR)."
        },
        {
            "text": "where N (S) is the k-sized neighborhood of session S, and sim(S, S ) is a measure of similarity between two sessions. FlowRec implements Cosine, Jaccard, Dice, and Tanimoto similarity. In the future, we plan to implement other kNN variants described in [13] .",
            "cite_spans": [
                {
                    "start": 253,
                    "end": 257,
                    "text": "[13]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Association Rules (AR)."
        },
        {
            "text": ". This is a bandit ensemble designed for streaming recommendations, which employs Thompson Sampling for the model selection. In [2] , eventspecific rule-based models were used as behavioral components of the ensemble. In FlowRec, any model implementing the predict proba(X) method can be added as a component of BEER [TS] . For each recommendation slot, the ensemble picks a model m with the highest sample \u03b8 m \u223c Beta(\u03b1 m + 1, \u03b2 m + 1), where \u03b1 m is the number of past successes, and \u03b2 m is the number of past failures. The method is adaptable to non-stationary data (e.g. occurring due to concept drift), which is achieved via exploration-exploitation. In addition, BEER[TS] supports component splitting into (relatively) stationary partitions (see [2] for details), which is achieved in FlowRec by setting the boundaries for probabilities returned by the predict proba(X) method. Further, the components of the ensemble can complement each other in case of poor coverage, which helps to attack sparsity and cold-start issues.",
            "cite_spans": [
                {
                    "start": 128,
                    "end": 131,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 317,
                    "end": 321,
                    "text": "[TS]",
                    "ref_id": null
                },
                {
                    "start": 750,
                    "end": 753,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "BEER[TS]"
        },
        {
            "text": "Popularity Baseline. This is the traditional baseline that outputs the top-N most popular items in descending order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "BEER[TS]"
        },
        {
            "text": "The above methods can be incrementally trained either on the global scale, or within the observation window. The latter option acts as a forgetting mechanism for older data, which aids model scalability and adaptability to recent trends.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "BEER[TS]"
        },
        {
            "text": "Prototyping streaming session-based recommenders can be facilitated by employing the rich collection of incremental algorithms offered by Scikit-Multiflow, including Bayesian methods, lazy learners, ensembles, neural networks, treebased methods, and more [14] . Utilizing any of these methods for recommendation tasks is achieved via a wrapper, which is a middle layer that handles the inputs and the outputs of an underlying learner. Some of the common tasks performed by wrappers include:",
            "cite_spans": [
                {
                    "start": 255,
                    "end": 259,
                    "text": "[14]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Hoeffding Tree Wrapper"
        },
        {
            "text": "-transforming a sample to the desired input format accepted by a learner. -calling the predict proba(X) method of a learner, and manipulating its return values to generate top-N recommendations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree Wrapper"
        },
        {
            "text": "Using the above approach, we develop a recommender system by 'wrapping' the HoeffdingTree classifier provided by Scikit-Multiflow.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree Wrapper"
        },
        {
            "text": ", a HT is an incremental, anytime decision tree inducer designed for learning from data streams. Its key idea lies in the fact that only a small subset of samples passing through a node may be sufficient for deciding on the split attribute. For estimating the minimum number of samples needed, the method employs the Hoeffding bound, which offers sound theoretical guarantees of performance (see [4] for details), asymptotically comparable to that of a batch decision tree.",
            "cite_spans": [
                {
                    "start": 396,
                    "end": 399,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "HT Wrapper Architecture. The Scikit-Multiflow's implementation of a HT supports Naive Bayes prediction at the leaves of the tree, and the possibility of assigning a weight to each fitted sample. We take advantage of both capabilities in the proposed HT recommender. The core idea of our algorithm is to encode all item-to-item associations employed by rule-based methods (see above) in a unified learner. This allows HT to capture both sequential and co-occurrence patterns in a session. The idea is conceptually similar to the BEER[TS] framework [2] , but instead of treating between-items associations as separate predictors explored by a bandit, we fit them to a single decision tree classifier using a specific weighting scheme, as explained below. We hence formulate the recommendation task as a multi-class classification problem. Due to the nature of the problem, HT is reduced to a decision stump, whose nodes represent input items, and the leaves contain item predictions obtained via Naive Bayes classification.",
            "cite_spans": [
                {
                    "start": 547,
                    "end": 550,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "Training the Model. The incremental training of a HT in Scikit-Multiflow can be done by calling the method partial fit(X, y, sample weight). The first two parameters specify the input feature vector and the output label, respectively, with an associated (optional) sample weight. We use these parameters to encode the sequential relation between two items, by letting the feature vector contain the antecedent item and the label represent the consequent item. For the ease of notation, we use the item in place of a feature vector in Algorithm 2 (y or y , lines 7 and 8). Internally, each antecedent is represented as a node of the tree. if i = |S| then 4:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "w \u2190 wMC weight for the 'next-item' sequence 5: else 6:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "w \u2190 1/(|S| \u2212 i + 1) weight for a non-contiguous sequence 7:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "ht.partial fit(y i , y, w) fit observed sequence 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "ht.partial fit(y, y i , w \u00b7 winv) fit inverse (unobserved) sequence",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "After fetching the current session vector S from the observation window, the wrapper learns all sequential patterns involving item y by fitting a series of samples (y i , y, w), \u2200i = 1, . . . , |S|, where the sample weight is inversely proportional to the distance between two items. Clearly, these fits utilize the same patterns as captured in Sequential Rules (SR) described above. Among these patterns, y |S| \u2192 y pertains to the Markov Chain (MC). The corresponding sample, (y |S| , y, w MC ), uses a separate weight reflecting the perceived importance of the 'next-item' sequence. Finally, encoding co-occurrence patterns captured by Association Rules (AR) is achieved via a series of the so-called inverse fits, i.e. (y, y i , w \u00b7 w inv ), \u2200i = 1, . . . , |S|, which complete the bidirectional associations. The fixed weight w inv \u2208 [0, 1] is used to inform the influence of inverse (hence unobserved) sequential patterns on the classification.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoeffding Tree (HT). Also known as a Very Fast Decision Tree (VFDT) [4]"
        },
        {
            "text": "Unlike rule-based methods, where the predictions are made solely on the basis of the latest item in a session, our HT wrapper makes predictions in an ensemble-like manner by combining the responses of all the relevant nodes of the tree. The prediction procedure is detailed in Algorithm 3. Pi \u2190 ht.predict proba(y i ) predict class probabilities from item y i 5:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Making Predictions."
        },
        {
            "text": "if i = |S| then 6:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Making Predictions."
        },
        {
            "text": "Pi \u2190 Pi \u00b7 wMC 7: else 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Making Predictions."
        },
        {
            "text": "Pi \u2190 Pi/(|S| \u2212 i + 1) 9:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Making Predictions."
        },
        {
            "text": "P \u2190 P + Pi 10: return\u0176 \u2190 (y1, . . . , yN ), \u2200P(yi) \u2208 top-N (P )",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Making Predictions."
        },
        {
            "text": "For each item y i in the current session vector, the wrapper calls the predict proba(y i ) method of a HT. This method returns a class probability vector that expresses the likelihood of each candidate item to follow item y i . The probability vectors P i are then weighted with the recency of item y i . Predictions obtained from the most recent item, y |S| , receive the highest weight specified by w MC . All weighted probability vectors are then added to produce the final scores for the candidate items, top-N of which are returned.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Making Predictions."
        },
        {
            "text": "We use public datasets containing sessionized browsing logs. The datasets originate from three recommendation contests representing news, travel, and ecommerce domains. They are summarized in Table 1 . ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 192,
                    "end": 199,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Datasets"
        },
        {
            "text": "We consider the task of online next-item recommendation, where the goal is to suggest the list of most probable items to appear in the next session event. We track Recall@10 and MRR@10 during the entire run of the simulation using the real-time visualizer provided by the framework, which reports the global and the current (sliding) averages. Time horizon for each simulation is set to 1M events, with evaluation and observation window sizes of 10K and 50K events, respectively. The latter size was chosen in consideration of sufficient (sliding) session history and a reasonable memory/runtime overhead. We use a separate validation set of 100K events (preceding those of the simulation) for hyperparameter tuning. The evaluation itself is performed from pure cold-start, with no model pre-training involved. Sessions of size 1 are excluded from the evaluation. For our simulations, we use Intel Core i7 CPU @ 2.80 GHz and 16 Gb RAM.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Prequential Evaluation Setup"
        },
        {
            "text": "We evaluate the models presented in Sect. 3, with an addition of a Random classifier that sets the lower bound for performance. Below we briefly outline the optimal model configurations after the hyperparameter tuning step.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Model Setup"
        },
        {
            "text": "Rule-based (AR, MC, SR) models operate on a global scale, whereas the popularity-based one (POP) works within a sliding window. S-kNN uses Cosine similarity, and k = 100 (Trivago), k = 200 (Clef), k = 300 (Yoochoose). We also use recent session sub-sampling [8] , with sub-sample sizes of 500 (Clef), 1000 (Trivago), and 1500 (Yoochoose). BEER[TS] includes AR, MC, SR, POP, and S-kNN as components of the ensemble. The HT wrapper uses weights w MC = 3 (Yoochoose), w MC = 5 (Clef, Trivago), and w inv = 0.01 (Clef), w inv = 0.9 (Yoochoose, Trivago). The HoeffdingTree class of Scikit-Multiflow is instantiated with leaf prediction='nb' to enable Naive Bayes prediction at the leaves. The preconfigured experiments are provided in FlowRec's code base for reproducibility. ",
            "cite_spans": [
                {
                    "start": 258,
                    "end": 261,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Model Setup"
        },
        {
            "text": "The results of the simulation for the three datasets are presented in Fig. 3 . The top performing model in each case is marked with an asterisk. Note that the column 'Sliding' contains the averages of the very last evaluation window.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 70,
                    "end": 76,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Results"
        },
        {
            "text": "The HT wrapper consistently achieves higher recall and MRR than the other baselines on all three datasets. This proves the effectiveness of combining item-toitem sequential patterns, and utilizing the entire user session at prediction time in an ensemble-like manner. The HT wrapper also happens to be noticeably faster than its main rival, BEER[TS] (in its current configuration). The total running times for each model are recorded by the framework. As a point of reference, we consider the upper limit of 100 ms per recommendation prescribed by the CLEF NewsReel challenge [10] . Table 2 reports average response times per recommendation request for each model. We observe that all runtimes fall within the recommended limit. The real-time visualization offers the possibility to diagnose potential issues at an early stage. For instance, the performance charts for Yoochoose and Trivago make it obvious that the inclusion of POP to BEER[TS] is not justified, and hence it can be dropped from the ensemble to gain speed. The live monitoring of model evolution helps to see how algorithms behave relative to each other on various segments of the dataset, as well as to better understand the peculiarities of the dataset itself. For example, the above two charts clearly show the stagnation of S-kNN after leaving the initial cold-start segment (\u22480-50K), while other models continue to learn. We also see that Clef exhibits a more dynamic domain (news) with more profound concept drift, which makes learning more challenging. It is the only dataset where the popularity recommender has decent performance, surpassing other models on certain data segments. The Clef chart also reveals the 'easy' portion of the dataset (\u2248600K-800K), where most algorithms (but not POP) boost their performance. ",
            "cite_spans": [
                {
                    "start": 576,
                    "end": 580,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [
                {
                    "start": 583,
                    "end": 590,
                    "text": "Table 2",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Results"
        },
        {
            "text": "We introduce FlowRec -a new recommendation framework for streaming session data developed on top of Scikit-Multiflow. It serves as a testbed for streaming recommendation models by offering prequential evaluation with realtime performance monitoring. One advantage of prototyping in FlowRec is the ability to 'wrap' various stream learners provided by Scikit-Multiflow, thus treating them as black boxes. We demonstrate how to develop such a wrapper for the HoeffdingTree class, capable of generating accurate session-based recommendations on evolving data streams. The framework will be further extended with additional evaluation protocols, metrics, and algorithms.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Proceedings of the 9th ACM Conference on Recommender Systems",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Ben-Shimon",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tsikinovsky",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Friedmann",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Shapira",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Rfokach",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hoerle",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "357--358",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A bandit-based ensemble framework for exploration/exploitation of diverse recommendation components: an experimental study within e-commerce",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Brod\u00e9n",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hammar",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "J"
                    ],
                    "last": "Nilsson",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Paraschakis",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "ACM Trans. Interact. Intell. Syst",
            "volume": "10",
            "issn": "1",
            "pages": "1--4",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Real-time top-n recommendation in social streams",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Diaz-Aviles",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Drumond",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Schmidt-Thieme",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Nejdl",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the Sixth ACM Conference on Recommender Systems",
            "volume": "",
            "issn": "",
            "pages": "59--66",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Mining high-speed data streams",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Domingos",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Hulten",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "Proceedings of the Sixth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining",
            "volume": "",
            "issn": "",
            "pages": "71--80",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Alpenglow: open source recommender framework with time-aware learning and evaluation",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Frig\u00f3",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "P\u00e1lovics",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kelen",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kocsis",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bencz\u00far",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "2017 Poster Track of the 11th ACM Conference on Recommender Systems (Poster-Recsys 2017)",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Streaming session-based recommendation",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Guo",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Yin",
                    "suffix": ""
                },
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Quoc Viet Hung",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery & Data Mining (KDD 2019)",
            "volume": "",
            "issn": "",
            "pages": "1569--1577",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Session-based recommendations with recurrent neural networks",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Hidasi",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Karatzoglou",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Baltrunas",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Tikk",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "When recurrent neural networks meet the neighborhood for session-based recommendation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jannach",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ludewig",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of the 11th ACM Conference on Recommender Systems",
            "volume": "",
            "issn": "",
            "pages": "306--310",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Streamingrec: a framework for benchmarking stream-based news recommenders",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Jugovac",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jannach",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Karimi",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 12th ACM Conference on Recommender Systems",
            "volume": "",
            "issn": "",
            "pages": "269--273",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Stream-based recommendations: online and offline evaluation as a service",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Kille",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "CLEF 2015",
            "volume": "9283",
            "issn": "",
            "pages": "497--517",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Flurs: a python library for online item recommendation",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Kitazawa",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Recsys challenge 2019: session-based hotel recommendations",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Knees",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Deldjoo",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "B"
                    ],
                    "last": "Moghaddam",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Adamczak",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "P"
                    ],
                    "last": "Leyson",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Monreal",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 13th ACM Conference on Recommender Systems",
            "volume": "",
            "issn": "",
            "pages": "570--571",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Evaluation of session-based recommendation algorithms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Ludewig",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Jannach",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "User Model. User Adapt. Interact",
            "volume": "28",
            "issn": "4-5",
            "pages": "331--390",
            "other_ids": {
                "DOI": [
                    "10.1007/s11257-018-9209-6"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Scikit-multiflow: a multi-output streaming framework",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Montiel",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Read",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Bifet",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Abdessalem",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "J. Mach. Learn. Res",
            "volume": "19",
            "issn": "72",
            "pages": "1--5",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Algorithms for sequence-aware recommender systems",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Quadrana",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Idomaar: a framework for multi-dimensional benchmarking of recommender algorithms",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Scriminaci",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "RecSys Posters. CEUR Workshop Proceedings",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Performance analysis of hoeffding trees in data streams by using massive online analysis framework",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Srimani",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "M"
                    ],
                    "last": "Patil",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Int. J. Data Min. Model. Manage",
            "volume": "7",
            "issn": "4",
            "pages": "293--313",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "Recommendations for streaming data",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Subbian",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Aggarwal",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Hegde",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 25th ACM International on Conference on Information and Knowledge Management (CIKM 2016)",
            "volume": "",
            "issn": "",
            "pages": "2185--2190",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Improved recurrent neural networks for session-based recommendations",
            "authors": [
                {
                    "first": "Y",
                    "middle": [
                        "K"
                    ],
                    "last": "Tan",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Proceedings of the 1st Workshop on Deep Learning for Recommender Systems (DLRS 2016)",
            "volume": "",
            "issn": "",
            "pages": "17--22",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Evaluation of recommender systems in streaming environments",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Vinagre",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "M"
                    ],
                    "last": "Jorge",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Gama",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "ACM RecSys Workshop on Recommender Systems Evaluation: Dimensions and Design",
            "volume": "",
            "issn": "",
            "pages": "393--394",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Streaming sessions (Color figure online) Fig. 2. Prequential protocol",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Basic prequential protocol for measuring recall Input: D: data stream, N : recommendation cutoff, n keep : size of the observation window, M : set of recommendation models Output: Recall@N of each model 1: W \u2190 create queue(n keep ) observation window of n keep latest events 2: rm \u2190 0, \u2200m \u2208 M reward counter 3: n \u2190 0 evaluation counter 4: while D.has more samples() do 5: X, y \u2190 D.next sample() 6: if X.session \u2208 W.sessions then 7:for all m \u2208 M do 8:\u0176 \u2190 m.predict(X) 9:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "HT Wrapper training procedure Input: (X, y): sample from the stream; wMC \u2265 1: importance weight for Markov Chain sequences; winv \u2208 [0, 1]: importance weight for inverse sequences. 1: S \u2190 (y 1 , . . . , y |S| ) item vector (in time order) for the session id encoded in X 2: for i \u2190 1, . . . , |S| do 3:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "HT Wrapper prediction procedure Input: X: feature vector containing session id; wMC \u2265 1: importance weight for Markov Chain sequences; winv \u2208 [0, 1]: importance weight for inverse sequences; N : recommendation cutoff Output:\u0176 : top-N recommendations 1: S \u2190 (y 1 , . . . , y |S| ) fetch item vector for the current session id encoded in X 2: P \u2190 (P(y1), . . . , P(y |P | )), set P(yi) \u2190 0, \u2200i, . . . , |P | init class probabilities 3: for i \u2190 1, . . . , |S| do 4:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Performance charts for Clef (top), Yoochoose (middle), and Trivago (bottom)",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Datasets summary (1M events each) We use the subset of the dataset provided in[13].",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Average recommendation time (msec) per model",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}