{
    "paper_id": "PMC7206628",
    "metadata": {
        "title": "Alternating Finite Automata with Limited Universal Branching",
        "authors": [
            {
                "first": "Alberto",
                "middle": [],
                "last": "Leporati",
                "suffix": "",
                "email": "alberto.leporati@unimib.it",
                "affiliation": {}
            },
            {
                "first": "Carlos",
                "middle": [],
                "last": "Mart\u00edn-Vide",
                "suffix": "",
                "email": "carlos.martin@urv.cat",
                "affiliation": {}
            },
            {
                "first": "Dana",
                "middle": [],
                "last": "Shapira",
                "suffix": "",
                "email": "shapird@g.ariel.ac.il",
                "affiliation": {}
            },
            {
                "first": "Claudio",
                "middle": [],
                "last": "Zandron",
                "suffix": "",
                "email": "zandron@disco.unimib.it",
                "affiliation": {}
            },
            {
                "first": "Chris",
                "middle": [],
                "last": "Keeler",
                "suffix": "",
                "email": "keeler@cs.queensu.ca",
                "affiliation": {}
            },
            {
                "first": "Kai",
                "middle": [],
                "last": "Salomaa",
                "suffix": "",
                "email": "ksalomaa@cs.queensu.ca",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Deterministic and nondeterministic finite automata (DFA and NFA) are well understood models for which a significant number of results are known. As a generalization of nondeterminism, alternation was introduced in [1], and has since been studied extensively for Turing machines [5, 6, 23], and pushdown automata [1, 20].",
            "cite_spans": [
                {
                    "start": 215,
                    "end": 216,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 279,
                    "end": 280,
                    "mention": "5",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 282,
                    "end": 283,
                    "mention": "6",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 285,
                    "end": 287,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 313,
                    "end": 314,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 316,
                    "end": 318,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The power of alternation in finite automata (AFAs) was first studied by Chandra, Kozen, and Stockmeyer [1], later by King [15] and Hromkovi\u010d [10], and state complexity trade-offs with NFAs and DFAs were given by Fellah et al. [3]. However, results on alternating finite automata remain relatively sparse compared to alternating pushdown automata and alternating (infinite) automata, and little effort has been made towards examining restricted computations within the context of alternation.",
            "cite_spans": [
                {
                    "start": 104,
                    "end": 105,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 123,
                    "end": 125,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 142,
                    "end": 144,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 227,
                    "end": 228,
                    "mention": "3",
                    "ref_id": "BIBREF16"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Restricted amounts of nondeterminism have been measured in various ways, including but not limited to ambiguity [19], tree width [11, 22], and string path width [13]. These so-called \u201cmeasures of nondeterminism\u201d examine some aspect of an automaton\u2019s computations. For example, the number of partial, or accepting computations on a given string. For a particular regular language and model, the state complexity is a measure of how complicated it is for that model to capture that language. The state complexity is combined with these measures of restricted nondeterminism, yielding tradeoffs between the amount of nondeterminism and the number of states required.",
            "cite_spans": [
                {
                    "start": 113,
                    "end": 115,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 130,
                    "end": 132,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 134,
                    "end": 136,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 162,
                    "end": 164,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "An automaton is said to alternate when it switches from an existential state to a universal state (or vice versa) [1]. There exists an exponential state complexity blow-up between two-way AFAs with at most k alternations and two-way AFAs with at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k+1$$\\end{document} alternations, and in general this hierarchy is infinite [7]. The emptiness problem for AFAs was shown to be PSPACE-Complete for general alphabets [8, 12]. More recently, the state complexity of various operations on AFAs has also been studied [9].",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 116,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 597,
                    "end": 598,
                    "mention": "7",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 687,
                    "end": 688,
                    "mention": "8",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 690,
                    "end": 692,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 784,
                    "end": 785,
                    "mention": "9",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this paper, we focus on the original model of AFAs (introduced by Chandra, Kozen, and Stockmeyer) where the states are either existential or universal [1, 7, 10, 12, 15, 23], rather than the one where states are labeled with boolean functions [18]. However, both of these models recognize exactly the regular languages. We also do not consider states or transitions with negation, though there is only a linear blow-up between our model and the one which can perform negation [3].",
            "cite_spans": [
                {
                    "start": 155,
                    "end": 156,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 158,
                    "end": 159,
                    "mention": "7",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 161,
                    "end": 163,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 165,
                    "end": 167,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 169,
                    "end": 171,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 173,
                    "end": 175,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 247,
                    "end": 249,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 480,
                    "end": 481,
                    "mention": "3",
                    "ref_id": "BIBREF16"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "This paper is organized as follows. Section 2 recalls several definitions, and fixes our model for alternating finite automata. Section 2.1 introduces the notions of acceptance width and maximal pared tree width, and provides several initial results and bounds for these new metrics. Section 3 gives a polynomial transformation for an NFA to simulate an AFA with bounded parallelism, shows that the decidability of several decision problems for AFAs with finite acceptance width, and gives algorithms to decide whether an AFA\u2019s maximal pared tree width or acceptance width is bounded by a given constant. Section 4 presents unary witness languages with finite acceptance width (with respect to the number of states) which require only a small number of states to be recognized by an AFA, but require an exponential number of states to be recognized by an NFA or DFA. Finally, Sect. 4.1 introduces a non-unary witness language, and provides another exponential state complexity blow-up; this time between AFAs with bounded tree width (with respect to the number of states), and NFAs and DFAs.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A=(Q_e,Q_u, \\varSigma , \\delta , q_0, F)$$\\end{document} be an AFA, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A_q$$\\end{document} be a copy of the AFA with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_e \\cup Q_u$$\\end{document} as the initial state. We point out that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varepsilon \\in L(A_q)$$\\end{document} if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in F$$\\end{document}. Consider \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_e \\cup Q_u, a \\in \\varSigma $$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta (q,a) = \\{p_1, \\ldots , p_n \\}$$\\end{document}. Then for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in \\varSigma ^*$$\\end{document}, define:If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_u$$\\end{document}, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a x \\in L(A_q)$$\\end{document} if and only if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in L(A_{p_i})$$\\end{document} for all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 \\le i \\le n$$\\end{document}.If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_e$$\\end{document}, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a x \\in L(A_q)$$\\end{document} if and only if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in L(A_{p_i})$$\\end{document} for some \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 \\le i \\le n$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "The language of A is defined as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L(A) = L(A_{q_0})$$\\end{document}.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "The computation tree of an AFA A on \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varepsilon $$\\end{document} from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_e \\cup Q_u$$\\end{document}, denoted \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,q,\\varepsilon }$$\\end{document} is the singleton node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(q,\\varepsilon )$$\\end{document}. The computation tree of an AFA A on cv from q, denoted \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,q,cv}$$\\end{document}, such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_e \\cup Q_u, c \\in \\varSigma , v \\in \\varSigma ^*$$\\end{document} is defined inductively as the tree:whose internal nodes are labeled by a tuple (p, a), for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p \\in Q, a \\in \\varSigma $$\\end{document} (i.e., each internal node is labeled by a state and character)which is rooted by a node (q, c)where the trees rooted at the children of (q, c) arethe computation trees \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$( T_{A,p_1,v}, \\ldots , T_{A, p_n, v} )$$\\end{document} if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta (q,c) = \\{p_1, \\ldots , p_n\\}$$\\end{document}, andthe failure node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\bot $$\\end{document} if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta (q,c) = \\emptyset $$\\end{document} (that is, if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta (q,c)$$\\end{document} is undefined).\n\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "If a computation tree of an AFA A on a string x starts on the initial state of A, then we omit the state label, denoting it as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,x}$$\\end{document}. We use the notation  to mean the (depth-first) ordered tuple of leaves in the computation tree T. The computation tree of an NFA is defined similarly, except its nodes are always labeled by existential states [11].",
            "cite_spans": [
                {
                    "start": 631,
                    "end": 633,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "We define the paring of a computation tree, which serves as the transformation around which our new measures are defined. For an AFA \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A=(Q_e,Q_u,\\varSigma ,\\delta ,$$\\end{document}\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q_0,F)$$\\end{document} and a string \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in \\varSigma ^*$$\\end{document}, a pared computation tree of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,x}$$\\end{document} is defined as a tree where for each node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(q,a) \\in T_{A,x}$$\\end{document}:if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_e$$\\end{document} then keep only one child node, andif \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_u$$\\end{document} then keep all child nodes.\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Since there is a choice made on each of the existential nodes, the same computation tree can result in many different pared computation trees. A pared tree represents a possible computation of the AFA A. At nodes labeled by existential states, the pared tree follows one (nondeterministically chosen) way to continue the computation. The nodes labeled by universal states have children labeled by all states reachable from that state in the next computation step. Note that every pared tree of an NFA will only have one leaf, since all of its states are existential. We denote the set of all pared computation trees on a tree T as\n\n. A pared computation tree is accepting if all of its leaves are labeled by accepting states (implying that no leaf is the failure node), and a string x is accepted by an AFA if and only if A has an accepting pared computation tree in\n\n.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Without loss of generality, we assume that all of an AFA\u2019s universal states are reachable. However, since emptiness for AFAs is PSPACE-Complete, we cannot assume that all of an AFA\u2019s states are useful in the sense that they can be used in an accepting computation. Since a universal state with at most one outgoing transition per character is no different than using an existential state, we also assume that every universal state has multiple outgoing transitions on at least one character.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "For a regular language L, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{sc}(L)$$\\end{document}, (respectively, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{nsc}(L), \\mathrm{asc}(L)$$\\end{document}), is the state complexity, (respectively, nondeterministic and alternating state complexity) of L.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A=(Q_e,Q_u, \\varSigma , \\delta , q_0, F)$$\\end{document} be an AFA. Then the acceptance width of A on a string \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in \\varSigma ^*$$\\end{document}, denoted \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A,x)$$\\end{document}, is the minimum number of leaves of any accepting pared computation tree of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,x}$$\\end{document}. The maximum pared tree width of A on a string \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in \\varSigma ^*$$\\end{document}, denoted \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {mptw}(A,x)$$\\end{document}, is the maximum number of leaves of any pared computation tree of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,x}$$\\end{document}. Formally, these are:\n\n",
            "cite_spans": [],
            "section": "Definition 2 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Since the (original) tree width does not perform the paring operation, we get that for any AFA A and string x, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A,x) \\le \\mathrm {mptw}(A,x) \\le \\mathrm {tw}(A,x)$$\\end{document}. We also get the following condition for equality between the measures, which occurs when the paring operation does not change the computation tree.",
            "cite_spans": [],
            "section": "Definition 2 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let A be an AFA, and x a string. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {mptw}(A,x)=\\mathrm {tw}(A,x)$$\\end{document} if and only if each node in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T_{A,x}$$\\end{document} with more than one child is labeled by some universal state in A.",
            "cite_spans": [],
            "section": "Remark 1 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "We extend the acceptance width and maximum pared tree width functions as functions on integers in the normal manner:\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A,\\ell ) = \\max \\{\\mathrm {aw}(A,x) \\mid x \\in \\varSigma ^\\ell \\},$$\\end{document}\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {mptw}(A,\\ell ) = \\max \\{\\mathrm {mptw}(A,x) \\mid x \\in \\varSigma ^\\ell \\}.$$\\end{document}\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A) = \\sup \\limits _{\\ell \\in \\mathbb {N}} \\{\\mathrm {aw}(A,\\ell )\\}, \\text { and } \\mathrm {mptw}(A) = \\sup \\limits _{\\ell \\in \\mathbb {N}} \\{\\mathrm {mptw}(A,\\ell )\\}.$$\\end{document}If, for a string x, there are no accepting computation trees, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A,x)=0$$\\end{document}. Since the emptiness problem is PSPACE-complete for AFAs [8], and these results hold even for unary languages, then we get the following equivalence.",
            "cite_spans": [
                {
                    "start": 1746,
                    "end": 1747,
                    "mention": "8",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Remark 1 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "([8]). Let A be an AFA. Then it is PSPACE-complete to decide whether or not \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A)=0$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 3,
                    "mention": "8",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Remark 2 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "If an m-state AFA has finite tree width, then its tree width is at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{m-2}$$\\end{document} [22]. Since, on any string, the acceptance width and maximal pared tree width of an AFA are upper-bounded by the tree width, we get the following conditional upper bound.",
            "cite_spans": [
                {
                    "start": 366,
                    "end": 368,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Remark 2 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "([22]). Let A be an m-state AFA with finite tree width. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A) \\le \\mathrm {mptw}(A) \\le 2^{m-2}$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Corollary 1 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Alternatively, we could replace the computation trees by directed acyclic graphs by merging any nodes on the same state on the same level. However, in this case, the acceptance width and maximal pared tree width of an m-state AFA would be at most m.",
            "cite_spans": [],
            "section": "Corollary 1 ::: Tree Width of Alternating Machines ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA, such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A)\\le k$$\\end{document}, for some constant k. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(m+1)^k$$\\end{document} states are sufficient for an NFA to simulate A.",
            "cite_spans": [],
            "section": "Lemma 1 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "It is known that the emptiness problem for NFAs can be solved in linear time, with respect to the number of states, using a breadth first search [4]. The transformation from Lemma 1 then yields a polynomial-time algorithm to decide emptiness for a finite acceptance width AFA.",
            "cite_spans": [
                {
                    "start": 146,
                    "end": 147,
                    "mention": "4",
                    "ref_id": "BIBREF17"
                }
            ],
            "section": "Lemma 1 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA with finite acceptance width k, for some constant k. Then in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m^k)$$\\end{document} time we can decide whether \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L(A) = \\emptyset $$\\end{document}.",
            "cite_spans": [],
            "section": "Corollary 2 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Using the transformation from Lemma 1, but modifying which states of the NFA are accepting, we can also decide whether the maximal pared tree width of an AFA is bounded.",
            "cite_spans": [],
            "section": "Corollary 2 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA and k a constant. Then we can decide whether or not the maximal pared tree width of A is at most k in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m^k)$$\\end{document} time.",
            "cite_spans": [],
            "section": "Theorem 1 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Using similar ideas from the characterization of NFAs with finite tree width [22], we are able to characterize AFAs with finite maximal pared tree width.",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 80,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Theorem 1 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A=(Q_u,Q_e,\\varSigma ,\\delta ,q_0,F)$$\\end{document} be an AFA. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {mptw}(A) > 2^{m-2}$$\\end{document} if and only if there exists some state \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$q \\in Q_u$$\\end{document} and character \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$c \\in \\varSigma $$\\end{document} such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\delta (q,c)| \\ge 2$$\\end{document} and q is involved in a cycle.",
            "cite_spans": [],
            "section": "Corollary 3 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Modifying existing algorithms for deciding finiteness of an NFA\u2019s tree width [14], we are also able to decide finiteness of an AFA\u2019s maximal pared tree width in polynomial time.",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 80,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Corollary 3 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "([14]). Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A=(Q_u,Q_e,\\varSigma ,\\delta ,q_0,F)$$\\end{document} be an m-state AFA. Then we can decide whether or not the maximal pared tree width of A is bounded by some constant k in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(m^3 \\cdot |\\varSigma |)$$\\end{document} time1.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Corollary 4 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "The general membership problem is P-complete for AFAs [12], and this holds even for finite unary languages. In fact, this P-completeness is even stronger, as it holds for all cycle-free AFAs.",
            "cite_spans": [
                {
                    "start": 55,
                    "end": 57,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Corollary 4 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Since an m-state cycle-free AFA has at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$m-1$$\\end{document} states being evaluated in parallel, then the membership problem for AFAs with bounded parallel computations is also P-complete.",
            "cite_spans": [],
            "section": "Corollary 4 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "([12]). Let A be a finite maximal pared tree width AFA. Then for a string x, it is P-complete to decide whether \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x \\in L(A)$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 4,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Corollary 5 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "We can also decide whether the pared acceptance width of an AFA is finitely bounded by some number.",
            "cite_spans": [],
            "section": "Corollary 5 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let A be an AFA, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k \\in \\mathbb {N}$$\\end{document}. Then it is decidable whether the acceptance width of A is bounded by k.",
            "cite_spans": [],
            "section": "Theorem 2 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "While it is decidable whether the acceptance width of an AFA is bounded by an integer k, the algorithm presented in Theorem 2 is not an efficient one and we cannot expect to have an efficient algorithm for this problem2. For a given AFA A and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k \\in \\mathbb {N}$$\\end{document} we can construct an AFA \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A'$$\\end{document} that begins the computation by a universal step with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k+1$$\\end{document} choices, where the first computation simulates A and the remaining k computations always accept deterministically. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{aw}(A') \\le k$$\\end{document} if and only if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L(A) = \\emptyset $$\\end{document} and deciding the emptiness of an AFA is PSPACE-complete [8].",
            "cite_spans": [
                {
                    "start": 2002,
                    "end": 2003,
                    "mention": "8",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Theorem 2 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "For any AFA A with finite tree width, the acceptance width of A must also be finite. Under this restriction, we can decide whether the acceptance width of A is finite using the construction from Theorem 2.",
            "cite_spans": [],
            "section": "Theorem 2 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA with finite tree width. By Corollary 1, the acceptance width is then at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{m-2}$$\\end{document}. Since the acceptance width of A is finite if and only if it is at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{m-2}$$\\end{document}, then it is decidable whether the acceptance width of A is finite. We do this by using Theorem 2 with an input value of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{m-2}$$\\end{document}.",
            "cite_spans": [],
            "section": "Corollary 6 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Since the acceptance width of an AFA is only upper bounded by its tree width, it is possible that an AFA has infinite tree width and finite acceptance width. In this case, we do not have an upper bound for the acceptance width.",
            "cite_spans": [],
            "section": "Corollary 6 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA with infinite tree width and finite acceptance width k. Is there any expression in m which bounds k?",
            "cite_spans": [],
            "section": "Question 1 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "As a result, it is not immediately obvious whether the finiteness of an AFA\u2019s acceptance width is decidable in general.",
            "cite_spans": [],
            "section": "Question 1 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "For an AFA A such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {tw}(A) \\notin O(1)$$\\end{document}, does there exist an algorithm to decide whether or not \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm {aw}(A) \\in O(1)$$\\end{document}?",
            "cite_spans": [],
            "section": "Question 2 ::: Decision Problems for Pared Tree Width and Acceptance Width",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I}$$\\end{document} be a set of integers. Then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{sc}(L_{\\forall \\mathcal {I}}) = \\mathrm{nsc}(L_{\\forall \\mathcal {I}}) = LCM(\\mathcal {I})$$\\end{document}.",
            "cite_spans": [],
            "section": "Lemma 2 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "The state complexity is, of course, maximal with respect to the size of the input set when its elements are pairwise coprime.",
            "cite_spans": [],
            "section": "Lemma 2 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I} = \\{p_1, \\ldots , p_n \\}$$\\end{document} be a set of n integers. If the elements of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I}$$\\end{document} are pairwise coprime, then there exists an AFA A recognizing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\forall \\mathcal {I}}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 + \\sum \\limits _{i=1}^n p_i$$\\end{document} states and tree width n such that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ \\mathrm{sc}(L(A)) = \\mathrm{nsc}(L(A)) = \\prod \\limits _{i=1}^n p_i.$$\\end{document}",
            "cite_spans": [],
            "section": "Lemma 3 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Lemma 3 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I} = \\{p_1, \\ldots , p_n\\}$$\\end{document} be a set of integers whose elements are pairwise coprime. We give the AFA recognizing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\forall \\mathcal {I}}$$\\end{document} in Fig. 1, whose tree width and number of states matches the claim. Since \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I}$$\\end{document}\u2019s elements are pairwise coprime, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$LCM(\\mathcal {I}) = \\prod \\limits _{i=1}^n p_i$$\\end{document}. And by Lemma 2, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{sc}(L_{\\forall \\mathcal {I}}) = \\mathrm{nsc}(L_{\\forall \\mathcal {I}}) = LCM(\\mathcal {I})$$\\end{document}.    \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\square $$\\end{document}",
            "cite_spans": [],
            "section": "Proof ::: State Complexity",
            "ref_spans": [
                {
                    "start": 730,
                    "end": 731,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Recognizing that the state complexity blow-up in Lemma 3 is exactly Landau\u2019s function [2, 21], we get the following exponential state complexity trade-off between AFAs with finite tree width (and therefore also finite acceptance width) and NFAs. A similar idea and result was also given by Kupferman et al. [17], though it was formulated to capture the unary language \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$a^{n+i}$$\\end{document}, for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i \\ge 0$$\\end{document}.",
            "cite_spans": [
                {
                    "start": 87,
                    "end": 88,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 90,
                    "end": 92,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 308,
                    "end": 310,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Proof ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "([2, 17, 21]). Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I}$$\\end{document} be a set of pairwise coprime integers, and A be an \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(m-1)$$\\end{document}-state AFA recognizing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\forall \\mathcal {I}}$$\\end{document} with tree width \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$|\\mathcal {I}|$$\\end{document}. Then any NFA equivalent to A will require at least \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$e^{(1 + o(1))\\cdot \\sqrt{m \\ln m}}$$\\end{document} states.",
            "cite_spans": [
                {
                    "start": 2,
                    "end": 3,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 5,
                    "end": 7,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 9,
                    "end": 11,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Theorem 3 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "While Landau\u2019s function gives a lower bound for the state complexity blow-up of simulating a restricted tree width AFA with an NFA, it is only given in terms of the number of states.",
            "cite_spans": [],
            "section": "Theorem 3 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {I}=\\{p_1, \\ldots , p_n\\}$$\\end{document} be a set of pairwise coprime integers, for some \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n \\in \\mathbb {N}$$\\end{document}. Let A be an m-state AFA such that A has acceptance width n and recognizes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\forall \\mathcal {I}}$$\\end{document}. Then any NFA equivalent to A will require at least \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(\\frac{m}{n \\cdot p_n})^n$$\\end{document} states.",
            "cite_spans": [],
            "section": "Lemma 4 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "In the general case, for every m, there exists an m-state AFA which cannot be simulated by any NFA with fewer than \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^m$$\\end{document} states [3], and any equivalent DFA needs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{2^m}$$\\end{document} states [1]. However, to get this double-exponential state complexity blow-up, the m-state AFA needs a tree width much larger than m.",
            "cite_spans": [
                {
                    "start": 412,
                    "end": 413,
                    "mention": "3",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 746,
                    "end": 747,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Lemma 4 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {P} = \\{p_1, \\ldots , p_n\\}$$\\end{document} be a set of n prime numbers. We define \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{2\\mathcal {P}}$$\\end{document}, the set of all unary strings whose lengths are a product of at least two distinct primes from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {P}$$\\end{document}.2\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\begin{aligned} L_{2\\mathcal {P}} = \\{ a^x \\mid (\\exists i,j)~1 \\le i < j \\le n, \\text{ such } \\text{ that } p_i \\text{ and } p_j \\text{ divide } x\\} \\end{aligned}$$\\end{document}\n",
            "cite_spans": [],
            "section": "Lemma 4 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "There exists an AFA A recognizing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{2\\mathcal {P}}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 + \\frac{n(n-1)}{2} + \\sum \\limits _{i=1}^n (p_i -1)$$\\end{document} states3 and a maximal pared tree width of 2.",
            "cite_spans": [],
            "section": "Lemma 5 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "We extend \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{2\\mathcal {P}}$$\\end{document}, defining \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{k\\mathcal {P}}$$\\end{document} as the set of all unary strings whose lengths are a product of at least k distinct primes from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {P}$$\\end{document}, for some constant k.3Using similar ideas as the proof from Lemma 5 but operating on an arbitrary number of elements instead of only two, we get the following result.",
            "cite_spans": [],
            "section": "Lemma 5 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "For every \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$k \\ge 2$$\\end{document}, there exists an AFA A recognizing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{k\\mathcal {P}}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 + {n \\atopwithdelims ()k} + \\sum \\limits _{i=1}^n (p_i -1)$$\\end{document} states and a maximal pared tree width of k.",
            "cite_spans": [],
            "section": "Lemma 6 ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {W} = (x_1, \\ldots , x_n)$$\\end{document} be an ordered, disjoint tuple of strings. Then there exists an AFA recognizing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\alpha \\mathcal {W}}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2 + \\sum \\limits _{i=1}^n |x_i|$$\\end{document} states and tree width n.",
            "cite_spans": [],
            "section": "Lemma 7 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {W} = (x_1, \\ldots , x_n)$$\\end{document} be an ordered, disjoint tuple of strings, and let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_{i}[j]$$\\end{document} be the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$j^{\\text {th}}$$\\end{document} character of the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i^{\\text {th}}$$\\end{document} string. We give the general structure for an AFA in Fig. 2, which recognizes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\alpha \\mathcal {W}}$$\\end{document} with 1 universal and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 + \\sum \\limits _{i=1}^n |x_i|$$\\end{document} existential states. This AFA has tree width n, and only alternates between universal and existential states once. The only final state is the one at the end of all the branches. And, excepting the initial state, we define the transition function deterministically. If the machine is reading \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_i$$\\end{document}, has read up to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x_{i}[j]$$\\end{document}, and then encounters some mismatched symbol, then the computation path currently in state i.j will return to state i, indicating that the infix must be restarted.    \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\square $$\\end{document}\n",
            "cite_spans": [],
            "section": "Proof ::: Universal Infix Language ::: State Complexity",
            "ref_spans": [
                {
                    "start": 1349,
                    "end": 1350,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "However, a DFA for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\forall \\mathcal {W}}$$\\end{document} needs exponentially more states than an AFA.",
            "cite_spans": [],
            "section": "Proof ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {W} = (x_1, \\ldots , x_n)$$\\end{document} be a disjoint tuple of strings. Then\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{sc}(L_{\\alpha \\mathcal {W}}) = 2^n + 2^{n-1} \\cdot \\sum \\limits _{i=1}^n (|x_i| -1).$$\\end{document}\n",
            "cite_spans": [],
            "section": "Lemma 8 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Furthermore, the addition of nondeterminism does not improve this bound.",
            "cite_spans": [],
            "section": "Lemma 8 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {W} = (x_1, \\ldots , x_n)$$\\end{document} be a disjoint tuple of strings. Then\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathrm{nsc}(L_{\\alpha \\mathcal {W}}) = 2^n + 2^{n-1} \\cdot \\sum \\limits _{i=1}^n (|x_i| - 1).$$\\end{document}\n",
            "cite_spans": [],
            "section": "Lemma 9 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Combining Lemmas 7, 8, and 9, we get the following theorem.",
            "cite_spans": [],
            "section": "Lemma 9 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "There exists an m-state AFA A (where m can be arbitrarily large) with tree width n such that any equivalent NFA needs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(m-n) \\cdot 2^{n-1}$$\\end{document} states. The AFA A can be chosen to alternate only once between universal and existential states. We note that the alphabet size of A depends on n.",
            "cite_spans": [],
            "section": "Theorem 4 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "We give the following constructive example to help clarify the state blow-up from Theorem 4.",
            "cite_spans": [],
            "section": "Theorem 4 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {W} = (aa, b, c)$$\\end{document}, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$A=(Q,\\{a,b,c\\},\\delta ,q_0,\\{111\\})$$\\end{document} be the DFA given in Fig. 3, which recognizes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\alpha (aa,b,c)}$$\\end{document}.\n",
            "cite_spans": [],
            "section": "Example 1 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": [
                {
                    "start": 666,
                    "end": 667,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "To make counting of states easier, below we assume that an AFA computation step always has at most two choices (i.e. computation step is either undefined, is deterministic, or has exactly two existential or universal choices). This assumption can be made with only a constant factor blow-up of the automaton\u2019s state complexity [16].",
            "cite_spans": [
                {
                    "start": 328,
                    "end": 330,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Example 1 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA with tree width n. Then A has an equivalent DFA B with at most \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(m+1)^n \\cdot (2^n -1)$$\\end{document} states.",
            "cite_spans": [],
            "section": "Lemma 10 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Combining the upper and lower bounds from Lemmas 8, 9 and 10, we get the following state complexity range for simulating a finite tree width AFA with a DFA.",
            "cite_spans": [],
            "section": "Lemma 10 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        },
        {
            "text": "Let A be an m-state AFA with tree width n. Then\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$2^{n-1}\\cdot (m - n) \\le \\mathrm{sc}(L(A)) \\le (2^n -1)\\cdot (m+1)^n.$$\\end{document}\n",
            "cite_spans": [],
            "section": "Corollary 7 ::: Universal Infix Language ::: State Complexity",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "Fig. 1.: AFA for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\forall \\mathcal {P}}$$\\end{document} where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {P} = \\{ p_1, \\ldots , p_n \\}$$\\end{document}. Universal states are marked with an additional label \u2018u\u2019, and existential states are given as normal.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: AFA for a universal infix language over \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(x_1, \\ldots , x_n)$$\\end{document}",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: 12-State DFA for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$L_{\\alpha (aa,b,c)}$$\\end{document}",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Alternation",
            "authors": [
                {
                    "first": "AK",
                    "middle": [],
                    "last": "Chandra",
                    "suffix": ""
                },
                {
                    "first": "DC",
                    "middle": [],
                    "last": "Kozen",
                    "suffix": ""
                },
                {
                    "first": "LJ",
                    "middle": [],
                    "last": "Stockmeyer",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "J. ACM",
            "volume": "28",
            "issn": "1",
            "pages": "114-133",
            "other_ids": {
                "DOI": [
                    "10.1145/322234.322243"
                ]
            }
        },
        "BIBREF1": {
            "title": "On the power of alternation in automata theory",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hromkovi\u010d",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "J. Comput. Syst. Sci.",
            "volume": "31",
            "issn": "1",
            "pages": "28-39",
            "other_ids": {
                "DOI": [
                    "10.1016/0022-0000(85)90063-7"
                ]
            }
        },
        "BIBREF2": {
            "title": "Communication complexity method for measuring nondeterminism in finite automata",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hromkovi\u010d",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Seibert",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Karhum\u00e4ki",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Klauck",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schnitger",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "Inform. Comput.",
            "volume": "172",
            "issn": "2",
            "pages": "202-217",
            "other_ids": {
                "DOI": [
                    "10.1006/inco.2001.3069"
                ]
            }
        },
        "BIBREF3": {
            "title": "A note on the space complexity of some decision problems for finite automata",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Jiang",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Ravikumar",
                    "suffix": ""
                }
            ],
            "year": 1991,
            "venue": "Inf. Process. Lett.",
            "volume": "40",
            "issn": "1",
            "pages": "25-31",
            "other_ids": {
                "DOI": [
                    "10.1016/S0020-0190(05)80006-7"
                ]
            }
        },
        "BIBREF4": {
            "title": "Branching measures and nearly acyclic NFAs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Keeler",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Descriptional Complexity of Formal Systems",
            "volume": "",
            "issn": "",
            "pages": "202-213",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "Nondeterminism growth and state complexity",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Keeler",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Descriptional Complexity of Formal Systems",
            "volume": "",
            "issn": "",
            "pages": "210-222",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "Alternating multihead finite automata (extended abstract)",
            "authors": [
                {
                    "first": "KN",
                    "middle": [],
                    "last": "King",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Automata, Languages and Programming",
            "volume": "",
            "issn": "",
            "pages": "506-520",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Succinct representation of regular languages by boolean automata",
            "authors": [
                {
                    "first": "EL",
                    "middle": [],
                    "last": "Leiss",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Theor. Comput. Sci.",
            "volume": "13",
            "issn": "",
            "pages": "323-330",
            "other_ids": {
                "DOI": [
                    "10.1016/S0304-3975(81)80005-9"
                ]
            }
        },
        "BIBREF10": {
            "title": "Descriptional complexity of nfa of different ambiguity",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Leung",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Int. J. Found. Comput. Sci.",
            "volume": "16",
            "issn": "5",
            "pages": "975-984",
            "other_ids": {
                "DOI": [
                    "10.1142/S0129054105003418"
                ]
            }
        },
        "BIBREF11": {
            "title": "Finite automata and unary languages",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Chrobak",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "Theoret. Comput. Sci.",
            "volume": "47",
            "issn": "",
            "pages": "149-158",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(86)90142-8"
                ]
            }
        },
        "BIBREF12": {
            "title": "A grammatical characterization of alternating pushdown automata",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Moriya",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Theor. Comput. Sci.",
            "volume": "67",
            "issn": "1",
            "pages": "75-85",
            "other_ids": {
                "DOI": [
                    "10.1016/0304-3975(89)90023-6"
                ]
            }
        },
        "BIBREF13": {
            "title": "Unambiguous finite automata over a unary alphabet",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Okhotin",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Inf. Comput.",
            "volume": "212",
            "issn": "",
            "pages": "15-36",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ic.2012.01.003"
                ]
            }
        },
        "BIBREF14": {
            "title": "State complexity of finite tree width nfas",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Palioudakis",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Salomaa",
                    "suffix": ""
                },
                {
                    "first": "SG",
                    "middle": [],
                    "last": "Akl",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Autom. Lang. Comb.",
            "volume": "17",
            "issn": "2\u20134",
            "pages": "245-264",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "Tree-size bounded alternation",
            "authors": [
                {
                    "first": "WL",
                    "middle": [],
                    "last": "Ruzzo",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "J. Comput. Syst. Sci.",
            "volume": "21",
            "issn": "2",
            "pages": "218-235",
            "other_ids": {
                "DOI": [
                    "10.1016/0022-0000(80)90036-7"
                ]
            }
        },
        "BIBREF16": {
            "title": "Constructions for alternating finite automata",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Fellah",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "J\u00fcrgensen",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Int. J. Comput. Math.",
            "volume": "35",
            "issn": "1\u20134",
            "pages": "117-132",
            "other_ids": {
                "DOI": [
                    "10.1080/00207169008803893"
                ]
            }
        },
        "BIBREF17": {
            "title": "Problems on finite automata and the exponential time hypothesis",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Fernau",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Krebs",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Algorithms",
            "volume": "10",
            "issn": "1",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.3390/a10010024"
                ]
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "Checking finite traces using alternating automata",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Finkbeiner",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Sipma",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Formal Methods Syst. Des.",
            "volume": "24",
            "issn": "2",
            "pages": "101-127",
            "other_ids": {
                "DOI": [
                    "10.1023/B:FORM.0000017718.28096.48"
                ]
            }
        },
        "BIBREF20": {
            "title": "An alternating hierarchy for finite automata",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Geffert",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Theor. Comput. Sci.",
            "volume": "445",
            "issn": "",
            "pages": "1-24",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2012.04.044"
                ]
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF22": {
            "title": "Operations on boolean and alternating finite automata",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Hospod\u00e1r",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jir\u00e1skov\u00e1",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Kraj\u0148\u00e1kov\u00e1",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Computer Science \u2013 Theory and Applications",
            "volume": "",
            "issn": "",
            "pages": "181-193",
            "other_ids": {
                "DOI": []
            }
        }
    }
}