{
    "paper_id": "630a61f863ed303d51816973cbddf79724336bcb",
    "metadata": {
        "title": "Modelling an Automotive Software-Intensive System with Adaptive Features Using ASMETA",
        "authors": [
            {
                "first": "Paolo",
                "middle": [],
                "last": "Arcaini",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "National Institute of Informatics",
                    "location": {
                        "settlement": "Tokyo",
                        "country": "Japan"
                    }
                },
                "email": "arcaini@nii.ac.jp"
            },
            {
                "first": "Silvia",
                "middle": [],
                "last": "Bonfanti",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Bergamo",
                    "location": {
                        "settlement": "Bergamo",
                        "country": "Italy"
                    }
                },
                "email": "silvia.bonfanti@unibg.it"
            },
            {
                "first": "Angelo",
                "middle": [],
                "last": "Gargantini",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Bergamo",
                    "location": {
                        "settlement": "Bergamo",
                        "country": "Italy"
                    }
                },
                "email": "angelo.gargantini@unibg.it"
            },
            {
                "first": "Elvinia",
                "middle": [],
                "last": "Riccobene",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Milano",
                    "location": {
                        "settlement": "Milan",
                        "country": "Italy"
                    }
                },
                "email": "elvinia.riccobene@unimi.it"
            },
            {
                "first": "Patrizia",
                "middle": [],
                "last": "Scandurra",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Universit\u00e0 degli Studi di Bergamo",
                    "location": {
                        "settlement": "Bergamo",
                        "country": "Italy"
                    }
                },
                "email": "patrizia.scandurra@unibg.it"
            }
        ]
    },
    "abstract": [
        {
            "text": "In the context of automotive domain, modern control systems are software-intensive and have adaptive features to provide safety and comfort. These software-based features demand software engineering approaches and formal methods that are able to guarantee correct operation, since malfunctions may cause harm/damage. Adaptive Exterior Light and the Speed Control Systems are examples of software-intensive systems that equip modern cars. We have used the Abstract State Machines to model the behaviour of both control systems. Each model has been developed through model refinement, following the incremental way in which functional requirements are given. We used the ASMETA tool-set to support the simulation of the abstract models, their validation against the informal requirements, and the verification of behavioural properties. In this paper, we discuss our modelling, validation and verification strategies, and the results (in terms of features addressed and not) of our activities. In particular, we provide insights on how we addressed the adaptive features (the adaptive high beam headlights and the adaptive cruise control) by explicitly modelling their software control loops according to the MAPE-K (Monitor-Analyse-Plan-Execute over a shared Knowledge) reference control model for self-adaptive systems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "P. Arcaini is supported by ERATO HASUO Metamathematics for Systems Design Project (No. JPMJER1603), JST. Funding",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Modern control systems, like those in the automotive domain, are software-intensive, have adaptive features, and must be reliable. Formal methods can be applied in order to improve their development and guarantee their correct operational behaviour and safety assurance. In this paper, we report our experience in applying the Abstract State Machine (ASM) formal method to the Adaptive Exterior Light (ELS) and the Speed Control Systems (SCS), which are examples of software-intensive systems that equip modern cars. We used the ASMETA framework, which provides a wide tool support to ASMs. ASMETA tries to combine the formality of ASMs with a tools set that supports the editing, simulation and animation of the abstract models, their validation against the informal requirements, and the verification of behavioural properties. Moreover, ASMETA adopts a refinement-based process, and employs several constructs in order to allow modularity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "To address the adaptive features of the case study, i.e., the adaptive high beam headlights and the adaptive cruise control, we exploited the concept of self-adaptive ASMs [5] , which allows modelling adaptation logics in terms of MAPE-K (Monitor-Analyse-Plan-Execute over a shared Knowledge) feedback control loops.",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 175,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The paper is structured as suggested by the call for paper of the case study. The following subsection briefly presents the ASM formal method and its supporting tool-set ASMETA. Section 2 explains our modelling strategy. Details about our models and how they capture the requirements are provided in Sect. 3 . We have applied several validation and verification (V&V) activities that are presented in Sect. 4. Section 5 discusses some observations that we draw from this experience, together with some limits of our approach. Section 6 concludes the paper.",
            "cite_spans": [
                {
                    "start": 306,
                    "end": 307,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Basic Definition. ASMs [10, 11] are an extension of Finite State Machines (FSMs) where unstructured control states are replaced by states comprising arbitrary complex data (i.e., domains of objects with functions defined on them), and transitions are expressed by transition rules describing how the data (state function values saved into locations) change from one state to the next. ASM models can be read as \"pseudocode over abstract data\" which comes with a well defined semantics: at each computation step, all transition rules are executed in parallel by leading to simultaneous (consistent) updates of a number of locations. Modelling Process and Tools. ASMs allow an iterative design process, shown in Fig. 1 , based on model refinement. Tools supporting the process are part of the ASMETA (ASM mETAmodeling) framework 1 [4] . Requirements modelling starts by developing a high-level model called ground model (ASM 0 in Fig. 1 ). It is specified by reasoning on the informal requirements (generally given as a text in natural language) and using terms of the application domain, possibly with the involvement of all stakeholders. The ground model should correctly reflect the intended requirements and should be consistent, i.e., without possible ambiguities of initial requirements. It does not need to be complete, i.e., it may not specify some given requirements. The ground model and the other ASM models can be edited in AsmEE by using the concrete syntax AsmetaL [14] . Starting from the ground model, through a sequence of refined models, further functional requirements can be specified until a complete model of the system is obtained. The refinement process allows to tackle the system complexity, and to bridge, in a seamless manner, specification to code. At each refinement level, already at the level of the ground model, different V&V activities can be applied. In Sect. 4, we explain in detail how model validation and property verification are performed in ASMETA tools.",
            "cite_spans": [
                {
                    "start": 23,
                    "end": 27,
                    "text": "[10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 28,
                    "end": 31,
                    "text": "11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 829,
                    "end": 832,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1477,
                    "end": 1481,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 710,
                    "end": 716,
                    "text": "Fig. 1",
                    "ref_id": null
                },
                {
                    "start": 928,
                    "end": 934,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "The ASM Method and the ASMETA Tool-Set"
        },
        {
            "text": "Model to code transformation are supported for C++ code [9] , and conformance checking is possible to check if the implementation, if externally provided, conforms to its specification. The tool ATGT [13] can be used to automatically generate tests from ASM models and, therefore, to check the conformance offline; CoMA [3] , instead, can be used to perform runtime verification, i.e., to check the conformance online.",
            "cite_spans": [
                {
                    "start": 56,
                    "end": 59,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 200,
                    "end": 204,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 320,
                    "end": 323,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "The ASM Method and the ASMETA Tool-Set"
        },
        {
            "text": "Machine and Modules. As better explained in Sect. 2, in our modelling activity we strongly make use of modularization. To concretely support it, we exploited the concept of ASM module as introduced in [11] and provided by the language of the ASMETA tool set. Specifically, an ASM module contains the declaration and definitions of domains, functions, invariants, and rules; an ASM machine is an ASM module that additionally contains a (unique) main rule representing the starting point of the machine execution, and an initial state. The keyword asm introduces the main ASM while the keyword module indicates a module. Self-adaptive ASMs. To model the adaptive features of the two automotive subsystems, we exploit the concept of MAPE-K (a sequence of four computations Monitor, Analyze, Plan, and Execute over a shared Knowledge) feedback control loop [16] commonly used to structure the adaptation logic of self-adaptive software systems. To this end, we adopt self-adaptive Abstract State Machines (self-adaptive ASMs) as defined in [5] to formalize the sequential execution of the four MAPE computations of a MAPE-K loop in terms of ASM transitions rules (see Sect. 3.1, CarSystem003).",
            "cite_spans": [
                {
                    "start": 201,
                    "end": 205,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 853,
                    "end": 857,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 1036,
                    "end": 1039,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Distinctive Features of the Modelling Approach"
        },
        {
            "text": "We here describe the general strategy adopted while modelling the ELS and the SCS using ASMs. We explain how our model is structured, how the structure relates to the requirements, the model purpose (in terms of properties addressed and not addressed by our solution), and our formalization approach. Model Structure. The ELS and SCS sub-systems are loosely coupled (i.e., they work in parallel and share some external signals), so we handle their requirements independently. More specifically, for each subsystem, we developed an ASM specification through a sequence of refined models, following the incremental way in which functional requirements of the software based controllers are described in the requirements document [15] . The models are numbered from 1 to 9: models from CarSystem001 to CarSystem004 refer to the ELS, while the SCS is modelled from CarSystem005 to CarSystem007. CarSystem008 merges the two systems and CarSystem009 introduces the faults handling and general properties. Since, at a given refinement level, only some parts of the model were refined, to keep track of maintained and refined parts and to relate abstract and refined submodels, we structure an ASM model in modules. Therefore, at each level, an ASM results in the horizontal and vertical composition of ASM modules (by exploiting the import module feature). For example, Fig. 2 illustrates the ASM models structure in terms of horizontal and vertical imports for the first three refined levels of the CarSystem related to the ELS subsystem. Level 1 consists of an ASM CarSystem001main that imports module CarSystem001HW that imports module CarSystem001Blink, till the final module CarSystem001Domains is imported 2 . At this level, module relations are all horizontal imports. Similarly, ASM CarSystem002main imports (horizontally) module CarSystem002Cornering from the same refinement level, and it imports (vertically) module CarSystem001HW from the previous refinement level. Note that module CarSystem002Domains imports module CarSystem001Domains, since the former enlarges (as expected during refinement) the latter. Vertical relations can be also module refinement relations. For example, Fig. 3 focuses on level 4 and illustrates the ASM CarSystem004main that imports, among the others, the module CarSystem004HW refining module CarSystem001HW from level 1, and module CarSystem004Cornering refining module CarSystem002Cornering from level 2. Other depicted import/refine-ment relations are self-explanatory. More details on the refinement levels and corresponding models are given in Sect. 3. To model the overall behaviour resulting from the union of the behaviours of all distributed software we simply exploit the notion of parallel ASMs [7] . Therefore, we model software running on ECUs as parallel algorithms working in sequential global time. Whenever necessary (as stated in the requirements document) and to avoid interference, the machine follows only one or a restricted subset of all possible parallel execution paths by using the mutual exclusive guards pattern at the level of rules, i.e., the simultaneous activation of certain rules is avoided by modelling them as conditional rules with mutual exclusive guards. Model Purpose. The proposed ASM model is primarily tailored to the formalization and analysis of functional aspects of the ELS and SCS subsystems in order to provide guarantees of their operational correctness. Modelling and validation activities revealed, however, some statements where the requirements were wrong or unambiguous. We had the possibility to check our doubts with the chairs (working as domain experts) and we got corrected version of the requirements. Further details on these missing/ambiguous aspects are given in Sect. 5.",
            "cite_spans": [
                {
                    "start": 727,
                    "end": 731,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 2741,
                    "end": 2744,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 1363,
                    "end": 1369,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 2187,
                    "end": 2193,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF1"
                }
            ],
            "section": "Modelling Strategy"
        },
        {
            "text": "Except for some features not addressed by our solution (see below), our model(s) capture(s) all requirements described in the document [15] . Each refined model was analyzed using different techniques (see Sect. 4), considering also the description of the operational scenarios that are given as annex part of the requirements. The most important properties addressed by our solution are:",
            "cite_spans": [
                {
                    "start": 135,
                    "end": 139,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [],
            "section": "Modelling Strategy"
        },
        {
            "text": "-On the ELS subsystem: a) The priority of hazard warning over blinking is guaranteed; b) Low beam headlights are turned on and off as required; c) Priority of ELS-19 over other requirements has been addressed when the ambient light is activated; d) High beam headlights are automatically turned on/off when the light rotary switch is set to Auto; e) When subvoltage/overvoltage occurs the system reacts as required. -On the SCS subsystem: a) (Adaptive) cruise control desired speed is set as required:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Modelling Strategy"
        },
        {
            "text": "the adaptive cruise control sets automatically the speed to reach the target based on different factors like the current speed and the speed of the vehicle ahead. b) Emergency brake intervenes to avoid collisions; c) Speed limit and traffic sign detection set the threshold speed when they are activated by the user.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Modelling Strategy"
        },
        {
            "text": "Not Addressed Features. The main feature not addressed by our solution is the time management. We are not able to deal with continuous time, although a notion of reactive timed ASMs has been proposed [17] , there is no tool support for it. To overcome this limitation, we assume that a monitored function notifies the system whether an interval time is passed. For example, requirement ELS-18 states that low beam headlights remain active at least for 3 s. As shown in Code 1, we have introduced a monitored function passed3Sec that notifies if 3 s had elapsed since the low beam headlights received the command to be turned off. A further not addressed feature is the frequency of blinking. Since the model does not support continuous time it is not possible to set the direction lamps state (ON or OFF) every second (the duration of a flashing cycle is 1 s). Due to this limitation, we have introduced an enumerative value that indicates the current pulse ratio and we have supposed that the Head-Unit sets the state of direction lamp given the pulse ratio value. Requirements Formalization Approach. To understand and specify the behaviour, we started from the textual description of the systems, and we tried to express the text in terms of transition rules, by supplying the necessary definitions of domains and functions. In naming functions, domains and transition rules, we have used an domainspecific terminology that can be understood by the stakeholders. Furthermore, for the functions defined in the tables at the end of the document of specification we have used the names proposed. An example of requirement formalization is shown in Code 1 that reports the requirement ELS-18 and the corresponding ASM rule. Sometimes the requirements are not independent of each other, for this reason more than one requirement is modelled by one rule. ",
            "cite_spans": [
                {
                    "start": 200,
                    "end": 204,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Modelling Strategy"
        },
        {
            "text": "In this section, we present the result of our modelling of the Adaptive Exterior Light and Speed Control systems 3 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Model Details"
        },
        {
            "text": "We have proceeded through refinement of the two systems independently and finally we have merged them together to obtain the complete system. Figure 4 shows the model refinement chain and lists the requirements introduced in each model. Table 1 shows the model dimensions in terms of number of functions and rules and the traceability table between requirements and rules/functions (see Table 2 ). In the sequel, we will show some parts of the models for each subsystem and then we will explain the merging of two systems. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 142,
                    "end": 150,
                    "text": "Figure 4",
                    "ref_id": null
                },
                {
                    "start": 237,
                    "end": 244,
                    "text": "Table 1",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 387,
                    "end": 394,
                    "text": "Table 2",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Model Details"
        },
        {
            "text": "ELS has been modelled into 4 refinement steps which are explained below. CarSystem001. This model describes the functions of direction blinking and hazard warning. The critical features found in this modelling phase are the following: a) the hazard warning has the priority over direction blinking (ELS-3); b) the tail lamp is used as an indicator for cars sold in USA and Canada (ELS-6). Code 2 shows that if hazard warning request is activated and any kind of blinking is running, blinking must be stopped and hazard warning is started. In case of direction blinking, the value of pitman arm is stored to restart the request as soon as hazard warning is deactivated; if the pitman arm is moved back to neutral position, the request is cancelled. The tail lamp status is updated to FIX or BLINK. It is BLINK only if blinking is active and car is sold in USA or Canada, otherwise it is FIX. Moreover, the value of light is dimmed by 50% during blinking (see Code 3). To address the requests from the pitman arm, we have defined three functions, pitmanArmUpDown for the incoming request, pit-manArmUpDown RunnReq for the running request and pitmanArmUpDown Buff to save the incoming request if it cannot be satisfied in the current state. When the run-ning request has been processed, the request in the buffer is executed unless a new one arrives.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Adaptive Exterior Light System"
        },
        {
            "text": "CarSystem002. This introduces the low beam headlights and cornering light, emergency brake light, and reverse light functions. Each of these functions is modelled in an ASM module. Common functions and domains are extended starting from those defined in the CarSystem001, while hazard warning and direction blinking are unchanged. Requirements ELS-15, ELS-16, ELS-17, and ELS-19 are interconnected because ELS-19 has the priority over the others if ambient light activated. We have defined a guard called ambientLightingAvailable which is true if ambient lighting is activated, the vehicle is not armoured and darkness mode is switched off. Some requirements state that the system performs an action if function X changes its value from state s to state s + 1. To detect the value change, we store the value of function X in the previous state (X Previous) and we compare that value with the current value. When the model detects a value change, the system acts as defined by rules. An example is the requirement ELS-19: the low beam headlamps are activated if engine has been stopped. We have captured the key state mutation by checking the value of keyState Previous compared to keyState. CarSystem003. This step introduces the control features for the manual and adaptive high beam headlights (ELS-30 to ELS-38). We first modelled the manual control of the high beam headlights and then, in the same refinement level, the adaptive one. The control variables are the high beam luminous strength (a percentage) and the illumination distance (expressed in meters).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Adaptive Exterior Light System"
        },
        {
            "text": "In manual mode (ELS30-ELS31), the user can set a fixed illumination area of 220 m and 100% of luminous strength, or activate the high beam headlights temporary (socalled flasher). We had to make the following assumptions due to missing requirements: (i) a maximum illumination area of 360 m and 100% of luminous strength in the flasher mode; (ii) the key is inserted or the engine is on to activate high beam in a fixed way.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Adaptive Exterior Light System"
        },
        {
            "text": "In adaptive mode (ELS32-ELS38), the illumination of the road is automated depending on the incoming vehicles (as detected by a built-in camera) and optimized to illuminate the appropriate area according to the vehicle speed, the last being the current speed of the vehicle or the target speed provided by the advanced cruise control in case it is activated. The illumination distance and the luminous strength are adjusted according to characteristic curves provided in the requirements document. In order to calculate such values, we had to reverse engineered the formulas as suggested in the additional information provided with the specification document. We modelled this adaptive behaviour in terms of a MAPE-K feedback control loop that starts with the rule r MAPE HBH (see Code 4). A control loop in self-adaptive systems is a sequence of four computations: Monitor-Analyse-Plan-Execute (MAPE) over a knowledge base. In self-adaptive ASMs [5] , it is modelled by means of four rules, one per MAPE computation, while the knowledge is modelled by means of functions, since in ASMs system memory is represented in terms of functions. In our case, the MAPE loop consists of the following rules invoked in a waterfall manner within one single ASM-step machine (see Code 4): r Monitor Analyze HBH, where monitor and analyze computations are modelled as a unique activity; r IncreasingPlan HBH and r DecreasingPlan HBH to plan the adaptation if necessary: light illumination distance and luminous strength are increased or decreased according to the vehicle speed; r Execute HBH to set the values as planned: highBeamOn to activate/deactivate the high beam, highBeamRange and highBeamMotor for the high beam luminous strength and illumination distance.",
            "cite_spans": [
                {
                    "start": 946,
                    "end": 949,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Adaptive Exterior Light System"
        },
        {
            "text": "CarSystem004. This modelling phase introduces fault handling, in particular how the software reacts to overvoltage or subvoltage. When subvoltage is present, some functionalities like cornering light and parking light are not available. This has been addressed by adding a guard that, in case of subvoltage (the voltage value is less than 8.5 V), disables them (see Code 5) . In case the voltage is more than 14.5 V, the system is in overvoltage. The maximum value of lights is computed by the setOvervoltage-ValueLight function: it returns the minimum between current light value and the value calculated by overVoltageMaxValueLight function. In this step of refinement, we have refined the modules whose behaviour is affected by the voltage value.",
            "cite_spans": [
                {
                    "start": 366,
                    "end": 373,
                    "text": "Code 5)",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Adaptive Exterior Light System"
        },
        {
            "text": "The final model of Speed Control System has been addressed through three steps of refinement explained in the following. CarSystem005. In the first model of SCS, we have implemented the functionalities of cruise control and setting and modifying desired speed (see CarSystem005Desired-SpeedCruiseC module). Desired speed and target speed are modified based on SCS lever position when (adaptive) cruise control is activated. CarSystem006. This step of refinement introduces the speed limit and traffic sign detection functionalities. If traffic sign detection is on, the target speed is modified by the recognized traffic sign value. The speed limit modifies the desired speed which must not be exceeded by the current speed. CarSystem007. This step of refinement introduces the adaptive cruise control and distance warning from the vehicle ahead (from SCS-18 to SCS-26), and the brake assistant (from SCS-27 to SCS-28) to initiate braking in critical situations. Similarly to the adaptive high beam headlights (see refinement CarSystem003), we modelled the adaptive behaviour of the cruise control in terms of a MAPE-K feedback control loop that monitors the distance from the vehicle ahead, plans and executes acceleration/deceleration automatically, including braking until a full standstill and starting from a standstill.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Speed Control System"
        },
        {
            "text": "Once we have developed the ELS and SCS separately, we have merged them to obtain a model that includes both systems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Merging ELS and SCS Models"
        },
        {
            "text": "CarSystem008. This step of refinement has been obtained easier than what we expected due to the modularity followed in the previous steps of refinement. Once the main module (CarSystem008main) has been defined, we have simply imported the modules previously developed. All rules are executed in parallel and no inconsistent update has been found because the systems are independent of each other, they have only common inputs. A schema that shows how we have imported modules is available on-line. CarSystem009. We have introduced the requirements from SCS-40 to SCS-43. The dangerous situations in SCS-40, SCS-41 and SCS-42 are already managed by the model; in this step of refinement we have integrated SCS-43 by refining the guards of CarSystem004EmergencyBrakeLights module. The brake lights are activated either by the brake pedal pressed by the user or the system activates the emergency brake.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Merging ELS and SCS Models"
        },
        {
            "text": "Validation and verification are supported by a set of ASMETA tools. In this section, we report results and tools used for each activity, and explain the changes to the models that resulted from the validation and the verification.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Validation and Verification"
        },
        {
            "text": "Validation. Model validation helps to ensure that the specification really reflects the intended requirements, and to detect faults and inconsistencies as early as possible with limited effort. While writing models, we have started the validation activity by using the animator AsmetaA [8] which uses tables to convey information about states and their evolution. We have performed interactive animation that consists in providing inputs (i.e., values of monitored functions) to the machine and observing the computed state. The animator, at each step, performs consistent updates checking to check that all the updates are consistent (in an ASM, two updates are inconsistent if they update the same location to two different values at the same time), and invariant checking.",
            "cite_spans": [
                {
                    "start": 286,
                    "end": 289,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Validation and Verification"
        },
        {
            "text": "With the increasing complexity of the ELS and SCS system models, we have intensely used the scenario-based validation AsmetaV [12] that allows to build and execute scenarios of expected system behaviours. In scenario-based validation, the designer provides a set of scenarios specifying the expected behaviour of the models (using the textual notation Avalla [12] ). These scenarios are used for validation by instrumenting the simulator AsmetaS [14] . During simulation, AsmetaV captures any check violation and, if none occurs, it finishes with a PASS verdict. Avalla provides constructs to express execution scenarios in an algorithmic way, as interaction sequences consisting of actions committed by the user to set the environment (i.e., the values of monitored/shared functions), to check the machine state, to ask for the execution of certain transition rules, and to enforce the machine itself to make one step as reaction of the user actions. Code 7 shows an example of scenario: it specifies the behaviour of the second validation sequence for the exterior light provided as part of the documentation 4 . More scenarios are available on our online repository, including all those provided with the case study document.",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 130,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 359,
                    "end": 363,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 446,
                    "end": 450,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Validation and Verification"
        },
        {
            "text": "Although interactive and scenario-based simulations are very useful to get a fast understanding of the developed models and quickly detect possible modelling errors, they do not allow to perform an exhaustive check. Therefore, we performed model review using the AsmetaMA tool [2] , as a complementary validation technique: it is a form of static analysis to determine if a model has sufficient quality attributes (as minimality, completeness, consistency). This automatic activity can find problems that could pass undetected during interactive simulation and scenario validation, which cannot be exhaustive and perform only some system executions. For example, CarSystem003 has a rule that decides when to switch on the parking lights (parkingLightON := true). By introducing requirement ELS-46, however, we added a rule to switch the lights off in case of subvoltage (parkingLightON := false). In the first version of the CarSystem004, the two rules sometimes conflicted, so leading to an inconsistent update. Model review allowed us to spot this problem, that we solved by introducing a guard to avoid the conflict.",
            "cite_spans": [
                {
                    "start": 277,
                    "end": 280,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Validation and Verification"
        },
        {
            "text": "AsmetaSMV [1] , and both Computation Tree Logic (CTL) and Linear Temporal Logic (LTL) formulas are supported. To perform model checking with NuSMV (the model checker AsmetaSMV is built on) that requires a finite state space, we reduce infinite domains in the original models to finite domains.",
            "cite_spans": [
                {
                    "start": 10,
                    "end": 13,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Verification. Formal verification of ASMs is possible by means of the tool"
        },
        {
            "text": "For the case study, some properties can be naturally derived from the requirements. The typical form of a requirement is \"when/if . . . then . . . \" describing that when something happens (a given external input received, a given state condition, etc.), some actions must be taken. Such kind of properties are naturally translated in temporal properties as (\u03c6 \u2192 (\u03c8)) or (\u03c6 \u2192 \u2666(\u03c8)). However, these kinds of properties (in particular the first one) are also reflected in the structure of ASM rules derived from the requirements, that take the form of if ... then ... else ... endif rules. In this case, tempo-ral properties assume the form of redundant specifications that can be used to enforce the model and make it robust against possible wrong future modifications of the model. An example of such kind of property that we developed related to requirement ELS-18 is the CTL property: ag((lightRotarySwitch = AUTO and engineOn and brightnessSensor <",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Verification. Formal verification of ASMs is possible by means of the tool"
        },
        {
            "text": "In addition to these straightforward properties, we specified more general properties that are not directly related to single requirements. For example, we specified the following three properties:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "200)implies ax(lowBeamLightingOn))."
        },
        {
            "text": "-both direction indicators blink iff the car is in hazard warning: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "200)implies ax(lowBeamLightingOn))."
        },
        {
            "text": "We here provide a more detailed discussion about our experience in modelling and analysing the case that took totally less than one month (around one week for understanding the requirements, and the remaining time for the model development and V&V). We report flaws we discovered in the requirements documents, features that we would have expected in the documents, and also missing functionalities of our framework that would have been helpful (besides the temporal aspects discussed in Sect. 2). Scenarios. The scenarios provided with the case study requirements turned out to be very useful as, in some cases, allowed us to clarify some misunderstanding we had when we developed the models starting from the requirements document. For example, observing the scenarios, we realized that desiredSpeed and targetSpeed are two separate entities that can assume different values with two updating policies, while, only reading the requirements document, we thought that the user could modify both at the same time. However, in other cases, the description of the scenarios and the description of the requirements were inconsistent. For some of such inconsistencies, it was clear that the document to trust was the scenario description; for example, the requirements document uses in an improper way the terms desired, target, and set speed, sometimes using them interchangeably; the scenarios document, instead, clearly distinguishes them and allows to observe their different roles. Other inconsistencies, instead, were less easy to disambiguate. This was the case of traffic sign detection for which the requirements document states that only the target speed is modified when the sign is recognized; however, scenario 6 of Validation Sequences Speed shows a case in which the car, when detects the sign, modifies both desired and target speed. Requirements Coverage. Since the scenarios turned out to be so useful, we would have liked to have a more exhaustive validation sequences in the informal documentation in order to build a set of scenarios covering all the requirements; using the coverage feature of our validator AsmetaV, we realized that this is not the case. For example, requirements ELS-42 to ELS-47 are not covered by any validation sequence and therefore by any of our scenario. Moreover, when doing this coverage checking, we realized a limit of our coverage tool that can only provide coverage information at the level of macro rule (similarly to call coverage). This coarse grained level of coverage may be not informative enough in situations in which requirements are mapped at the level of, e.g., branches of conditional rules. As future work, we plan to extend our coverage evaluator to provide information as decision and condition coverage. Scenario Derivation and Animation. As said previously, we have extensively used scenario-based validation during the modelling activity. We realized that a better integration with model animation [8] would permit to save animation sessions in terms of scenarios, and also to animate existing scenarios. For this work, we have developed the former technique that allows us to export into Avalla scripts the animations we perform, and re-execute them later when changing the model (in a kind of regression testing using \"record and replay\"). Parametric ASMs. The systems described in the case study actually represent a family of systems that can be configured on the base of the market and type of car. Different configurations lead to different behaviours of the systems. In order to model all these features, we had to introduce flags to be set in the initial state: this reduces the readability and maintainability of the models. It would be useful to have a parametric version of the ASM model, similarly to what done for software programs using Software Product Lines. A recent approach has been proposed in this context for ASM [6] , and we plan to consider it in future usages. Implementation. In modelling the case study, we did not consider any implementation. However, the ASMETA framework provides support in this sense. First of all, a translator to C++ [9] is available; it could be applied to generate a first prototype of the implementation, which could be then further extended by developers. Instead, if a system implementation is available, conformance checking approaches can be applied, in terms of model-based testing and runtime verification both supported by ASMETA.",
            "cite_spans": [
                {
                    "start": 2964,
                    "end": 2967,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 3901,
                    "end": 3904,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 4133,
                    "end": 4136,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Discussion"
        },
        {
            "text": "We have presented the specification, validation, and property verification of an automotive system by using ASMs. We have discussed our experience in modelling an adaptive exterior light and the speed control systems that equip modern cars, also addressing the adaptive features of the two systems in terms of MAPE-K feedback control loops. We have also shown how to write and run scenarios and verify properties addressed by our models. We have found some misunderstanding in the document of requirements, because the described behaviour was different from the behaviour expected in validation sequences. We have found some limitations in our tools, e.g., the coverage evaluator provides only coverage in terms of macro rules, that we plan to overcome with future improvements. On the other hand, this case study has provided us the opportunity to test our framework in terms of robustness and user experience in modelling complex systems. We have noticed that the framework is particularly suitable to handle the increasing complexity of the models: the support for modularization (at the level of modelling and scenario construction) allows producing refined model and refined scenarios with limited effort.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "AsmetaSMV: a way to link high-level ASM models to low-level NuSMV specifications",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Frappier",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Gl\u00e4sser",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Khurshid",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Laleau",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ABZ 2010",
            "volume": "5977",
            "issn": "",
            "pages": "61--74",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-11811-1_6"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Automatic review of abstract state machines by meta property verification",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proceedings of the Second NASA Formal Methods Symposium (NFM 2010)",
            "volume": "",
            "issn": "",
            "pages": "4--13",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "CoMA: conformance monitoring of Java programs by abstract state machines",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "RV 2011",
            "volume": "7186",
            "issn": "",
            "pages": "223--238",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-29860-8_17"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "A model-driven process for engineering a toolset for a formal method",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Softw. Pract. Exp",
            "volume": "41",
            "issn": "",
            "pages": "155--166",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Formal design and verification of self-adaptive systems with decentralized control",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Arcaini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Trans. Auton. Adapt. Syst",
            "volume": "11",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Modularization of refinement steps for agile formal methods",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Benduhn",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Th\u00fcm",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Schaefer",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Saake",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ICFEM 2017",
            "volume": "10610",
            "issn": "",
            "pages": "19--35",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-68690-5_2"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Abstract state machines capture parallel algorithms",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Blass",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Gurevich",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "ACM Trans. Comput. Log",
            "volume": "4",
            "issn": "",
            "pages": "578--651",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "AsmetaA: animator for abstract state machines",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bonfanti",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Mashkoor",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ABZ 2018",
            "volume": "10817",
            "issn": "",
            "pages": "369--373",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-91271-4_25"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Design and validation of a C++ code generator from abstract state machines specifications",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bonfanti",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Mashkoor",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "J. Softw. Evol. Proc",
            "volume": "32",
            "issn": "2",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Modeling Companion for Software Practitioners",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "B\u00f6rger",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Raschke",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Heidelberg",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-56641-1"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Abstract State Machines: A Method for High-Level System Design and Analysis",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "B\u00f6rger",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "St\u00e4rk",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-18216-7"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "A scenario-based validation language for ASMs",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Carioni",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "ABZ 2008",
            "volume": "5238",
            "issn": "",
            "pages": "71--84",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-87603-8_7"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Using spin to generate tests from ASM specifications",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Rinzivillo",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "ASM 2003",
            "volume": "2589",
            "issn": "",
            "pages": "263--277",
            "other_ids": {
                "DOI": [
                    "10.1007/3-540-36498-6_15"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "A metamodel-based language and a simulation engine for abstract state machines",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gargantini",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Riccobene",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Scandurra",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "J. UCS",
            "volume": "14",
            "issn": "12",
            "pages": "1949--1983",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Adaptive exterior light and speed control system",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Houdek",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Raschke",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "The vision of autonomic computing",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "O"
                    ],
                    "last": "Kephart",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "M"
                    ],
                    "last": "Chess",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Computer",
            "volume": "36",
            "issn": "1",
            "pages": "41--50",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Simulation of timed abstract state machines with predicate logic model-checking",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Slissenko",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Vasilyev",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "J. Univers. Comput. Sci",
            "volume": "14",
            "issn": "12",
            "pages": "1984--2006",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "ASM structure of the first 3 levels",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "ASM structure of level 4",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "ag((blinkLeft != 0 and blinkLeftPulseRatio != NOPULSE and blinkRight != 0 and blinkRightPulseRatio != NOPULSE)= hazardWarningSwitchOn Runn) -if tail lamps are blinking, the car is not European: ag((tailLampLeftStatus=BLINK or tailLampRightStatus=BLINK)implies marketCode!=EU) -the market code of a car cannot be changed: forall $c in MarketCode with (marketCode = $c implies ag(marketCode = $c))",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "CarSystem001: Direction Blinking, Hazard warning light ELS-1 to ELS-13 CarSystem002: Low Beam headlights, Cornering light, Emergency Brake Light and Reverse Light ELS-14 to ELS-29 and ELS-39 to ELS-41 Fig. 4. Chain of refined models and captured requirements",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Models dimensionFunctionsRules Monitored Controlled Derived Static n rules declarations n rules",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Traceability table between requirements and rules/functions",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}