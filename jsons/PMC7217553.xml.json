{
    "paper_id": "PMC7217553",
    "metadata": {
        "title": "Minimal percolating sets for mutating infectious diseases",
        "authors": [
            {
                "first": "Yuyuan",
                "middle": [],
                "last": "Luo",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Laura",
                "middle": [
                    "P."
                ],
                "last": "Schaposnik",
                "suffix": "",
                "email": null,
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "The model introduced in this paper, described in Eq. (1), is a dynamical generalization of what is known as bootstrap percolation, introduced in 1979 in the context of solid state physics to analyze diluted magnetic systems in which strong competition exists between exchange and crystal-field interactions [16]. Bootstrap percolation has seen applications in diverse areas, including the studies of fluid flow in porous areas, the orientational ordering process of magnetic alloys, as well as the failure of units in a structured collection of computer memory (e.g., see Ref. [17]).",
            "cite_spans": [
                {
                    "start": 307,
                    "end": 311,
                    "mention": "[16]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 577,
                    "end": 581,
                    "mention": "[17]",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Bootstrap percolation ::: INTRODUCTION",
            "ref_spans": []
        },
        {
            "text": "Bootstrap percolation has long been studied mathematically on arbitrary trees [18], as well as on finite and infinite rooted trees including Galton-Watson trees (e.g., see Ref. [19]). Compared with other models for infectious diseases, cellular automata models better simulate the effects of individual behavior and the spatial aspects of epidemic spreading, and better account for the effects of mixing patterns of individuals, as each individual is modeled separately, instead of all individuals being assumed as homogeneous. Hence, contagious diseases in which these factors have significant effects are better understood when analyzed with cellular automata models such as bootstrap percolation [20], which is defined as follows. For n\u2208Z+, we define an r-bootstrap percolation model on a graph G with vertices V and initially infected set A0 as the process in which at time t+1 has infected set given by\n(2)At+1=At\u222a{v\u2208V:|N(v)\u2229At|\u2265r}.Here, as before, we denoted by N(v) the set of neighboring vertices to v.",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 82,
                    "mention": "[18]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 177,
                    "end": 181,
                    "mention": "[19]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 699,
                    "end": 703,
                    "mention": "[20]",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Bootstrap percolation ::: INTRODUCTION",
            "ref_spans": []
        },
        {
            "text": "In contrast, a SIR Model relates at each time t the number of susceptible individuals S(t) to the number of infected individuals I(t) and the number of recovered individuals R(t), by a system of differential equations\u2014an example of a SIR model used to simulate the spread of the dengue fever disease appears in Ref. [21]. In these models, a fixed parameter \u03b2 denotes the average number of transmissions from an infected node per time period. In particular, the rate of spread of diseases are not necessarily constant in these models. This helps motivate the introduction of a time-dependent model of bootstrap percolation where the rate of spread varies according to time, done in Sec. II.",
            "cite_spans": [
                {
                    "start": 316,
                    "end": 320,
                    "mention": "[21]",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Bootstrap percolation ::: INTRODUCTION",
            "ref_spans": []
        },
        {
            "text": "In what follows we shall present a dynamical generalization of the above model, for which it will be useful to have an example to establish the comparisons. Consider the (irregular) tree with three infected nodes at time t=0, given by A0={2,4,5} as shown in Fig. 1. Through 2-bootstrap percolation at time t=1, node 3 becomes infected because its neighbors 4 and 5 are infected at time t=0. At time t=2, node 1 becomes infected since its neighbors 2 and 3 are infected at time t=1. Finally, note that nodes 6,7,8 cannot become infected because they each have only 1 neighbor, yet two or more infected neighbors are required to become infected.\n",
            "cite_spans": [],
            "section": "Bootstrap percolation ::: INTRODUCTION",
            "ref_spans": [
                {
                    "start": 263,
                    "end": 264,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The motivation of time-dependent percolation models appears since the rate of spread of diseases may change over time. In the SIR models mentioned before, since \u03b2 is the average number of transmissions from an infected node in a time period, 1/\u03b2 is the time it takes to infect a node. If we \u201cdivide the work\u201d among several neighbors, then 1/\u03b2 is also the number of infected neighbors needed to infect the current node.",
            "cite_spans": [],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "Consider now an infection which would evolve with time. This is, instead of taking the same number of neighbours in r-bootstrap percolation, consider a percolation model where the number of neighbours required to be infected for the disease to propagate changes with time, following the behavior of a function F(t). We shall say a function is a percolation function if it is a function F:I\u2192N where I is an initial segment of N (or all of N) that we use in a time-dependent percolation process, and which specifies the number of neighbors required to infect a node at time t.",
            "cite_spans": [],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "One should note that r-bootstrap percolation can be recovered from F(t)-bootstrap percolation by setting the percolation function to be the constant F(t)=r. In what follows, unless otherwise stated, the initial set A0 is chosen in the same way as in r-bootstrap percolation: by randomly selecting a set of initially infected vertices with probability p, for some fixed value of p which is called the probability of infection.",
            "cite_spans": [],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "If there are multiple percolation functions and initially infected sets under consideration, then we may use the notation AtF to denote the set of infected nodes at time t percolating under the function F(t) with A0 as the initially infected set. In particular, this would be the case when generalising the above dynamical model to a multitype bootstrap percolation model such as the one introduced in Ref. [22].",
            "cite_spans": [
                {
                    "start": 407,
                    "end": 411,
                    "mention": "[22]",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "To understand some basic properties of F(t)-bootstrap percolation, we shall first focus on a single update function F(t), and consider the critical probability pc of infection for which the probability of percolation is 12 on finite trees\u2014in the case of infinite trees, this is the value below which there are no clusters, and above which there are infinite clusters, with probability 1. When considering classical bootstrap percolation, note that the resulting set A\u221er of r-bootstrap percolation is always contained in the resulting set A\u221en of n-bootstrap percolation provided n\u2264r. From the above, setting the value m:=mintF(t), the resulting A\u221eF set of F(t)-bootstrap percolation will be contained in A\u221em.",
            "cite_spans": [],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "Note that for any time t\u2605 such that\nF(t\u2605)=m,one has that if v\u2208At\u2605F, then v\u2208At\u2605\u2032F for the next time t\u2605\u2032 for which F(t\u2605\u2032)=m. Moreover, since for the recurrent functions we are considering there are infinitely many times t\u2605 such that F(t\u2605)=m, one has that the final resulting set A\u221em of m-bootstrap percolation is contained in the final resulting set A\u221eF of F(t)-bootstrap percolation. Then, the resulting sets of m-bootstrap percolation and F(t)-bootstrap percolation need to be identical, and hence the critical probability for F(t)-bootstrap percolation is that of m-bootstrap percolation. In other words, we have shown that if F(t) equals its minimum for infinitely many times t, then the critical probability of infection pc for which the probability of percolation is 1/2, is given by the value of the critical probability in m-bootstrap percolation for m:=mintF(t), this is\n(4)pc[F(t)\u2212bootstrap]=pc(m\u2212bootstrap)form=mintF(t).The type of update functions that satisfy this include sinusoidal functions and, since we restricted the codomain to be positive, weakly decreasing functions.",
            "cite_spans": [],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "The percolation function F(t) can be written in terms of a one-parameter family of parameters \u03b2 by setting F(t):=\u23081\u03b2(t)\u2309. As we shall see later, different choices of the one-parameter family \u03b2(t) defining F(t) will lead to very different dynamical models. A particular setup arises from Ref. [23], which provides data on the time-dependent rate of a specific virus spread, and through which one has that an interesting family of parameters appears by setting\n\u03b2(t)=(b0\u2212bf)(1\u2212k)t+bf,where b0 is the initial rate of spread, bf is the final rate of spread, and 0<k<1. Then at time t, the number of infected neighbors it takes to infect a node is\nF(t):=1(b0\u2212bf)\u00b7(1\u2212k)t+bf.",
            "cite_spans": [
                {
                    "start": 292,
                    "end": 296,
                    "mention": "[23]",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "In this case, since \u03b2(t) tends to bf, and 1\u03b2 tends to 1bf, one cans see that there will be infinitely many times t such that\nF(t)=1bf.Hence, in this setting from Eq. (4), the critical probability will be same as that of a r-bootstrap percolation where r=\u23081bf\u2309.",
            "cite_spans": [],
            "section": "TIME-DEPENDENT PERCOLATION",
            "ref_spans": []
        },
        {
            "text": "Expanding on the notation of Eq. (5), we shall denote by A\u221eF the set of nodes infected by percolating the set A0 on the graph with percolation function F(t), and we shall simply write A\u221e when the percolation function F(t) is clear from context or irrelevant. Moreover, we shall say that two percolation functions F1:I1\u2192Z+ and F2:I2\u2192Z+ are equivalent (written as F1\u2261F2) for the graph G if for all initially infected sets A0, one has that\n(6)A\u221eF1=A\u221eF2.This equivalence relation can be understood through the lemma below, which uses an additional function \u03b3(t) to relate two percolation functions F0 and F0\u2032 if F0\u2032 can be intuitively \u201cgenerated\u201d by removing some values of F0. This removal procedure is further specified below.",
            "cite_spans": [],
            "section": "Equivalent functions ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "Given two subsets I1 and I2 of N, we say a function \u03b3:I1\u2192I2\u222a{\u22121} is a nice function if it is surjective and\n1.it is injective on \u03b3\u22121(I2);2.it is increasing on \u03b3\u22121(I2);3.it satisfies \u03b3(a)\u2264a or \u03b3(a)=\u22121.",
            "cite_spans": [],
            "section": "Equivalent functions ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "The notion of a nice function allows us to understand the relation between two different dynamical percolation models defined through two functions F(t) and F\u2032(t). Given I1,I2\u2282N, let F(t) be any percolation function with domain I1, and define the percolation function F\u2032(t) with domain I2 as\nF\u2032(t):=F[\u03b3\u22121(t)]for \u03b3(t) a nice function. Through the function F\u2032(t), for any fixed initially infected set A0 and t\u2208I2, one can show by induction (see Appendix A) that\n(7)AtF\u2032\u2286A\u03b3\u22121(t)F.",
            "cite_spans": [],
            "section": "Equivalent functions ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "Intuitively, the above results tell us that given a fixed time t0 and some t>t0, if F(t)=\u2113 is the smallest value the function takes on after the time t0, and F(t) has already taken on that value more than \u2113 times, for \u2113 the number of nodes in the graph, then there will be no nodes that will be infected at that time and the value is safe to be \u201cremoved.\u201d",
            "cite_spans": [],
            "section": "Equivalent functions ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "In what follows we shall clarify the removal process, by defining an upper bound on percolation time on a specified tree and function F(t). For this, let G be a regular tree of degree d and \u2113 vertices. Given a percolation function F(t), define the functions F\u2032(t) and \u03b3:N\u2192N\u222a{\u22121} by setting:\n(i)F\u2032(0):=F(0), and \u03b3(0):=0.(ii)Suppose the least value we have not considered F(t) at is a, and let b be the least value where F\u2032(b) has not yet been defined. If F(a) has not yet appeared \u2113 times since the last time t such that F(t)<F(a) and F(a)\u2264d, then set F\u2032(b):=F(a), and let \u03b3(a)=b. Otherwise, \u03b3(a)=\u22121.",
            "cite_spans": [],
            "section": "Removal process ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "Then, one can show (see Appendix B) that the two functions are equivalent as defined in Eq. (6), this is\n(8)F\u2032(t)\u2261F(t).",
            "cite_spans": [],
            "section": "Removal process ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "From the above description of equivalent functions, we can see two things:\n(i)The upper bound on the percolation time is the time of the largest t such that F\u2032(t) is defined, and we can use this function in an algorithm to find the smallest minimal percolating set since F(t) and F\u2032(t) are equivalent.(ii)An upper bound on the percolation time can not be obtained without regards to the percolation function.",
            "cite_spans": [],
            "section": "Removal process ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "To see item (ii), suppose we have such an upper bound b on some connected graph with degree d and with 1 node initially infected and more than 1 node not initially infected. If we have percolation function F(t) such that F(t)=d+1 for all t\u2208N\u2264b and F(m)=1 otherwise, then we see that there will be nodes infected at time b+1, leading to a contradiction.",
            "cite_spans": [],
            "section": "Removal process ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "To see the implications of the above points within the equivalence of functions, suppose that the degree of the graph in consideration is d, and define a sequence a, where a1=d and\nan+1=(an+1)d.Then, the size of the domain of F\u2032(t) in Eq. (8) is\n(9)\u03a3i=1dai.Indeed, suppose each value do appear exactly d times after the last value smaller than it appears. To count how large the domain can be, we start with the possible ts such as F\u2032(t)=1s in the function; there are d of them as 1 can maximally appear d times. Note that this is equal to a1. Now, suppose we have already counted all the possible ts when F\u2032(t)<n+1, for 1leqn<d, which amounted to an. Then, there can be maximally d instances at the between the appearance of each t when F\u2032(t)<n as well as before and after all such appearances, so there are an+1 places where F\u2032(t)=n can appear. Thus, there are maximally (an+1)d elements t in the domain such that F\u2032(t)=n+1. Summing all of them yields \u03a3i=1dai, the total number of elements in the domain in Eq. (9). Finally, note that from Eq. (8), for some F(t), A0 and n, one has A\u03b3\u22121(n)F=AnF\u2032. If A\u221eF\u2032 is reached by time \u03a3i=1dai, then the set must be infected by time \u03b3\u22121(\u03a3i=1dai). Hence, in this setting an upper bound of F(t) percolating on a graph with d vertices can be found by taking \u03b3\u22121(\u03a3i=1dai), as defined in Eq. (9).",
            "cite_spans": [],
            "section": "Removal process ::: PERCOLATION TIME",
            "ref_spans": []
        },
        {
            "text": "When considering percolations within a graph, it is of much interest to understand which subsets of vertices, when infected, would lead to the infection reaching the whole graph. To study those sets, we shall refer to a percolating set of a graph G with percolation function F(t) is a set A0 for which A\u221eF=G at a finite time. A minimal percolating set is a percolating set A such that if any node is removed from A, it will no longer be a percolating set.",
            "cite_spans": [],
            "section": "MINIMAL PERCOLATING SETS",
            "ref_spans": []
        },
        {
            "text": "A natural motivation for studying minimal percolating sets is that as long as we keep the number of individuals infected to less than the size of the minimal percolating set, we know that the entire population will not be decimated. Bounds on minimal percolating sets on grids and other less regular graphs have extensively been studied. For instance, it has been shown in Ref. [24] that for a grid [n]d, there exist a minimal percolating set of size\n4n2/33+o(n2),but there does not exist one larger than (n+2)2/6. In the case of trees, Ref. [15] gives an algorithm that finds the largest and smallest minimal percolating sets on trees. Since then, only a few further results have been obtained improving those bounds (see, for example, the work on degree conditions for bootstrap percolation from small sets in Ref. [25] and references therein). However, the results in the above papers cannot be easily extended to the dynamical model because it makes several assumptions such as F(t)\u22601 that do not necessarily hold in the dynamical model.",
            "cite_spans": [
                {
                    "start": 378,
                    "end": 382,
                    "mention": "[24]",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 542,
                    "end": 546,
                    "mention": "[15]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 817,
                    "end": 821,
                    "mention": "[25]",
                    "ref_id": "BIBREF17"
                }
            ],
            "section": "MINIMAL PERCOLATING SETS",
            "ref_spans": []
        },
        {
            "text": "In the following sections we shall study minimal percolating sets for certain models of F(t)-bootstrap percolations, but before this is done, we shall first consider an example of a minimal percolating set with F(t)=t, as shown in Fig. 3.\n",
            "cite_spans": [],
            "section": "MINIMAL PERCOLATING SETS",
            "ref_spans": [
                {
                    "start": 236,
                    "end": 237,
                    "mention": "3",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "In this case, the minimal percolating set has size 3, as shown in Fig. 3(a). Indeed, we see that if we take away any of the shaded nodes, the remaining initially infected shaded nodes would not percolate to the whole tree, and thus they form a minimal percolating set; further, there exists no minimal percolating sets of size 1 or 2, thus this is the smallest minimal percolating set. It should be noted that minimal percolating sets can have different sizes. For example, another minimal percolating set with 5 vertices appears in Fig. 3(b).",
            "cite_spans": [],
            "section": "MINIMAL PERCOLATING SETS",
            "ref_spans": [
                {
                    "start": 71,
                    "end": 75,
                    "mention": "3(a)",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 538,
                    "end": 542,
                    "mention": "3(b)",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "In what follows we shall work with general finite trees T(V,E) with set of vertices V and set of edges E. In particular, we shall consider the smallest minimal percolating sets in the following section.",
            "cite_spans": [],
            "section": "MINIMAL PERCOLATING SETS",
            "ref_spans": []
        },
        {
            "text": "To build an algorithm to find smallest percolating sets, we first need to introduce a few definitions that will simplify the notation at later stages. First, we shall denote by L(a) the largest time t such that a\u2264F(t), and if there does not exist such a time t, then set L(a)=\u221e, this is\n(10)L(a)=maxt{t:a\u2264F(t)}ifitexists,\u221eotherwise.Similarly, let B(a) be the smallest time t such that a\u2264F(t), and if such a time t does not exist, set B(a)=\u221e, leading to\n(11)B(a)=mint{t:a\u2264F(t)}ifitexists,\u221eotherwise.",
            "cite_spans": [],
            "section": "Smallest and largest times ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Given a,b\u2208N, if a<b, then L(a)\u2265L(b). Indeed, this holds because if a node can be infected to with b neighbors, then it can with a neighbors where a<b. Note that in general, a smallest percolating set A0 must be a minimal percolating set. To see this, suppose not. Then there exists some v in A0 such that A0\u2212{v} percolates the graph. That means that A0\u2212{v}, a smaller set that A0, is a percolating set. However, since A0 is a smallest percolating set, we have a contradiction. Hence, showing that a percolating set A0 is the smallest implies that A0 is a minimal percolating set.",
            "cite_spans": [],
            "section": "Smallest and largest times ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "The first algorithm one may think of is to try every case. There are 2n possible sets A0, and for each set we much percolate A0 on T to find the smallest percolating set. This amounts to an algorithm of complexity,\nO(t2n),where t is the upper bound on the percolation time. In what follows we shall describe a polynomial-timed algorithm to find the smallest minimal percolating set on T(V,E), described in the algorithm. For this, we shall introduce two particular times associated to each vertex in the graph, and formally define what isolated vertices are.",
            "cite_spans": [],
            "section": "Smallest and largest times ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "For each node v in the graph, we let ta(v) be the time when it is infected, and t*(v) the time when it is last allowed to be infected; moreover, when building our algorithm, each vertex will be allocated a truth value of whether it needs to be further considered. A node v is said to be isolated with regards to A0 if there is no vertex w\u2208V such that v becomes infected when considering F(t)-bootstrap percolation with initial set A0\u222a{w}. From these definitions, a node is isolated with regards to a set if it is impossible to infect it by adding one of any other node to that set that is not itself.",
            "cite_spans": [],
            "section": "Isolated nodes ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Building toward the percolating algorithm, we shall show a few properties first. First, note that if a node cannot be infected by including a neighbor in the initial set, it is isolated. Hence, by filling the neighbor in the initial set, we either increased the number of neighbors infected to a sufficient amount, or we expanded the time allowed to percolate with fewer neighbors so that percolation is possible.",
            "cite_spans": [],
            "section": "Isolated nodes ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "A quick test to see whether a vertex is isolated can be done as follows. Let v be an uninfected node such that not all of its n neighbors are in set A0. Define a function\n(12)N:{0,1,...,n}\u2192Z,where N(i) is the smallest time when i of the neighbors of node v is infected, and set N(0)=0. Then, a vertex v is isolated iff there exists no i such that\n(13)F(t)\u2264i+1forsomet\u2208(N(i),t*].To see that this test works, suppose s\u2208N(v)\u2229A0. If there exists i such that F(t)\u2264i+1 for some t\u2208(N(i),t*], then using A0\u222a{s} as the initially infected set allows percolation to happen at time t since there would be i+1 neighbors infected at each time N(i). Thus, by contradiction, the forward direction is proven.",
            "cite_spans": [],
            "section": "Isolated nodes ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Let v be not isolated, and v\u2208P(A0\u222a{s}) for some neighbor s of v. Then there would be i+1 neighbors infected at each time N(i). Moreover, for v being to be infected, the i+1 neighbors must be able to fill v in the allowed time, (N(i),t*]. Thus, there exists N(i) such that F(t)\u2264i+1 for some t\u2208(N(i),t*]. By contradiction, we proved the backwards direction.",
            "cite_spans": [],
            "section": "Isolated nodes ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Note that if a vertex v is uninfected and N(v)\u2282A0, then the vertex must be isolated. In what follows we shall study the effect of having different initially infected sets when studying F(t)-bootstrap percolation. For this, let Q be an initial set for which a fixed vertex v with n neighbours is isolated. Denoting the neighbors of v be s1,s2,...,sn, we let the times at which they are infected be t1Q,t2Q,...,tnQ. Here, if for some 1\u2264i\u2264n, the vertex si is not infected, then set tiQ to be some arbitrarily large number. Moreover, consider another initial set P such that the times at which s1,s2,...,sn are infected are t1P,t2P,...,tnP satisfying\n(14)tiQ=tiPfori\u2260j,\n(15)tjQ\u2264tjPfori=j,for some 1\u2264j\u2264n.",
            "cite_spans": [],
            "section": "Variation of initial sets ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "In the above setting, if v\u2209P, then the vertex v must be isolated with regards to P as well. Indeed, consider NQ(i) as defined in Eq. (12) for the set Q, and NP(i) the corresponding function for the set P. Then for all integers k\u2208{0,1,...,n}, one has that NQ(k)\u2264NP(k). Indeed, this is because with set P, each neighbor of v is infected at or after they are with set Q. Then, from Eq. (3), v is isolated with regards to Q so there is no m such that\nF(t)\u2264m+1forsomet\u2208(NQ(m),t*].However, since\nNQ(k)\u2264NP(k)forallk\u2208{0,1,...,n},we can say that there is no m such that\nF(t)\u2264m+1forsomet\u2208(NP(m),t*],as (NP(m),t*]\u2286(NQ(m),t*]. Thus, we know that v must also be isolated with regards to P.",
            "cite_spans": [],
            "section": "Variation of initial sets ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 384,
                    "end": 385,
                    "mention": "3",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "Given a vertex v which is not isolated with n infected neighbors, we shall define tp(v)\u2208(0,t*] to be the largest integer such that for i\u2208{0,1,...n}, one has that\n(16)F(tp)\u2264i+1.Note that to fill an isolated node v, one can fill it by filling one of its neighbors by time tp(v), or just add the vertex it to the initial set. Hence, one needs to fill a node vn which is either the parent par(vn), a child chi(vn), or itself.",
            "cite_spans": [],
            "section": "Variation of initial sets ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "One can further understand the variation of initially infected sets by noting that, given an isolated node v\u2209A0, to achieve percolation, it is always better (faster) to include v in A0 than attempting to make v unisolated. Indeed, it is possible to make v isolated by including only descendants of v in A0 since we must include less than deg(v) neighbors. But we know that if given the choice to include a descendant or a v to the initial set, choosing v is absolutely advantageous because the upwards percolation achieved by v infected at some positive time is a subset of upwards percolation achieved by filling it at time 0. Thus, including v to the initial set is superior.",
            "cite_spans": [],
            "section": "Variation of initial sets ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "The above set-up can be understood further to find which vertex needs to be chosen to be vn. To see this, consider a vertex v\u2209A0. Then, in finding a node u to add to A0 so that v\u2208A\u221e for the initial set A0\u222a{u} and such A\u221e is maximized, the vertex vn must be the parent par(v) of v. This can be understood by noting that filling v by time t*(v) already ensures that all descendants of v will be infected, and that all percolation upwards must go through the parent par(v) of v. This means that filling any child of v to fill v (by including some descendant of v in A0) we obtain a subset of percolation if we include the parent par(v) of v in A0. Therefore, the parent par(v) of v or a further ancestor needs to be included in A0, which means vn needs to be the parent par(v) of v.",
            "cite_spans": [],
            "section": "Variation of initial sets ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Note that given a node v\u2209A0, if we fill its parent par(v) before tp(v), then the vertex will be infected. We are now ready for our main result, which improves the naive O(t2n) bound for finding minimal percolating sets to O(tn), as discussed further in the last section.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "To obtain one smallest minimal percolating set of a tree T(V,E) with percolation function F(t), proceed as follows:\n1.Step 1. Initialize tree: For each node v, set t*(v) to be some arbitrarily large number, and set it to true for needing to be considered.2.Step 2. Percolate using current A0. Save the time ta's at which the nodes were infected. Stop the algorithm if the set of nodes that are infected equals the set V.3.Step 3. Consider a node v that is furthest away from the root, and if there are multiple such nodes, then choose the one that is isolated, if it exists.(a)if v is isolated or is the root, then add v to A0.(b)otherwise, set\nt*[par(v)]=tp(v)\u22121if it is smaller than the current t*[par(v)] of the parent [for tp(v) defined in Eq. (16)].Set v as considered.4.Step 4. Go to step 2.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "After the process has finished, the resulting set A0 is one of the smallest minimal percolating sets.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Note that the specification that the tree must be finite is important as the algorithm is iterative and relies on the existence of a node furthest from the root.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "The description of the algorithm through which one can find a smallest percolating set, shall be organized as follows: we will first show that the set A0 constructed through the steps of the algorithm is a minimal percolating set, and then show that it is the smallest such set. To see that A0 is a minimal percolating set, we first need to show that A0 percolates. In step 3, we have included all isolated nodes, as well as the root if it wasn't infected already, in A0 and guaranteed to fill all other nodes by guaranteeing that their parents will be infected by their time tp.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Showing that A0 is a minimal percolating set is equivalent to showing that if we remove any node from A0, it will not percolate to the whole tree. Note that in the process, we have only included isolated nodes in A0 other than the root. This means that if any node v0 is removed from A0, it will not percolate to v0 because we only fill nodes higher than v0 after considering v0 and since turning a node isolated requires filling at least one node higher and one descendant of v0, it cannot be infected to after removing it from A0. Moreover, if the root is in A0, since we considered the root last, it is implied that the rest of A0 does not percolate to the root. Thus, A0 is a minimal percolating set.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Now we show that the set A0 constructed through the algorithm is of the smallest percolating size by contradiction using Lemma 15. For this, suppose there is some other minimal percolating set B for which |B|\u2264|A|. Then, we can build an injection A0 to B in the following manner: iteratively consider the node a that is furthest from the root and a\u2208A0 that hasn't been considered, and map it to a vertex b0 which is itself or one of its descendants of b where b\u2208B. We know that such a b0 must exist by induction.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "We first consider the case where a has no descendant in A. Then, if the vertex b\u2208B and b is a descendant of a, we map a to b. Now suppose there is no node b that is a descendant of a where b\u2208B. Then, a\u2208B because otherwise a would be isolated with regards to B as well, by Lemma 15. This means that we can map a to a in this case.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "Now we can consider the case where all the descendants d of a such that d\u2208A:=A0 has been mapped to a node bd\u2208B where bd is d or a descendant of d. If there is such a b\u2208B, then b is a descendant of a, and thus no nodes in A have been matched to b yet, allowing us to map a to b. Now suppose there is no such b\u2208B. This means that there is no b\u2208B such that all of the descendants of a are descendants of b. Then, all nodes in B that are descendants of a is either some descendant of a\u2208A or some descendant of a descendant of a in A. This means that percolating B, the children of a will all be infected at later times than when percolating A, and by Lemma 15, one has that a\u2208B because a would be isolated with regards to B. So in this case, we can map a to a.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "The map constructed above is injective because each element of B has been mapped to not more than once. Since we constructed an injective function from the set generated by the algorithm A0 to a smaller minimal percolating set B0, we have a contradiction because A0 then must be the same size or larger than B0. Thus, the set generated from the algorithm must be a smallest minimal percolating set.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "From Sec. V D one can find the smallest minimal percolating set on any finite tree. Moreover, it gives an intuition for how to think of the vertices of the graph: in particular, the property of \u201cisolated\u201d is not an absolute property, but a property relative to the set of nodes that has been infected before it. This isolatedness is easy to define and work with in trees since each node has at most one parent. Moreover, a similar property may be considered in more general graphs and we hope to explore this in future work. Below we shall demonstrate the algorithm of Sec. V D with an example.",
            "cite_spans": [],
            "section": "Smallest minimal percolating set algorithm ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": []
        },
        {
            "text": "We will preform the algorithm on the tree in Fig. 3, with percolating function F(t)=t. We first initialize all the nodes, setting their time t* to some arbitrarily large number, represented as \u221e in Fig. 4.\n",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 50,
                    "end": 51,
                    "mention": "3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 203,
                    "end": 204,
                    "mention": "4",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "Percolating the empty set A0, the resulting infected set is empty, as shown in Fig. 4(a). We then consider the furthest node from root. None of them are isolated, so we can consider any; we begin by considering node v=6 in the labeling of Fig. 3. It is not isolated, so we set the value to be\nt*[par(v)]=tp(v)\u22121=0,as can be seen in Fig. 4(b). Then we consider another node furthest from the root, and through the algorithm set the t* of the parent to tp\u22121=0, as can be seen in Fig. 4(c).",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 84,
                    "end": 88,
                    "mention": "4(a)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 244,
                    "end": 245,
                    "mention": "3",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 337,
                    "end": 341,
                    "mention": "4(b)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 482,
                    "end": 486,
                    "mention": "4(c)",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "The following steps of the algorithm are depicted in Fig. 5 below. As done in the first three steps of Fig. 4, we consider the next furthest node v from the root, and by the same reasoning as node 6, set the t*par(v) of the parent to t*par(v)=1, as can be seen in Fig. 5(a) below.\n",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 58,
                    "end": 59,
                    "mention": "5",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 108,
                    "end": 109,
                    "mention": "4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 269,
                    "end": 273,
                    "mention": "5(a)",
                    "ref_id": "FIGREF5"
                }
            ]
        },
        {
            "text": "Now we consider node 4: since it is isolated, we fill it in as in Fig. 5(b). The set of nodes infected can be seen in Fig. 5(c). We then consider node 5, the furthest node from the root not considered yet. Since it is not isolated, change the t*par(v) of its parent to tp(v)\u22121=0, as in Fig. 6(a).\n",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 71,
                    "end": 75,
                    "mention": "5(b)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 123,
                    "end": 127,
                    "mention": "5(c)",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 291,
                    "end": 295,
                    "mention": "6(a)",
                    "ref_id": "FIGREF6"
                }
            ]
        },
        {
            "text": "Then we consider node 3, which is isolated, so we include it in A0. The infected nodes as a result of percolation by this A0 is shown as red vertices in Fig. 6(c). To finish the process, consider the vertex v=2 since it is the furthest away nonconsidered node. It is not isolated so we change the\nt*[par(v)]=tp(v)\u22121=0,as shown in Fig. 7(a). Finally, we consider the root: since it is isolated, we include it in our A0 as seen in Fig. 7(b). Finally, percolating this A0 results in all nodes being infected as shown in Fig. 7(c), and thus we stop our algorithm.\n",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 158,
                    "end": 162,
                    "mention": "6(c)",
                    "ref_id": "FIGREF6"
                },
                {
                    "start": 335,
                    "end": 339,
                    "mention": "7(a)",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 434,
                    "end": 438,
                    "mention": "7(b)",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 522,
                    "end": 526,
                    "mention": "7(c)",
                    "ref_id": "FIGREF7"
                }
            ]
        },
        {
            "text": "Through the above algorithm, we have constructed a smallest minimal percolating set shown as red vertices in Fig. 7(c), which is of size 3. Comparing it with Fig. 3, we see that the minimal percolating set in that example is indeed the smallest, also with 3 elements. Finally, it should be noted that in general the times tp for each node could be different from each other and are not the same object.",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 114,
                    "end": 118,
                    "mention": "7(c)",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 163,
                    "end": 164,
                    "mention": "3",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "From the above example, and its comparison with Fig. 3, one can see that a graph can have multiple different smallest minimal percolating sets, and the algorithm finds just one. In the algorithm of Sec. V D, one minimizes the size of a minimal percolating set, relying on the fact that as long as a node is not isolated, one can engineer its parent to become infected so as to infect the initial node. The motivation of the definition of isolated stems from trying to find a variable that describes whether a node is still possible to become infected by infecting its parent. Because the algorithm is on trees, we could define isolation to be the inability to be infected if we add only one node.",
            "cite_spans": [],
            "section": "Smallest minimal percolating sets on trees ::: ALGORITHMS FOR FINDING SMALLEST MINIMAL PERCOLATING SET",
            "ref_spans": [
                {
                    "start": 53,
                    "end": 54,
                    "mention": "3",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "First, we shall consider the complexity of the algorithm in Sec. V D to find the smallest minimal percolating set on a graph with n vertices. To calculate this, suppose t is the upper bound on percolation time; we have presented a way to find such an upper bound in the previous sections. In the algorithm, we first initialize the tree, which is linear timed. Steps 2 and 3 are run at most n times as there can only be a total of n unconsidered nodes. The upper bound on time is t, so steps 2 will take t to run. Determining whether a node is isolated is linear timed, so determining isolated-ness of all nodes on the same level is quadratic timed, and doing the specifics of step 3 is constant timed. Thus, the algorithm is\nO[n+n(t+n2)]=O(tn+n3)=O(tn),much better than then O(t2n) complexity of the naive algorithm.",
            "cite_spans": [],
            "section": "Complexity ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": []
        },
        {
            "text": "Finally, we shall compare our algorithm with classical r-bootstrap percolation. For this, in Fig. 8 we show a comparison of sizes of the smallest minimal percolating sets on perfect trees of height 4, varying the degree of the tree. Two different functions were compared: one is constant and the other is quadratic. We see that the time-dependent bootstrap percolation model can be superior in modeling diseases with time-variant speed of spread, for that if each individual has around 10 social connections, the smallest number of individuals needed to be infected to percolate the whole population has a difference of around 103 between the two models.\n",
            "cite_spans": [],
            "section": "Comparison on perfect trees ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": [
                {
                    "start": 98,
                    "end": 99,
                    "mention": "8",
                    "ref_id": "FIGREF8"
                }
            ]
        },
        {
            "text": "We shall conclude this work by comparing the smallest minimal percolating sets found through our algorithm and those constructed by Riedl in Ref. [15]. To understand the difference of the two models, we shall first consider in Fig. 9 three percolating functions F(t) on random trees of different sizes, where each random tree has been formed by beginning with one node, and then for each new node i we add, use a random number from 1 to i\u22121 to determine where to attach this node.\n",
            "cite_spans": [
                {
                    "start": 146,
                    "end": 150,
                    "mention": "[15]",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Comparison on random trees ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": [
                {
                    "start": 232,
                    "end": 233,
                    "mention": "9",
                    "ref_id": "FIGREF9"
                }
            ]
        },
        {
            "text": "In Fig. 9, the size of the smallest minimal percolating set can be obtained by multiplying the size of the minimal percolating set by the corresponding value of n. In particular, one can see how the exponential function requires an increasingly larger minimal percolating set in comparison with polynomial percolating functions.",
            "cite_spans": [],
            "section": "Comparison on random trees ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": [
                {
                    "start": 8,
                    "end": 9,
                    "mention": "9",
                    "ref_id": "FIGREF9"
                }
            ]
        },
        {
            "text": "Riedl provided an algorithm for the smallest minimal percolating sets in trees for r-bootstrap percolation in Ref. [15] that runs in linear time. We shall describe his algorithm generally to clarify the comparisons we will make. Riedl defined a trailing star or trailing pseudostar as a subtree with each vertex being of distance at most 1 or 2 away, respectively, from a certain center vertex that is connected to the rest of the tree by only one edge. Then, the first step of Riedl's algorithm is a reduction procedure that ensures every nonleaf has degree at least r: Intuitively, one repeatedly finds a vertex with degree less than r, include it to the minimal percolating set, remove it and all the edges attached to it, and for each of the connected components, add a new node with degree 1 connected to the node that was a neighbor of the node we removed.",
            "cite_spans": [
                {
                    "start": 115,
                    "end": 119,
                    "mention": "[15]",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Comparison with Ref.\u00a0[15]c15bibr ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": []
        },
        {
            "text": "Then, the algorithm identifies a trailing star or pseudostar, whose center shall be denoted by v and its set of leaves by L. Letting the original tree be T, if the number of leafs on v is less than r, then set T\u2032=T\u2216(v\u222aL); otherwise, set T\u2032=T\u2216L. Recursively set A\u2032 as the smallest minimal percolating set of T\u2032 under r-bootstrap percolation. Then, the smallest minimal percolating set for T is A\u2032\u222aL if |L|<r and A\u2032\u222aL\u2216v otherwise. Using Riedl's algorithm, we first note that there is a trailing star centered at 3 with 2 leaves, as seen in Fig. 10. Removing the leaf, there is a trailing star at 1 with 1 leaf. Removing 1 and 2, we have one node left, which is in our A\u2032. Adding the leaves back and removing 3, we have an A0 of 2,3 and 5, a smallest minimal percolating set. Thus, the smallest minimal percolating set with Riedl's algorithm also has size 3, as expected.\n",
            "cite_spans": [],
            "section": "Comparison with Ref.\u00a0[15]c15bibr ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": [
                {
                    "start": 543,
                    "end": 545,
                    "mention": "10",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "To compare with the work of Ref. [15], we shall run the algorithm with F(t)=2 (leading to 2-bootstrap percolation as considered in Ref. [15]) as well as linear-timed function on the following graph:",
            "cite_spans": [
                {
                    "start": 33,
                    "end": 37,
                    "mention": "[15]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 136,
                    "end": 140,
                    "mention": "[15]",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Comparison with Ref.\u00a0[15]c15bibr ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": []
        },
        {
            "text": "With our algorithm, we see that nodes 2, 3, and 5 are isolated, respectively, and when we add them to the initial set, all nodes become infected. Thus, the smallest minimal percolating set with our algorithm has size 3.",
            "cite_spans": [],
            "section": "Comparison with Ref.\u00a0[15]c15bibr ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": []
        },
        {
            "text": "We shall now compare our algorithm to that of Riedl. A key step in Riedl's algorithm, which is including the leaves of stars and pseudostars in the final minimal percolating set, assumes that these leaves cannot be infected as it is assumed that r>1. However, in our algorithm, we consider functions that may have the value of 1 somewhere in the function, thus we cannot make that assumption. Further, in r-bootstrap percolation, time of infection of each vertex does not need to be taken into account when calculating the conditions for a node to be infected as that r is constant, whereas in the time-dependent case, it is necessary: Suppose a node has n neighbors, and there is only one t such that F(t)\u2264n, so all neighbors must be infected by time n in order for n to become infected.",
            "cite_spans": [],
            "section": "Comparison with Ref.\u00a0[15]c15bibr ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": []
        },
        {
            "text": "The problem our algorithm solves is a generalization of Riedl's, for that it finds one smallest minimal percolating set for functions including constant ones. It has higher computational complexity for that it is not guaranteed for an unisolated node to be infected once one other neighbor of it is infected without accounting for time limits.",
            "cite_spans": [],
            "section": "Comparison with Ref.\u00a0[15]c15bibr ::: FURTHER PROPERTIES OF F(t)-BOOTSTRAP PERCOLATION AND OUR ALGORITHM",
            "ref_spans": []
        },
        {
            "text": "This paper is dedicated to the introduction and study of a novel time-dependant percolation model. The set up generalises the standard r-bootstrap percolation by introducing a time-dependant percolation function F(t), through which we define F(t)-bootstrap percolation (see Definition 1). Some basic properties of F(t)-bootstrap percolation are then studied, with particular attention given to the critical probability pc for certain recurrent functions F(t), for which we give bounds in Sec. II.",
            "cite_spans": [],
            "section": "CONCLUDING REMARKS",
            "ref_spans": []
        },
        {
            "text": "Our motivation comes partially from the study of effective vaccination programs which would allow to contain an epidemic, and thus we are interested both in the percolation time of the model, as well as in minimal percolating sets. We study the former in Sec. III, where by considering equivalent functions to F(t), we obtained bounds on the percolating time (see Fig. 2). In particular, the results in Sec. III we show that if F(t)=\u2113 is the smallest value the function takes on after some fixed time t0, and F(t) has already taken on that value more than times than the number of nodes in the graph, then there will be no nodes that will be infected at that time and the value is safe to be \u201cremoved.\u201d The removal process is explained in the same section, and is characterized by obtaining an upper bound on percolation time on a specified tree and function F(t).",
            "cite_spans": [],
            "section": "CONCLUDING REMARKS",
            "ref_spans": [
                {
                    "start": 369,
                    "end": 370,
                    "mention": "2",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "In Secs. IV and V we introduce and study smallest minimal percolating sets for F(t)-bootstrap percolation on (nonregular) trees. Our main results appear in Sec. V D, and are given by an algorithm for finding the smallest minimal percolating sets. To show the relevance of our work, we shall conclude this note with a short comparison of our model with those existing in the literature.",
            "cite_spans": [],
            "section": "CONCLUDING REMARKS",
            "ref_spans": []
        },
        {
            "text": "Finally, we should mention that the work presented in previous sections could be generalized in several directions and, in particular, we hope to develop a similar algorithm for largest minimal percolating set; and study the size of largest and smallest minimal percolating sets in lattices.",
            "cite_spans": [],
            "section": "CONCLUDING REMARKS",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "FIG. 1.: Depiction of 2-bootstrap percolation, where shaded vertices indicated infected nodes.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "FIG. 10.: Degree 2 tree with 5 nodes.",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "FIG. 2.: Percentage of nodes infected at time t for F(t)-bootstrap percolation with initial probability p, on graphs with 100 nodes and 300 edges.",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "FIG. 3.: (a) In this tree, having nodes 2,4,5 infected (shaded) initially is sufficient to ensure that the whole tree is infected. (b) This minimal percolating set shaded is of size 5.",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "FIG. 4.: Panels (a\u2013c) show the first three updates through the algorithm in Sec. V D, where the vertices considered at each time are shaded and each vertex is assigned the value of t*.",
            "type": "figure"
        },
        "FIGREF5": {
            "text": "FIG. 5.: Panels (a, b) update 4\u20135 through the algorithm. Panel (c) sets A0 in light shade, and infected vertices as gridded vertices.",
            "type": "figure"
        },
        "FIGREF6": {
            "text": "FIG. 6.: Panels (a\u2013c) update through the algorithm in Sec. V D after setting A0 to be as in Fig. 5.",
            "type": "figure"
        },
        "FIGREF7": {
            "text": "FIG. 7.: Final steps of the algorithm, as in Fig. 5.",
            "type": "figure"
        },
        "FIGREF8": {
            "text": "FIG. 8.: The size of smallest minimal percolating sets on perfect trees with height 4, with a constant and a nonconstant percolation function F(t).",
            "type": "figure"
        },
        "FIGREF9": {
            "text": "FIG. 9.: Trials done on 10 000 random trees of n nodes, taking the average, and dividing it by n for the fraction of node needed to be initially infected for the model to percolate.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": 1766,
            "venue": "Histoire de l'Academie Royale des Sciences",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": 2017,
            "venue": "Comput. Math. Methods Med.",
            "volume": "2017",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1155/2017/2403851"
                ]
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": 2018,
            "venue": "Complexity",
            "volume": "2018",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1155/2018/9253846"
                ]
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": 2019,
            "venue": "PLoS ONE",
            "volume": "14",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1371/journal.pone.0211245"
                ]
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": 2015,
            "venue": "Epidemics",
            "volume": "10",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.epidem.2014.09.005"
                ]
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": 2015,
            "venue": "Epidemics",
            "volume": "10",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.epidem.2014.09.004"
                ]
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": 2012,
            "venue": "Electr. J. Combinat.",
            "volume": "19",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.37236/2152"
                ]
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": 1979,
            "venue": "J. Phys. C: Solid State Phys.",
            "volume": "12",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1088/0022-3719/12/1/008"
                ]
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": 2003,
            "venue": "Braz. J. Phys.",
            "volume": "33",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1590/S0103-97332003000300031"
                ]
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": 2006,
            "venue": "Probabil. Comput.",
            "volume": "15",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1017/S0963548306007619"
                ]
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": 2014,
            "venue": "Electron. J. Probab.",
            "volume": "19",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1214/EJP.v19-2758"
                ]
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": 1910,
            "venue": "The Prevention of Malaria",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": 2007,
            "venue": "Appl. Math. Comput.",
            "volume": "186",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.amc.2006.06.126"
                ]
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": 2013,
            "venue": "World J. Model. Simul.",
            "volume": "9",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": 2020,
            "venue": "Proc. R. Soc. London A",
            "volume": "476",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1098/rspa.2019.0826"
                ]
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": 2010,
            "venue": "J. Virol.",
            "volume": "84",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1128/JVI.02284-09"
                ]
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": 2009,
            "venue": "Electr. J. Combinat.",
            "volume": "16",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.37236/91"
                ]
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": 2019,
            "venue": "J. Graph Theory",
            "volume": "15",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1002/jgt.22517"
                ]
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": 1927,
            "venue": "Proc. R. Soc. London A",
            "volume": "115",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1098/rspa.1927.0118"
                ]
            }
        },
        "BIBREF19": {
            "title": "",
            "authors": [],
            "year": 2017,
            "venue": "Infect. Dis. Model.",
            "volume": "2",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.idm.2017.02.001"
                ]
            }
        },
        "BIBREF20": {
            "title": "",
            "authors": [],
            "year": 1974,
            "venue": "Ann. Probabil.",
            "volume": "2",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1214/aop/1176996493"
                ]
            }
        },
        "BIBREF21": {
            "title": "",
            "authors": [],
            "year": 2015,
            "venue": "Environ. Res.",
            "volume": "142",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.envres.2015.06.040"
                ]
            }
        },
        "BIBREF22": {
            "title": "",
            "authors": [],
            "year": 2018,
            "venue": "BMC Med.",
            "volume": "16",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1186/s12916-018-1184-6"
                ]
            }
        },
        "BIBREF23": {
            "title": "",
            "authors": [],
            "year": 2009,
            "venue": "BMC Med. Info. Decision Making",
            "volume": "9",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1186/1472-6947-9-39"
                ]
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": 2015,
            "venue": "J. Theor. Biol.",
            "volume": "387",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1016/j.jtbi.2015.09.037"
                ]
            }
        }
    }
}