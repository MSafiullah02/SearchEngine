{
    "paper_id": "4711cf6a76d954e9cb5db71f09f3aabe9b406f6a",
    "metadata": {
        "title": "LinearDesign: Efficient Algorithms for Optimized mRNA Sequence Design",
        "authors": [
            {
                "first": "He",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Baidu Research USA",
                    "location": {
                        "postCode": "94089",
                        "settlement": "Sunnyvale",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Liang",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "affiliation": {},
                "email": ""
            },
            {
                "first": "Ziyu",
                "middle": [],
                "last": "Li",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Oregon State University",
                    "location": {
                        "postCode": "97330",
                        "settlement": "Corvallis",
                        "region": "OR",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Kaibo",
                "middle": [],
                "last": "Liu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Baidu Research USA",
                    "location": {
                        "postCode": "94089",
                        "settlement": "Sunnyvale",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Boxiang",
                "middle": [],
                "last": "Liu",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Baidu Research USA",
                    "location": {
                        "postCode": "94089",
                        "settlement": "Sunnyvale",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "David",
                "middle": [
                    "H"
                ],
                "last": "Mathews",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Baidu Research USA",
                    "location": {
                        "postCode": "94089",
                        "settlement": "Sunnyvale",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Liang",
                "middle": [],
                "last": "Huang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Baidu Research USA",
                    "location": {
                        "postCode": "94089",
                        "settlement": "Sunnyvale",
                        "region": "CA",
                        "country": "USA"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "A messenger RNA (mRNA) vaccine has emerged as a promising direction to combat the current COVID-19 pandemic. This requires an mRNA sequence that is stable and highly productive in protein expression, features which have been shown to benefit from greater mRNA secondary structure folding stability and optimal codon usage. However, sequence design remains a hard problem due to the exponentially many synonymous mRNA sequences that encode the same protein. We show that this design problem can be reduced to a classical problem in formal language theory and computational linguistics that can be solved in O(n 3 ) time, where n is the mRNA sequence length. This algorithm could still be too slow for large n (e.g., n = 3, 822 nucleotides for the spike protein of SARS-CoV-2), so we further developed a linear-time approximate version, Lin-earDesign, inspired by our recent work, LinearFold. This algorithm, LinearDesign, can compute the approximate minimum free energy mRNA sequence for this spike protein in just 16 minutes using beam size b = 1, 000, with only 0.6% loss in free energy change compared to exact search (i.e., b = +\u221e, which costs 1.6 hours). We also develop two algorithms for incorporating the codon optimality into the design, one based on k-best parsing to find alternative sequences and one directly incorporating codon optimality into the dynamic programming. Our work provides efficient computational tools to speed up and improve mRNA vaccine development.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Availability: server: http://rna.baidu.com/lineardesign; code: to be released on GitHub.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "\u2660 These two authors contributed equally.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "To defeat the current COVID-19 pandemic, which has already claimed 100,000+ deaths as of early April, a messenger RNA (mRNA) vaccine has emerged as a promising approach thanks to its rapid and scalable production and non-infectious and non-integrating properties. However, designing an mRNA sequence to achieve high stability and protein production remains a challenging problem. Recently, it is discovered that greater secondary structure folding stability and optimal codon usage synergize to increase protein expression. 1 The design problem can therefore be formulated as finding the mRNA sequence(s) that are good in both secondary structure stability and codon optimality among the exponentially many synonymous sequences that encode the same protein.",
            "cite_spans": [
                {
                    "start": 524,
                    "end": 525,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Each amino acid is translated by a codon, which is 3 adjacent mRNA nucleotides. For example, the start codon AUG translates into methionine, the first amino acid in any protein sequence. But due to redundancies in the genetic code (4 3 = 64 triplet codons for 21 amino acids), most amino acids can be translated from multiple codons. This fact makes the search space of mRNA design increase exponentially with protein length, e.g., for the spike protein of SARS-CoV-2 (the virus that causes the COVID-19 pandemic), which contains 1,273 amino acids (plus the stop codon which is part of the mRNA but not part of a protein), there are about 10 632 mRNA candidates. The mRNA design problem, therefore, aims to exploit the redundancies in the genetic code to find more stable and productive mRNA sequences than the wild type in nature.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our key idea is to show that this design problem can be reduced to a classical notion in formal language theory and computational linguistics, namely the intersection between a Stochastic Context Free Grammar (SCFG) and a Deterministic Finite Automaton (DFA), which dates back to 1961. 2 Here the SCFG represents the folding free energy model and the DFA represents the set of all possible synonymous mRNA sequences that code a given protein. While the use of SCFG in RNA folding is well-known, 3 the use of DFA to encode the mRNA search space and solving the design problem via the intersection of SCFG and DFA are novel. This intersection can be done in O(n 3 ) time, where n is the mRNA sequence length, but it could still be too slow for large n (e.g., n = 3 \u00d7 (1273 + 1) = 3, 822 nucleotides for the spike protein of SARS-CoV-2), so we further developed a linear-time approximate version, LinearDesign, inspired by our recent work, LinearFold. 4 We also develop two algorithms for incorporating the codon optimality into the design, one based on k-best parsing to find alternative sequences and one directly incorporating codon optimality into the dynamic programming.",
            "cite_spans": [
                {
                    "start": 286,
                    "end": 287,
                    "text": "2",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 495,
                    "end": 496,
                    "text": "3",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 949,
                    "end": 950,
                    "text": "4",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "After the completion of our algorithm design and implementation of our Python prototype and C++ code, we became aware of two earlier, independent, papers that tackled the same problem of \"most stable RNA design\" using dynamic programming. 5, 6 The second paper \"CDSfold\" published in 2016 did not cite the first one, published in 2003. Our work is different in three aspects. First, we reduced the mRNA design problem to \"CFG-DFA intersection\", a classical problem in formal language theory and computational linguistics, which is more general and can be applied to other scenarios with alternative inputs, whereas the previous algorithms were ad hoc. Second, we integrated codon optimality in the optimization. Third, we further developed a linear-time approximate version with greatly reduced runtime for long sequences and small sacrifices in search quality.",
            "cite_spans": [
                {
                    "start": 239,
                    "end": 241,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 242,
                    "end": 243,
                    "text": "6",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The mRNA design problem can be formulated as follows: given a protein sequence p = p1 . . . pm where each pi is an amino acid, we search, among all possible mRNA sequences r that translate into protein p, the best mRNA sequence r (p), defined as the sequence that has the structure with minimum folding free energy change: r (p) = argmin r\u2208RNA(p) MFE(r) [1] MFE(r) = min s\u2208structures(r) \u2206G \u2022 (r, s) [2] where RNA(p) = {r | protein(r) = p} is the search space, structures(r) is the set of all possible secondary structure for RNA The thick arrows indicate the best mRNA sequence after intersecting this DFA with the context-free grammar (see Fig. 3 ).",
            "cite_spans": [
                {
                    "start": 354,
                    "end": 357,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 399,
                    "end": 402,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [
                {
                    "start": 641,
                    "end": 647,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "sequence r, and \u2206G \u2022 (r, s) is the free energy change of structure s for RNA r according to an energy model. Note that the mRNA sequence length is n = 3(m + 1) due to the final stop codon, which is not translated into the protein sequence. Next we first show how to represent the exponentially large search space RNA(p) compactly via DFAs, and then discuss how to do this argmin search (over the product of two exponentially large spaces) efficiently via dynamic programming, which can be reduced to the CFG intersection with DFA.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "A. DFA representation for amino acid codons and mRNA search space. In the fields of formal language theory and computational linguistics, the DFA graph is typically used to encode ambiguities in languages. 7 We notice that the ambiguity of codon choice for amino acid is similar as to the language ambiguity problem, and can be represented with a DFA graph too. We first illustrate how to represent the amino acid codons using DFAs.",
            "cite_spans": [
                {
                    "start": 206,
                    "end": 207,
                    "text": "7",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "Informally, a DFA is a directed graph with labeled edges and distinct start and end nodes. For our purpose each edge is labeled by a nucleotide, so that each start-to-end path represents a triplet codon. Formally, a DFA is a 5-tuple Q, \u03a3, \u03b4, q0, F where Q is the set of nodes, \u03a3 is the alphabet (here \u03a3 = {A, C, G, U}), q0 is the start node, F is the set of end nodes (in this work the end node is unique, i.e., |F | = 1), and \u03b4 is the transition function that takes a node q and a symbol a \u2208 \u03a3 and returns the next node q , i.e., \u03b4(q, a) = q encodes a labeled edge q a \u2192 q . Fig. 1 illustrates how DFAs represent 4 different types of amino acids and their codons. All these DFAs have (0, 0) and (3, 0) as their start and end nodes, respectively. Fig. 1A is the DFA representation for methionine, which has only one path. Fig. 1B is the DFA for amino acid valine, whose codon has a choice at the third nucleotide (most amino acids are of this type). Fig. 1C represents the most complex case, serine, leucine, and arginine, which have 6 codons each, and the branching happens at the start node. Fig. 1D is the DFA for the stop codon. It is special because branching happens at the second step, at node (1, 0).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 576,
                    "end": 582,
                    "text": "Fig. 1",
                    "ref_id": null
                },
                {
                    "start": 747,
                    "end": 754,
                    "text": "Fig. 1A",
                    "ref_id": null
                },
                {
                    "start": 822,
                    "end": 829,
                    "text": "Fig. 1B",
                    "ref_id": null
                },
                {
                    "start": 950,
                    "end": 957,
                    "text": "Fig. 1C",
                    "ref_id": null
                },
                {
                    "start": 1094,
                    "end": 1101,
                    "text": "Fig. 1D",
                    "ref_id": null
                }
            ],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "After building DFAs for each amino acid, we can concatenate them into a single DFA D(p) for a protein sequence p, which represents all possible mRNA sequences that translate into that protein",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "by stitching the end node of each DFA with the start node of the next. The new end node of the protein DFA is (3(m + 1), 0). Fig. 2 gives a DFA of the protein sequence \"methionine leucine\".",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 125,
                    "end": 131,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "We also define out_edges(q) to be set of outgoing edges from node q, and in_edges(q) to be the set of incoming edges: ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LinearDesign Algorithms"
        },
        {
            "text": "A stochastic context-free grammar (SCFG) is a context-free grammar in which each rule is augmented with a weight. More formally, an SCFG is a 4-tuple N, \u03a3, P, S 0,0 S 9,0 where N is the set of non-terminals, \u03a3 is the set of terminals (identical to the alphabet in the DFA, in this case {A, C, G, U}), P is the set of weight-associated context-free writing rules, and S \u2208 N is the start symbol. Each rule in P has the form A w \u2192 (N \u222a \u03a3) * where A \u2208 N is a non-terminal that can be rewritten according to this rule into a sequence of non-terminals and terminals ( * means repeating zero or more times) and w \u2208 R is the weight associated with this rule.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. CFG intersection with DFA."
        },
        {
            "text": "SCFGs are used to represent RNA folding. The weight of a derivation (parse tree, or a secondary structure in this case) is the sum of weights of the productions used in that derivation. 3 For example, for the very simple Nussinov-Jacobson model 8 (which simplifies the energy model to the number of base pairs), we can define this SCFG G:",
            "cite_spans": [
                {
                    "start": 186,
                    "end": 187,
                    "text": "3",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "B. CFG intersection with DFA."
        },
        {
            "text": "Here the first line is the bifurcating case, the second line is the base-pairing case (with weight \u22121, and the negative score mirrors the free energy minimization problem), and the third line is the unpaired cases (note S 0 \u2192 N N N makes sure the minimum hairpin length is 3, i.e., no sharp turn is allowed).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "B. CFG intersection with DFA."
        },
        {
            "text": "The standard RNA secondary structure prediction problem under a Nussinov model can be cast a parsing problem: given the above SCFG G and an input RNA sequence, what is the minimum-weight derivation in G that can generate sequence? For example, for input CCAAAGG, the best derivation is showed in Fig. 4 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 296,
                    "end": 302,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "B. CFG intersection with DFA."
        },
        {
            "text": "The mRNA design problem is now a simple extension of the above single-sequence folding problem to the case of multiple inputs: instead of finding the minimum energy structure (minimum weight derivation) for a given sequence, we find the minimum energy structure (and its corresponding sequence) among all possible structures for all possible sequences. This can be solved by intersecting the SCFG G on the protein DFA D, which results in a bigger SCFG and find the best derivation in G . 2, 9 In the intersected grammar G , each nonterminal has the form q1Aq2, where A \u2208 N is an original nonterminal in G and q1 and q2 are two nodes in D; and the new start symbol is q0Sqn where S is the original start symbol in G and q0 and qn are the start and end nodes in D. The bifurcation rule S 0 \u2192 S S will become q1Sq3 0 \u2192 q1Sq2 q2Sq3 for all (q1, q2, q3) node triplets in D. We can see that this intersection construction generalizes the widely-used CKY algorithm 10, 11, 12 where the triple of states (q1, q2, q3) generalizes the triple of string indices (i, k, j). The CKY algorithm is a special case of intersection when the DFA only encodes one string, e.g., when the protein is made of amino acids that have only one codon (methionion and tryptophan). Similarly, in computational linguistics, this intersection construction is widely used for word-lattice parsing in speech recognition where the word-lattice is a DFA to account for ambiguity in word identity. 13 The terminal rule N 0 \u2192 A will become",
            "cite_spans": [
                {
                    "start": 488,
                    "end": 490,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 491,
                    "end": 492,
                    "text": "9",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 958,
                    "end": 961,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 962,
                    "end": 965,
                    "text": "11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 966,
                    "end": 968,
                    "text": "12",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1460,
                    "end": 1462,
                    "text": "13",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [],
            "section": "B. CFG intersection with DFA."
        },
        {
            "text": "This intersected grammar G will have N |Q| 2 nonterminals and P |Q| 3 rules in the worst case (|Q| is the number of nodes in D). This resembles the space and time complexities of the CKY algorithm for i = 0 . . . (n \u2212 l) do 13: j \u2190 i + l 14: for each qi \u2208 nodes(D, i) do 15: for each qj \u2208 nodes(D, j) do 16: if j \u2212 i > 4 then pairing (no sharp turn) 17: for each (qi+1, nuci) \u2208 out_edges(D, qi) do 18: for each (qj\u22121, nucj\u22121) \u2208 in_edges(D, qj) do 19: if match(nuci, nucj\u22121) then 20:",
            "cite_spans": [
                {
                    "start": 224,
                    "end": 227,
                    "text": "13:",
                    "ref_id": null
                },
                {
                    "start": 238,
                    "end": 241,
                    "text": "14:",
                    "ref_id": null
                },
                {
                    "start": 271,
                    "end": 274,
                    "text": "15:",
                    "ref_id": null
                },
                {
                    "start": 304,
                    "end": 307,
                    "text": "16:",
                    "ref_id": null
                },
                {
                    "start": 350,
                    "end": 353,
                    "text": "17:",
                    "ref_id": null
                },
                {
                    "start": 398,
                    "end": 401,
                    "text": "18:",
                    "ref_id": null
                },
                {
                    "start": 447,
                    "end": 450,
                    "text": "19:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "B. CFG intersection with DFA."
        },
        {
            "text": "UPDATE(qi, qj, score, (nuci, qi+1, qj\u22121, nucj\u22121)) 22: for k = (i + 1) . . . (j \u2212 1) do bifurcation 23: for each q k \u2208 nodes(D, k) do (where |Q| = n). Indeed, intersection is a generalization of CKY from fixed input (RNA folding) to lattice input (mRNA design). Now we just need to find the best (minimum weight) derivation in G , from which we can read off the best mRNA sequence and its corresponding structure. Fig. 3 shows one of the best derivations for the DFA in Fig. 2 .",
            "cite_spans": [
                {
                    "start": 50,
                    "end": 53,
                    "text": "22:",
                    "ref_id": null
                },
                {
                    "start": 99,
                    "end": 102,
                    "text": "23:",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 413,
                    "end": 419,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 469,
                    "end": 475,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "21:"
        },
        {
            "text": "C. Bottom-up dynamic programming on Nussinov model. We describe how to do dynamic programming based on CFG intersection with DFA. First, we use bottom-up dynamic programming on the Nussinov-Jacobson energy model as an introduction. Fig. 5 gives the pseudocode for this simplified version. We first build up the given protein's DFA graph, and initialize two hash tables, best to store the best score for each state, and back to store the best backpointer for each state. The base cases (singleton rule) are best[qi, qi+1] \u2190 0 and back[qi, qi+1] \u2190 nuci for each state (qi, qi+1), where nuci is the edge between qi and qi+1. Next, for each state (qi, qj) it goes through the pairing rule and bifurcation rules, and updates if a better score is found. After filling out the hash tables bottom-up, we can backtrace the best mRNA sequence stored with the backpointers. See The algorithm based on bottom-up dynamic programming runs in cubic time, however, it is still slow for long sequences. Inspired by our previous work, LinearFold, 4 we further developed a linear-time 1: function LINEARDESIGN(p, b) b is beam size 11: for j = 1 . . . n do 12: for each qj\u22121 \u2208 nodes(D, j \u2212 1) do 13: for each qi such that [qi, qj\u22121] \u2208 best do 14: for each (qj, nucj\u22121) \u2208 out_edges(D, qj\u22121) do 15: backpointer \u2190 (qj\u22121, nucj\u22121) 16 :",
            "cite_spans": [
                {
                    "start": 1029,
                    "end": 1030,
                    "text": "4",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1066,
                    "end": 1068,
                    "text": "1:",
                    "ref_id": null
                },
                {
                    "start": 1112,
                    "end": 1115,
                    "text": "11:",
                    "ref_id": null
                },
                {
                    "start": 1137,
                    "end": 1140,
                    "text": "12:",
                    "ref_id": null
                },
                {
                    "start": 1176,
                    "end": 1179,
                    "text": "13:",
                    "ref_id": null
                },
                {
                    "start": 1223,
                    "end": 1226,
                    "text": "14:",
                    "ref_id": null
                },
                {
                    "start": 1273,
                    "end": 1276,
                    "text": "15:",
                    "ref_id": null
                },
                {
                    "start": 1306,
                    "end": 1308,
                    "text": "16",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [
                {
                    "start": 232,
                    "end": 238,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1069,
                    "end": 1096,
                    "text": "function LINEARDESIGN(p, b)",
                    "ref_id": null
                }
            ],
            "section": "21:"
        },
        {
            "text": "if j \u2212 (i \u2212 1) > 4 then 18: for each (qi\u22121, nuci\u22121) \u2208 in_edges(D, qi) do 19 : approximation algorithm for mRNA design. We apply beam pruning, 14 a classical pruning technique, to significantly narrow down the search space without sacrificing too much search quality. Fig. 6 gives the pseudocode of simplified LinearDesign algorithm for the Nussinov model, based on left-to-right dynamic programming and beam pruning. LinearDesign replaces bottom-up dynamic programming with a left-to-right parsing. At each step j (the jth position of mRNA sequence), we only keep the top b states with the lowest free energy and prune out the less promissing states, since they are unlikely to be the optimal sequence. Here b, the beam size, is a user-adjustable parameter to balance runtime and search quality. This approximation leads to a significant runtime reduce from O(n 3 ) to O(nb 2 ). Notice that we use b = 100 as default in LinearFold, 4 but in LinearDesign we usually use a larger b because the search space is much larger.",
            "cite_spans": [
                {
                    "start": 24,
                    "end": 27,
                    "text": "18:",
                    "ref_id": null
                },
                {
                    "start": 73,
                    "end": 75,
                    "text": "19",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 142,
                    "end": 144,
                    "text": "14",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [
                {
                    "start": 267,
                    "end": 273,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF6"
                }
            ],
            "section": "21:"
        },
        {
            "text": "E. Implementation on Turner model. Our real system uses a leftto-right dynamic programming with beam pruning on the Turner nearest neighbor free energy model. 15, 16 We implement the thermodynamic parameters following Vienna RNAfold, 17 except for the dangling ends and special hairpins. Dangling ends refer to stabilizing interactions for multiloops and external loops, which require knowledge of the nucleotide sequence outside of the state (qi, qj). Though it could be integrated in LinearDesign, the implementation becomes more involved. Special hairpins are hairpin loop sequences of length 3, 4, or 6 unpaired nucleotides with folding free energies stored in lookup tables, rather than estimated from features like other sequences. Special hairpins can be also integrated in LinearDesign with some preprocessing. We will include both dangling end and special hairpin stabilities in future versions.",
            "cite_spans": [
                {
                    "start": 159,
                    "end": 162,
                    "text": "15,",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 163,
                    "end": 165,
                    "text": "16",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "21:"
        },
        {
            "text": "Since CAI is also important for mRNA functional half life, 1 ",
            "cite_spans": [
                {
                    "start": 59,
                    "end": 60,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "where m is the protein length, logwi(r) is the measurement of deviation from the optimal codon (0 is optimal) for the ith amino acid (given an mRNA candidate), and \u03bb is a hyperparameter that balances MFE and CAI.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "We integrate this equation into LinearDesign dynamic process, i.e., each DFA graph's edge will have a cost so that the combined cost of traversing a local path (choosing a codon) equals logwi. Each edge cost is the \"best\" of the paths (i.e., codons) that uses this edge. with their CAI, each has a corresponding path in the DFA graph (see Fig. 7B ). For example, codon UCU has a CAI of 0.18, while the best codon AGC has a CAI of 0.24. The edge costs in \"UCU path\" are 0, 0, log(0.18/0.24) = \u22120.29, therefore, logwi of UCU is -0.29. The best codon AGC has a logwi of 0, meaning that choosing AGC would not have a cost.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 339,
                    "end": 346,
                    "text": "Fig. 7B",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "Considering LinearDesign is doing left-to-right dynamic programming with beam pruning, and at each step j states with lower scores are pruned, it is better to incur edge costs as early as possible in a path, which ensures the states with better CAI paths are more likely to survive in each step. Fig. 7C rearranges the edge cost to fit better for LinearDesign. Note that different edge costs in Fig. 7B and C would not affect exact search.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 296,
                    "end": 303,
                    "text": "Fig. 7C",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 395,
                    "end": 402,
                    "text": "Fig. 7B",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "G. The top k best mRNA candidates. An alternative solution for finding mRNA candidates with both stable secondary structure and high CAI is to provide the top k mRNA candidates with the lowest MFE, and post-process them by features such as CAI. Although this is not as principled as the algorithm described in subsection 2F, this solution is easier to implement, and is more flexible in the sense that users are free to add other customized filters.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "Inspired by the k-best parsing algorithm, 18 we developed an efficient algorithm to find suboptimal candidates in a sorted order. During the dynamic programming process (forward-phase), instead of just saving the single best prestate as the backpointer for each state, we store alternative prestates that all transit to this state. Then in the backtrace process (backforward-phase), starting from the last state, we query the second best. The answer is one of the two cases: (1) the second best is from another prestate S1; or (2) the second best is from the same prestate S0. In the former case we can find the second best by backtracing the best path going through prestate S1, while in the latter case we keep querying for the second best from the prestate S0. Recursively, we would compute and get as many solutions as needed.",
            "cite_spans": [
                {
                    "start": 42,
                    "end": 44,
                    "text": "18",
                    "ref_id": "BIBREF17"
                }
            ],
            "ref_spans": [],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "To our knowledge, our algorithm is the first one to output suboptimal results in the mRNA design problem. Two previous algorithms explored searching suboptimal secondary structure for RNA folding problem. 19, 20, 21 Zuker's algorithm is to find diverse suboptimal secondary structures, and Wuchty's algorithm is to find all secondary structures in a given free energy gap. Our algorithm is different from these two in the sense that: (1) ours is for mRNA design problem; and (2) ours can output all top k best candidates in a sorted order.",
            "cite_spans": [
                {
                    "start": 205,
                    "end": 208,
                    "text": "19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 209,
                    "end": 212,
                    "text": "20,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 213,
                    "end": 215,
                    "text": "21",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "Combining the k-best algorithm and linearization, LinearDesign is able to quickly design a large set of mRNA candidates, which provide a set of alternative designs for follow up with wet lab experiments.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "F. MFE and CAI joint optimization."
        },
        {
            "text": "Some studies have shown that protein translation level will drop if the 5'-end leader region has more secondary structure. 22, 23, 24, 25, 1 Considering this practical issue, LinearDesign can be used to design an ORF with an absence of base pairing in the 5'-end leader region by utilizing a simple strategy.",
            "cite_spans": [
                {
                    "start": 123,
                    "end": 126,
                    "text": "22,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 127,
                    "end": 130,
                    "text": "23,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 131,
                    "end": 134,
                    "text": "24,",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 135,
                    "end": 138,
                    "text": "25,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 139,
                    "end": 140,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "H. Less secondary structure at 5'-end leader region."
        },
        {
            "text": "Instead of designing the most stable sequence for the whole coding region, we leave the 5'-end leader region (e.g., the first 15 nt) unchanged from the wildtype, since the wildtype usually has less structure in this region. Then we use LinearDesign for the rest of the coding region. Because the designed region will be composed of strong base pairs (generally maximizing GC content), it is unlikely for a global structure change when concatenating with the wildtype 5'-end head region, which we observe is often depleted of GC content. Refolding using secondary structure prediction tools for the concatenated sequence, we get its corresponding secondary structure and observe that the first 15 nucleotides are unpaired.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "H. Less secondary structure at 5'-end leader region."
        },
        {
            "text": "If a wildtype sequence is not available, we can alternatively enumerate all possible sequences in the 5'-end leader region. Because each amino acid has 3 codons on average and the start codon is fixed, the enumeration space of the first 15 nt in the 5'-end region is small (3 4 = 81), which makes the enumeration feasible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "H. Less secondary structure at 5'-end leader region."
        },
        {
            "text": "A. Efficiency and scalability. To estimate the run-time complexity of LinearDesign, we use 100 protein sequences from Uniprot 26 following CDSfold, with length from 78 to 2,828 nt (not including the stop codon). We found that there are three sequences whose lengths reported in CDSfold do not match the ones currently in Uniprot, so we removed these sequences, resulting in a dataset with 97 diverse protein sequences.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "We compared LinearDesign in exact (infinite beam size) and approximate modes (beam size b = 1, 000 and b = 100). Because CDSfold code is not currently available, we directly use the runtime reported in CDSfold paper as a comparison allowing us to compare the computational complexity. Note that CDSfold results and our results were run in different machines. We run LinearDesign on a machine with 2 Intel Xeon E5-2660 v3 CPUs (2.60 GHz), while CDSfold is run on the Chimera cluster system at AIST, which was reported in the paper as 176 Intel Xeon E5550 CPUs (2.53 GHz). B. Search quality of linear-time approximation. Since the Lin-earDesign algorithm is significantly faster than its exact counterpart, we envision that the LinearDesign algorithm will be used for long sequences. To ensure the quality of the approximation used in Lin-earDesign (with beam pruning mode), we compared the energy gap between the exact (b = \u221e) and approximate algorithm (b = 1, 000).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "For this analysis, we used the same dataset as in subsection 3A. Fig. 9 represents the folding free energy differences between the exact search and approximation. Fig. 9A compares the free energy changes of the mRNA sequences designed with exact search and with the b = 1, 000 approximation. The x-axis is the free energy of exact search, while the y-axis corresponds to the free energy of approximation. We see that all plots are on or close to the diagonal, which confirms that the folding free energy differences are 0 or small. Fig. 9B shows the trend of free energy differences increases linearly with mRNA sequence length. They y-axis is the percentage of free energy change gap, which is the free energy change gap (\u2206\u2206G \u2022 ) divided by the total free energy change of the MFE structure (\u2206G \u2022 ). The percentage of free energy change gap is small for all sequences in the dataset. For b = 1, 000, all sequences have gaps within 1%. Even for the longest sequence (8,484 nt), the gap is 0.8%. For b = 100, most gaps are within 5%, and the largest gap is 7%. We also investigate the percentage of free energy change gap against beam size for two specific protein sequences, the spike protein of SARS-CoV-2 and EGFP (GenBank KM042177.1), in Fig. 9C . The purple curve shows the result of the spike protein. Starting with a small beam size, b = 20, the gap is 10.6%. With increasing beam size, the gap shrinks quickly to less than 6% at b = 100. Further increasing b up to 500, the gap drops to 1%. With a beam size of b = 2, 000 the gap drops to 0, which indicates that the approximate result is the same as the exact search. The EGFP result (the green curve) has the same shape as the spike protein, but the gap drops faster and down to less than 2% at b = 100. This is because EGFP is shorter (239 amino acids), thus the approximation is close to the exact result even with smaller beam size. At b = 200, the gap increases 0.25% compared with b = 100. This happens because more states are kept when enlarging the beam size, among which states with higher scores at length j survive. Their extension to longer lengths (like offspring) beat states and fill the beams, but all these states become worse at the end, resulting a small drop of the search quality. The fluctuation happens in this sequence, but the jump is small and the gap quickly decreases to 0 at b = 400 and above.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 65,
                    "end": 71,
                    "text": "Fig. 9",
                    "ref_id": null
                },
                {
                    "start": 163,
                    "end": 170,
                    "text": "Fig. 9A",
                    "ref_id": null
                },
                {
                    "start": 532,
                    "end": 539,
                    "text": "Fig. 9B",
                    "ref_id": null
                },
                {
                    "start": 1241,
                    "end": 1248,
                    "text": "Fig. 9C",
                    "ref_id": null
                }
            ],
            "section": "Results"
        },
        {
            "text": "C. Example for the coding mRNA of the spike protein. The spike protein of SARS-CoV-2, which has 1,273 amino acid residues, is the target of mRNA vaccines (https://clinicaltrials. gov/ct2/show/NCT04283461).Therefore, we use the spike protein of SARS-CoV-2 as an example, and compare our designed sequences with the wildtype sequence and random generated sequences.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Results"
        },
        {
            "text": "We use the mRNA sequence from the reference genome of SARS-CoV-2 (https://www.ncbi.nlm.nih.gov/nuccore/ MN908947) as the wildtype sequence, which contains 3,822 nucleotides (including the stop codon). Additionally, we use two different strategies to generate random sequences (5,000 sequences for each strategy) as another baseline. One of the two strategies, named \"pure random\", is to randomly (with equal probabilities) choose a codon for each amino acid in the spike protein, and form a mRNA sequence by concatenation. The other strategy, called \"codon-biased random\", is to choose a codon the probability proportional to its usage frequency. We also run LinearDesign (in both exact mode and approximation mode) to evaluate the best sequences we can achieve. Since previous studies show that both the folding free energy change of mRNA secondary structure and codon optimality influence the vaccine effectiveness, 1 we do a two-dimensional comparison, MFE and codon adaptation index (CAI), 27 between mRNA sequences. Fig. 10 shows the results. The wildtype sequence, denoted in a red circle, folds into a structure with the minimum free energy change of -967.80 kcal/mol, and has a low CAI of 0.655. Most \"pure random\" sequences, denoted in blue cloud, have similar free energy changes (-987.90 kcal/mol on average) as the wildtype, but with higher CAI (0.671 on average). This may be because SARS-CoV-2 just recently infected human cells and does not have enough mutations to optimize for human codons. Compared with the wildtype and \"pure random\" sequences, \"codon-biased random\" sequences, denoted in A UCUU 1,000 Fig. 11 . The secondary structures of the wildtype and designed mRNA sequences that translate into the spike protein of SARS-CoV-2. A: Wildtype sequence and its secondary structure. B: The best mRNA sequence (with lowest free energy change) designed by LinearDesign with b = 1, 000. C: The best mRNA sequence designed by LinearDesign with b = +\u221e, i.e. an exact search. D: A zoom in of C showing the 5'-end, which is base paired with the 3' end. E: The best mRNA sequence designed by LinearDesign with b = +\u221e, while using the wildtype sequence for the first 15 nt nucleotide at 5'-end. These 15 nucleotides do not base pair with the designed sequence and therefore remain unstructured. F: A zoom in of E showing just the 5'-end and the 3' end.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1021,
                    "end": 1028,
                    "text": "Fig. 10",
                    "ref_id": "FIGREF11"
                },
                {
                    "start": 1621,
                    "end": 1628,
                    "text": "Fig. 11",
                    "ref_id": null
                }
            ],
            "section": "Results"
        },
        {
            "text": "orange cloud, have much higher CAI (0.768 on average), and slight improvement on MFE (-1063.23 kcal/mol on average). We also notice that both \"pure random\" and \"codon-biased random\" sequences are packed in cloud-shaped small regions. This is because the search space of possible mRNAs is extremely huge and most of the random sequences have similar MFE and CAI. On the left (with much lower MFE) we plot our designed sequences. The blue plots are optimized by MFE only. The leftmost one is the sequence designed in exact search mode, which has the lowest MFE of -2,477.70 kcal/mol and a CAI of 0.726. The MFE gap between our best designed sequence and the wildtype, as well as random sequences, is large (more than 1,300 kcal/mol). With only 0.56% MFE loss from the exact search sequence, the designed sequence with beam size b = 1, 000 achieves an MFE of -2,463.8 kcal/mol and a higher CAI of 0.751. Compared to the exact mode, which takes 1.6 hours for designing the sequence, the approximation with b = 1, 000 only takes 16 minites, resulting in a 6\u00d7 speed-up. For b = 100 and b = 20, the MFE are still lower than -2,200 kcal/mol, with CAI both at around 0.735 and 0.725, respectively. Our designed sequences, for both exact search sequence and approximate search sequences, are much better than random ones and the wildtype in terms of MFE.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "U C C A G A UC G A C C GG C U C A U C A CU G G U C G C C UC C A GA G U U U G C A G A C G U A C G U A AC U C A G C A G C U C A U"
        },
        {
            "text": "We show that the top 10, 000, 000 suboptimal sequences for exact mode (the dark-red cloud on the right of exact design sequence). The MFE of the sequences are very close to the optimal one, and the free energy gaps are within 20 kcal/mol. Some of the sequences have higher CAI, e.g., some have the CAI higher than 0.730. This shows that our k best algorithm can be used to select sequences with low MFE and relative higher CAI as vaccine candidates.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "U C C A G A UC G A C C GG C U C A U C A CU G G U C G C C UC C A GA G U U U G C A G A C G U A C G U A AC U C A G C A G C U C A U"
        },
        {
            "text": "Further, we show the results of MFE and CAI joint optimization.The light-blue curve is joint optimization design using exact mode. Each point on the curve is with a different \u03bb, which balances the importance of MFE and CAI. We see that the curve is on the topleft of the figure, indicating that the sequences on the curve have both stable secondary structures and higher CAI. In fact, this curve is the accessible boundary of all possible sequences, i.e., no sequences can achieve the region beyond (to the top-left) the curve. The points on the curve are good candidates for an mRNA vaccine. For example, the point with \u03bb = 100, has the free energy change of -2,414.6 kcal/mol and CAI of 0.823, which is only 2.5% away from the optimal MFE sequence but with 0.097 increase in CAI. We observe that with \u03bb > 100, the sequences on the curve have better CAI than codon-biased random sequences. Shifting right from the light-blue curve with a small margin, the magenta curve is the results of joint optimization using b = 1, 000. This curve shows that the approximation quality is good with b = 1, 000. We also designed a CAI-greedy sequence, which greedily chooses the best codon for each amino acid, leading to a special sequence with CAI=1. We see that the two curves both point to the CAI-greedy design, comfirming that the designed sequences achieve better CAI but sacrifice MFE with increasing \u03bb, and reach CAI-greedy design with a large \u03bb (e.g., \u03bb = 3, 000).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "U C C A G A UC G A C C GG C U C A U C A CU G G U C G C C UC C A GA G U U U G C A G A C G U A C G U A AC U C A G C A G C U C A U"
        },
        {
            "text": "Note that the MFE of the wildtype, the CAI-greedy design and random sequences are calculated by Vienna RNAfold 17 with \"-d0\" (disable stabilizing interactions for multiloops and external loops), to make fair comparisons with our designed sequences. All the sequences can be refolded using RNAfold without \"-d0\", by which the points will shift to the left. Figure 11 shows the secondary structures of the wildtype sequences, our designed sequences with b = 1, 000 and b = +\u221e, as well as designed sequences with less structures at the 5'-end leader region. We can see that the secondary structures of the wildtype (Fig. 11A) have a large number of loops, and our designed sequences ( Fig. 11B and C) have longer helices and fewer loops, which makes the structure more stable. The designed sequence with b = 1, 000 (Fig. 11B) has similar free energy changes as the one with b = +\u221e (Fig. 11C) , but it has a multiloop in the middle.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 356,
                    "end": 365,
                    "text": "Figure 11",
                    "ref_id": null
                },
                {
                    "start": 612,
                    "end": 622,
                    "text": "(Fig. 11A)",
                    "ref_id": null
                },
                {
                    "start": 682,
                    "end": 697,
                    "text": "Fig. 11B and C)",
                    "ref_id": null
                },
                {
                    "start": 812,
                    "end": 822,
                    "text": "(Fig. 11B)",
                    "ref_id": null
                },
                {
                    "start": 878,
                    "end": 888,
                    "text": "(Fig. 11C)",
                    "ref_id": null
                }
            ],
            "section": "U C C A G A UC G A C C GG C U C A U C A CU G G U C G C C UC C A GA G U U U G C A G A C G U A C G U A AC U C A G C A G C U C A U"
        },
        {
            "text": "Additionally, we investigate the effectiveness of our strategy for less structure design at the 5'-end leader region. Fig. 11E is the whole secondary structure of the designed sequence with the goal of leaving the 5' end unpaired (the first 15 nucleotides kept identical to the wildtype and the remaining nucleotides designed by LinearDesign), and we zoom in the 5'-end in Fig. 11F . As a comparison, we also zoom in the 5'-end of designed sequence without constraint in Fig. 11D . This demonstrates our strategy can keep the 5' end unstructured, whereas designing the complete sequence results in basepairing at the 5' end.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 118,
                    "end": 126,
                    "text": "Fig. 11E",
                    "ref_id": null
                },
                {
                    "start": 373,
                    "end": 381,
                    "text": "Fig. 11F",
                    "ref_id": null
                },
                {
                    "start": 471,
                    "end": 479,
                    "text": "Fig. 11D",
                    "ref_id": null
                }
            ],
            "section": "U C C A G A UC G A C C GG C U C A U C A CU G G U C G C C UC C A GA G U U U G C A G A C G U A C G U A AC U C A G C A G C U C A U"
        },
        {
            "text": "The mRNA design problem is of utmost importance, especially for mRNA vaccines during the current COVID-19 pandemic. We reduced this problem into a classical problem in formal language theory and computational linguistics, namely the intersection of a CFG (encoding the energy model) with a DFA (encoding the mRNA search space). This reduction provides a natural O(n 3 )-time CKY-style bottom-up algorithm, where n is the mRNA sequence length, but this algorithm might still be too slow for long proteins such as the spike protein of SARS-CoV-2, a promising candidate for an mRNA vaccine. Inspired by our recent work of LinearFold, we then developed a left-to-right algorithm, LinearDesign, which employs beam search to reduce the runtime to O(n), with the cost of exact search. LinearDesign is orders of magnitude faster than exact search (i.e., b = +\u221e) and suffers only a small loss in folding free energy. For example, for this spike protein, LinearDesign can finish in 16 minutes while exact search takes 1.6 hours, and the free energy difference is only 0.6%. We also developed two algorithms for incorporating codon optimality (CAI) into the consideration, one using k-best algorithms to compute suboptimal sequences and one directly integrating CAI into dynamic programming. Our work provides efficient computational tools to speed up and improve mRNA vaccine development.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Discussion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "mRNA structure regulates protein expression through changes in functional half-life",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "Joseph",
                    "middle": [],
                    "last": "Mauger",
                    "suffix": ""
                },
                {
                    "first": "Vladimir",
                    "middle": [],
                    "last": "Cabral",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Presnyak",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Stephen",
                    "suffix": ""
                },
                {
                    "first": "David",
                    "middle": [
                        "W"
                    ],
                    "last": "Su",
                    "suffix": ""
                },
                {
                    "first": "Brooke",
                    "middle": [],
                    "last": "Reid",
                    "suffix": ""
                },
                {
                    "first": "Kristian",
                    "middle": [],
                    "last": "Goodman",
                    "suffix": ""
                },
                {
                    "first": "Nikhil",
                    "middle": [],
                    "last": "Link",
                    "suffix": ""
                },
                {
                    "first": "John",
                    "middle": [],
                    "last": "Khatwani",
                    "suffix": ""
                },
                {
                    "first": "Melissa",
                    "middle": [
                        "J"
                    ],
                    "last": "Reynders",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Moore",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the National Academy of Sciences U.S.A",
            "volume": "116",
            "issn": "48",
            "pages": "24075--24083",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "On formal properties of simple phrase structure grammars. Zeitschrift f\u00fcr Phonetik",
            "authors": [
                {
                    "first": "Yehoshua",
                    "middle": [],
                    "last": "Bar-Hillel",
                    "suffix": ""
                },
                {
                    "first": "Micha",
                    "middle": [],
                    "last": "Perles",
                    "suffix": ""
                },
                {
                    "first": "Eli",
                    "middle": [],
                    "last": "Shamir",
                    "suffix": ""
                }
            ],
            "year": 1961,
            "venue": "Sprachwissenschaft und Kommunikationsforschung",
            "volume": "14",
            "issn": "2",
            "pages": "143--172",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "The four ingredients of single-sequence RNA secondary structure prediction. a unifying perspective",
            "authors": [
                {
                    "first": "Elena",
                    "middle": [],
                    "last": "Rivas",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "RNA Biology",
            "volume": "10",
            "issn": "7",
            "pages": "1185--1196",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "LinearFold: linear-time approximate RNA folding by 5'-to-3' dynamic programming and beam search",
            "authors": [
                {
                    "first": "Liang",
                    "middle": [],
                    "last": "Huang",
                    "suffix": ""
                },
                {
                    "first": "He",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Dezhong",
                    "middle": [],
                    "last": "Deng",
                    "suffix": ""
                },
                {
                    "first": "Kai",
                    "middle": [],
                    "last": "Zhao",
                    "suffix": ""
                },
                {
                    "first": "Kaibo",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "David H",
                    "middle": [],
                    "last": "Hendrix",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Mathews",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Bioinformatics",
            "volume": "35",
            "issn": "14",
            "pages": "295--304",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Natural selection and algorithmic design of mRNA",
            "authors": [
                {
                    "first": "Barry",
                    "middle": [],
                    "last": "Cohen",
                    "suffix": ""
                },
                {
                    "first": "Steven",
                    "middle": [],
                    "last": "Skiena",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Journal of Computational Biology",
            "volume": "10",
            "issn": "3-4",
            "pages": "419--432",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "CDSfold: an algorithm for designing a proteincoding sequence with the most stable secondary structure",
            "authors": [],
            "year": 2016,
            "venue": "Bioinformatics",
            "volume": "32",
            "issn": "6",
            "pages": "828--834",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Introduction to Automata Theory, Languages, and Computation",
            "authors": [
                {
                    "first": "John",
                    "middle": [
                        "E"
                    ],
                    "last": "Hopcroft",
                    "suffix": ""
                },
                {
                    "first": "Rajeev",
                    "middle": [],
                    "last": "Motwani",
                    "suffix": ""
                },
                {
                    "first": "Jeffrey",
                    "middle": [
                        "D"
                    ],
                    "last": "Ullman",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Fast algorithm for predicting the secondary structure of single-stranded RNA",
            "authors": [
                {
                    "first": "Ruth",
                    "middle": [],
                    "last": "Nussinov",
                    "suffix": ""
                },
                {
                    "first": "Ann",
                    "middle": [
                        "B"
                    ],
                    "last": "Jacobson",
                    "suffix": ""
                }
            ],
            "year": 1980,
            "venue": "Proceedings of the National Academy of Sciences U.S.A",
            "volume": "77",
            "issn": "11",
            "pages": "6309--6313",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Probabilistic parsing as intersection",
            "authors": [
                {
                    "first": "Jan",
                    "middle": [],
                    "last": "Mark",
                    "suffix": ""
                },
                {
                    "first": "Giorgio",
                    "middle": [],
                    "last": "Nederhof",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Satta",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Proceedings of the Eighth International Conference on Parsing Technologies",
            "volume": "",
            "issn": "",
            "pages": "137--148",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "An efficient recognition and syntax-analysis algorithm for context-free languages",
            "authors": [
                {
                    "first": "Tadao",
                    "middle": [],
                    "last": "Kasami",
                    "suffix": ""
                }
            ],
            "year": 1966,
            "venue": "Coordinated Science Laboratory Report",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Recognition and parsing of context-free languages in time n 3",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Daniel",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Younger",
                    "suffix": ""
                }
            ],
            "year": 1967,
            "venue": "Information and control",
            "volume": "10",
            "issn": "2",
            "pages": "189--208",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids",
            "authors": [
                {
                    "first": "Richard",
                    "middle": [],
                    "last": "Durbin",
                    "suffix": ""
                },
                {
                    "first": "Sean",
                    "middle": [
                        "R"
                    ],
                    "last": "Eddy",
                    "suffix": ""
                },
                {
                    "first": "Anders",
                    "middle": [],
                    "last": "Krogh",
                    "suffix": ""
                },
                {
                    "first": "Graeme",
                    "middle": [],
                    "last": "Mitchison",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "An efficient word lattice parsing algorithm for continuous speech recognition",
            "authors": [
                {
                    "first": "Masaru",
                    "middle": [],
                    "last": "Tomita",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "ICASSP'86. IEEE International Conference on Acoustics, Speech, and Signal Processing",
            "volume": "11",
            "issn": "",
            "pages": "1569--1572",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Structured perceptron with inexact search",
            "authors": [
                {
                    "first": "Liang",
                    "middle": [],
                    "last": "Huang",
                    "suffix": ""
                },
                {
                    "first": "Suphan",
                    "middle": [],
                    "last": "Fayong",
                    "suffix": ""
                },
                {
                    "first": "Yang",
                    "middle": [],
                    "last": "Guo",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies",
            "volume": "",
            "issn": "",
            "pages": "142--151",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Expanded sequence dependence of thermodynamic parameters improves prediction of RNA secondary structure",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "Jeffrey",
                    "middle": [],
                    "last": "Mathews",
                    "suffix": ""
                },
                {
                    "first": "Michael",
                    "middle": [],
                    "last": "Sabina",
                    "suffix": ""
                },
                {
                    "first": "Douglas H",
                    "middle": [],
                    "last": "Zuker",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Turner",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Journal of Molecular Biology",
            "volume": "288",
            "issn": "5",
            "pages": "911--940",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Incorporating chemical modification constraints into a dynamic programming algorithm for prediction of RNA secondary structure",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "Matthew",
                    "middle": [
                        "D"
                    ],
                    "last": "Mathews",
                    "suffix": ""
                },
                {
                    "first": "Jessica",
                    "middle": [
                        "L"
                    ],
                    "last": "Disney",
                    "suffix": ""
                },
                {
                    "first": "Susan",
                    "middle": [
                        "J"
                    ],
                    "last": "Childs",
                    "suffix": ""
                },
                {
                    "first": "Michael",
                    "middle": [],
                    "last": "Schroeder",
                    "suffix": ""
                },
                {
                    "first": "Douglas",
                    "middle": [
                        "H"
                    ],
                    "last": "Zuker",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Turner",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "Proceedings of the National Academy of Sciences U.S.A",
            "volume": "101",
            "issn": "19",
            "pages": "7287--7292",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "ViennaRNA package 2.0",
            "authors": [
                {
                    "first": "Ronny",
                    "middle": [],
                    "last": "Lorenz",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Stephan",
                    "suffix": ""
                },
                {
                    "first": "Christian",
                    "middle": [],
                    "last": "Bernhart",
                    "suffix": ""
                },
                {
                    "first": "Hakim",
                    "middle": [],
                    "last": "Hoener Zu Siederdissen",
                    "suffix": ""
                },
                {
                    "first": "Christoph",
                    "middle": [],
                    "last": "Tafer",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Flamm",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Peter",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Stadler",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Hofacker",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Algorithms for Molecular Biology",
            "volume": "6",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Better k-best parsing",
            "authors": [
                {
                    "first": "Liang",
                    "middle": [],
                    "last": "Huang",
                    "suffix": ""
                },
                {
                    "first": "David",
                    "middle": [],
                    "last": "Chiang",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proceedings of the Ninth International Workshop on Parsing Technologies",
            "volume": "",
            "issn": "",
            "pages": "53--64",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "On finding all suboptimal foldings of an RNA molecule",
            "authors": [
                {
                    "first": "Michael",
                    "middle": [],
                    "last": "Zuker",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "Science",
            "volume": "244",
            "issn": "4900",
            "pages": "48--52",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Complete suboptimal folding of RNA and the stability of secondary structures",
            "authors": [
                {
                    "first": "Stefan",
                    "middle": [],
                    "last": "Wuchty",
                    "suffix": ""
                },
                {
                    "first": "Walter",
                    "middle": [],
                    "last": "Fontana",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Ivo",
                    "suffix": ""
                },
                {
                    "first": "Peter",
                    "middle": [],
                    "last": "Hofacker",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Schuster",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Biopolymers",
            "volume": "49",
            "issn": "2",
            "pages": "145--65",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Revolutions in RNA secondary structure prediction",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Mathews",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Journal of molecular biology",
            "volume": "359",
            "issn": "3",
            "pages": "526--532",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "In vivo genome-wide profiling of RNA secondary structure reveals novel regulatory features",
            "authors": [
                {
                    "first": "Yiliang",
                    "middle": [],
                    "last": "Ding",
                    "suffix": ""
                },
                {
                    "first": "Yin",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                },
                {
                    "first": "Chun",
                    "middle": [
                        "Kit"
                    ],
                    "last": "Kwok",
                    "suffix": ""
                },
                {
                    "first": "Yu",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Philip",
                    "middle": [],
                    "last": "Bevilacqua",
                    "suffix": ""
                },
                {
                    "first": "Sarah",
                    "middle": [],
                    "last": "Assmann",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Nature",
            "volume": "11",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Landscape and variation of RNA secondary structure across the human transcriptome",
            "authors": [
                {
                    "first": "Yue",
                    "middle": [],
                    "last": "Wan",
                    "suffix": ""
                },
                {
                    "first": "Kun",
                    "middle": [],
                    "last": "Qu",
                    "suffix": ""
                },
                {
                    "first": "Qiangfeng",
                    "middle": [
                        "Cliff"
                    ],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Ryan",
                    "middle": [
                        "A"
                    ],
                    "last": "Flynn",
                    "suffix": ""
                },
                {
                    "first": "Ohad",
                    "middle": [],
                    "last": "Manor",
                    "suffix": ""
                },
                {
                    "first": "Zhengqing",
                    "middle": [],
                    "last": "Ouyang",
                    "suffix": ""
                },
                {
                    "first": "Jiajing",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Robert",
                    "middle": [
                        "C"
                    ],
                    "last": "Spitale",
                    "suffix": ""
                },
                {
                    "first": "Michael",
                    "middle": [
                        "P"
                    ],
                    "last": "Snyder",
                    "suffix": ""
                },
                {
                    "first": "Eran",
                    "middle": [],
                    "last": "Segal",
                    "suffix": ""
                },
                {
                    "first": "Howard",
                    "middle": [
                        "Y"
                    ],
                    "last": "Chang",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Nature",
            "volume": "505",
            "issn": "",
            "pages": "706--709",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "Ratelimiting steps in yeast protein translation",
            "authors": [
                {
                    "first": "Premal",
                    "middle": [],
                    "last": "Shah",
                    "suffix": ""
                },
                {
                    "first": "Yang",
                    "middle": [],
                    "last": "Ding",
                    "suffix": ""
                },
                {
                    "first": "Malwina",
                    "middle": [],
                    "last": "Niemczyk",
                    "suffix": ""
                },
                {
                    "first": "Grzegorz",
                    "middle": [],
                    "last": "Kudla",
                    "suffix": ""
                },
                {
                    "first": "Joshua",
                    "middle": [
                        "B"
                    ],
                    "last": "Plotkin",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Cell",
            "volume": "153",
            "issn": "",
            "pages": "1589--601",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Multiple roles of the coding sequence 5' end in gene expression regulation",
            "authors": [
                {
                    "first": "Tamir",
                    "middle": [],
                    "last": "Tuller",
                    "suffix": ""
                },
                {
                    "first": "Hadas",
                    "middle": [],
                    "last": "Zur",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Nucleic Acids Research",
            "volume": "43",
            "issn": "1",
            "pages": "13--28",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Uniprot: a hub for protein information",
            "authors": [
                {
                    "first": "Uniprot",
                    "middle": [],
                    "last": "Consertium",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Nucleic Acids Research",
            "volume": "42",
            "issn": "",
            "pages": "204--216",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "The codon adaptation index-a measure of directional synonymous codon usage bias, and its potential applications",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Paul",
                    "suffix": ""
                },
                {
                    "first": "Wen-Hsiung",
                    "middle": [],
                    "last": "Sharp",
                    "suffix": ""
                },
                {
                    "first": "",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "Nucleic Acids Research",
            "volume": "15",
            "issn": "3",
            "pages": "1281--1295",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Four examples of Deterministic Finite Automaton (DFA) representations for amino acids. Each example represents one amino acid. A: DFA for methionine, with only one path (tryptophan is the only other amino acid with a single codon path in the standard genetic code); B: DFA for valine, with alternatives only at the third nucleotide (15 of 21 amino acids are like this, with 2-4 paths); C: DFA for serine, which branches at the start node and has a total of 6 paths (leucine and arginine are also like this); D: DFA for the stop codon. The protein DFA for \"methionine leucine\" by concatenating small DFAs from individual amino acids, i.e., D(methionine) \u2022 D(leucine) \u2022 D(STOP).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "For the DFA in Fig. 2, out_edges((3, 0)) = {((4, 0), U), ((4, 1), C)} and in_edges((9, 0)) = {((8, 0), A), ((8, 0), G), ((8, 1), A)}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "One of the best derivations of the intersected grammar, demonstrating the path through the SCFG and the DFA (there are multiple best trees due to the simple energy model). The corresponding secondary structure (in dot-bracket format) is shown below the solid arrows. The rest of the DFA (fromFig. 2) is shown in light gray.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "The the best derivation of sequence CCAAAGGusing the Nussinov-Jacobson grammar.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "The pseudocode of a simplified bottom-up version of the mRNA Design algorithm. See Fig. SI 1 for UPDATE and BACKTRACE functions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Fig. SI 1 for details of Update and Backtrace functions. D. Left-to-right dynamic programming with beam pruning.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "The pseudocode of (simplified) LinearDesign algorithm.The first 10 lines are the same as in BOTTOMUPDESIGN (seeFig. 5). SeeFig. SI 1for UPDATE, BACKTRACE2, and BEAMPRUNE functions.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "The DFA representation integrating CAI as edge weight. A: Codon table of \"serine\". B: DFA graph of \"serine\" with CAI as edge weight; weights only differ at the last edges. C: Improved edge weights to differ earlier.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "uses serine as an example, showing how to integrating CAI as edge cost in DFA graph. The 6 codons of serine, listed inFig. 7A",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Runtime comparison between CDSfold and LinearDesign on Uniprot dataset. A: the runtime of CDSfold as reported by Terai et al. B: the runtime of LinearDesign (exact mode b = \u221e, and approximation mode b = 1, 000 and b = 100) run by us on an Intel Xeon E5-2660 v3 CPU. Search quality of LinearDesign with beam pruning is good. A: LinearDesign with b = 1, 000 has small free energy gap compared with exact search for 97 Uniprot sequences. B: The percentage of LinearDesign free energy gap changes linearly with mRNA sequence length for both b = 100 and b = 1, 000 on Uniprot dataset. C: The percentage of LinearDesign free energy gap changes with beam size for the spike protein of SARS-CoV-2 (in purple) and EGFP (in green).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "shows the runtime plots. We observe that CDSfold has an estimated runtime complexity of O(n 3.1 ), while LinearDesign (exact mode b = \u221e) runs in a complexity of O(n 2.8 ). Both CDSfold and LinearDesign (b = \u221e) have nearly cubic runtime, but LinearDesign (b = \u221e) is under the exact O(n 3 ) because we use the \"jump\" trick as in LinearFold,4 i.e., jump to the next possible nucleotide nucj that can pair with nuci (with the help of preprocessing), instead of checking all positions one by one. In terms of the time cost, CDSfold takes 31 hours for the longest sequence in the dataset (8,484 nt), while LinearDesign (b = \u221e) takes 17 hours. If applying beam pruning, the runtime of LinearDesign reduces to linear complexity as expected. With beam size b = 1, 000, the runtime is O(n 1.2 ), and further reduces to O(n 1.0 ) with b = 100. Our LinearDesign finishes the longest sequence design in 46 minutes with b = 1, 000, and in only 3 minutes with b = 100, which is 340\u00d7 speed up compared with the LinearDesign exact search.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Two-dimensional comparisons (MFE and CAI) between wildtype mRNA sequence (the light-red circle), random sequences (the blue cloud and the orange cloud) and our designed sequences (the blue spots, the light-blue curve and the magenta curve) on the spike protein of SARS-CoV-2. The better performance is the upper left of the graph, with low MFA and high CAI. Our designed sequences include three parts: (1) the sequence with the lowest MFE in exact mode and in approximation mode (b = 1, 000, b = 100 and b = 20, respectively), which are optimized by MFE only (shown in dark-blue spots and labeled by beam size); (2) sequences that are jointly optimized by MFE and CAI (showed in light-blue curve for exact mode and magenta curve for b = 1, 000); and (3) top 10, 000, 000 best sequences (dark-red cloud next to the b = +\u221e blue spot). We also show CAI-greedy design result as a grey point.",
            "latex": null,
            "type": "figure"
        },
        "TABREF2": {
            "text": "...",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "we consider optimizing MFE and CAI jointly. We add CAI as an additive regularization term in the",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "We thank Rhiju Das for introducing the mRNA design problem to us. D.H.M. is supported by National Institutes of Health grant R01GM076485.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "ACKNOWLEDGMENTS."
        },
        {
            "text": "return nuci, \".\"return nuci + seq + nucj\u22121, \"(\" + struct + \")\" q k \u2190 backpointer 12:seq 2 , struct2 \u2190 BACKTRACE(q k , qj) 14: return seq 1 + seq 2 , struct1 + struct2 q k\u22121 , nuci\u22121, q k , qj\u22121, nucj\u22121 \u2190 backpointer 8:seq 2 , struct2 \u2190 BACKTRACE2(q k , qj\u22121) 10: return seq 1 + nuci\u22121 + seq2 + nucj\u22121, struct1 + \"(\" + struct2 + \")\" seq, struct \u2190 BACKTRACE2(qi, qj\u22121) 14: return seq + nucj\u22121, struct + \".\" if key qi not in cands then 9: delete (qi, qj) in best prune out low-scoring states ",
            "cite_spans": [
                {
                    "start": 122,
                    "end": 125,
                    "text": "14:",
                    "ref_id": null
                },
                {
                    "start": 259,
                    "end": 262,
                    "text": "10:",
                    "ref_id": null
                },
                {
                    "start": 367,
                    "end": 370,
                    "text": "14:",
                    "ref_id": null
                },
                {
                    "start": 433,
                    "end": 435,
                    "text": "9:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "annex"
        }
    ]
}