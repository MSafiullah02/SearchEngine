{
    "paper_id": "PMC7242096",
    "metadata": {
        "title": "Adding Concurrency to a Sequential Refinement Tower",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Gerhard",
                "middle": [],
                "last": "Schellhorn",
                "suffix": "",
                "email": "schellhorn@informatik.uni-augsburg.de",
                "affiliation": {}
            },
            {
                "first": "Stefan",
                "middle": [],
                "last": "Bodenm\u00fcller",
                "suffix": "",
                "email": "stefan.bodenmueller@informatik.uni-augsburg.de",
                "affiliation": {}
            },
            {
                "first": "J\u00f6rg",
                "middle": [],
                "last": "Pf\u00e4hler",
                "suffix": "",
                "email": "joerg.pfaehler@gmx.de",
                "affiliation": {}
            },
            {
                "first": "Wolfgang",
                "middle": [],
                "last": "Reif",
                "suffix": "",
                "email": "reif@informatik.uni-augsburg.de",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Development of formally proved software systems using incremental refinement has been successfully used in many case studies. Often the system developed is a sequential system, e.g. a compiler. The standard technique used then is data refinement [8, 9, 14] or closely related definitions [2].",
            "cite_spans": [
                {
                    "start": 247,
                    "end": 248,
                    "mention": "8",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 250,
                    "end": 251,
                    "mention": "9",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 253,
                    "end": 255,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 289,
                    "end": 290,
                    "mention": "2",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Our group has developed a verified file system for flash memory [12, 13, 22, 26] using a strategy based on data types specified as abstract state machines (ASMs, [4]), data refinement, and subcomponents. The resulting refinement tower is shown in Fig. 1. It starts with an abstract state machine that specifies the POSIX file system operations. This interface is then refined to an implementation VFS (denoted by VFS \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\sqsubseteq $$\\end{document} POSIX), which calls operations of a submachine AFS. This machine acts as an abstract interface to the next implementation. This continues until the MTD layer is reached, which is the generic interface for flash hardware used in Linux.",
            "cite_spans": [
                {
                    "start": 65,
                    "end": 67,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 69,
                    "end": 71,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 73,
                    "end": 75,
                    "mention": "22",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 77,
                    "end": 79,
                    "mention": "26",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 163,
                    "end": 164,
                    "mention": "4",
                    "ref_id": "BIBREF24"
                }
            ],
            "section": "Introduction",
            "ref_spans": [
                {
                    "start": 252,
                    "end": 253,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Scala code for simulations as well as C code integrated into the Linux kernel has been generated from the implementations (shown in grey). The file system so far is strictly sequential, i.e., all operations are called in sequential order. Adding concurrency is however relevant for practical usability and efficiency on at least three levels: top-level operations, garbage collection and wear leveling.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Since existing refinement strategies are typically designed to start with an atomic specification that is refined to a concurrent system, this raises the question how to add concurrency a posteriori to intermediate levels of such a refinement tower without losing modularity and without having to start verification from scratch. This paper gives a positive answer to the question, by \u201cshifting\u201d parts of the refinement towers, i.e., by modifying individual specifications and implementations, to make them concurrent.\n",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We will use erase block management (the EBM interface) and the concurrent implementation of wear leveling (WL) based on the interface Blocks as an example to demonstrate how concurrency is added. A specification of the sequential specifications and refinements involved has already been published in [23].",
            "cite_spans": [
                {
                    "start": 301,
                    "end": 303,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The next section will give a simplified version of the relevant sequential specifications and implementation, to demonstrate in Sect. 3 how concurrency using locks is added and how restrictions are encoded as ownership constraints. Section 4 informally introduces the well-known concept of linearizability as the relevant concept to verify correctness of concurrent implementations, and shows how the proof of linearizability can be split into one of data refinement (that reuses the original proof) and one of atomicity refinement. Section 5 will give a proof strategy based on rely-guarantee proofs and reduction. Both have been implemented in our KIV [11] theorem prover. The specifications and proofs for the case study are available online [18]. Section 6 gives related work, and Sect. 7 concludes.",
            "cite_spans": [
                {
                    "start": 655,
                    "end": 657,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 746,
                    "end": 748,
                    "mention": "18",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Flash hardware is partitioned into erase blocks. Blocks can be written sequentially, and erased as a whole. Erasing wears out the block until it becomes unusable. Therefore, for efficient usage of a flash device, blocks must be worn out evenly. In particular if a device is filled to a large part with static data, the blocks with these data must sometimes be swapped with other (currently empty) blocks, that have often been modified and erased. This is called wear leveling. Wear leveling is hidden from the more abstract levels of the file system by the erase block manager (EBM) interface. The interface offers access to logical blocks. The task of the implementation (WL) is to map them to the physical blocks offered by the hardware, and to change the mapping when this is advisable, using an internal operation for wear leveling that has no effect (implements skip) for the interface EBM.",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "An abstract specification of the erase block manager is given with the ASM\n\n. The state consists of a function that maps logical block numbers to actual content and a set of currently used (\u201cmapped\u201d) block numbers.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "For simplicity, we do not specify\n\n, except for a default value\n\n. The interface of\n\nshown in Fig. 2 allows to read and to write the content of logical blocks. The operations use a semicolon to separate input and output parameters.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": [
                {
                    "start": 99,
                    "end": 100,
                    "mention": "2",
                    "ref_id": "FIGREF3"
                }
            ]
        },
        {
            "text": "The implementation of\n\nis given by the ASM\n\ntogether with a specification\n\nas a submachine. This refinement introduces the distinction between logical and physical blocks.\n\nallows reading and writing of physical blocks while\n\nis responsible for the mapping of logical to physical blocks. Furthermore, the wear leveling algorithm is implemented in\n\n.",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "To enable wear leveling each physical block in\n\ncontains a header. This header stores which logical block is mapped to the physical block or if the block is currently unmapped\n\n.The state of\n\nis a function that maps physical block numbers to blocks. Initially all blocks are unmapped and empty.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "The interface of\n\nas shown in Fig. 3 provides additional functionality to write and read the header of a physical block. Accessing the content of a block requires it to be mapped, i.e., the header of the block must not be\n\n. For wear leveling the interface also offers an interface operation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {blocks\\_get\\_wl}$$\\end{document} that returns two physical blocks\n\nand\n\n, that are suitable for wear leveling. The actual decision is based on erase counts (also stored in block headers), but we leave the concrete implementation open here. To signal that wear leveling is currently unnecessary, the operation returns a block\n\nwith an unmapped header.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": [
                {
                    "start": 35,
                    "end": 36,
                    "mention": "3",
                    "ref_id": "FIGREF4"
                }
            ]
        },
        {
            "text": "The operations of\n\nare depicted in Fig. 4. To avoid scanning the headers of all blocks, the state of\n\nmaintains an in-memory mapping from logical block numbers to headers, which contain the corresponding physical block numbers if the logical block is mapped.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": [
                {
                    "start": 40,
                    "end": 41,
                    "mention": "4",
                    "ref_id": "FIGREF5"
                }
            ]
        },
        {
            "text": "Reading and writing of content delegates to the corresponding operations of\n\nby following\n\n. If a logical block is unmapped, the write operation first maps this block to an unused physical block by writing a header and updating\n\n. Therefore\n\nprovides an operation\n\n that returns a fresh block that can be mapped.",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "The wear leveling operation\n\n, that is not visible to the clients, first requests a pair of blocks to be wear leveled by calling\n\n. If the\n\nBlock is mapped, its header and content are copied to the\n\nBlock and\n\nis updated. We leave away many details here, that ensure, that crashing in the middle of wear leveling will result in a consistent state, see [23].",
            "cite_spans": [
                {
                    "start": 353,
                    "end": 355,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "To prove the refinement\n\nthree invariants are established in\n\n.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "The three predicates guarantee a valid mapping between logical and physical blocks.\n\n prohibits that two logical blocks are mapped to the same physical block,\n\n ensures that each mapped physical block in\n\npoints to the correct logical block, and\n\n ensures that each mapped physical block also has a matching entry in\n\n.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "The abstraction relation between states of the specification and states of the implementation ensures that mapped blocks in\n\nconform with mapped logical blocks in\n\nand that contents of\n\nconform to the contents of the mapped physical blocks in\n\n.\n",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "Together with the invariants this is sufficient to prove a data refinement using forward simulation.",
            "cite_spans": [],
            "section": "The Refinement for Wear Leveling",
            "ref_spans": []
        },
        {
            "text": "The sequential code calls the wear leveling operation at the end of every other operation. This causes small pauses in between operations. A better solution is to call wear leveling in a separate thread concurrently. This exploits that even the MTD hardware interface is capable of reading and writing different blocks concurrently. This is not possible for individual blocks, since these do not provide random access, but can be written sequentially only.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "Adding concurrency implies that interface operations are now called concurrently by several threads, and it is natural to assume that they now have an atomic semantics (which is the natural semantics of ASMs, but was not required in a sequential context). We emphasize this, by writing\n\nand\n\nfor\n\nand\n\nwith atomic semantics, although the machines are the same. Assuming an atomic semantics for the implementation is however unrealistic.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "A simple solution that enforces an atomic semantics for an implementation is to use a single global mutex, that is set before each operation and released afterwards. Doing so for the operations of\n\nwould however prevent wear leveling from running concurrent.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "An implementation of\n\nthat uses such a simple locking strategy would be correct to enforce atomicity, but too restrictive as it would prevent concurrent access to different blocks. It would also not be sufficient for the correctness of\n\n. To understand this, consider the implementation of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_write}$$\\end{document} in Fig. 4 and a potential interleaving of two concurrent executions of this operation as depicted in Fig. 5. Here two threads\n\nand\n\nwrite two contents to different logical blocks\n\nresp.\n\n. Both logical blocks are unmapped so by calling \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {blocks\\_map}$$\\end{document} unmapped physical blocks are chosen to be mapped. Although the operation is atomic it is possible that for\n\nthe same physical block\n\nis returned as for\n\nsince\n\nhas not written the new header yet. Both threads would then write to the same physical block, first different headers that point to\n\nresp.\n\n, then different contents\n\nresp.\n\n. After both writes finish an inconsistent state is reached to the effect that the written data of\n\nis lost and the injectivity of the block mapping is violated.\n",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 603,
                    "end": 604,
                    "mention": "4",
                    "ref_id": "FIGREF5"
                },
                {
                    "start": 701,
                    "end": 702,
                    "mention": "5",
                    "ref_id": "FIGREF6"
                }
            ]
        },
        {
            "text": "A concept is needed that enforces on the level of\n\nthat its implementation can assume that only one thread is writing each block at one time, and that headers are written by a single thread only.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "The concept we use is that of threads owning data structures.\n",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "An owner can either own a data structure non-exclusively (typically for reading) or exclusively for writing. That a thread owns all headers or some block for reading or writing is specified as two ghost variables\n\nand\n\n. To ensure, that clients of the extended interface\n\nshown in Fig. 6 respect the ownership, we add preconditions to the operations, that request read-ownership for reading and write-ownership for writing blocks and headers. A thread that wants to call an operation of\n\nmust now acquire ownership before it and can release ownership afterwards. For this purpose the interface is extended with two auxiliary acquire and release operations. These acquire and release full ownership, which is sufficient for the concurrent implementation of wear leveling given below. It is possible to add operations that acquire and release read-ownership too. Acquiring full ownership has the precondition that there is no current owner. If two threads now try to write the same block, one of them will violate the precondition of acquire (if it tries to acquire) or it will violate the precondition of writing (if it does not). But this is impossible, since submachine calls in implementations are checked to satisfy their preconditions.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 286,
                    "end": 287,
                    "mention": "6",
                    "ref_id": "FIGREF7"
                }
            ]
        },
        {
            "text": "Calls to acquire and release in the augmented code of wear leveling will now ensure, that ownership is properly acquired. They are used for verification, but are \u201cghost code\u201d that is eliminated when generating executable code.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "To make sure, that calls to acquire never violate their precondition, we have to use locks in the extended implementation of\n\ngiven in Fig. 8. The simple implementation we give here just uses mutexes.\n\n",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 140,
                    "end": 141,
                    "mention": "8",
                    "ref_id": "FIGREF9"
                }
            ]
        },
        {
            "text": "The locking and unlocking operations \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {mutex\\_lock}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {mutex\\_unlock}$$\\end{document} are specified as the atomic program statements given in Fig. 7. The definition of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {mutex\\_lock}$$\\end{document} uses the program construct\n\n. The\n\nconstruct blocks the current thread until its guard \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi $$\\end{document} is satisfied. Immediately afterwards, the program \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} is executed in a single, indivisible step.\n",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 718,
                    "end": 719,
                    "mention": "7",
                    "ref_id": "FIGREF8"
                }
            ]
        },
        {
            "text": "Figure 8 shows the result of applying sufficient locking and ownership acquisition to\n\n. Additionally, each atomic step gets an individual label (W1\u2013W18, R1\u2013R8, and WL1\u2013WL21) to give assertions for this program point when reasoning about atomicity (see Sect. 5). We refer to this concurrent implementation as\n\n. The state of\n\nis enhanced by a lock that protects the headers of all blocks, and locks for each logical block that protects its contents.\n\n",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "8",
                    "ref_id": "FIGREF9"
                }
            ]
        },
        {
            "text": "We use mutexes for all locks, since they match our simplification of acquiring write-ownership only. The actual Erase-Block-Manager in Flashix employs reader-writer locks whenever parallel reading is unproblematic. The general locking concept of\n\n is to acquire\n\nonly if the mapping from logical to physical blocks needs to be updated. This is the case when writing to an unmapped block or when wear leveling is active. Otherwise, locking only one individual\n\nof a specific logical block\n\nis sufficient. This lock protects the corresponding entry\n\nof the block mapping as well as the content of the physical block\n\n. With this strategy multiple reads and writes to different, mapped logical blocks are possible, even in parallel to wear leveling.\n",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": []
        },
        {
            "text": "One exception is that the\n\nhas to be acquired in every \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_write}$$\\end{document} execution (W2\u2013W14 in Fig. 8), at least for a short amount of time. This is due to the locking hierarchy that is employed to avoid deadlocks. When running in parallel, it is possible that a \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_write}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_wear\\_leveling}$$\\end{document} may both need to acquire\n\nand the same\n\n, so it must be ensured that those operations request the locks in the same order. Because \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_wear\\_leveling}$$\\end{document} needs to be owner of\n\nto get suitable physical blocks at WL4 before a logical block can be locked, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_write}$$\\end{document} must request\n\nahead of requesting\n\n.",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 386,
                    "end": 387,
                    "mention": "8",
                    "ref_id": "FIGREF9"
                }
            ]
        },
        {
            "text": "Figure 9 shows the resulting refinement of\n\n. Proving\n\nusing linearizability is discussed in detail in the next sections. It remains to integrate the new \u201cshifted\u201d refinement into the refinement tower. The layers above\n\ncan remain untouched since\n\nis identical to\n\n, and sequential use of\n\nis not problematic. Below\n\nan adjustment is necessary: a simple one is to use a global lock around the operations of its implementation. Since the level is already close to the MTD hardware interface, the real solution propagates ownership down to ownerships at the hardware level (where blocks store a sequence of bytes instead of a header and content).",
            "cite_spans": [],
            "section": "Adding Concurrency and Ownership",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "9",
                    "ref_id": "FIGREF10"
                }
            ]
        },
        {
            "text": "The standard correctness criterion we use to prove correctness of the refinement of\n\nto\n\nfrom Fig. 9 is linearizability. A formal definition can be found in [15], we only give an informal description here.",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 160,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": [
                {
                    "start": 99,
                    "end": 100,
                    "mention": "9",
                    "ref_id": "FIGREF10"
                }
            ]
        },
        {
            "text": "A concurrent implementation CASM with nonatomic programs \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$COP_i$$\\end{document} is linearizable to an atomic specification AASM with atomic operations \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$AOP_i$$\\end{document}, if the input/output behaviors of each concurrent run can be explained by mapping them to the sequential input/output behavior of some sequential run of AASM.\n",
            "cite_spans": [],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The mapping between a concurrent and a sequential run is as follows: for each concurrent call of an operation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$COP_i$$\\end{document} that is started at time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t_i$$\\end{document} and returns at time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t'_i$$\\end{document} find some point in time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l_i$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t_i \\le l_i \\le t'_i$$\\end{document}, such that all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l_i$$\\end{document} are different. The point is called the linearization point of the operation call. Then construct some sequential run of AASM that executes each corresponding abstract operation \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$AOP_i$$\\end{document} atomically at time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l_i$$\\end{document}. Note that even for fixed linearization points this may give several sequential runs if the abstract operations are nondeterministic.",
            "cite_spans": [],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "A refinement from AASM to CASM then is linearizable, if for every concurrent run linearization points and an abstract sequential run can be found, such that all operation calls have the same inputs and outputs.",
            "cite_spans": [],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The clients of the interface then cannot distinguish the concurrent run from one, where each operation call is delayed until time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$l_i$$\\end{document}, executes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$AOP_i$$\\end{document} atomically and then is delayed again until time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$t'_i$$\\end{document}.",
            "cite_spans": [],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Our proof technique will use an intermediate machine\n\nthat is the same as\n\n, but executes the code of each operation as one atomic step. This splits the refinement problem into three parts as shown in Fig. 10. The data refinement\n\n, that we have already proved (since the ASMs are the same as\n\nand\n\n). Second, a trivial refinement\n\nthat abstracts from the locking/unlocking (and acquire/release) instructions in\n\n, since the overall effect of locking/unlocking in one atomic step is empty. Finally, the atomicity refinement\n\n, where both machines have the same data and operations, but different atomicity. Splitting the refinement from an atomic AASM to a concurrent CASM by using an intermediate \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathtt {at}$$\\end{document}(CASM), which executes the operations of CASM atomically, has the advantage that data refinement is completely decoupled from atomicity refinement.",
            "cite_spans": [],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": [
                {
                    "start": 206,
                    "end": 208,
                    "mention": "10",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "The next section will describe a proof strategy for proving the atomicity refinement between\n\nand\n\n, which is the new problem we get from adding concurrency to the refinement tower.",
            "cite_spans": [],
            "section": "Linearizabilty and Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The variant of the rely-guarantee calculus used here is similar to the one given in [30], Section 5. The basic correctness statement1 is of the form\n",
            "cite_spans": [
                {
                    "start": 85,
                    "end": 87,
                    "mention": "30",
                    "ref_id": "BIBREF23"
                }
            ],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "where program \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} is assumed to be the sequential program of some thread, that executes atomic steps. These alternate with environment steps, where one environment step is an arbitrary sequence of steps of other threads.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The program is assumed to use the state variables\n\n. Precondition\n\n, postcondition\n\n, predicate\n\n, and global invariant\n\nare predicates over this state. The rely\n\nand the guarantee\n\nrestrict environment and program steps. They are predicates over\n\nand\n\nWe write arguments in predicates if they differ from the standard ones only.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The formula asserts, that program \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document}, when started in a state that satisfies precondition\n\nand global invariant\n\n, will execute steps that satisfy\n\nand preserve the invariant\n\n, as long as all previous environment steps satisfy\n\nand preserve\n\ntoo. No program step will block, when at that time\n\nholds. In addition, when all environment steps satisfy\n\nand preserve\n\n, then the program will either terminate and the final state will satisfy\n\n, or it will stop in a blocked state where\n\nis false.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The calculus to prove such formulas in KIV is based on symbolic execution. The basic rule to execute one atomic step at label L, that is annotated with an assertion \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi _L$$\\end{document} is\n",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The rule reduces the conclusion at the bottom to premises. The first premise states that before executing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} the assertion at the initial label holds, and that the first step does not block (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi $$\\end{document} holds) whenever the\n\npredicate is true.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The second premise uses the Dynamic Logic formula\n\nwhich asserts that the sequential program \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} has a terminating run that yields a state \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{x'}$$\\end{document}. The premise ensures that the first atomic step of the program, which executes \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha $$\\end{document} is a step that satisfies\n\nand preserves the invariant\n\n.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The third premise continues symbolic execution with the rest of the program. Its precondition uses two sets \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{x}_0$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{x}_1$$\\end{document} of fresh variables, to represent the two old states before and after the first atomic program step. The subsequent environment step from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{x}_1$$\\end{document} to the current state \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{x}$$\\end{document} is assumed to satisfy\n\n. Since rely steps preserve the invariant, it can be assumed for the current state again.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "One common instance of the rule is a parallel assignment \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{y} := \\underline{t}$$\\end{document}, which can be viewed as an abbreviation for atomic true {\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{y} := \\underline{t}$$\\end{document}}. In this case the formula\n\nreduces to\n\n, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{z}$$\\end{document} are the remaining variables from \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\underline{x}$$\\end{document} that are not assigned.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The rules for other constructs like conditionals resemble the usual rules for symbolic execution of programs, except that similar to the rule above they have rely steps in between program steps and side conditions for assertions and guarantee. For loops, a loop invariant (that holds at the start of each iteration) and a variant, that decreases with a wellfounded order are needed. Proofs for recursive routines need wellfounded induction.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Individual rely-guarantee proofs for single threads can be combined to a rely-guarantee property of a concurrent system. The crucial property that needs to hold for this to work, is that the relies and guarantees must be compatible: the guarantee of each thread\n\nmust imply the relies\n\nof other threads\n\n. For our state machines where all threads are known to execute the same operations, the guarantee can be chosen to be\n\n, the weakest guarantee possible that is trivially compatible. The system is deadlock-free, if the disjunction of all\n\nholds. When a mutex is used,\n\nis chosen to be\n\nwhich implies this condition. This easily generalizes to the hierarchy of locks used in the case study.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "In summary, to verify assertions for a specification of a concurrent state machine with operations \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$OP_i$$\\end{document}, the user has to provide an invariant\n\n, a rely\n\nand a predicate\n\n. The latter describes states, where a thread is not currently executing an operation. From these predicate logic proof obligations (e.g. the\n\nmust be reflexive, initial states satisfy the invariant etc.) are generated, together with the following rely guarantee proof obligation for each operation.\n",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Successful verification guarantees that each of the assertions \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi _L$$\\end{document} holds every time a thread reaches label L, that the operations terminate and that the implementation is deadlock-free.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The verified assertions are then used to combine atomic statements to larger ones following Lipton\u2019s [19] strategy of reduction. The idea is that a thread executing two atomic steps \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L2}$$\\end{document} (at labels L1 and L2) with an environment step in between is often equivalent to first executing the environment step, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L2}$$\\end{document} with no intermediate environment step. In this case the two steps can be merged together to form one atomic step.\n",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 104,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Reverting the order of first executing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} and then an environment step is possible, if all steps of other threads, that could be a part of the environment step, commute to the right with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document}, in the sense that executing them in both orders gives the same final state. In this case \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} is called a right mover. Analogous to this, a step that commutes to left with all steps is called a left mover. Figure 11 shows an example, where the environment step consists of two steps \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{M}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{N}$$\\end{document} of other threads. The original run is shown at the bottom, the alternative run which allows executing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L2}$$\\end{document} as one atomic step at the top. The intermediate states of the runs are different, but they reach the same final state.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": [
                {
                    "start": 1272,
                    "end": 1274,
                    "mention": "11",
                    "ref_id": "FIGREF2"
                }
            ]
        },
        {
            "text": "The atomic steps of the programs can all be written in the form where L is the label, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi _L$$\\end{document} the assertion established. The guard\n\nis true for all statements, except locking instructions, cf. Figure 7. Program \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{L}$$\\end{document} is either an assignment, or the call of a submachine operation. For a conditional or a while loop with test \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\delta $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{L}$$\\end{document} is defined to be \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$b := \\delta $$\\end{document} using a fresh variable b, while binding a local variable \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf{let}\\ y = t\\ \\mathbf{in} \\ldots $$\\end{document} gives \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\alpha _{L} \\equiv \\{ y := t\\}$$\\end{document}. The formal condition for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} to commute to the right with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L2}$$\\end{document} executed by another thread is1In the formula,\n\nare variants, that rename thread local variables used in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{M}$$\\end{document} to new, primed variables disjoint from the shared state and the local variables of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L}$$\\end{document}. The criterion critically uses the assertions at both labels, since they often show that the preconditions of the implication contradict each other, trivializing the proof. If, for example the two steps are both in a region where a common lock is needed, they commute trivially: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi _{L}$$\\end{document} implies\n\n, while \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\varphi '_{M}$$\\end{document} implies\n\n, so the proof obligation trivially holds. A general result is that locking is always a right mover, while unlocking is always a left mover.",
            "cite_spans": [],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": [
                {
                    "start": 492,
                    "end": 493,
                    "mention": "7",
                    "ref_id": "FIGREF8"
                }
            ]
        },
        {
            "text": "Combining steps to larger steps can be translated into rules for making statements like sequential composition, conditionals and loops atomic, when their parts are atomic already. We use rules similar to the reduction rules given in [10]. Iterated application gives larger and larger atomic blocks. Ideally, the final result is that the whole concurrent program of one operation has been combined into a single atomic step. If this is possible, then a linearizability proof becomes trivial, as the linearizability point then simply is the single atomic step.",
            "cite_spans": [
                {
                    "start": 234,
                    "end": 236,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Rely-Guarantee Proofs and Reduction ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The main task for proving the atomicity refinement of the case study is to find assertions, rely conditions and a global invariant that are strong enough to allow atomicity refinement.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The rely conditions are derived from the crucial ideas what data structures are protected from being changed, when thread\n\nhas a certain lock or ownership. This results in the following clauses.\n",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The only rely that is somewhat difficult to find is the last one: if a thread locks logical block\n\n, then other threads are not allowed to change the block header to point to or to point away from\n\n.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "The global invariant and the assertions are derived from several sources. First, ownership as used in the interface\n\nhas to be compatible with the use of locks.2\n3\n4The invariant (2) states that headers are owned only if the lock has been taken. Invariant (3) states that a mapped physical block\n\ncan be owned (and therefore changed) only if the corresponding logical block that is stored in its header is locked. For unmapped blocks property (4) states that they can be owned only if\n\nhas taken the header lock.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Second, the three global invariants of the sequential code are relevant. Dropping them completely would result in illegal states where e.g. the block mapping is no longer injective. However, the invariants of the sequential verification are only guaranteed to hold in idle states, where no thread is running. So it is necessary to give weaker assertions for intermediate states, that are still sufficient to avoid illegal ones.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "For the given case study, it turns out that\n\nand\n\nare preserved by all steps, but that\n\ndoes not hold while the headers are locked. As a result the global invariant can include\n\nonly when the headers are currently not owned (\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$Oheaders = readers(\\emptyset )$$\\end{document}). To establish this assertion, after a step that releases\n\n, assertions have to be given for all labels, where\n\nis taken. For writing the predicate is violated between line\n\nafter the header of block\n\nhas been set to\n\nand line\n\n, where\n\nis set to\n\n. For all lines in this range\n\nholds: if\n\nwere already updated, then\n\nwould hold. The wear leveling algorithm gives similar assertions for the range\n\n.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Finally, assertions are sometimes necessary for the code after a test or after assignments to a variable. In a purely sequential setting, the test for\n\nat R2 ensures that this formula holds, until the subsequent let binding\n\nat line R4, which will ensure\n\nwhen the variable\n\nis used later on. However, in the concurrent setting\n\nmay be assigned by other threads, destroying each of these properties. In the given case, the rely conditions are strong enough to propagate the formulas, so we assert that at line R4 the first formula holds, while for lines R5\u2013R7 the second holds. A number of similar assertions are needed for other local variables.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Proving the rely-guarantee proof obligations for the individual programs requires the main effort in proving the concurrent setting correct. This is in line with case studies we have done for lock-free algorithms [25, 27\u201329], where proving rely-guarantee assertions caused the main effort too.",
            "cite_spans": [
                {
                    "start": 214,
                    "end": 216,
                    "mention": "25",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 218,
                    "end": 220,
                    "mention": "27",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 221,
                    "end": 223,
                    "mention": "29",
                    "ref_id": "BIBREF21"
                }
            ],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "After establishing assertions for all program points, the program can then be reduced, combining atomic steps to larger ones. This requires to find out, which steps are left or right movers (or both). The current strategy implemented in KIV does simple syntactic checks to check whether the resulting commutativity requirement (1) is trivial: either the accessed variables are disjoint, or the preconditions of the proof obligation trivially reduce to false. Otherwise it is possible to generate proof obligations, by manually asserting that certain steps (identified by their label) are left or right movers (or both).",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "For the case study, manual specifications of mover types are currently necessary for the atomic calls \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {blocks\\_acquire}$$\\end{document} (right mover) and\n\n(left mover) of\n\n. The reader may check, that this trivially implies that the other operations of\n\nare left and right movers. After the mover types have been determined, the reduction rules are then applied automatically, to form maximally large atomic blocks.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "This immediately results in a single atomic block for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_write}$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_read}$$\\end{document}. Reducing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_wear\\_leveling}$$\\end{document} creates three atomic blocks. The first ends at the conditional at line WL6 and is a right mover. The second is for the let-block WL7\u2013WL19. The third is for the last two lines WL20\u2013WL21, and is a left mover. The conditional cannot be reduced, since its then-branch requires the lock for block\n\nto be free, while the empty else-branch does not have this guard. With the atomic blocks now being much larger than before, it becomes possible to prove much stronger invariants that just hold in between blocks, but did not hold for the original programs. In particular, since all locking and unlocking of blocks is now within atomic regions, the simple invariant that all\n\nare always free can be established using another simple rely-guarantee proof. With the new invariant established, another reduction step finds, that the conditional at line WL6 can now be reduced to an atomic block. Together with the initial and the final block being right resp. left movers already, the wear leveling code is combined by another reduction step into a single step. This implies that the concurrent implementation of wear leveling is indeed linearizable and a correct refinement.",
            "cite_spans": [],
            "section": "Proving the Case Study ::: Proof Strategy for Atomicity Refinement",
            "ref_spans": []
        },
        {
            "text": "Related work on wear leveling and the flash file system we have developed has already been given in [23], where the full version of the sequential wear leveling algorithm has been specified.",
            "cite_spans": [
                {
                    "start": 101,
                    "end": 103,
                    "mention": "23",
                    "ref_id": "BIBREF15"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "This paper is based on the PhD of J\u00f6rg Pf\u00e4hler [21], where concurrency was added to the full wear leveling algorithm. The full version needs to add ownership annotations and locks to several refinements. This version is now used in our actual flash file system implementation. The PhD also contains extensions that allow verifying crash-safety, which we could not address in this paper.",
            "cite_spans": [
                {
                    "start": 48,
                    "end": 50,
                    "mention": "21",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "The flash file system by Damchoom et al. [7] has concurrent wear leveling. The synchronization between threads is implicitly performed by the semantics of Event-B models, i.e., an event in an Event-B model is always executed atomically, and not explicitly via locks or other synchronization primitives. This makes the step to actual running code more difficult and less straightforward. The full erase block management used in our flash file system is also more general, because it does not use additional bits of out-of-band data of an erase block.",
            "cite_spans": [
                {
                    "start": 42,
                    "end": 43,
                    "mention": "7",
                    "ref_id": "BIBREF27"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Verification of concurrent, lock-based systems is of course a very broad topic with lots of important contributions, and the proof techniques we use are from this field. We are not aware of other formal methods that specifically address the question of this paper: how to add concurrency a posteriori to an existing modular, sequential system, without having to prove the system from scratch. Adding concurrency to components of an existing software system to increase efficiency is however a recurring software engineering task that should be supported by formal methods.",
            "cite_spans": [],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Refinement and abstraction of atomicity is quite common for concurrent systems, and many refinement definitions for concurrent systems like [1] or [20] address refinements of atomicity. The refinement calculus of Back [3] uses the opposite direction. It starts out with an atomic program and splits it into smaller actions in refinement steps.",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 142,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 148,
                    "end": 150,
                    "mention": "20",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 219,
                    "end": 220,
                    "mention": "3",
                    "ref_id": "BIBREF22"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "The calculus of atomic actions due to Elmas et al. [10] is an extension of Lipton\u2019s [19] original approach for highly concurrent, linearizable programs. It provides a more incremental verification methodology than the calculus given here for highly concurrent systems and its implementation is better automated. The assertions and invariants are incrementally validated in [10], whereas here a rely/guarantee proof is used to validate them before applying any reductions. The rules of the calculus in [10] address partial correctness, so termination would have to be proven differently. Nevertheless, many of the reduction rules given in this paper are directly used in our approach too.",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 54,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 85,
                    "end": 87,
                    "mention": "19",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 374,
                    "end": 376,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 502,
                    "end": 504,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "Ownership annotations are used in the C verifier VCC [6] and Spec# [16] in order to ensure data-race freedom of the code. They are typically coupled to objects of the programming language, while we decouple the use of ownership from objects. Fractional permissions [5] in concurrent versions of separation logics [24] serve a similar purpose as ownership. These are for example supported by the C code verifier VeriFast [17].",
            "cite_spans": [
                {
                    "start": 54,
                    "end": 55,
                    "mention": "6",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 68,
                    "end": 70,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 266,
                    "end": 267,
                    "mention": "5",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 314,
                    "end": 316,
                    "mention": "24",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 421,
                    "end": 423,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                }
            ],
            "section": "Related Work",
            "ref_spans": []
        },
        {
            "text": "We have presented an approach for adding concurrency to an existing refinement tower. The given approach allows to add concurrency by enhancing some of the components of the refinement tower. Abstract interfaces are extended with acquire and release operations, that specify allowed concurrency. In our case study concurrent writes on different blocks are possible, while concurrent writes on the same block are disallowed. Concurrent code using these interfaces is then possible, that enhances the existing sequential code with suitable locking strategies. We have evaluated this strategy of \u201cshifting parts of the refinement\u201d tower by making wear-leveling concurrent in the Flashix file system. Specifications using the same concept have been defined for concurrent garbage collection, with executable code already running. Verification is work in progress. We also work on a allowing concurrent calls for POSIX file system operations.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "Fig. 1.: Flashix refinement tower",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 10.: Splitting the refinement",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 11.: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_{L1}$$\\end{document} commutes to the right of environment step \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$At_M; At_N$$\\end{document}",
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Fig. 2.: Sequential specification of the erase block manager (\n\n)",
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Fig. 3.: Sequential specification of the physical block layer (\n\n)",
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Fig. 4.: Sequential implementation of the wear leveling layer (\n\n)",
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Fig. 5.: Critical interleaving of two \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbf {wl\\_write}$$\\end{document} executions",
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Fig. 6.: Atomic specification of the physical block layer with ownership (\n\n)",
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Fig. 7.: Mutex locking operations",
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Fig. 8.: Concurrent implementation of the wear leveling layer (\n\n)",
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Fig. 9.: Concurrency refinement of the erase-block-manager",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "KIV - overview and verifythis competition",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ernst",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pf\u00e4hler",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Haneberg",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Reif",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Softw. Tools Techn. Transf.",
            "volume": "17",
            "issn": "6",
            "pages": "677-694",
            "other_ids": {
                "DOI": [
                    "10.1007/s10009-014-0308-3"
                ]
            }
        },
        "BIBREF3": {
            "title": "Inside a verified flash file system: transactions & garbage collection",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ernst",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pf\u00e4hler",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Reif",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "VSTTE 2015",
            "volume": "",
            "issn": "",
            "pages": "73-93",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "Data refinement refined resume",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "He",
                    "suffix": ""
                },
                {
                    "first": "CAR",
                    "middle": [],
                    "last": "Hoare",
                    "suffix": ""
                },
                {
                    "first": "JW",
                    "middle": [],
                    "last": "Sanders",
                    "suffix": ""
                }
            ],
            "year": 1986,
            "venue": "ESOP 86",
            "volume": "",
            "issn": "",
            "pages": "187-196",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "Linearizability: a correctness condition for concurrent objects",
            "authors": [
                {
                    "first": "MP",
                    "middle": [],
                    "last": "Herlihy",
                    "suffix": ""
                },
                {
                    "first": "JM",
                    "middle": [],
                    "last": "Wing",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "ACM Trans. Program. Lang. Syst. (TOPLAS)",
            "volume": "12",
            "issn": "3",
            "pages": "463-492",
            "other_ids": {
                "DOI": [
                    "10.1145/78969.78972"
                ]
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "VeriFast: a powerful, sound, predictable, fast verifier for C and Java",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Jacobs",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Smans",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Philippaerts",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Vogels",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Penninckx",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Piessens",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "NASA Formal Methods",
            "volume": "6617",
            "issn": "",
            "pages": "41-55",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-20398-5_4"
                ]
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Reduction: a method of proving properties of parallel programs",
            "authors": [
                {
                    "first": "RJ",
                    "middle": [],
                    "last": "Lipton",
                    "suffix": ""
                }
            ],
            "year": 1975,
            "venue": "Commun. ACM",
            "volume": "18",
            "issn": "12",
            "pages": "717-721",
            "other_ids": {
                "DOI": [
                    "10.1145/361227.361234"
                ]
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "Modular verification of order-preserving write-back caches",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pf\u00e4hler",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ernst",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bodenm\u00fcller",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Reif",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Integrated Formal Methods",
            "volume": "",
            "issn": "",
            "pages": "375-390",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "Formal specification of an erase block management layer for flash memory",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Pf\u00e4hler",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ernst",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Haneberg",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Reif",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Hardware and Software: Verification and Testing",
            "volume": "",
            "issn": "",
            "pages": "214-229",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF16": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF17": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF18": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF19": {
            "title": "Towards a thread-local proof technique for starvation freedom",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Travkin",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wehrheim",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Integrated Formal Methods",
            "volume": "",
            "issn": "",
            "pages": "193-209",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF20": {
            "title": "Formal verification of a lock-free stack with hazard pointers",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Tofan",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Reif",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Theoretical Aspects of Computing \u2013 ICTAC 2011",
            "volume": "",
            "issn": "",
            "pages": "239-255",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF21": {
            "title": "Two approaches for proving linearizability of multiset",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Tofan",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Travkin",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Schellhorn",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Wehrheim",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Sci. Comput. Program.",
            "volume": "96",
            "issn": "P3",
            "pages": "297-314",
            "other_ids": {
                "DOI": [
                    "10.1016/j.scico.2014.04.001"
                ]
            }
        },
        "BIBREF22": {
            "title": "A method for refining atomicity in parallel algorithms",
            "authors": [
                {
                    "first": "RJR",
                    "middle": [],
                    "last": "Back",
                    "suffix": ""
                }
            ],
            "year": 1989,
            "venue": "PARLE \u201989 Parallel Architectures and Languages Europe",
            "volume": "",
            "issn": "",
            "pages": "199-216",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF23": {
            "title": "The rely-guarantee method for verifying shared variable concurrent programs",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                },
                {
                    "first": "W-P",
                    "middle": [],
                    "last": "de Roever",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "He",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Formal Aspects Comput.",
            "volume": "9",
            "issn": "2",
            "pages": "149-174",
            "other_ids": {
                "DOI": [
                    "10.1007/BF01211617"
                ]
            }
        },
        "BIBREF24": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF25": {
            "title": "Checking interference with fractional permissions",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Boyland",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Static Analysis",
            "volume": "",
            "issn": "",
            "pages": "55-72",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF26": {
            "title": "VCC: a practical system for verifying concurrent C",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Cohen",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Theorem Proving in Higher Order Logics",
            "volume": "",
            "issn": "",
            "pages": "23-42",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF27": {
            "title": "Applying event and machine decomposition to a flash-based filestore in Event-B",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Damchoom",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Formal Methods: Foundations and Applications",
            "volume": "",
            "issn": "",
            "pages": "134-152",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF28": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF29": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}