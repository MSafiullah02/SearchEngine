{
    "paper_id": "ee69d5ddc67d91538d24090c1741a8861bddbc58",
    "metadata": {
        "title": "A New Algorithm for Fast All-Against-All Substring Matching",
        "authors": [
            {
                "first": "Marina",
                "middle": [],
                "last": "Barsky",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Victoria",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": "mgbarsky@cs.uvic.ca"
            },
            {
                "first": "Ulrike",
                "middle": [],
                "last": "Stege",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Victoria",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": "stege@cs.uvic.ca"
            },
            {
                "first": "Alex",
                "middle": [],
                "last": "Thomo",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Victoria",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": "thomo@cs.uvic.ca"
            },
            {
                "first": "Chris",
                "middle": [],
                "last": "Upton",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Victoria",
                    "location": {
                        "country": "Canada"
                    }
                },
                "email": "cupton@uvic.ca"
            }
        ]
    },
    "abstract": [
        {
            "text": "We present a new and efficient algorithm to solve the 'threshold all vs. all' problem, which involves searching of two strings (with length N and M respectively) for finding all maximal approximate matches of length at least S and with up to K differences. The algorithm is based on a novel graph model, and it solves the problem in time O(NMK 2 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "An important problem in the field of string matching is the extraction of exact and approximate common patterns from a set of strings. In special application areas such as biological sequence analysis, finding exact patterns only can miss a great deal of useful information.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The problem can be defined as \"all-against-all approximate substring matching\" [1, 2, 4] , and is notorius for its computational difficulty [5] . In practice, various constraints are set for the sought solutions, such as the maximum allowed number of approximations or \"errors\" and the minimum length of substrings. Despite past attempts, this problem is far from being efficiently solved. Our contribution is a fast algorithm for solving \"all-against-all approximate substring matching\" for two strings.",
            "cite_spans": [
                {
                    "start": 79,
                    "end": 82,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 83,
                    "end": 85,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 86,
                    "end": 88,
                    "text": "4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 140,
                    "end": 143,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A naive approach to this problem is to exhaustively test each pair of substrings from s and t respectively. This approach has O(N 2 M 2 ) time complexity.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The best known solution was proposed by Baeza-Yates and Gonnet in [1, 2] , and is widely used [8] . Their solution significantly improved the average time complexity of the naive approach, by avoiding the examination of repeating substrings. In their method, the two input strings are organized into a suffix tree structure, and the order of substrings comparisons is guided by a depth-first traversal of the suffix tree nodes. The time complexity based on their practical results lies between N M (best case) and N 2 M 2 (worst case), but closer to N 2 M 2 [4] . Setting threshold criteria bounding the error number, i.e., allowing at most K differences in an approximate substring match, significantly improves the performance of the Baeza-Yates and Gonnet algorithm. This is because the value of K can be directly incorporated into their algorithm to cut down the depth of the suffix tree traversal. As we verify through experiments, for small values of K, the Baeza-Yates and Gonnet algorithm performs very well. However, as K increases, the number of suffix tree nodes that are examined grows almost exponentially in K, which is in accordance with Ukkonen [7] .",
            "cite_spans": [
                {
                    "start": 66,
                    "end": 69,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 70,
                    "end": 72,
                    "text": "2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 94,
                    "end": 97,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 558,
                    "end": 561,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1161,
                    "end": 1164,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We cast the original problem into the problem of finding \"maximal paths\" in a special \"matching\" graph. 1 Via a careful study of this graph, we are able to derive interesting and useful properties that help us in devising a higly optimized depth-first search procedure for finding \"maximal paths,\" which correspond to the solutions of the original string problem. Our proposed algorithm runs in O(N M K 2 ) time, which is a significant improvement over the Baeza-Yates and Gonnet algorithm. Moreover, we experimentally show that our algorithm scales linearly (as opposed to quadratically) in K and it outperforms the Baeza-Yates and Gonnet algorithm by an order of magnitude for bigger values of K. Finally, our algorithm has an additional nice feature: it reversely depends on the alphabet size. This is contrary to the behavior of the Baeza-Yates and Gonnet algorithm, whose running time worsens with the increase of the alphabet size.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Let \u03a3 be a finite alphabet. A sequence of letters a 1 a 2 . . . a N , where a i \u2208 \u03a3 is called a string over \u03a3. We denote strings with s and t. Given string s, we denote its i-th letter with s[i], and we denote a substring of s starting at position i and ending at position j with s[i, j]. Substring s[i, j] has length j \u2212 i + 1. Let the edit distance for two strings s and t be the minimum number of edit operations needed to transform s into t, as defined in [4] . We say the pair (s, t) is a K-bounded approximate match if the edit distance between s and t is at most K. We solve Problem 1 by casting it to an equivalent problem on graphs induced by a \"matching matrix\".",
            "cite_spans": [
                {
                    "start": 460,
                    "end": 463,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "A Graph Model for the All-Against-All Substring Matching"
        },
        {
            "text": "The matching matrix of s and t (M s,t ) is defined as",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Graph Model for the All-Against-All Substring Matching"
        },
        {
            "text": "Based on matching matrix M, we define a weighted directed graph G M with vertices v ij corresponding to the 1-elements of the matrix, and with (directed) edges defined in a \"top-down\" and \"left-right\" fashion as follows: there is an edge e(v ij , v kl ) iff i < k and j < l (cf. Fig. 1 ). We define the cost of an edge",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 279,
                    "end": 285,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "A Graph Model for the All-Against-All Substring Matching"
        },
        {
            "text": "A path in graph G M is a sequence of vertices connected by edges. For a path in G M , we define two characteristic properties. The match length of path \u03c0 between v ij and v kl is defined as M L(\u03c0) = min(k \u2212 i + 1, l \u2212 j + 1). The error number, EN (\u03c0), is defined as the sum of all costs of edges in \u03c0.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Graph Model for the All-Against-All Substring Matching"
        },
        {
            "text": "Note that G M is not a dynamic programming (induced) graph (edit graph [4] ); DP graphs have been very well studied in the literature. However, to the best of our knowledge there is no work that formally studies the properties of G M graph. Graph G M possesses a very desirable property which is as follows.",
            "cite_spans": [
                {
                    "start": 71,
                    "end": 74,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "A Graph Model for the All-Against-All Substring Matching"
        },
        {
            "text": "v ij to v kl in G M .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Theorem 1. The edit distance between s[i, k] and t[j, l] is equal to the error number of the cheapest path(s) from"
        },
        {
            "text": "Input: The graph G M for two strings s and t, and positive integers K and S. Output: All maximal paths with EN \u2264 K and with match length at least S.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem 2. All paths below threshold"
        },
        {
            "text": "Based on Theorem 1 we conclude that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem 2. All paths below threshold"
        },
        {
            "text": "The problem all bounded approximate matches can be reduced to the all paths below threshold problem.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem 2. All paths below threshold"
        },
        {
            "text": "We show next how to construct an instance for all paths below threshold from an instance of all bounded approximate matches.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem 2. All paths below threshold"
        },
        {
            "text": "We outline the logic flow of algorithm APBT, omitting all formal proofs due to space constraints. In the full version of the paper we give a simple way for building and storing the matching matrix in linear time and space. As for graph G M , we never explicitly construct and store it (remaining so linear w.r.t. space). Rather, as we show, we traverse it by constructing the needed paths \"on the fly.\"",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "Path Expansion. We scan the matching matrix in row-major order. When a vertex of G M is encountered, we initialize a path \u03c0 with EN (\u03c0) = 0 and M L(\u03c0) = 1. The algorithm then builds all the possible expansions of this initial path by adding one vertex at a time and by keeping track of the best paths found so far. As paths are constructed, the algorithm examines each partially completed path \u03c0: if no more vertices can be added without exceeding threshold K, then we stop the expansion and check whether M L(\u03c0) \u2265 S. If true, then we report path \u03c0 as a solution.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "A Single-Step Path Expansion. Since the error number of a path cannot exceed K, an edge to be appended to a path clearly has to have a cost of at most K. As a consequence all edges in G M of cost higher than K are excluded from further consideration. Consider a path \u03c0 with error number EN (\u03c0), which ends at vertex v ij . From the above discussion, it is clear that for a single-step expansion of \u03c0 we need to search (in M) for a possible \"next vertex\" only inside square ABCD, where A = (i + 1, j + 1), and C = (i + 1 + \u03ba, j + 1 + \u03ba), for \u03ba = K \u2212 EN (\u03c0). We call square ABCD the target square for path \u03c0 at vertex v ij . The area of the target square decreases as the error number accumulated by \u03c0 increases.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "On the first sight, for any vertex v ij in G M there are at most (\u03ba + 1) \u00d7 (\u03ba + 1) outgoing edges to be considered. We show how to reduce the number of edges for consideration. For this, we introduce the following definitions regarding diagonals in the matching matrix M.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "Let (i, j) be an arbitrary cell in M.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "(2) Let q be a value between 0 and N \u2212 j. The (i, j)-q-upper diagonal is the (i, j + q)-main diagonal. (3) Let r be a value between 0 and M \u2212 i. The (i, j)-r-lower diagonal is the (i + r, j)-main diagonal.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "Let \u03c0 be a path in G M ending at vertex v ij and with EN (\u03c0) \u2264 K. Now, assume that v kl and v mn are two vertices in the target square for \u03c0 at v ij , which lie on one of the upper diagonals w.r.t. v ij . In terms of edge cost it means, that c(v ij , v kl ) = l \u2212 j \u2212 1, and c(v ij , v mn ) = n \u2212 j \u2212 1. Now, assume that i < k < m and j < l < n. This means that if we build an edge from v ij directly to v mn , we \"ignore\" vertex v kl , and unnecessarily increase EN (\u03c0). Rather, we better expand path \u03c0 to v kl and later on, in the next round, continue to v mn . Practically, this means that: if we find a vertex v kl on an upper diagonal of the target square, then we can exclude from the search for single-step expansion all the triangular area of the target square, which is bounded by (1) row k (exclusive), and (2) the upper diagonal passing through v kl (inclusive). Symmetrically, if vertex v kl lies on some lower diagonal, then we can exclude from the search for expansion all the triangular area of the target square, which is bounded by (1) column l (exclusive), and (2) the lower diagonal passing through v kl (inclusive). If vertex v kl lies on the main diagonal of the target square, then both triangular areas are excluded at once.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "In the full paper, we strengthen the above result by showing that we can safely exclude the row k (or column l) from the search for path expansion. Observe that, the scanning of a target square in this order guarantees that the exclusion of triangular areas takes place as early as possible.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Solving \"All Paths Below the Threshold\" (APBT)"
        },
        {
            "text": "Single path extension from an arbitrary vertex v ij in G M is performed at most once for each of the 2K + 1 diagonals surrounding v ij , and therefore the number of possible extensions for v ij is bounded by 2K + 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 2."
        },
        {
            "text": "is accessed at most once from each of 2K + 1 diagonals. This also implies that an arbitrary vertex v ij serves as a path extension for at most 2K + 1 vertices.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Corollary 3. An arbitrary cell of a matrix M[i, j]"
        },
        {
            "text": "We show next how the information from previously explored paths can be reused.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interdependence of Paths in G M ."
        },
        {
            "text": "Let \u03c0 1 be a previously explored path, which connects vertex v ij with v mn . Let \u03c0 2 be another path that we are currently exploring, which originates in v kl , and is built up to vertex v mn . Clearly, if EN (\u03c0 2 ) \u2265 EN (\u03c0 1 ) and M L(\u03c0 2 ) \u2264 M L(\u03c0 1 ), we can omit the further expansion of \u03c0 2 . An illustration is given in Fig. 1 , where path v 01 , v 13 , v 24 , v 46 serves as \u03c0 1 , which is explored earlier in a row-major order, and path v 04 , v 46 serves to exemplify \u03c0 2 . Clearly, path \u03c0 2 will only offer a sub-solution to the solution corresponding to \u03c0 1 , since the substring t [4, 6] is a substring of t [1, 6] .",
            "cite_spans": [
                {
                    "start": 594,
                    "end": 597,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 598,
                    "end": 600,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 621,
                    "end": 624,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 625,
                    "end": 627,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 327,
                    "end": 333,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Interdependence of Paths in G M ."
        },
        {
            "text": "Thus, if we remember the smallest error number among all paths, which reached a particular vertex, then at each vertex, we will do at most (K + 1) expansions. The row major processing order ensures, that if M L is defined by the length of the vertical substring, then M L(\u03c0 2 ) \u2264 M L(\u03c0 1 ). This is because both paths end at the same vertex, and \u03c0 2 starts at the same or later (greater) row than \u03c0 1 . Notably, if we repeat the computation in a column-major order, all paths where M L was defined by the horizontal substring will now be defined by the vertical substring, thus M L of the later path will again be less than M L of the previously built path. For more detailed explanations see the full version.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interdependence of Paths in G M ."
        },
        {
            "text": "The union of the solution sets of the two runs of the algorithm yields the final solution set.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interdependence of Paths in G M ."
        },
        {
            "text": "From the above, we can conclude, that each vertex in G M is expanded at most 2(K + 1) times. Proof. Since during path extension, any cell is accessed only once from at most 2K + 1 vertices (cf. Corollary 3) and each of these cells, if it is a vertex, is expanded at most 2(K + 1) times (cf. discussion), the upper bound for traversing a particular cell of the matrix is at most 2(K + 1)(2K + 1). Since there are at most M N many cells in M, the total time complexity is O(N M K 2 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interdependence of Paths in G M ."
        },
        {
            "text": "The pseudocode of our algorithm is given below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Interdependence of Paths in G M ."
        },
        {
            "text": "Expand path(\u03c0) scan M in row major order if ML(\u03c0) \u2265 S then if M[i, j] = 1 then add \u03c0 to the set of solutions create a single-vertex vij path \u03c0 EN (\u03c0) = 0 if a path with error number EN (\u03c0) Expand path(\u03c0) has already been extended through v kl then abort \u03c0 and return scan M in column major order if M[i, j] = 1 then Do a single-step expansion (if possible) of \u03c0 create a single-vertex vij path \u03c0 creating new expanded path \u03c0exp EN (\u03c0) = 0 Expand path(\u03c0) E x p a n d path (\u03c0exp)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "All paths below threshold(M,K,S)"
        },
        {
            "text": "We present an experimental evaluation of our All Paths Below Threshold algorithm as it compares with the algorithm of Baeza-Yates and Gonnet [2] . We implemented Gusfield's variant of the Baeza-Yates and Gonnet algorithm [4] . 2 We optimized it using Ukkonen's error bounded dynamic programming method [6] We abbreviate this optimized variant by BY G + U .",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 144,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 221,
                    "end": 224,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 227,
                    "end": 228,
                    "text": "2",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 302,
                    "end": 305,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Evaluation"
        },
        {
            "text": "The running time was tested on the same 1.2 GHz PC with 312 MB of RAM. Fig. 2 represents the running time of BY G + U and AP BT on a pair of RNA sequences belonging to viruses from the same family, and where the minimum length of matches is set to S = 50. Notably the AP BT algorithm outperforms the BY G+U algorithm for values of K \u2265 6. We also show the size of the output, and this clearly shows that in order to obtain any output at all, even for similar RNA sequences, one has to set a bigger or equal to 6 value of K. Interestingly, for K \u2264 5, the BY G + U algorithm outperforms the AP BT algorithm. This is because the BY G+U algorithm benefits from the early stop of deeply going in the suffix trees, when the accumulated error exceeds K. However, as K grows the BY G+U algorithm goes deeper in the suffix trees, and we observe an almost exponential in K increase in the running time. In contrast, AP BT scales on average linearly with K.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 71,
                    "end": 77,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Experimental Evaluation"
        },
        {
            "text": "Also, we emphasize the fact that for alphabets of bigger size the AP BT algorithm performs better than the BY G+ U algorithm. The performance of AP BT is orders of magnitute better than BY G+ U for protein sequences with alphabet size of 20. This can be explained by the greater \"bushiness\" of the suffix trees (used by BY G + U ) close to the root, and by the fact that with the increase of the alphabet size, our matching matrix becomes much sparser. The AP BT algorithm behaves so much better than the BY G + U algorithm that we had to plot their behavior in different scales (cf. Fig. 3 ). ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 584,
                    "end": 590,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Experimental Evaluation"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "All-against-all sequence matching",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "A"
                    ],
                    "last": "Baeza-Yates",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "H"
                    ],
                    "last": "Gonnet",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Rep. Dept. of CS",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A fast algorithm on average for all-against-all sequence matching",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "A"
                    ],
                    "last": "Baeza-Yates",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "H"
                    ],
                    "last": "Gonnet",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Proc. SPIRE/CRIWG 99",
            "volume": "",
            "issn": "",
            "pages": "16--23",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A New Algorithm for Fast All-Against-All Substring Matching",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Barsky",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Stege",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Thomo",
                    "suffix": ""
                },
                {
                    "first": "Upton",
                    "middle": [
                        "C A"
                    ],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Algorithms on Strings, Trees and Sequences",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Combinatorial approaches to finding subtle signals in DNA sequences",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Pevzner",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "H"
                    ],
                    "last": "Sze",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "Proc. ISMB 00",
            "volume": "",
            "issn": "",
            "pages": "269--278",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Algorithms for approximate string matching",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ukkonen",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "Information and Control",
            "volume": "64",
            "issn": "",
            "pages": "100--118",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Approximate string matching over suffix trees",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ukkonen",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "LNCS",
            "volume": "93",
            "issn": "",
            "pages": "228--242",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Pattern Discovery from Biosequences",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Vilo",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Matching matrix and partial induced graph. Only edges of cost at most 3 are shown; the directions of the edges are left out.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "In search for expansions, we scan the cells of the target square in a diagonal-major order, that is: first scan the main diagonal, possibly excluding parts of the target square from further scan. Next, scan the remaining of the target square through the 1-upper diagonal and the 1-lower diagonal, possibly excluding other areas of the target square. Then, continue with the 2-upper diagonal and the 2-lower diagonal and so on.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "The All Paths Below Threshold algorithm has a time complexity of O(N M K 2 ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Running time for two viral RNA sequences (30,000 bp): Human coronavirus 229E (27317 bp) and Human coronavirus OC43 (30738 bp) from[9]. The figure on the right is a zooming of the figure on the left for K < 8.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Effect of alphabet size (random strings pairs of length 1000)",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Problem 1. All error-bounded approximate matches Input: Strings s and t over alphabet \u03a3, and positive integers K and S. Output: All error bounded approximate maximal matches (s[i, j], t[k, l]) such that (1) the edit distance between s[i, j] and t[k, l] is at most K and (2) the lengths of both s[i, j] and t[k, l] are at least S.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}