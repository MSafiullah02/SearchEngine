{
    "paper_id": "06749abc643cb7bd0e304dfaeec38a697a7f2588",
    "metadata": {
        "title": "A 3.5-Approximation Algorithm for Sorting by Intergenic Transpositions",
        "authors": [
            {
                "first": "Andre",
                "middle": [],
                "last": "Rodrigues Oliveira",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Campinas",
                        "country": "Brazil"
                    }
                },
                "email": "andrero@ic.unicamp.br"
            },
            {
                "first": "G\u00e9raldine",
                "middle": [],
                "last": "Jean",
                "suffix": "",
                "affiliation": {
                    "laboratory": "LS2N, UMR CNRS 6004",
                    "institution": "University of Nantes",
                    "location": {
                        "settlement": "Nantes",
                        "country": "France"
                    }
                },
                "email": "geraldine.jean@univ-nantes.fr"
            },
            {
                "first": "Guillaume",
                "middle": [],
                "last": "Fertin",
                "suffix": "",
                "affiliation": {
                    "laboratory": "LS2N, UMR CNRS 6004",
                    "institution": "University of Nantes",
                    "location": {
                        "settlement": "Nantes",
                        "country": "France"
                    }
                },
                "email": "guillaume.fertin@univ-nantes.fr"
            },
            {
                "first": "Klairton",
                "middle": [],
                "last": "Lima Brito",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Campinas",
                        "country": "Brazil"
                    }
                },
                "email": "klairton@ic.unicamp.br"
            },
            {
                "first": "Ulisses",
                "middle": [],
                "last": "Dias",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Limeira",
                        "country": "Brazil"
                    }
                },
                "email": "ulisses@ft.unicamp.br"
            },
            {
                "first": "Zanoni",
                "middle": [],
                "last": "Dias",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of Campinas",
                    "location": {
                        "settlement": "Campinas",
                        "country": "Brazil"
                    }
                },
                "email": "zanoni@ic.unicamp.br"
            }
        ]
    },
    "abstract": [
        {
            "text": "Genome Rearrangements affect large stretches of genomes during evolution. One of the most studied genome rearrangement is the transposition, which occurs when a sequence of genes is moved to another position inside the genome. Mathematical models have been used to estimate the evolutionary distance between two different genomes based on genome rearrangements. However, many of these models have focused only on the (order of the) genes of a genome, disregarding other important elements in it. Recently, researchers have shown that considering existing regions between each pair of genes, called intergenic regions, can enhance the distance estimation in realistic data. In this work, we study the transposition distance between two genomes, but we also consider intergenic regions, a problem we name Sorting Permutations by Intergenic Transpositions (SbIT). We show that this problem is NP-hard and propose a 3.5-approximation algorithm for it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Genome rearrangements are events that modify genomes by inserting or removing large stretches of DNA sequences, or by changing the order and the orientation of genes inside genomes. A transposition [1] is a rearrangement that swaps the position of two adjacent sequences of genes inside a genome. Another example of genome rearrangement is the reversal [11] , that reverses the order and the orientation of a sequence of genes.",
            "cite_spans": [
                {
                    "start": 198,
                    "end": 201,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 353,
                    "end": 357,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "We compute the rearrangement distance between two genomes by determining the minimum number of events that transform one into another. A model M is a set of genome rearrangements that can be used to calculate the rearrangement distance.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Algorithms based on the rearrangement distance perform whole-genome comparison and may be used as a tool to infer phylogenetic relationships. The usual method fills a matrix of pairwise distances among genomes that is later used to generate phylogenetic trees [2, 12, 14] . As for \"classical\" rearrangements, having a large spectrum of models globally helps better-understanding things.",
            "cite_spans": [
                {
                    "start": 260,
                    "end": 263,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 264,
                    "end": 267,
                    "text": "12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 268,
                    "end": 271,
                    "text": "14]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "While in practice it is likely rarely so, if genomes contain no repeated gene and share the same set of n genes, they can be represented as permutations. Without loss of generality, we consider that one of these genomes is the identity permutation, i.e., the sorted permutation \u03b9 = (1 2 . . . n).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The Sorting by Rearrangements Problem thus consists in determining the shortest sequence of events from M that sorts a permutation \u03c0, i.e., that transforms it to \u03b9. Sorting by Rearrangements has been extensively studied in the past. For instance, Sorting by Transpositions has been proved NP-hard [6] , while the best algorithm so far has an approximation factor of 1.375 [8] .",
            "cite_spans": [
                {
                    "start": 297,
                    "end": 300,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 372,
                    "end": 375,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Representing genomes through their gene order (thus, by permutations) implies that information not contained directly in the genes is lost. In particular, in the case of intergenic regions, DNA sequences between the genes are not considered. Recently, some authors argued that incorporating intergenic regions sizes in the models changes the distance estimations, and actually improves them [3, 4] . It seems worth investigating models considering both gene order and intergenic sizes.",
            "cite_spans": [
                {
                    "start": 391,
                    "end": 394,
                    "text": "[3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 395,
                    "end": 397,
                    "text": "4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Results considering intergenic sizes for models with Double-Cut and Join (DCJ) and DCJs along with indels (i.e., insertions and deletions) are known: the former is NP-hard and it has a 4/3-approximation algorithm [9] , while the latter is polynomial [7] . In addition to the approximation algorithm, the authors in [7] also developed two exact algorithms: a fixed-parameter tractable algorithm and an integer linear programming formulation. Practical tests from [7] showed that statistical properties of the inferred scenarios using intergenic regions are closer to the true ones than scenarios which do not use them.",
            "cite_spans": [
                {
                    "start": 213,
                    "end": 216,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 250,
                    "end": 253,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 315,
                    "end": 318,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 462,
                    "end": 465,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Some results considering intergenic sizes with super short operations (i.e., a reversal or a transposition applied to one or two genes of the genome) are known [13] . Using the concept of breakpoints, Brito et al. showed a 4-approximation algorithm (resp. 6-approximation algorithm) for sorting by reversals (resp. reversals and transpositions) when also considering intergenic regions on unsigned permutations [5] . They also showed that both problems are NP-hard.",
            "cite_spans": [
                {
                    "start": 160,
                    "end": 164,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 411,
                    "end": 414,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we investigate the transposition distance between genomes that also takes into account intergenic regions, a problem we name Sorting by Intergenic Transpositions (SbIT). Instead of using breakpoints, here we propose a modification of a known graph structure to represent both gene order and intergenic sizes in a single graph. We show that SbIT is NP-hard, and, with the help of this adapted graph structure, we design a 3.5-approximation algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This work is organized as follows. Section 2 presents some definitions we extensively use throughout this paper. Section 3 presents the graph structure we use to produce our approximation algorithm. Section 4 contains a series of intermediate lemmas that support our algorithm. Section 5 describes the 3.5approximation algorithm for SbIT. Section 6 concludes the paper.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A genome G is a sequence of n genes denoted by g i , with i \u2208 [1..n], in which two consecutive genes g j\u22121 and g j , with j \u2208 [2..n], are separated by a noncoding region called intergenic region, denoted by r j -that are also present on its extremities (r 1 and r n+1 ): G = r 1 , g 1 , r 2 , g 2 , . . . , r n , g n , r n+1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "Given two genomes of closely related species, for the simplifying purposes of our initial analysis, we expect they will share the same set of genes, which may appear in different orders due to genome rearrangements. Selective pressures tend to conserve genes and not intergenic regions [3] . Therefore, genome rearrangements hardly cut inside genes, whereas cuts appear in intergenic regions.",
            "cite_spans": [
                {
                    "start": 286,
                    "end": 289,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "Our model assumes that (i) no gene is duplicated in a genome and (ii) both genomes share the same set of genes. We assign unique integer numbers in the range [1. .n] to each gene and represent them as a permutation. Therefore, the sequence of genes in a genome is modeled by a permutation \u03c0 = (\u03c0 1 \u03c0 2 . . . \u03c0 n ), \u03c0 i \u2208 N, 1 \u2264 \u03c0 i \u2264 n, and \u03c0 i = \u03c0 j for all i = j.",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 161,
                    "text": "[1.",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "We represent intergenic regions by their lengths instead of assigning unique identifiers to each of them, which would be pointless because rearrangements may split intergenic regions several times. The sequence of intergenic regions around n genes is represented as\u03c0 = (\u03c0 1\u03c02 . . .\u03c0 n +1 ),\u03c0 i \u2208 N. Intergenic region\u03c0 i is on the left side of \u03c0 i , whereas\u03c0 i+1 is on the right side.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "Our goal is to compute the distance between two genomes: (\u03c0,\u03c0) and (\u03c3,\u03c3). We may assign unique labels to genes arbitrarily, so we simplify the definition of our problem by setting \u03c3 as the identity permutation \u03b9, such that \u03c3 = \u03b9 = (1 2 . . . n) and\u03c3 =\u03b9, which describes all the information we need to our problem. Therefore, an instance of our problem is composed by three elements (\u03c0,\u03c0,\u03b9), such that n+1 i=1\u03c0 i = n+1 i=1\u03b9 i , which guarantees that total intergenic region lengths are conserved.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "An intergenic transposition is an operation \u03c1 (i,j,k) (x,y,z) , 1 \u2264 i < j < k \u2264 n+1, 0 \u2264 x \u2264\u03c0 i , 0 \u2264 y \u2264\u03c0 j , 0 \u2264 z \u2264\u03c0 k , and {x, y, z} \u2282 N. An intergenic transposition acts on instances to generate new ones: (\u03c0,\u03c0,\u03b9)\u00b7\u03c1 (i,j,k) (x,y,z) = (\u03c0 ,\u03c0 ,\u03b9), where (i) \u03c0 = (\u03c0 1 \u03c0 2 . . . \u03c0 i\u22121 \u03c0 j \u03c0 j+1 . . . \u03c0 k\u22121 \u03c0 i \u03c0 i+1 . . . \u03c0 j\u22121 \u03c0 k \u03c0 k+1 . . . \u03c0 n ), and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "As we can see, while \u03c1 (i,j,k) (x,y,z) keeps\u03b9 intact, it moves segments from \u03c0 and \u03c0 to other positions and also modifies the contents of three elements from\u03c0: it cuts\u03c0 i after first x nucleotides,\u03c0 j after first y nucleotides, and\u03c0 k after first z nucleotides, and rearranges them as defined above. Figure 1 shows examples of instances and the application of an intergenic transposition.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 300,
                    "end": 308,
                    "text": "Figure 1",
                    "ref_id": null
                }
            ],
            "section": "Basic Definitions"
        },
        {
            "text": "The intergenic transposition distance d t (\u03c0,\u03c0,\u03b9) is the minimum number m of intergenic transpositions \u03c1 1 , . . . , \u03c1 m that transform \u03c0 into \u03b9, and\u03c0 into\u03b9. Therefore, d t (\u03c0,\u03c0,\u03b9) = m implies a minimal sequence (\u03c0,\u03c0,\u03b9) \u00b7 \u03c1 1 \u00b7 . . . \u00b7 \u03c1 m = (\u03b9,\u03b9,\u03b9).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Basic Definitions"
        },
        {
            "text": "Proof. The Sorting by Transpositions problem (SbT) has already been proved NP-hard [6] . An instance of this problem consists of a permutation \u03b3 and a nonnegative integer d. The goal is to determine if its possible to transform \u03b3 into \u03b9 applying at most d transpositions.",
            "cite_spans": [
                {
                    "start": 83,
                    "end": 86,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Lemma 1. Sorting by Intergenic Transpositions (SbIT) is NP-hard."
        },
        {
            "text": "We can reduce all instances of SbT to instances of SbIT by setting \u03c0 = \u03b3 and\u03c0 =\u03b9 = (0 0 ... 0). Note that it is possible to transform \u03b3 into \u03b9 applying at most d transpositions if and only if d t (\u03c0,\u03c0,\u03b9) \u2264 d.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1. Sorting by Intergenic Transpositions (SbIT) is NP-hard."
        },
        {
            "text": "From now on, we will refer to intergenic transposition as transposition only.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1. Sorting by Intergenic Transpositions (SbIT) is NP-hard."
        },
        {
            "text": "We adapted a graph structure called breakpoint graph [1, 10] to conveniently represent an instance (\u03c0,\u03c0,\u03b9) in a single graph. This structure allows us to describe algorithms and prove approximation bounds. All definitions we propose here are exemplified in Figs. 2 and 3.",
            "cite_spans": [
                {
                    "start": 53,
                    "end": 56,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 57,
                    "end": 60,
                    "text": "10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "We represent a given instance by a weighted cycle graph G(\u03c0,\u03c0,\u03b9) =",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "the set of edges that can be either gray or black, and w : E \u2192 N is a function mapping edges to values corresponding to intergenic region lengths. The black edge set is {e i = (\u2212\u03c0 i , +\u03c0 i\u22121 ) : 1 \u2264 i \u2264 n + 1}, and w(e i ) =\u03c0 i . The gray edge set is {e i = (+(i \u2212 1), \u2212i) : 1 \u2264 i \u2264 n + 1}, and w(e i ) =\u03b9 i . In this definition, we consider \u03c0 0 = 0 and \u03c0 n+1 = n+1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "The graph can be drawn in many arbitrary ways, but it is more convenient to place its vertices on a horizontal line in the same order as the elements of \u03c0, so \u03c0 0 (resp. \u2212\u03c0 n+1 ) is the leftmost (resp. rightmost) element of it. In addition, Fig. 1 . Two (fictitious) genomes G1 and G2 that share 8 genes. We represent G1 as the identity permutation, which leads to G2 as the permutation \u03c0 = (3 2 1 7 6 4 8 5). We assume that the number of nucleotides between genes are good estimators for intergenic regions lengths. For example, in G1 before \"Gene 1\" we have 3 nucleotides, between \"Gene 1\" and \"Gene 2\" we have 5, and so on. Thus, (\u03c0,\u03c0,\u03b9) is such that \u03c0 = ( 3 2 1 7 6 4 8 5),\u03c0 = (1 7 0 4 2 7 4 0 9), and\u03b9 = ( 3 5 1 5 6 3 7 2 2). Genome G3 represents (\u03c0 ,\u03c0 ,\u03b9 ) = (\u03c0,\u03c0,\u03b9)\u00b7\u03c1 (2, 5, 6) (2,1,2) , so \u03c0 = ( 3 6 2 1 7 4 8 5),\u03c0 = (1 3 7 0 4 6 4 0 9).",
            "cite_spans": [
                {
                    "start": 775,
                    "end": 778,
                    "text": "(2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 779,
                    "end": 781,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 782,
                    "end": 784,
                    "text": "6)",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 241,
                    "end": 247,
                    "text": "Fig. 1",
                    "ref_id": null
                }
            ],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "for each element \u03c0 i \u2208 \u03c0, vertex \u2212\u03c0 i \u2208 G(\u03c0,\u03c0,\u03b9) is drawn to the left of vertex +\u03c0 i . Since black edges relate to \u03c0, they are drawn as horizontal lines, and we label the black edge e i as i. Gray edges are drawn as arcs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "Each vertex in G(\u03c0,\u03c0,\u03b9) has a gray edge and a black edge, which allows a unique decomposition of edges in cycles of alternating colors. Each cycle C with black edges is represented as a list (c 1 , c 2 , . . . , c ) of the labels from its black edges, and to make the notation unique we assume c 1 to be the index of the \"rightmost\" black edge (i.e., the black edge with the highest label using our default drawing) and we traverse it from right to left. We follow by several definitions regarding cycles.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "A cycle is long if it has 3 or more black edges; a cycle is short if it has 2 black edges; a cycle is trivial if it has 1 black edge; a cycle is non-trivial if it is either short or long. A non-trivial cycle C = (c 1 , . . . , c ) is non-oriented if c 1 , . . . , c is a decreasing sequence (note that every short cycle C is non-oriented); C is oriented otherwise.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "Given a non-trivial cycle C = (c 1 , . . . , c ), every pair of black edges e c i and Figure 3 shows an example of a weighted cycle graph and the application of an intergenic transposition on it, as well as the weighted cycle graph for an instance (\u03b9,\u03b9,\u03b9).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 86,
                    "end": 94,
                    "text": "Figure 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "Let c(\u03c0,\u03c0,\u03b9), c b (\u03c0,\u03c0,\u03b9) , and c u (\u03c0,\u03c0,\u03b9), denote the number of cycles, balanced cycles, and unbalanced cycles in G(\u03c0,\u03c0,\u03b9), respectively. Lemma 2. The instance (\u03b9,\u03b9,\u03b9) has two properties that do not occur together in any other instance: (i) c(\u03b9,\u03b9,\u03b9) = n + 1, and (ii) c b (\u03b9,\u03b9,\u03b9) = n + 1. As a consequence, we have that c u (\u03b9,\u03b9,\u03b9) = 0 (see Fig. 3(c) for an example).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 4,
                    "end": 25,
                    "text": "c(\u03c0,\u03c0,\u03b9), c b (\u03c0,\u03c0,\u03b9)",
                    "ref_id": null
                },
                {
                    "start": 343,
                    "end": 352,
                    "text": "Fig. 3(c)",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "Note that Sorting by Intergenic Transpositions is more complicated than the Sorting by Transpositions because increasing the number of cycles is not sufficient -these cycles need to be balanced.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "Given a sequence of transpositions S \u03c1 = (\u03c1 1 , \u03c1 2 , . . . , \u03c1 k ), let (\u03c0,\u03c0,\u03b9) \u00b7 S \u03c1 denotes (\u03c0,\u03c0,\u03b9) \u00b7 \u03c1 1 \u00b7 \u03c1 2 \u00b7 . . . \u00b7 \u03c1 k such that \u03c1 i+1 is always a transposition for (\u03c0,\u03c0,\u03b9)\u00b7\u03c1 1 \u00b7. . .\u00b7\u03c1 i with 1 \u2264 i < k. Let \u0394c(\u03c0,\u03c0,\u03b9, S \u03c1 ) = c((\u03c0,\u03c0,\u03b9)\u00b7S \u03c1 )\u2212c(\u03c0,\u03c0,\u03b9) and \u0394c b (\u03c0,\u03c0,\u03b9, S \u03c1 ) = c b ((\u03c0,\u03c0,\u03b9) \u00b7 S \u03c1 ) \u2212 c b (\u03c0,\u03c0,\u03b9) denote the variation in the number of cycles and balanced cycles, respectively, when S \u03c1 is applied to (\u03c0,\u03c0,\u03b9). Proof. From Lemma 3 we know that we can increase the number of cycles by at most 2. In this scenario, one cycle C is split in three by a single transposition \u03c1. If C is balanced, the best we can expect is that \u03c1 creates three balanced cycles, so \u0394c b (\u03c0,\u03c0,\u03b9, \u03c1) = 2. Otherwise, at least one of the resulting cycles shall be unbalanced too, since weights of black edges of the three cycles sum up to a value that is different from the sum of weights of gray edges. Therefore, the best we expect is that the other two cycles are balanced, so \u0394c b (\u03c0,\u03c0,\u03b9, \u03c1) = 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "Proof. By Lemma 2 we know that c b (\u03b9,\u03b9,\u03b9) = n + 1. Therefore, our goal is to increase the number of cycles from c b (\u03c0,\u03c0,\u03b9) to n+1; since this number increases by at most 2 for each transposition (Lemma 4), the lemma follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Weighted Cycle Graph"
        },
        {
            "text": "This section presents properties and lemmas to support the 3.5-approximation presented in Sect. 5 .",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 97,
                    "text": "5",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Preliminary Results"
        },
        {
            "text": "Let e c x and e c y be two arbitrary black edges in the same cycle C = (c 1 , . . . , c ), with {x, y} \u2282 [1.. ]. We define the function f :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminary Results"
        },
        {
            "text": "In other words, given the path P of black and gray edges that goes from e c x to e c y , f (e c x , e c y ) computes the sum of weights of gray edges in P minus the weights of black edges from P -excluding the black edges e c x and e c y . Observe that we traverse the first black edge in the cycle from right to left, which means that the path that goes from e c x to e c y is different from the path that goes from e c y to e c x .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminary Results"
        },
        {
            "text": "Note that f (e c x , e c y ) + f (e c y , e c x ) \u2212 w(e c x ) \u2212 w(e c y ) indeed computes the sum of weights of all gray edges minus the sum of weights of all black edges.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminary Results"
        },
        {
            "text": "We follow by presenting several lemmas, that will later be combined to prove the correctness of our 3.5-approximation algorithm. Let us first present the ideas behind them. Due to space constraints, proofs of Lemmas 6-13 are omitted. However, it can be seen in Fig. 4 how (and in which case) each of these lemmas is applied, as explained in detail right after the lemmas.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 261,
                    "end": 267,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Preliminary Results"
        },
        {
            "text": "The next two lemmas deal with non-trivial negative cycles. Lemmas 6 and 8 show that it is always possible to increase balanced cycles by applying one transposition on negative cycles that are non-oriented and oriented, respectively. C = (c 1 , . . . , c k ) be a non-trivial oriented cycle. If C is not positive, there is a triple (c x , c y , c z ) with c x > c z > c y and",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 233,
                    "end": 257,
                    "text": "C = (c 1 , . . . , c k )",
                    "ref_id": null
                },
                {
                    "start": 324,
                    "end": 349,
                    "text": "triple (c x , c y , c z )",
                    "ref_id": null
                }
            ],
            "section": "Preliminary Results"
        },
        {
            "text": "1 \u2264 x < y < z \u2264 k such that 0 \u2264 f (e c x , e c y ) \u2264 w(c x ) + w(c y ), or 0 \u2264 f (e c y , e c z ) \u2264 w(c y ) + w(c z ), or 0 \u2264 f (e c z , e c x ) \u2264 w(c z ) + w(c x ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 7. Let"
        },
        {
            "text": "Let C be an oriented long negative cycle. There is a transposition that increases the number of balanced cycles by 1 and the number of cycles by 2. Now let us explain how to deal with trivial negative cycles. We use Lemma 9 as an intermediary step to the correctness of Lemma 10, that shows how many transpositions are needed to transform trivial negative cycles into trivial balanced. The next three lemmas dealing with non-trivial balanced cycles. Lemmas 11, 12 and 13 show that it is possible to increase balanced cycles by applying transpositions on oriented long balanced cycles, non-oriented long balanced cycles, and short balanced cycles, respectively. Lemma 11. Let C be an oriented long balanced cycle. Then it is possible to increase the number of balanced cycles by two after at most three transpositions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 8."
        },
        {
            "text": "Lemma 13. Let G be a graph with no long cycles such that all cycles are balanced. If G has short cycles it is possible to increase the number of balanced cycles by two after two transpositions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 12. Let C be a non-oriented long balanced cycle in a graph with no oriented cycles. It is possible to increase the number of balanced cycles by four after at most seven transpositions."
        },
        {
            "text": "In Fig. 4(a) the blue cycle A = (6, 4, 2) is non-oriented and negative, so we can apply Lemma 6 using the positive cycle B = (7, 5), and the intergenic transposition \u03c1 (2,6,7) (5,4,1) generates in Fig. 4 (b) the trivial balanced cycle C = (2), and the non-trivial cycle D = (7, 5, 3, 6) , that in this case is negative and oriented. We then can use Lemma 8 on D, and the transposition \u03c1 (3, 6, 7) (2,1,0) generates in Fig. 4 (c) the trivial balanced cycle E = (3), the trivial cycle F = (7), and the short cycle G = (6, 4) . Note that F is negative and G is balanced. At this stage, there is no long cycle, and we can use Lemma 10 on the trivial negative cycle F . This lemma requires a positive cycle to interact with the trivial negative, and H = (8) is the only positive cycle. Since H is also trivial, we need to borrow a black edge of a balanced cycle to apply the transposition, so let us use the short balanced cycle G. Two consecutive transpositions on these black edges (see shows a sequence of intergenic transpositions that sorts the instance (\u03c0,\u03c0,\u03b9) with \u03c0 = (3 2 1 6 5 4 7), \u03c0 = (2, 6, 5, 4, 1, 4, 3, 0), and\u03b9 = (4, 1, 3, 5, 2, 3, 6, 1) using Lemmas 6-10 and 13. (h)-(n) shows a sequence of intergenic transpositions that sorts the instance (\u03c0,\u03c0,\u03b9) with \u03c0 = (5 4 3 2 1 6 8 7),\u03c0 = (3, 7, 8, 3, 7, 4, 10, 1, 2) , and\u03b9 = (3, 1, 6, 5, 9, 8, 4, 2, 7) using Lemmas 11 and 12. (Color figure online) Fig. 4(c) and (d)) generate two balanced cycles I = (7) and J = (8) in Fig. 4(e) , without modifying G. The weighted cycle graph in Fig. 4 (e) has only balanced cycles, and they are either short or trivial. In this case we can use Lemma 13 that applies two intergenic transpositions to two non-oriented short cycles, in this case G = (6, 4) and K = (5, 1). The two consecutive transpositions applied to G and K (see Fig. 4 (e) and (f)) generate four balanced cycles, increasing the number of balanced cycles by 2, and completing the sorting process -the weighted cycle graph in Fig. 4 (g) has only balanced cycles.",
            "cite_spans": [
                {
                    "start": 274,
                    "end": 277,
                    "text": "(7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 278,
                    "end": 280,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 281,
                    "end": 283,
                    "text": "3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 284,
                    "end": 286,
                    "text": "6)",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 387,
                    "end": 390,
                    "text": "(3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 391,
                    "end": 393,
                    "text": "6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 394,
                    "end": 396,
                    "text": "7)",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 516,
                    "end": 519,
                    "text": "(6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 520,
                    "end": 522,
                    "text": "4)",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1293,
                    "end": 1296,
                    "text": "(3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1297,
                    "end": 1299,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1300,
                    "end": 1302,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1303,
                    "end": 1305,
                    "text": "3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1306,
                    "end": 1308,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1309,
                    "end": 1311,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1312,
                    "end": 1315,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1316,
                    "end": 1318,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1319,
                    "end": 1321,
                    "text": "2)",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1331,
                    "end": 1334,
                    "text": "(3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1335,
                    "end": 1337,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1338,
                    "end": 1340,
                    "text": "6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 1341,
                    "end": 1343,
                    "text": "5,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1344,
                    "end": 1346,
                    "text": "9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 1347,
                    "end": 1349,
                    "text": "8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1350,
                    "end": 1352,
                    "text": "4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1353,
                    "end": 1355,
                    "text": "2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1356,
                    "end": 1358,
                    "text": "7)",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 12,
                    "text": "Fig. 4(a)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 197,
                    "end": 203,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 418,
                    "end": 424,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1405,
                    "end": 1414,
                    "text": "Fig. 4(c)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1476,
                    "end": 1485,
                    "text": "Fig. 4(e)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1537,
                    "end": 1543,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1821,
                    "end": 1827,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1983,
                    "end": 1989,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Lemma 12. Let C be a non-oriented long balanced cycle in a graph with no oriented cycles. It is possible to increase the number of balanced cycles by four after at most seven transpositions."
        },
        {
            "text": "In Fig. 4 (h) the green cycle A = (9, 7, 8) is oriented, and since it is also balanced we can use Lemma 11. The three transpositions in Fig. 4(h-j) breaks A into three balanced cycles. In Fig. 4(k) we have only balanced non-oriented cycles, and we can use Lemma 12 that applies a transposition followed by Lemma 11 twice. The first transposition is applied over cycle B = (5, 3, 1) transforming the blue cycle in Fig. 4 (k) into an oriented balanced cycle C = (6, 2, 4). The first application of Lemma 11 breaks C into three balanced cycles (in this case, one transposition is sufficient) and also transforms the non-oriented cycle B into the oriented cycle B = (5, 1, 3) (from Fig. 4 (l) to (m)). The second application of Lemma 11 breaks B into three balanced cycles (using again only one transposition), completing the sorting process - Fig. 4(g) has only balanced cycles.",
            "cite_spans": [
                {
                    "start": 34,
                    "end": 37,
                    "text": "(9,",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 38,
                    "end": 40,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 41,
                    "end": 43,
                    "text": "8)",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 306,
                    "end": 314,
                    "text": "Lemma 11",
                    "ref_id": null
                }
            ],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 9,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 136,
                    "end": 147,
                    "text": "Fig. 4(h-j)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 188,
                    "end": 197,
                    "text": "Fig. 4(k)",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 413,
                    "end": 419,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 678,
                    "end": 684,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 840,
                    "end": 849,
                    "text": "Fig. 4(g)",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Lemma 12. Let C be a non-oriented long balanced cycle in a graph with no oriented cycles. It is possible to increase the number of balanced cycles by four after at most seven transpositions."
        },
        {
            "text": "Algorithm 1 focuses on applying transpositions that increase the number of balanced cycles, following a sequence of steps using Lemmas 6, 8, 10, 11, 12, and 13.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The 3.5-Approximation Algorithm"
        },
        {
            "text": "Data: an instance (\u03c0,\u03c0,\u03b9). Result: a sequence \u03c11, \u03c12, . . . , \u03c1m such that (\u03c0,\u03c0) \u00b7 \u03c11 \u00b7 \u03c12 \u00b7 . . . \u00b7 \u03c1m = (\u03b9,\u03b9). 1 sequence \u2190 \u2205 2 while (\u03c0,\u03c0,\u03b9) = (\u03b9,\u03b9,\u03b9) do Let us briefly show the correctness of Algorithm 1, i.e., it stops and reaches (\u03b9,\u03b9,\u03b9).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "While (\u03c0,\u03c0,\u03b9) = (\u03b9,\u03b9,\u03b9) we have that one of the following must be true: (i) there is an oriented cycle. in this scenario we break this cycle if it is balanced or negative on lines 5 and 7; (ii) there is a negative cycle (considering that they are not oriented): we create balanced cycles if it is non-oriented or trivial on lines 9 and 11; and (iii) cycles are all balanced, and there is no oriented cycles. If there is a long cycle we break it at line 13, and we break short cycles at line 15.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "Note that we did not care about the positive oriented cycles: they become either balanced or negative before the algorithm uses (iii), and will be handled in (i) at some point. If the algorithm reaches (iii) then all cycles are balanced since any negative cycle is handled by (i) and (ii).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "Concerning the complexity of Algorithm 1, the loop of lines 2-17 iterates up to m = n+1 times. Since each time the algorithm applies one of those lemmas, it increases the number of balanced cycles by at least one. Finding which lemma to use (and at which positions the transposition takes place) requires O(n 2 ) time. Thus, the overall complexity of Algorithm 1 is O(n 3 ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "Now let us discuss about the approximation factor Algorithm 1 guarantees. Note that some of the steps of the algorithm require more than one transposition, so the approximation factor will be computed as follows: Definition 14. Let S \u03c1 = (\u03c1 1 , \u03c1 2 , . . . , \u03c1 d ) be a sequence of transpositions such that (\u03c0,\u03c0,\u03b9) \u00b7 S \u03c1 = (\u03c3,\u03c3,\u03b9). By Lemma 4, S \u03c1 creates up to 2d balanced cycles. Therefore, the approximation factor is at most 2d cb (\u03c3,\u03c3 ,\u03b9)\u2212cb (\u03c0 ,\u03c0 ,\u03b9) .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "The following lemma shows that each step of Algorithm 1 guarantees an approximation factor of 3.5 or less, which leads to the 3.5-approximation algorithm we propose.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "Lemma 15. Algorithm 1 has an approximation factor of 3.5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "Proof. We use the formula from Definition 14 to calculate the approximation factor of each step.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "-Step using Lemma 8 creates at least one new balanced cycle using one transposition, which leads to the maximum approximation 2 1 = 2. -Step using Lemma 11 creates at least two new balanced cycles using up to three transpositions, so its maximum approximation factor is 6 2 = 3. -Step using Lemma 6 creates a new balanced cycles using one transposition, and its approximation is 2 1 = 2. -Step using Lemma 10 it creates two new balanced cycles using two transpositions, so its approximation is 4 2 = 2. -Step using Lemma 12 creates four new balanced cycle using up to seven transpositions, and it follows that the maximum approximation is 14 4 = 3.5. -Step using Lemma 13 creates two new balanced cycles using two transpositions, so it follows that its approximation is 4 2 = 2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Algorithm 1. a 3.5-approximation algorithm for SbIT."
        },
        {
            "text": "We adapted the breakpoint graph to represent both gene order and intergenic sizes, and investigated properties of this new graph structure during a sorting process. As a result, we were able to design an approximation algorithm for the Sorting by Intergenic Transpositions. We also show that this problem is NP-Hard.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "As future works, one can explore a problem where the probability of an intergenic region being affected by transpositions is related to its size, i.e., when genome rearrangements are more likely to cut the genome on bigger intergenic regions. One can also investigate the use of reversals and transpositions on signed permutations along with intergenic regions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Sorting by transpositions",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Bafna",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "A"
                    ],
                    "last": "Pevzner",
                    "suffix": ""
                }
            ],
            "year": 1998,
            "venue": "SIAM J. Discrete Math",
            "volume": "11",
            "issn": "2",
            "pages": "224--240",
            "other_ids": {
                "DOI": [
                    "10.1137/S089548019528280X"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Genome rearrangement distances and gene order phylogeny in \u03b3-proteobacteria",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Belda",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Moya",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "J"
                    ],
                    "last": "Silva",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Mol. Biol. Evol",
            "volume": "22",
            "issn": "6",
            "pages": "1456--1467",
            "other_ids": {
                "DOI": [
                    "10.1093/molbev/msi134"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Breaking good: accounting for fragility of genomic regions in rearrangement distance estimation",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Biller",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Gu\u00e9guen",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Knibbe",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Genome Biol. Evol",
            "volume": "8",
            "issn": "5",
            "pages": "1427--1439",
            "other_ids": {
                "DOI": [
                    "10.1093/gbe/evw083"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Comparative genomics on artificial life",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Biller",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Knibbe",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Beslon",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "CiE 2016",
            "volume": "9709",
            "issn": "",
            "pages": "35--44",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-40189-8_4"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Sorting by genome rearrangements on both gene order and intergenic sizes",
            "authors": [
                {
                    "first": "K",
                    "middle": [
                        "L"
                    ],
                    "last": "Brito",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jean",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Fertin",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Oliveira",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Dias",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Dias",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "J. Comput. Biol",
            "volume": "27",
            "issn": "2",
            "pages": "156--174",
            "other_ids": {
                "DOI": [
                    "10.1089/cmb.2019.0293"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Sorting by transpositions is difficult",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Bulteau",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Fertin",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Rusu",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "SIAM J. Comput",
            "volume": "26",
            "issn": "3",
            "pages": "1148--1180",
            "other_ids": {
                "DOI": [
                    "10.1137/110851390"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Genome rearrangements with indels in intergenes restrict the scenario space",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Bulteau",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Fertin",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "BMC Bioinform",
            "volume": "17",
            "issn": "S14",
            "pages": "225--231",
            "other_ids": {
                "DOI": [
                    "10.1186/s12859-016-1264-6"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "A 1.375-approximation algorithm for sorting by transpositions",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Elias",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Hartman",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinform",
            "volume": "3",
            "issn": "4",
            "pages": "369--379",
            "other_ids": {
                "DOI": [
                    "10.1109/TCBB.2006.44"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Algorithms for computing the double cut and join distance on both gene order and intergenic sizes",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Fertin",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jean",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Algorithm Mol. Biol",
            "volume": "12",
            "issn": "16",
            "pages": "1--11",
            "other_ids": {
                "DOI": [
                    "10.1186/s13015-017-0107-y"
                ]
            }
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Transforming men into mice (polynomial algorithm for genomic distance problem)",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Hannenhalli",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "A"
                    ],
                    "last": "Pevzner",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Proceedings of the 36th Annual IEEE Symposium Foundations of Computer Science (FOCS 1995)",
            "volume": "",
            "issn": "",
            "pages": "581--592",
            "other_ids": {
                "DOI": [
                    "10.1109/SFCS.1995.492588"
                ]
            }
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Exact and approximation algorithms for sorting by reversals, with application to genome rearrangement",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "D"
                    ],
                    "last": "Kececioglu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sankoff",
                    "suffix": ""
                }
            ],
            "year": 1995,
            "venue": "Algorithmica",
            "volume": "13",
            "issn": "",
            "pages": "180--210",
            "other_ids": {
                "DOI": [
                    "10.1007/BF01188586"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "TIBA: a tool for phylogeny inference from rearrangement data with bootstrap analysis",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Lin",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Rajan",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "M E"
                    ],
                    "last": "Moret",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Bioinformatics",
            "volume": "28",
            "issn": "24",
            "pages": "3324--3325",
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/bts603"
                ]
            }
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Super short operations on both gene order and intergenic sizes",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "R"
                    ],
                    "last": "Oliveira",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Jean",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Fertin",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Dias",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Dias",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Algorithm Mol. Biol",
            "volume": "14",
            "issn": "21",
            "pages": "1--17",
            "other_ids": {
                "DOI": [
                    "10.1186/s13015-019-0156-5"
                ]
            }
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Distancebased genome rearrangement phylogeny",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "S"
                    ],
                    "last": "Wang",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Warnow",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [
                        "M E"
                    ],
                    "last": "Moret",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [
                        "K"
                    ],
                    "last": "Jansen",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [
                        "A"
                    ],
                    "last": "Raubeson",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "J. Mol. Evol",
            "volume": "63",
            "issn": "4",
            "pages": "473--483",
            "other_ids": {
                "DOI": [
                    "10.1007/s00239-005-0216-y"
                ]
            }
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Besides, the pair of black edges e c 1 and e c is called an open gate if c 1 > c j > c for any c j \u2208 C with j \u2208 {1, }. Note that on every short cycle C = (c 1 , c 2 ) the pair e c 1 , e c 2 is an open gate.Bafna and Pevzner[1] showed that for every open gate e c i and e c j from C with c i > c j there exists another non-trivial cycle D with black edges e d i ande d j such that either c i > d i > c j > d j or d i > c i > d j > c j .In this case, we say that D closes this open gate.Figure 2 shows two examples of cycles with open gates and how cycles can close these open gates. Cycles can be either balanced or unbalanced. A cycle C = (c 1 , . . . , c ) is balanced if i=1 |w(e c i ) \u2212 w(e c i )| = 0, and is unbalanced otherwise. In other words, one cycle is balanced if the sum of weights of gray edges equals the sum of weights of black edges, and it is unbalanced otherwise. An unbalanced cycle C = (c 1 , . . . , c ) is called positive if i=1 (w(e c i ) \u2212 w(e c i )) > 0, and it is called negative otherwise.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "(a) The cycle C = (c 1 , c 2 ) has an open gate (c 1 , c 2 ) closed by D = (d 1 , d 2 ) on the right. (b) The cycle F = (f 1 , f 2 , f 3 ) has three open gates (f 1 , f 2 ), (f 2 , f 3 ), and (f 3 , f 1 ) closed by G = (g 1 , g 2 , g 3 ) on the right.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "\u0394c(\u03c0,\u03c0,\u03b9, \u03c1) \u2208 {2, 0, \u22122} for any transposition \u03c1.Proof. Straightforward from Bafna and Pevzner[1].",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "We color the figure to improve cycle visualization. Black edges are drawn as horizontal lines, and gray edges are drawn as arcs. Arrows over black edges represent how we traverse them, and numbers on the top of the image indicate black edges labels. (a) The weighted cycle graph G(\u03c0,\u03c0,\u03b9) for \u03c0 = . G(\u03c0,\u03c0,\u03b9) has four cycles: A = (8, 6) is a non-oriented positive short cycle; B = (7, 5) is a non-oriented short negative cycle; C = (4) is a trivial balanced cycle, and D = (3, 1, 2) is an oriented long negativecycle. (b)The weighted cycle graph G((\u03c0,\u03c0,\u03b9) \u00b7 \u03c1 3,1) ), with \u0394c(\u03c0,\u03c0,\u03b9, \u03c1) = 2 and \u0394c b (\u03c0,\u03c0,\u03b9, \u03c1) = 1. The transposition applied to the negative cycle D from (a) transformed it into three trivial cycles D = (3), D = (2), and D = (1) such that D is balanced. (c) The weighted cycle graph G(\u03b9,\u03b9,\u03b9), with c(\u03b9,\u03b9,\u03b9) = c b (\u03b9,\u03b9,\u03b9) = n + 1, and cu(\u03b9,\u03b9,\u03b9) = 0.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "\u0394c b (\u03c0,\u03c0,\u03b9, \u03c1) \u2264 2 for any transposition \u03c1.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "It is possible to make any redistribution of weights of three distinct black edges e b 1 , e b 2 , and e b 3 using two transpositions. Lemma 10. Let G be a weighted cycle graph in which all negative cycles are trivial. Then, there are two transpositions that increase the number of balanced cycles by 2.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Black egdes are drawn as horizontal lines, and their labels are on the top of the figure. Gray edges are drawn as arcs. (a)-(g)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "\u2190 G(\u03c0,\u03c0,\u03b9) 4 if there exists an oriented cycle C in G that is either balanced or negative then 5 if C is negative then 6 S\u03c1 \u2190 transposition from Lemma 8 7 else S\u03c1 \u2190 transpositions from Lemma 11 8 else if there exists a negative cycle C in G that is either non-oriented or trivial then 9 if C is non-oriented then 10 S\u03c1 \u2190 transposition from Lemma 6 11 else S\u03c1 \u2190 transpositions from Lemma 10 12 else 13 if there exists a long balanced cycle C in G then 14 S\u03c1 \u2190 transpositions from Lemma 12 15 else S\u03c1 \u2190 transpositions from Lemma 13 16(\u03c0,\u03c0,\u03b9) \u2190 (\u03c0,\u03c0,\u03b9) \u00b7 S\u03c1 17 sequence.append(S\u03c1) 18 return sequence",
            "latex": null,
            "type": "figure"
        }
    },
    "back_matter": []
}