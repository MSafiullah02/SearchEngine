{
    "paper_id": "PMC7197061",
    "metadata": {
        "title": "TreeSolve: Rapid Error-Correction of Microbial Gene Trees",
        "authors": [
            {
                "first": "Carlos",
                "middle": [],
                "last": "Mart\u00edn-Vide",
                "suffix": "",
                "email": "carlos.martin@urv.cat",
                "affiliation": {}
            },
            {
                "first": "Miguel",
                "middle": [
                    "A."
                ],
                "last": "Vega-Rodr\u00edguez",
                "suffix": "",
                "email": "mavega@unex.es",
                "affiliation": {}
            },
            {
                "first": "Travis",
                "middle": [],
                "last": "Wheeler",
                "suffix": "",
                "email": "travis.wheeler@umontana.edu",
                "affiliation": {}
            },
            {
                "first": "Misagh",
                "middle": [],
                "last": "Kordi",
                "suffix": "",
                "email": "misagh.kordi@uconn.edu",
                "affiliation": {}
            },
            {
                "first": "Mukul",
                "middle": [
                    "S."
                ],
                "last": "Bansal",
                "suffix": "",
                "email": "mukul.bansal@uconn.edu",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "One of the most fundamental tasks in studying gene family evolution is the construction of a gene tree showing the evolutionary relationships among individual genes from that gene family. However, it is well known that gene trees can be very hard to reconstruct accurately and there is often considerable uncertainty in gene tree topologies reconstructed using gene sequences alone [2, 8\u201310]. To address the problem of gene tree error, many species-tree-aware methods have been developed for reconstructing or error-correcting gene trees. These methods make use of a known species tree and a phylogenetic reconciliation model that makes it possible to extract topological information from the species tree and use it to guide gene tree inference. In this work, we focus specifically on the reconstruction of microbial gene trees, where the relevant phylogenetic reconciliation model is the Duplication-Transfer-Loss (DTL) reconciliation which models the evolution of gene trees within species trees through speciation, gene duplication, gene loss, and horizontal gene transfer. Given its importance to understanding microbial evolution, the DTL reconciliation problem has been widely studied, e.g., [1, 3, 4, 7, 11\u201316], and all existing species-tree-aware methods for microbial gene trees are based on DTL reconciliation or its variants. Existing species-tree-aware methods for microbial gene trees include AnGST [3], MowgliNNI [9], ALE [15], PrIME-DLTRS [12], TreeFix-DTL [2], TERA [11], and ecceTERA [5]. Amongst all these methods, TreeFix-DTL [2] and ecceTERA [5] have been shown to be among the most accurate. Both TreeFix-DTL and ecceTERA are gene tree error-correction methods that take as input a previously reconstructed sequence-only gene tree and error-correct it based on a given species tree. Note that ecceTERA also implements the amalgamation-based algorithm implemented in TERA [11]; however, in this manuscript, ecceTERA refers only to the implementation of the gene tree resolution algorithm from [5].",
            "cite_spans": [
                {
                    "start": 383,
                    "end": 384,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 386,
                    "end": 387,
                    "mention": "8",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 388,
                    "end": 390,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 1200,
                    "end": 1201,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1203,
                    "end": 1204,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1206,
                    "end": 1207,
                    "mention": "4",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1209,
                    "end": 1210,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1212,
                    "end": 1214,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1215,
                    "end": 1217,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1414,
                    "end": 1415,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 1429,
                    "end": 1430,
                    "mention": "9",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 1438,
                    "end": 1440,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1456,
                    "end": 1458,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 1474,
                    "end": 1475,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1484,
                    "end": 1486,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1503,
                    "end": 1504,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1547,
                    "end": 1548,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 1564,
                    "end": 1565,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 1894,
                    "end": 1896,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 2015,
                    "end": 2016,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "In this work, we introduce a new species-tree-aware method, TreeSolve (portmanteau of Tree and Resolve), for error-correction of microbial gene trees that significantly outperforms the best existing methods in terms of accuracy, speed, or both. TreeSolve builds upon two key ideas already used for microbial gene tree error-correction and combines and extends them in novel ways. The first of these two keys ideas is to handle gene tree uncertainty by collapsing all weakly supported edges in the input sequence-based gene tree, resulting in a non-binary gene tree, and then optimally resolving this non-binary gene trees by reconciling to the given species tree, e.g., [5, 7, 17]. The second key idea is the consideration of gene tree bootstraps or other replicates to constrain the search space for the final gene tree to only a biologically meaningful subset of the full search space [3, 11, 15]. While both of these ideas have been separately used before, TreeSolve combines and extends them to achieve improved speed and accuracy. Specifically, TreeSolve collapses weakly supported edges of the input gene tree, resulting in a non-binary gene tree, and then uses new algorithms and techniques to optimally resolve the non-binary gene trees with respect to the given species tree in a constrained search space defined by a collection of bootstrap/replicate gene tree. An important novel aspect of our algorithm is that it is self-adaptive in that it can automatically increase or decrease the search space by considering only those clades that appear in at least a certain fraction of the bootstrap/replicate gene trees (by default, the considered clades should appear in at least one of the bootstrap/replicate gene trees). This self-adaptability is required because, even with the constraints imposed by the gene tree bootstraps/replicates, the number of optimal resolutions can grow exponentially in the degree and number of non-binary nodes in the given non-binary gene tree. By dynamically increasing or decreasing the minimum support value required for the clades considered, the algorithm is guaranteed to be very efficient even on very large and highly non-binary gene trees while still maintaining its accuracy. Another key strength of TreeSolve is that it implicitly keeps track of multiple, equally optimal, gene tree resolutions; it can either output a single best estimate of the gene tree or it can output multiple distinct gene tree candidates ordered by their average bootstrap/replicate support values.",
            "cite_spans": [
                {
                    "start": 671,
                    "end": 672,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 674,
                    "end": 675,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 677,
                    "end": 679,
                    "mention": "17",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 888,
                    "end": 889,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 891,
                    "end": 893,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 895,
                    "end": 897,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We compared the accuracy and runtime of TreeSolve against the two most accurate gene tree error-correction methods for microbial gene trees, TreeFix-DTL [2] and ecceTERA [5], using an extensive experimental study with thousands of real and simulated gene trees. TreeFix-DTL has been previously demonstrated to have greater accuracy than AnGST and MowgliNNI [2], and ecceTERA demonstrated to have either greater or comparable accuracy to ALE, TERA, and PrIME-DLTRS [5, 11]). Furthermore, ecceTERA is among the fastest species-tree-aware methods currently available for microbial gene trees, and it is also the method conceptually most similar to TreeSolve. Our results demonstrate that (i) TreeSolve is orders of magnitude faster and far more scalable than TreeFix-DTL, while matching or exceeding it in accuracy on larger gene trees, (ii) TreeSolve is significantly more accurate than ecceTERA and has comparable running times, (iii) the self-adaptive algorithm implemented in TreeSolve is highly scalable and efficient and can be easily applied to large genome-scale datasets and gene trees having many hundreds of leaves, and (iv) aggregating over multiple gene tree candidates output by TreeSolve helps distinguish between correct and incorrect branches of an error-corrected gene tree. An implementation of TreeSolve is available from https://compbio.engr.uconn.edu/software/TreeSolve/.",
            "cite_spans": [
                {
                    "start": 154,
                    "end": 155,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 171,
                    "end": 172,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 358,
                    "end": 359,
                    "mention": "2",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 465,
                    "end": 466,
                    "mention": "5",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 468,
                    "end": 470,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Given \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} and S, along with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varDelta $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varTheta $$\\end{document}, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_{loss}$$\\end{document}, a most parsimonious reconciliation (MPR) for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} and S is a DTL-scenario with minimum reconciliation cost.",
            "cite_spans": [],
            "section": "Definition 1 (MPR) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Optimal Gene Tree Resolution. TreeSolve works by first converting the given binary gene tree into a non-binary gene tree by collapsing weakly supported edges (based on a user-provided threshold), and then optimally resolving this non-binary gene tree based on the species tree under appropriate topological constraints. A closely related problem formulation that has been previously studied is that of optimal gene tree resolution (OGTR) under DTL reconciliation [6, 7]. In the OGTR problem, given non-binary gene tree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} and a species tree, one must find a binary resolution \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} such that an MPR of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} with S has smallest reconciliation cost. Moreover, since there may be more than one optimal binary resolution of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document}, the desired formulation of the problem is to find all optimal resolutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document}. This leads to the following computational problem [7].",
            "cite_spans": [
                {
                    "start": 464,
                    "end": 465,
                    "mention": "6",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 467,
                    "end": 468,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 2591,
                    "end": 2592,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Definition 1 (MPR) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Given \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} and S, along with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varDelta $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varTheta $$\\end{document}, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_{loss}$$\\end{document}, the All Optimal Gene Tree Resolutions (OGTR-All) problem is to compute the set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {OR} (G^{N})$$\\end{document} of all optimal binary resolutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} such that, for any \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} \\in \\mathcal {OR} (G^{N})$$\\end{document}, an MPR of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} and S has the smallest reconciliation cost among all gene trees in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {BR} (G^{N})$$\\end{document}.",
            "cite_spans": [],
            "section": "Problem 1 (OGTR-All) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "The OGTR-All problem is known to be NP-hard [6] (even for computing a single optimal resolution), and existing algorithms are limited to solving instances in which the maximum out-degree in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} is small [7].",
            "cite_spans": [
                {
                    "start": 45,
                    "end": 46,
                    "mention": "6",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 492,
                    "end": 493,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Problem 1 (OGTR-All) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Constrained Optimal Gene Tree Resolution. In addition to its very high computational time complexity, which greatly limits its applicability, the OGTR-All problem ignores sequence information and is therefore prone to over-fitting the gene tree to the species tree. TreeSolve addresses both these limitations by constraining the set of binary resolutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} that can be considered. Specifically, TreeSolve allows all binary resolutions that are supported by the sequence data and disallows those that are unsupported. To achieve this goal TreeSolve solves a constrained version of the OGTR-All problem in which, in addition to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} and S, we take as input a set of unrooted gene trees that define constraints on the set of binary resolutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document}. The set of unrooted gene trees used should represent a sample of gene tree topologies supported by the sequence data and can be easily obtained by either computing bootstrap replicates or sampling from the posterior distribution in a Bayesian analysis.",
            "cite_spans": [],
            "section": "Problem 1 (OGTR-All) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "More formally, let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B} = \\{B_1, B_2, \\ldots , B_b\\}$$\\end{document} denote a sample of b unrooted gene trees. Then, we define the cluster set of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document} to be: \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B}) = \\bigcup _{i=1}^{b} {{\\,\\mathrm{\\textit{Cluster}}\\,}}(B_i)$$\\end{document}. This set of clusters is used to define the constrained set of binary resolutions as follows.",
            "cite_spans": [],
            "section": "Problem 1 (OGTR-All) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Given \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document} and a non-binary tree T, we say that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T'$$\\end{document} is a constrained binary resolution of T (with respect to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}), if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$T' \\in \\mathcal {BR} (T)$$\\end{document} and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{Clade}}\\,}}(T') \\subseteq {{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B})$$\\end{document}. We denote by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {CBR} (T)$$\\end{document} the set of all constrained binary resolutions of a rooted non-binary tree T.",
            "cite_spans": [],
            "section": "Definition 2 (Constrained binary resolution) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "The idea of a constrained binary resolution is illustrated in Fig. 1. We can now state the constrained optimal gene tree resolution problem.\n",
            "cite_spans": [],
            "section": "Definition 2 (Constrained binary resolution) ::: Definitions and Preliminaries",
            "ref_spans": [
                {
                    "start": 67,
                    "end": 68,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "Given \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document}, S, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}, along with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varDelta $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varTheta $$\\end{document}, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_{loss}$$\\end{document}, the All Constrained Optimal Gene Tree Resolutions (C-OGTR) problem is to compute the set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {COR} (G^{N})$$\\end{document} of all optimal constrained binary resolutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} such that, for any \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} \\in \\mathcal {COR} (G^{N})$$\\end{document}, an MPR of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} and S has the smallest reconciliation cost among all gene trees in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {CBR} (G^{N})$$\\end{document}.",
            "cite_spans": [],
            "section": "Problem 2 (C-OGTR) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Note: To ensure that a solution always exists to the C-OGTR problem, TreeSolve includes the original binary gene tree from which \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} is obtained in the set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}. This ensures, that a constrained binary resolution of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} always exists.",
            "cite_spans": [],
            "section": "Problem 2 (C-OGTR) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "We also define a variant of the problem above that only seeks to find a single optimal reconciliation with highest average clade support.",
            "cite_spans": [],
            "section": "Problem 2 (C-OGTR) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Given \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document}, S, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}, along with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varDelta $$\\end{document}, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_\\varTheta $$\\end{document}, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$P_{loss}$$\\end{document}, the Best Constrained Optimal Gene Tree Resolutions (C-OGTR-Best) problem is to compute a tree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} \\in \\mathcal {CBR} (G^{N})$$\\end{document} such that the total number of occurrences in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document} of all clades in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{B} $$\\end{document} is the largest among all trees in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {CBR} (G^{N})$$\\end{document}.",
            "cite_spans": [],
            "section": "Problem 3 (C-OGTR-Best) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Note that TreeSolve does not directly solve the C-OGTR and C-OGTR-Best problems. Rather, for improved efficiency and accuracy, TreeSolve solves variants of these problems where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B})$$\\end{document} is further restricted to only contain those clusters that are present in at least a certain number, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{minSup}}\\,}}$$\\end{document}, of the samples in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{minSup}}\\,}}$$\\end{document} is updated dynamically during the search. Furthermore, TreeSolve maintains ordered lists of binary resolutions at each step sorted by average support value (i.e., by the total number of occurrences in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document} of all clades in that binary resolution).",
            "cite_spans": [],
            "section": "Problem 3 (C-OGTR-Best) ::: Definitions and Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Our algorithms for the C-OGTR and C-OGTR-Best problems leverage the dynamic programming algorithm for the OGTR-All problem described in [7]. The primary difference is that the new algorithms limit the possible binary resolutions considered at each non-binary node to those that can be constructed from the clusters available in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B})$$\\end{document}. Further technical details are omitted for brevity. Here, we describe how solutions for C-OGTR/C-OGTR-Best are used within TreeSolve as part of the larger self-adaptive approach and optimal resolution ordering.",
            "cite_spans": [
                {
                    "start": 137,
                    "end": 138,
                    "mention": "7",
                    "ref_id": "BIBREF14"
                }
            ],
            "section": "Algorithmic Overview",
            "ref_spans": []
        },
        {
            "text": "TreeSolve\u2019s Self-adaptive Algorithm. Note that, despite the restriction on permitted resolutions imposed by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}, the total number of constrained optimal binary resolutions can be exponential in the number of non-binary nodes of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document} as well as its maximum out-degree. To address this limitation, TreeSolve employs a novel self-adaptive approach to limit the number of binary resolutions considered at each non-binary node. To describe the self-adaptive approach, we need some additional definitions and notation. We first define an upper bound, denoted U, on the total number of binary resolutions considered by TreeSolve during any step in its execution. For example, for all the experimental results presented in the next section, we assigned \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$U = 25000$$\\end{document}. We also define the following:\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B}, {{\\,\\mathrm{\\textit{minSup}}\\,}}) = \\{ x \\in {{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B}) \\mid x \\text { appears in at least }{{\\,\\mathrm{\\textit{minSup}}\\,}}\\text { trees from }\\mathbb {B}\\}.$$\\end{document}Finally, define \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N(g, {{\\,\\mathrm{\\textit{minSup}}\\,}})$$\\end{document} to be the number of distinct binary resolutions of the non-binary node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g \\in G^{N} $$\\end{document} permitted by the cluster set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{Cluster}}\\,}}(\\mathbb {B}, {{\\,\\mathrm{\\textit{minSup}}\\,}})$$\\end{document}. For each non-binary node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g \\in G^{N} $$\\end{document} independently, TreeSolve computes a value for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$${{\\,\\mathrm{\\textit{minSup}}\\,}}$$\\end{document} for which \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N(g, {{\\,\\mathrm{\\textit{minSup}}\\,}}) \\le U$$\\end{document} but \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N(g, {{\\,\\mathrm{\\textit{minSup}}\\,}}-1) > U$$\\end{document}. This can be accomplished efficiently through a binary-search in the range \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$[1, |\\mathbb {B}|]$$\\end{document}. Thus, at each non-binary node of the gene tree, we limit the total number of resolutions considered to at most U of the most highly supported ones.",
            "cite_spans": [],
            "section": "Algorithmic Overview",
            "ref_spans": []
        },
        {
            "text": "Ordering of Binary Resolutions by Average Clade Support. In addition to its use for limiting the number of possible resolutions at each non-binary node, TreeSolve also uses the upper bound U to bound the total number of resolutions considered at the subtree rooted at each node of the gene tree. In other words, TreeSolve executes a variant of the algorithm for C-OGTR that always limits the total number of resolutions of the subtree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document} stored at any node g of the gene tree to U. In particular, at each node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g \\in G^{N} $$\\end{document} the algorithm only stores up to the U best (in terms of average clade support) resolutions for the subtree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document} encountered during the search, ordered by their average clade support. We denote this ordered list of the U best resolutions for the subtree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document} by \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (g)$$\\end{document} (for optimal resolution vector). Note that each resolution stored in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (g)$$\\end{document} also has an associated average clade support value stored along with it. Next, we describe how each \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (\\cdot )$$\\end{document} is computed as part of the bottom-up dynamic programming traversal of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} $$\\end{document}. We first need some additional notation. Given any binary or non-binary node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g \\in G^{N} $$\\end{document}, define the set of nearest non-binary descendants of g, denoted \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {N}(g)$$\\end{document}, to be {\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$h \\in V(G^{N} (g)) \\setminus \\{g\\} \\mid h$$\\end{document} is non-binary and no other non-binary nodes exist on the path from g to h}. Note that \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {N}(g)$$\\end{document} may be empty.",
            "cite_spans": [],
            "section": "Algorithmic Overview",
            "ref_spans": []
        },
        {
            "text": "Consider any binary or non-binary node \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$g \\in G^{N} $$\\end{document}. If all nodes in the subtree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document} are binary then there is only one possible resolution (i.e., the current resolution). If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {N}(g) = \\emptyset $$\\end{document} but g itself is non-binary then we apply the self-adaptive approach described above and compute up to U binary resolutions of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document}. These resolutions are then sorted according to decreasing average clade support (based on the trees in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathbb {B}$$\\end{document}) and stored as \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (g)$$\\end{document}. If \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {N}(g) \\ne \\emptyset $$\\end{document} and g is binary, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (g)$$\\end{document} can be computed by suitably combining the vectors \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (h)$$\\end{document}, for each \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$h \\in \\mathcal {N}(g)$$\\end{document}, already computed in previous steps of the algorithm. Observe that each combination of resolutions from the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (h)$$\\end{document}\u2019s, across all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$h \\in \\mathcal {N}(g)$$\\end{document}, yields a permitted resolution for the subtree \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document}. Since each \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (h)$$\\end{document} is in sorted order and each resolution is associated with its average clade support value, computing the U best resolutions for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document}, i.e., computing \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (g)$$\\end{document}, can be accomplished by performing a merge-like procedure (from merge sort) on the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (h)$$\\end{document}\u2019s to identify just the U best resolutions for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$G^{N} (g)$$\\end{document}. The remaining case, where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {N}(g) \\ne \\emptyset $$\\end{document} and g is non-binary can be handled similarly by considering the sorted list of permitted resolutions for node g together with the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (h)$$\\end{document}\u2019s.",
            "cite_spans": [],
            "section": "Algorithmic Overview",
            "ref_spans": []
        },
        {
            "text": "Computing Only a Single Best Resolution. By default, TreeSolve computes a sorted list of up to U (where \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$U = 25000$$\\end{document} in all our experiments) distinct best resolutions of the initial non-binary gene tree. However, in many applications, only a single best estimate of the error-corrected gene tree may be required. Indeed, most existing species-tree-aware methods for microbial gene tree error-correction, including TreeFix-DTL and ecceTERA, only compute a single best gene tree. It is easy to see that the first tree output by TreeSolve corresponds to this best tree, i.e., with highest average clade support. However, if only the best solution was required, TreeSolve could make use of the simpler C-OGTR-Best problem formulation, instead of the C-OGTR problem as described above. Solving the C-OGTR-Best problem is simpler and more efficient than the C-OGTR problem (though still potentially exponential). Specifically, to only compute the resolution with highest average clade support, we need not maintain \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\mathcal {ORV} (\\cdot )$$\\end{document} vectors and only need to save the best resolution corresponding to each subproblem c(g, s).",
            "cite_spans": [],
            "section": "Algorithmic Overview",
            "ref_spans": []
        },
        {
            "text": "Simulated Datasets Results. We first compared the accuracies of TreeSolve, ecceTERA, and TreeFix-DTL on the 24 baseline simulated datasets. These results are shown in Fig. 2. As the figure shows, TreeSolve results in significantly more accurate gene tree resolutions than ecceTERA in 19 out of the 24 datasets (and across all high DTL datasets), while TreeFix-DTL outperforms both ecceTERA and TreeSolve on all 24 datasets. As we discuss later, this improved accuracy of TreeFix-DTL comes at the expense of orders of magnitude greater running time. The average normalized Robinson-Foulds distances (NRFD) for RAxML, ecceTERA, TreeSolve, and TreeFix-DTL are 7.4%, 3.9%, 3.1%, and 1.86%, respectively, across the 12 normal sequence-length datasets, and 12.5%, 7.6%, 6.6%, and 3.8%, respectively, across the 12 short sequence datasets. As expected, all three species-tree-aware methods were significantly more accurate than the sequence-only method RAxML, and absolute error rates for all four methods were higher for the short (173) sequence length datasets than for the normal (333) length datasets. Interestingly, we observed that while the accuracies of ecceTERA and TreeFix-DTL consistently worsen with increasing DTL rates, the accuracy of TreeSolve is only slightly affected by DTL rates (Fig. 2). As a result, the accuracy of TreeSolve starts to approach that of TreeFix-DTL on the high DTL datasets. Specifically, the average NRFDs across the high-DTL datasets for TreeFix are 2.7% and 5.1% for the normal and short sequence-length datasets, respectively, while for TreeSolve these numbers are only slightly larger at 3.5% and 6.9%, respectively.\n",
            "cite_spans": [],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": [
                {
                    "start": 172,
                    "end": 173,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1298,
                    "end": 1299,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Impact of Gene Tree Size. To study the impact of tree size on the relative accuracies of the three methods, we used the two simulated datasets of 100 gene tree/species tree pairs each on 200 taxa. As expected, TreeSolve continues to significantly outperform ecceTERA on these larger datasets, with an average NRFD of 3.0% for ecceTERA and only 1.8% for TreeSolve. More significantly, we find that TreeSolve slightly outperforms TreeFix-DTL on these larger trees, with average NRFD of 1.8% to TreeFix-DTL\u2019s 1.85%. This is not entirely surprising, since TreeFix-DTL relies on an iterative local search approach that can become less effective as tree size increases. Thus, TreeSolve can be expected to outperform all other methods for larger gene trees.",
            "cite_spans": [],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": []
        },
        {
            "text": "Impact of Enumerating Multiple Optimal Resolutions. Recall that a key feature of TreeSolve is that it can compute and output multiple optimal resolutions, ordered by their average support values. To explore the impact of considering multiple optimal resolutions instead of only using the \u201cbest\u201d resolution computed through TreeSolve, we computed the false positive and false negative branch rates for the strict consensus of all multiple optimal resolutions computed by TreeSolve. We found that the strict consensus of all optimal resolutions computed by TreeSolve results in a significantly lower false positive rate compared to just using the \u201cbest\u201d TreeSolve gene trees across each of the 24 datasets, with an overall average of 3.45% versus 5.85%, respectively. This suggests that the optimal resolutions computed by TreeSolve can be used to distinguish between correct and incorrect gene tree edges. Unsurprisingly, this improvement in the false positive rate comes at the expense of an increased false negative rate, with the average normalized false negative rate over all 24 datasets being 8.5 for the strict consensus of all multiple optimal resolutions computed by TreeSolve. For brevity, detailed results on individual datasets are omitted from this manuscript.",
            "cite_spans": [],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": []
        },
        {
            "text": "Running Time and Scalability. Both ecceTERA and TreeSolve required only a few seconds per simulated gene tree. Specifically, the average running time of ecceTERA was 2.9 s per tree across the 24 baseline simulated datasets, and for TreeSolve the corresponding average running time was 10.2 s. TreeFix-DTL was far slower than ecceTERA and TreeSolve, requiring an average of over an hour for each of the trees in these 24 baseline simulated datasets. On the larger 200-taxon simulated datasets, ecceTERA and TreeSolve averaged 2.5 s and 82 s per gene tree, respectively. In contrast, TreeFix-DTL required an average of over 10 h per gene tree. Thus, TreeSolve is almost three orders of magnitude faster than TreeFix-DTL on these larger gene trees while also showing better accuracy. All timed runs were executed using a single core on a commodity Macbook Pro laptop with 16 GB of RAM and a 2.3 GHz Intel i9 CPU.",
            "cite_spans": [],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": []
        },
        {
            "text": "Results on Real Dataset. We studied the impact of applying ecceTERA, TreeSolve and TreeFix-DTL on a real biological dataset of over 4736 gene trees from 100 predominantly prokaryotic species [3]. We found that 4419 out of the 4736 gene trees became non-binary at the 90% bootstrap cutoff threshold, and ecceTERA and TreeSolve were thus able to error-correct these 4419 trees. Over all gene trees, ecceTERA had an average running time of 15.1 s and a maximum running time of 317 s. TreeSolve had a slightly larger average running time of 71.6 s and a maximum of 1736 s. Note that the largest gene tree in this dataset has 600 leaves. This demonstrates how TreeSolve can be applied to very large gene trees within minutes.",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 193,
                    "mention": "3",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": []
        },
        {
            "text": "For the 4419 non-binary gene trees, we found that ecceTERA resulted in an average decrease of 26.4% in the reconciliation cost of the error-corrected gene trees. For TreeSolve, this decrease was a much larger 38.5%. The magnitude of decrease in reconciliation cost is a highly imperfect proxy for gene tree accuracy; still, these numbers suggest that TreeSolve is more effective at error-correcting these real gene trees.",
            "cite_spans": [],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": []
        },
        {
            "text": "In contrast to ecceTERA and TreeSolve, which executed within minutes on even the largest gene trees, TreeFix-DTL required more than a week of running time on each of the larger gene trees in this dataset.",
            "cite_spans": [],
            "section": "Results ::: Experimental Evaluation",
            "ref_spans": []
        },
        {
            "text": "In this work, we introduced a new species-tree-aware method, TreeSolve, for error-correcting microbial gene trees. TreeSolve combines new and existing techniques and uses novel algorithms to strike a balance between speed and accuracy. As our extensive experimental analysis demonstrates, TreeSolve significantly outperforms the best existing species-tree-aware methods for microbes in terms of accuracy, speed, or both. TreeSolve is especially effective for error-correction of large gene trees, where it makes it possible to perform speedy error-correction without any compromise on reconstruction accuracy. Furthermore, TreeSolve has the extremely useful ability to compute not just a single best estimate of the error-corrected gene tree but a ranked list of multiple distinct \u201croughly equally good\u201d candidates. As we show in our experimental study, the resulting ability to aggregate over multiple gene tree candidates helps distinguish between correct and incorrect relationships in an error-corrected gene tree. Overall, TreeSolve has the potential to transform the reconstruction of large microbial gene trees and to increase the robustness of downstream evolutionary inferences by enabling the accounting of gene tree reconstruction uncertainty.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "FIGREF0": {
            "text": "Fig. 1.: Constrained binary resolutions. Given the (rooted) non-binary gene tree on the top left and the three (unrooted) bootstrap replicate gene trees on the right, the figure shows a possible constrained binary resolution of the non-binary gene tree. Note that each new clade in the binary resolution appears as a cluster in at least one of the three bootstrap replicate trees. These clusters are highlighted using the yellow boxes. Each internal edge in the gene trees is labeled by its branch support (number in red), i.e., the number of bootstrap replicates that support that branch. In this example, the constrained binary resolution happens to be a constrained optimal binary resolution since no other constrained binary resolution has higher average branch support. (Color figure online)",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: Accuracy on baseline datasets. Error rates are shown for gene trees inferred using RAxML, ecceTERA, TreeSolve, and TreeFix-DTL on the 12 normal sequence-length (top) and 12 short sequence-length (bottom) simulated datasets.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss",
            "authors": [
                {
                    "first": "MS",
                    "middle": [],
                    "last": "Bansal",
                    "suffix": ""
                },
                {
                    "first": "EJ",
                    "middle": [],
                    "last": "Alm",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kellis",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Bioinformatics",
            "volume": "28",
            "issn": "12",
            "pages": "283-291",
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/bts225"
                ]
            }
        },
        "BIBREF1": {
            "title": "A bayesian approach for fast and accurate gene tree reconstruction",
            "authors": [
                {
                    "first": "MD",
                    "middle": [],
                    "last": "Rasmussen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kellis",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Mol. Biol. Evol.",
            "volume": "28",
            "issn": "1",
            "pages": "273-290",
            "other_ids": {
                "DOI": [
                    "10.1093/molbev/msq189"
                ]
            }
        },
        "BIBREF2": {
            "title": "Joint amalgamation of most parsimonious reconciled gene trees",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Jacox",
                    "suffix": ""
                },
                {
                    "first": "GJ",
                    "middle": [],
                    "last": "Szollosi",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Bioinformatics",
            "volume": "31",
            "issn": "6",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/btu728"
                ]
            }
        },
        "BIBREF3": {
            "title": "A bayesian method for analyzing lateral gene transfer",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Sjostrand",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tofigh",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Daubin",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Arvestad",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Sennblad",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lagergren",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Syst. Biol.",
            "volume": "63",
            "issn": "3",
            "pages": "409-420",
            "other_ids": {
                "DOI": [
                    "10.1093/sysbio/syu007"
                ]
            }
        },
        "BIBREF4": {
            "title": "Inferring duplications, losses, transfers and incomplete lineage sorting with nonbinary species trees",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Stolzer",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Lai",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Xu",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Sathaye",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Vernot",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Durand",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Bioinformatics",
            "volume": "28",
            "issn": "18",
            "pages": "409-415",
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/bts386"
                ]
            }
        },
        "BIBREF5": {
            "title": "Phylogenetic modeling of lateral gene transfer reconstructs the pattern and relative timing of speciations",
            "authors": [
                {
                    "first": "GJ",
                    "middle": [],
                    "last": "Szollosi",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Boussau",
                    "suffix": ""
                },
                {
                    "first": "SS",
                    "middle": [],
                    "last": "Abby",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Daubin",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proc. Natl. Acad. Sci. USA",
            "volume": "109",
            "issn": "43",
            "pages": "17513-17518",
            "other_ids": {
                "DOI": [
                    "10.1073/pnas.1202997109"
                ]
            }
        },
        "BIBREF6": {
            "title": "Lateral gene transfer from the dead",
            "authors": [
                {
                    "first": "GJ",
                    "middle": [],
                    "last": "Szollosi",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lartillot",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Daubin",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Syst. Biol.",
            "volume": "62",
            "issn": "3",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1093/sysbio/syt003"
                ]
            }
        },
        "BIBREF7": {
            "title": "Simultaneous identification of duplications and lateral gene transfers",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Tofigh",
                    "suffix": ""
                },
                {
                    "first": "MT",
                    "middle": [],
                    "last": "Hallett",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Lagergren",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinform.",
            "volume": "8",
            "issn": "2",
            "pages": "517-535",
            "other_ids": {
                "DOI": [
                    "10.1109/TCBB.2010.14"
                ]
            }
        },
        "BIBREF8": {
            "title": "Reconciliation with non-binary gene trees revisited",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Research in Computational Molecular Biology",
            "volume": "",
            "issn": "",
            "pages": "418-432",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Improved gene tree error correction in the presence of horizontal gene transfer",
            "authors": [
                {
                    "first": "MS",
                    "middle": [],
                    "last": "Bansal",
                    "suffix": ""
                },
                {
                    "first": "YC",
                    "middle": [],
                    "last": "Wu",
                    "suffix": ""
                },
                {
                    "first": "EJ",
                    "middle": [],
                    "last": "Alm",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kellis",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Bioinformatics",
            "volume": "31",
            "issn": "8",
            "pages": "1211-1218",
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/btu806"
                ]
            }
        },
        "BIBREF10": {
            "title": "Rapid evolutionary innovation during an archaean genetic expansion",
            "authors": [
                {
                    "first": "LA",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "EJ",
                    "middle": [],
                    "last": "Alm",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Nature",
            "volume": "469",
            "issn": "",
            "pages": "93-96",
            "other_ids": {
                "DOI": [
                    "10.1038/nature09649"
                ]
            }
        },
        "BIBREF11": {
            "title": "An efficient algorithm for gene/species trees parsimonious reconciliation with losses, duplications and transfers",
            "authors": [
                {
                    "first": "J-P",
                    "middle": [],
                    "last": "Doyon",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                },
                {
                    "first": "KY",
                    "middle": [],
                    "last": "Gorbunov",
                    "suffix": ""
                },
                {
                    "first": "GJ",
                    "middle": [],
                    "last": "Sz\u00f6ll\u0151si",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Ranwez",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Berry",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Comparative Genomics",
            "volume": "",
            "issn": "",
            "pages": "93-108",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "Resolution and reconciliation of non-binary gene trees with transfers, duplications and losses",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Jacox",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Weller",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Tannier",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Bioinformatics",
            "volume": "33",
            "issn": "7",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1093/bioinformatics/btw778"
                ]
            }
        },
        "BIBREF13": {
            "title": "On the complexity of duplication-transfer-loss reconciliation with non-binary gene trees",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kordi",
                    "suffix": ""
                },
                {
                    "first": "MS",
                    "middle": [],
                    "last": "Bansal",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IEEE/ACM Trans. Comput. Biology Bioinform.",
            "volume": "14",
            "issn": "3",
            "pages": "587-599",
            "other_ids": {
                "DOI": [
                    "10.1109/TCBB.2015.2511761"
                ]
            }
        },
        "BIBREF14": {
            "title": "Exact algorithms for duplication-transfer-loss reconciliation with non-binary gene trees",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kordi",
                    "suffix": ""
                },
                {
                    "first": "MS",
                    "middle": [],
                    "last": "Bansal",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "IEEE/ACM Trans. Comput. Biology Bioinform.",
            "volume": "16",
            "issn": "4",
            "pages": "1077-1019",
            "other_ids": {
                "DOI": [
                    "10.1109/TCBB.2017.2710342"
                ]
            }
        },
        "BIBREF15": {
            "title": "Treefam: a curated database of phylogenetic trees of animal gene families",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Nucleic Acids Res.",
            "volume": "34",
            "issn": "Suppl. 1",
            "pages": "D572-D580",
            "other_ids": {
                "DOI": [
                    "10.1093/nar/gkj118"
                ]
            }
        },
        "BIBREF16": {
            "title": "Accounting for gene tree uncertainties improves gene trees and reconciliation inference",
            "authors": [
                {
                    "first": "TH",
                    "middle": [],
                    "last": "Nguyen",
                    "suffix": ""
                },
                {
                    "first": "J-P",
                    "middle": [],
                    "last": "Doyon",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Pointet",
                    "suffix": ""
                },
                {
                    "first": "A-MA",
                    "middle": [],
                    "last": "Chifolleau",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Ranwez",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Berry",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Algorithms in Bioinformatics",
            "volume": "",
            "issn": "",
            "pages": "123-134",
            "other_ids": {
                "DOI": []
            }
        }
    }
}