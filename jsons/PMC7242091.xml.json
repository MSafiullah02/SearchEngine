{
    "paper_id": "PMC7242091",
    "metadata": {
        "title": "Validating Multiple Variants of an Automotive Light System with Electrum",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Alcino",
                "middle": [],
                "last": "Cunha",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Nuno",
                "middle": [],
                "last": "Macedo",
                "suffix": "",
                "email": "nfmmacedo@di.uminho.pt",
                "affiliation": {}
            },
            {
                "first": "Chong",
                "middle": [],
                "last": "Liu",
                "suffix": "",
                "email": null,
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Electrum [10] is a state-based modelling language that extends the structural definitions and first-order relational logic of Alloy [8] with mutable relations and (past and future) linear temporal logic (LTL) operators. Its companion Analyzer [2], itself an extension of the Alloy Analyzer, provides support for validation \u2013 through scenario animation \u2013 and verification \u2013 through two automatic model checking backends, one bounded and another complete. Both animation instances and verification counter-examples are presented back to the user in a unified graphical interface. The combination of first-order and temporal logic makes Electrum well-suited to address systems rich in both structural and dynamic properties, such as automotive software product lines with architectural and behavioural variability. To further ease the feature-oriented design of software families, language extensions to Alloy have also been proposed [1, 9].",
            "cite_spans": [
                {
                    "start": 10,
                    "end": 12,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 133,
                    "end": 134,
                    "mention": "8",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 244,
                    "end": 245,
                    "mention": "2",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 932,
                    "end": 933,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 935,
                    "end": 936,
                    "mention": "9",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "This paper reports the modelling and subsequent validation and verification of an adaptive exterior lights system (ELS) with multiple variants in Electrum1, carried out as an answer to the ABZ\u201920 call for case study submissions, following the successful submission to ABZ\u201918 [4]. The employed approach \u2013 which we hope can be applied to similar signal-based systems \u2013 is presented in Sect. 2. As described in Sect. 3, we have been able to model most ELS requirements by finding an abstraction sweet-spot \u2013 in particular for real-time issues. The Electrum language is presented throughout this section as needed. Section 4 describes two explored approaches to modelling multiple variants, one in pure Electrum and another using language extension for feature-oriented design [9]. The ELS model was validated against all the provided validation sequences [7], and verified for most of the ELS requirements, as described in Sect. 5. To ease validation, a prototype was developed to translate tabular validation sequences into Electrum and back for inspection by domain experts. Lastly, Sect. 6 discusses issues identified in the requirements and limitations of the followed approach.",
            "cite_spans": [
                {
                    "start": 276,
                    "end": 277,
                    "mention": "4",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 774,
                    "end": 775,
                    "mention": "9",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 853,
                    "end": 854,
                    "mention": "7",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The main goal of this work was to validate the ELS requirements by checking their feasibility and consistency for all valid variants. We started by modelling a single variant of the ELS as a (rough) state machine against which the validation sequences were tested and the requirements subsequently verified. An Electrum model contains both the system specification and the analysis commands, thus our model, described in detail in Sect. 3, is structured as follows:Environment the available input and output signals, their acceptable values, and possible restrictions to their evolution [6, \u00a74.1\u20134.3].ELS state machine a predicate calculating the state of output signals (mostly) from the current state of the input ones, allowing alternative behaviours; inferred from the requirements [6, \u00a74.4].Animation scenarios simple state sequences, and associated run commands, that exercise the ELS for preliminary validation and regression testing.Reference scenarios the encoding of the provided validation sequences [7], and associated run commands, with imposed inputs and expected outputs, for validating the modelled ELS state machine; a prototype was developed to translate them from the provided tabular format [7].Visual elements elements ignored by the analyses but aiding the visualization of scenarios (accompanied by a theme, stored in a separate file).Requirement assertions the formalization of the requirements [6, \u00a74.4] in temporal logic, and associated check commands to automatically verify them; these assess the overall consistency of the ELS requirements.\n",
            "cite_spans": [
                {
                    "start": 588,
                    "end": 589,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 787,
                    "end": 788,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 1012,
                    "end": 1013,
                    "mention": "7",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1212,
                    "end": 1213,
                    "mention": "7",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 1420,
                    "end": 1421,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Modelling Strategy",
            "ref_spans": []
        },
        {
            "text": "The ELS has both structural \u2013 that introduce additional signals \u2013 and behavioural \u2013 that change certain signal outcomes \u2013 variability points [6, \u00a73], which Electrum is well-suited to address. Once a single variant was modelled and validated, two strategies were explored to address the remaining variants, as described in Sect. 4: one based on an Electrum idiom where features and variability points are modelled in plain Electrum, and another adapting a language extension developed by us for Alloy [9] where variability points are annotated with features. This introduces another component in the ELS model for imposing the set of valid variants \u2013 the feature model.",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 143,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 501,
                    "end": 502,
                    "mention": "9",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Modelling Strategy",
            "ref_spans": []
        },
        {
            "text": "As expected, the development of these components was not sequential but rather iterative as new ELS functions were added to the model. This process was applied to all 9 main ELS functions divided in 48 requirements as of version 1.17 [6], for all 12 valid variants (although only 4 effectively have distinct behaviour) and to all 9 validation sequences of version 1.7 [7]. This work focused on the ELS, but we believe a similar approach could be followed for the speed control system (SCS) [6], although the SCS is richer in continuous aspects, which would require additional abstractions. It should also be noted that the authors had no particular domain knowledge, and that the process was solely based on the provided reference material [6, 7] and discussions with the case study chair.",
            "cite_spans": [
                {
                    "start": 235,
                    "end": 236,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 369,
                    "end": 370,
                    "mention": "7",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 491,
                    "end": 492,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 741,
                    "end": 742,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 744,
                    "end": 745,
                    "mention": "7",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Modelling Strategy",
            "ref_spans": []
        },
        {
            "text": "The most challenging features of the ELS were those dealing with real-time aspects and the integer nature of the signals. For both we developed proper abstractions \u2013 respectively arbitrary duration events and value discretization, described in the next section \u2013 that still allowed us to address most requirements. Only requirements requiring arithmetic operations were not addressed at all.",
            "cite_spans": [],
            "section": "Modelling Strategy",
            "ref_spans": []
        },
        {
            "text": "This section describes the main features of the ELS model developed for the simplest variant, that is, when the vehicle is not armoured and aimed at the EU market (the driver position does not affect the ELS).",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "System Environment. The ELS follows a typical architecture that communicates with the external world through input \u2013 from the user interface and sensors \u2013 and output signals \u2013 to actuators. Our model mimics this architecture so that the translation can be streamlined. In Electrum, likewise Alloy, structure is introduced through the declaration of signatures \u2013 sets of uninterpreted atoms \u2013 and fields declared within them \u2013 relations of arbitrary arity between signatures. A hierarchy on signatures can be imposed through simple inclusion or through extension, in which case children must be disjoint; signatures can also be declared as abstract, meaning all atoms must belong to its children. Signatures and fields can be restricted by simple multiplicity constraints. Lastly, both may be static (by default) or declared as variable, in which case their state may change over time.\n",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "The ELS environment specification declares signals, the values that can be assigned to such signals, and how these assignments are represented in time. Signals form a static hierarchy starting from an (abstract)\n\nsignature. Although the ELS signals are \u201cflat\u201d, related signals are often better handled together. Thus, for instance, all light signals are aggregated in an abstract signature\n\n, and left and right low beam signals in the abstract signature\n\n. At the bottom of the hierarchy are the concrete signals themselves as singleton signatures (multiplicity\n\n), such as\n\nand\n\n, whose names match those specified in the reference documents. The hierarchy relevant for the low beams function is encoded in Electrum as  where field\n\nwill be explained shortly. To simplify the modelling process, we distinguish Boolean signals (\n\n, a sub-signature of\n\n) from the others. Those relevant for the low beams function are declared as: \n",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "Although signals are integer, most requirements simply test whether they are within certain ranges. Thus, to keep the model manageable and avoid state explosion, we discretize the values of each signal into those ranges relevant for the requirements. For instance, it is only relevant to detect whether the ambient brightness levels are below 200, over 300 or between the two, while low beam headlights are only set to 20%, 50% or 100% intensity [6, 4.4]. Thus only these distinct classes of values are encoded in our model. Values form a hierarchy matching that of the signals, topped by\n\n, whose direct children group the states of related signals, such as\n\nfor\n\nsignals. The next layer provides the discretized values, such as\n\n,\n\n,\n\nor\n\nfor beam intensity. Lastly, since our model abstracts real-time aspects, occasionally we require additional temporal context regarding the state of the signals. For instance, when low beams are activated due to ambient darkness, they must remain active for 3 s even if ambient brightness is detected (ELS-18); thus, within\n\nbeam intensity we distinguish between this temporary state (\n\n) and permanent activation (\n\n). Part of this hierarchy relevant for the low beam function is encoded as: \n",
            "cite_spans": [
                {
                    "start": 447,
                    "end": 448,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "Lastly, we model the evolution of the state of the signals. For Boolean signals a variable sub-signature\n\nwill contain at each state all active signals:  For the other signals, a variable field called\n\nwill contain at each state exactly\n\nrespective value, such as the one declared above for\n\nand respective\n\n. Often the requirements impose certain restrictions on the evolution of the environment. In Electrum these restrictions are imposed through facts, representing model axioms, which can contain arbitrary temporal constraints. In the ELS, e.g., a fact forces the pitman arm to go back to neutral when the steering wheel returns to the vertical position [6, \u00a74.1].",
            "cite_spans": [
                {
                    "start": 660,
                    "end": 661,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "We have encoded the over 30 signals of the ELS in this manner, including those of the user interface [6, \u00a74.1], the sensors [6, \u00a74.2] and the actuators [6, \u00a74.3]. An excerpt of the resulting environment signature hierarchy for the low beam headlights function is depicted in Fig. 1 as generated by the Analyzer. Dashed elements are variable and singleton signatures are in thicker lines (some state names are abbreviated). Throughout the rest of the paper we will rely on this function to demonstrate the features of the developed model.",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 103,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 125,
                    "end": 126,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 153,
                    "end": 154,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "The ELS Model",
            "ref_spans": [
                {
                    "start": 280,
                    "end": 281,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "State Machine. Next we derived a state machine from the ELS requirements. Electrum formulas are written in relational linear temporal logic with transitive closure. Relational expressions combine signatures and fields (and constants, namely the universe of atoms\n\n, the unary empty relation\n\nand the identity relation\n\n) with typical set theory operators such as union (\n\n), intersection (\n\n), difference (\n\n), Cartesian product (\n\n), binary relation overriding (\n\n), and relational join (\n\n). In Electrum everything is seen as a relational expression, so\n\ncan be used to retrieve the current state of a concrete signal\n\nor all the states of a set of signals\n\n. Primed expressions can be used to refer to their value in the succeeding state, e.g.,\n\nfor the next value of\n\n. Atomic formulas either test relational expressions for inclusion\n\nor equality\n\nor are simple multiplicity tests. So,\n\ntests whether a Boolean signal\n\nis currently active, and\n\nwhether signal\n\ncurrently has value\n\n(if\n\nsingleton). Complex formulas are composed by Boolean operators (e.g.\n\n,\n\n,\n\n,\n\n,\n\nor\n\n-then-\n\n), first-order operators (e.g.\n\nor\n\n), and future (unary\n\n,\n\nor\n\n, or binary\n\nor\n\n) and past (unary\n\n,\n\nor\n\n, or binary\n\nor\n\n) linear temporal logic operators. Predicates and functions can be defined for auxiliary formulas and expressions and let-expressions for local definitions.",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "A predicate is defined for each function encoding the expected behaviour, which are subsequently called in a fact that enforces the full state machine. For the low beam headlights function, this predicate mostly restricts the succeeding state of the low beam headlights given the current state of the other signals. For instance, if the light rotary switch (\n\n) is set to\n\nwhile the key (\n\n) is in the ignition on position, the succeeding state of the low beams is set to\n\n(ELS-14): Expression\n\naggregates the state of both the left and right low beams; since every light must have a\n\nassigned,\n\nsets both to full intensity. As a more complex example, consider ELS-17 that specifies daytime running lights, which activate the low beams when the engine is started until the key is removed from ignition, unless ambient light control is also active: \n",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "In our model, real-time is abstracted away and no particular duration is imposed to states, meaning that within a certain interval of time an arbitrary number of events may occur. This affects the modelling of events with a bounded duration, since we must identify when the trace is within that bound and allow multiple steps within. For this purpose, such events are explicitly identified in our state but not forced to last any particular number of states. For instance, the mandatory 3 s for automatic low beams (ELS-18) is identified by the state\n\n; when brightness is detected, the low beams may be turned\n\nor the\n\nstate propagated. This could be encoded in the following relational formula:  Here\n\nabbreviates the state of both left and right low beams and we rely on relational operators to specify alternative updates. For instance, expression\n\nrelates every state with\n\nand additionally\n\nwith itself; thus,\n\nreturns\n\nand\n\nwhen the current state is\n\nand solely\n\notherwise. This allows the exploration of transitions with different durations: either low beams activation remains within the 3 s, or the 3 s are exceeded and they are deactivated. Formula\n\nguarantees that left and right beams are updated consistently (i.e., with the same value). Liveness properties then guarantee that the system eventually evolves. In Electrum arbitrary temporal constraints can be imposed, this one taking the shape: \n",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "This strategy was employed to model all the ELS main functions \u2013 direction blinking, hazard warning light, low beams, cornering lights, manual and adaptive high beams, emergency brake and reverse lights, and fault handling.",
            "cite_spans": [],
            "section": "The ELS Model",
            "ref_spans": []
        },
        {
            "text": "The ELS assumes the existence of variability points, namely the market region, whether it is an armoured vehicle and the driver position (although this last does not affect the behaviour of the ELS) [6, \u00a73]. The model described in the previous section represented a single ELS variant, and multiple independent models could be developed in such a way for each of the valid variants. However, such a strategy has poor maintainability and will not scale as the number of features increase. Electrum is sufficiently flexible to support systems with structural and behavioural variability points and effectively model families of software products. However, such idioms may be cumbersome, error-prone, and reduce comprehension, so to explore alternative approaches we implemented in Electrum an annotative language extension to natively support feature-oriented design. This extension was previously developed for Alloy but its adaptation to Electrum was straightforward. This section describes the design of the ELS family of products in both approaches, which allow simultaneously specifying and analysing all the 12 ELS variants. For both approaches, we assume the variant presented in the previous section to be the base variant, which is extended into a multi-variant model.",
            "cite_spans": [
                {
                    "start": 200,
                    "end": 201,
                    "mention": "6",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "A Pure \n Idiom. The first step in both approaches is to encode the feature model \u2013 the possible features and the constraints over them denoting the valid variants. When relying on a variability idiom, this is done by making features first-class elements of the model. A possibility is to create a signature (here,\n\n) with an atom for each available feature (through singleton sub-signatures, such as\n\nor\n\nfor the ELS). A sub-signature then contains a particular selection of these features, representing the variant under analysis (here,\n\n). Lastly, a fact restricts which variants are considered valid, in the case of ELS forcing a single market to be selected through a multiplicity test: \n",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "To model architectural variability, conditional signatures and fields can be assigned a loose multiplicity that is restricted depending on the variant under analysis. In the ELS the darkness mode switch only exists on armoured vehicles, so its multiplicity is set to\n\n(at most one such signal exists), and then a fact forces its existence exactly when the respective feature is selected:  Behavioural variability can be modelled by testing which features are selected in\n\nand adapting the relevant transitions of the state machine predicates. In the case of low beams, for instance, ambient lights should be ignored with active darkness mode in armoured vehicles (ELS-21), so the pre-condition for activating them when the engine is started (ELS-19) is adapted to:  Notice that since features are regular signatures, it may become difficult to identify which parts of the predicate are variability points. It may also led to unpredictable issues if the architectural variability is not handled with care: the distracted developer could simply write\n\nto test whether darkness mode is active without testing the feature presence, which is always true in variants without feature\n\nsince\n\nis empty, thus permanently disabling ambient lighting.",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "For an example regarding the USA and Canada market variants, during direction blinking, for instance, the intensity of daytime running lights (ELS-17) must be reduced to half in the respective side (ELS-6), so the transition shown in the previous section would be adapted to:  where the state of the blinking lights\n\nand\n\nis tested in case the USA or Canada markets are selected.",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "A Colourful \n Extension. Approaches to explicitly introduce variability in a system usually fall in two categories: compositional approaches where features are implemented as distinct code units which are then composed when creating a variant, and annotative approaches where the code is annotated to dictate which fragments will appear in each variant. Both compositional [1] and annotative [9] approaches have been proposed to enable feature-oriented design in Alloy, the latter by us relying on colourful annotations that have been shown to improve understandability [5]. Annotative approaches are better suited for small granularity variability points, which in our experience is often the case in Alloy/Electrum, such as the examples above where one needs to change part of a formula or expression rather than replace the predicate altogether.",
            "cite_spans": [
                {
                    "start": 374,
                    "end": 375,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 393,
                    "end": 394,
                    "mention": "9",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 571,
                    "end": 572,
                    "mention": "5",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "In our lightweight annotative approach model elements can be marked with features, identified by a digit, to control their presence/absence without obfuscating the code. Positive and negative annotations are introduced, respectively, by delimiters\n\nand\n\nfor \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$1 \\le i \\le 9$$\\end{document}, and colour highlighted by the Analyzer. These can be nested, representing the conjunction of presence conditions, and be applied to most declarations or branches of certain operators (namely conjunction, disjunction, intersection and union). Semantically, when the presence conditions are not met the element is interpreted as the neutral element of the respective operator. For instance, in\n\nis only tested in variants with feature 1, and\n\nin those without feature 2, being replaced by true otherwise.",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "The multi-variant ELS model under this extension uses five feature annotations, one for each variability point. To model the feature model one can rely on annotated facts to forbid certain variants. For the ELS this could be achieved by the following fact, which mimics the colour highlighting of the Analyzer: \n",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "where, for instance,\n\nforbids the coexistence of USA and Canada market codes, and\n\nforces the selection of at least one market code2. At the level of abstraction of Electrum, feature models are usually small and simple to encode with facts like the one above, but we are studying whether dedicated support for encoding feature models is necessary.",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "Architectural variability is trivially modelled, as one may mark the signature (or field) declaration with the relevant annotations, as in the case of the darkness mode switch signal, that only exists for armoured vehicles:  One type rule imposed by colourful Electrum is that element calls must respect the annotations in which they were declared, thus guaranteeing that they are never called in variants where the element is absent. Thus, the interaction between ELS-19 and ELS-21 would now be encoded as: \n",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "In variants without\n\nthis test will be disregarded (i.e., interpreted as true). The same mechanism can be applied to relational expressions. For instance, the interaction of ELS-17 and ELS-6 for USA and Canada markets is encoded as: \n",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "where the beams are always set to\n\nin the EU market, but in other markets (through the negative\n\n) the state of blinking lights is tested. A union branch is interpreted as the empty relation when the presence conditions do not hold.",
            "cite_spans": [],
            "section": "Handling Variability",
            "ref_spans": []
        },
        {
            "text": "Validation Scenarios. Animation commands are defined through\n\ninstructions, which can be provided arbitrary constraints that must hold for the generated instances. This allows the quick definition of scenarios for early validation, which are also useful as regression tests as the model evolves. For the ELS we have defined over 60 such scenarios exercising simple behaviours of the system. We follow an idiom where one predicate defines the evolution of the environment (state of input signals) and another the expected behaviour of the system (state of output signals). For instance, to test basic low beam headlights sub-functions such as having the light rotary switch set to on with key inserted, a predicate is defined to encode the behaviour of the relevant input signals:  where\n\nforces\n\nto hold in all states of the trace and\n\nabbreviates\n\n, an operator introduced precisely to ease scenario specification [4]. A predicate then encodes the expected outcome of the ELS for these inputs:  This predicate states that the beams should be activated with intensity reduced to half. Lastly, a command to generate this scenario by enforcing the environment and the expected behaviour (in the succeeding state, since output signals are calculated from the previous state) is defined:  Commands must have scopes assigned to signatures, but in our ELS model all signatures are exactly bound, since all signals and possible states are known a priori. For bounded model checking \u2013 more efficient and thus better suited for validation \u2013 the maximum number of states that form a trace must also be provided (the scope of\n\n). Since this is a simple scenario that bound is set to 5. Once instances are generated, the user is able to iterate over alternative scenarios for which the constraints hold. Scenario exploration operations (see the toolbar of Fig. 2) include changing the configuration (here, the selected variant), the initial state, or the current transition [3].",
            "cite_spans": [
                {
                    "start": 916,
                    "end": 917,
                    "mention": "4",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1963,
                    "end": 1964,
                    "mention": "3",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": [
                {
                    "start": 1849,
                    "end": 1850,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "In the multi-variant ELS models one is able to restrict which subset of variants should be analysed. As an example, let us consider the animation of the effect of darkness mode when ambient lighting is activated. In the Electrum variability idiom the part of this environment predicate could be specified as: \n\n",
            "cite_spans": [],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "which includes the selection of the feature\n\nand the behaviour of the\n\n. The same scenario in the colourful extension would instead be specified as: \n",
            "cite_spans": [],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "where the behaviour of the darkness mode switch is annotated with the corresponding feature. The execution of this scenario must then also be restricted to only variants where feature 4 is selected. In colourful\n\nthis is defined through the command scope as: \n",
            "cite_spans": [],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "Theme Customizations. In our experience, the proper graphical representation of instances is key to promote the interpretation of the model among interested parties. Inheriting from Alloy, the Analyzer depicts instances as graphs, applying a graph representation algorithm and distributing nodes among layers, obliviously of the underlying semantics of the nodes and edges. Themes may be defined to ease interpretation. From our experience the most useful customizations are simply changing the colour, shape or label of elements, hiding elements, showing relations as edges or attributes, and inverting edges (the easiest way to change the shape of the graph). Visualization can also be projected over a signature, focusing the visualization on the elements related to the selected atom. These customizations are hierarchical, meaning that subsets of elements may inherit the parameters of their parents or change them. Although simple, these features can become extremely powerful given another key functionality of the visualizer \u2013 after analysis, and during the creation of the graph, auxiliary functions defined in the model are introduced into the instance. These can be of arbitrary arity, and thus can represent subsets of atoms or new relations between them.",
            "cite_spans": [],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "In our ELS model we have used such features to produce a visualization such as that of Fig. 2. Since the signals are mostly flat, we introduce elements to somehow layout signals according to their role in the system. Singleton signatures \u2013 which do not affect the solving process since they are exactly bound and not referred elsewhere \u2013 simulate the vehicle architecture, such as the\n\nitself or the driver\u2019s\n\n Auxiliary relations (defined as functions with zero arguments) then connect such elements to signals, such as assigning the sensors to the car (which are set to be shown as attributes of\n\nrather than edges) or the lights to the respective side of the car, and can be defined as follows: \n",
            "cite_spans": [],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": [
                {
                    "start": 92,
                    "end": 93,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "Auxiliary sets grouping together signals under certain states were also defined to ease the theme customization. For instance, all active signals are grouped so that they can easily be painted with a distinguishing colour (yellow in Fig. 2):  The theme file is available alongside the model specification.",
            "cite_spans": [],
            "section": "Animation and Validation ::: Validation and Verification",
            "ref_spans": [
                {
                    "start": 238,
                    "end": 239,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "To effectively validate the developed model we checked its behaviour against that of the reference validation sequences [7]. These are complex \u2013 each step specifying the value of all the over 30 input and output signals, with some containing over 20 steps \u2013 rendering their manual codification infeasible. Thus, we implemented a prototype to automatically translate tabular data that represents signal values over time into Electrum and back. This validator is able to i) given a sequence of input and output signals, report whether it is a valid execution in our model; and ii) given a sequence of only input signals, generate possible executions of the output signals to be subsequently validated by domain experts.",
            "cite_spans": [
                {
                    "start": 121,
                    "end": 122,
                    "mention": "7",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Reference Validation Sequences ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "We implemented the prototype so that the process could be reproducible for other signal-based systems. Thus, besides the sensor data, two additional pieces of information must be provided to the validator for each specific application: i) how the signal values should be discretized; and ii) the presence conditions for signals. For our prototype, this information is passed in the header of the tabular data, as depicted in Table 1 for validation sequence 1 of the ELS (note that this is only an excerpt of the codification of the more than 30 signals over 17 steps). Single-value ranges are assumed to have the same lower- and upper-bound. It also assumes, as described in Sect. 3, that all signals are leaves of the hierarchy on\n\nwith the exact same name as that of the sequence header, and that elements representing the discretized values are at the second layer of the\n\nhierarchy, again with the same name as the discretization in the header.\n",
            "cite_spans": [],
            "section": "Reference Validation Sequences ::: Validation and Verification",
            "ref_spans": [
                {
                    "start": 431,
                    "end": 432,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Reference Validation Sequences ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "The translation can then be streamlined as follows. The presence/absence of a Boolean signal\n\ncan simply be stated as\n\nand\n\n, respectively, while the state of the others is encoded as\n\nfor a discretized value\n\n. Sequences of signal states are encoded using the operator\n\n, and let-expressions are used to simplify this codification. The particular variant of the sequence must also be encoded. The validator currently implements only the pure variability idiom, forcing the exact value of signature\n\n.",
            "cite_spans": [],
            "section": "Reference Validation Sequences ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "The resulting predicates resemble the one in Fig. 3 for the sequence from Table 1 (including steps that have been omitted for simplicity). The expected variant (ll.11\u201312) and both the sequence of input (ll. 1\u201310) and output (ll. 15\u201317) signals are encoded, relying on let-expressions for improved readability (recall that unlike the validation sequences, our output signals are only updated in the succeeding state, hence the\n\n). At the last state an\n\noperator is applied, since outputs are expected to stabilize when inputs do. Although the reference sequences provide timestamps for the events (the first column), these are ignored since real-time is abstracted in our model.",
            "cite_spans": [],
            "section": "Reference Validation Sequences ::: Validation and Verification",
            "ref_spans": [
                {
                    "start": 50,
                    "end": 51,
                    "mention": "3",
                    "ref_id": "FIGREF2"
                },
                {
                    "start": 80,
                    "end": 81,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Figure 2 depicts the outcome of running this predicate (with\n\nscope determined from the length of the sequence), particularly the transition where the brightness is below the threshold and the low beam headlights are activated. We were able to model all 9 validation sequences of version 1.8 and show that they hold for our ELS model, except for concrete values for the high beam illumination distance and strength in sequence 9 (ELS-33) due to arithmetic operations.",
            "cite_spans": [],
            "section": "Reference Validation Sequences ::: Validation and Verification",
            "ref_spans": [
                {
                    "start": 7,
                    "end": 8,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "The last step of the process was to effectively verify whether the requirements hold for the modelled ELS. In Electrum assertions (\n\n) can be specified in full relational temporal logic, which the Analyzer is instructed to verify (within given scopes) with\n\ncommands.",
            "cite_spans": [],
            "section": "Requirement Verification ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "As an example, consider requirement ELS-14, stating that whenever the engine is on and the light switch set to on, low beams will be active. This can be specified in the following temporal assertion: \n",
            "cite_spans": [],
            "section": "Requirement Verification ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "For a more complex example, consider ELS-17, stating that with daytime running light but without ambient light, the low beams are activated until the engine is turned off. This can be encoded as:  stating that in traces where daytime running light is active but not ambient lighting, the engine is turned off and the low beams are deactivated (temporal operator\n\n) or the engine remains on forever.",
            "cite_spans": [],
            "section": "Requirement Verification ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "We were able to check most ELS requirements except for the limitations discussed in the following section. The described checks (that verify the property for all variants at once) take around 6 s and 10 s, respectively, using the bounded engine of Electrum under the Glucose SAT solver and for 15\n\nin a commodity 2,3 GHz Intel Core i5 with 16 GB RAM. More complex requirements \u2013 like those including periodic events such as ELS-2 and ELS-4 \u2013 take around 1 min.",
            "cite_spans": [],
            "section": "Requirement Verification ::: Validation and Verification",
            "ref_spans": []
        },
        {
            "text": "The Reference Document. Throughout the development of the ELS model we encountered 14 issues with the reference documents, mostly during modelling and preliminary validation, and when running the reference sequences. We reported them to the case study chair who promptly replied. Of the first 4 reported issues, 3 resulted in fixes to the reference document (version 1.11); unfortunately, at the time of submission no new version has been released after the other interactions (unofficially, at least 3 resulted in validation sequence fixes). Roughly, the issues encountered were either with theEnvironment model inconsistencies or missing features related to the signals detected in the early modelling process (e.g., the lack of a signal for the middle brake light, making it impossible to flash (ELS-40); or inconsistent representations of the pitman arm signals when it was split into two distinct signals for vertical and horizontal movement);Behavioural model ambiguities detected in the requirements while modelling and animating the state machine (e.g., conflicting requirements where the precedence is not explicitly stated, such as whether ELS-18 or ELS-19 has priority on low beam behaviour; ambiguous nomenclature, such as what activating high beams means for the 3 relevant signals; or under-specified behaviour, such as the beam intensity of tail lamps);Validation sequences inadmissible sequences, meaning that the expected output signals could not be achieved from the input signals in our model (e.g., tail lamps not being activated or not blinking in sequence 7).\n",
            "cite_spans": [],
            "section": "Results Discussion",
            "ref_spans": []
        },
        {
            "text": "It must also be noted that, since the modelling and validation process was iterative, some requirement ambiguities were clarified by observing the reference sequences. For instance, it is not clear from ELS-22 that when tail lamps are activated, they are so with the same intensity as that of the low beams, but the sequences showed that to be the case (e.g., in ELS-15).",
            "cite_spans": [],
            "section": "Results Discussion",
            "ref_spans": []
        },
        {
            "text": "In our experience, there were two main sources of confusion in the requirements. One has to do with the blinking lights and the nature of the dark cycles: it was not clear under which situations, if any, such cycles should be interrupted, and under which situations do they impact the tail lamps. The second has to do with high beam headlights, which are controlled by 3 distinct signals: it is often not clear what it means to activate the high beams and how the 3 signals should be updated and again how they relate to the intensity of the tail lamps.",
            "cite_spans": [],
            "section": "Results Discussion",
            "ref_spans": []
        },
        {
            "text": "The Followed Approach. As already stated, we only failed to address requirements requiring arithmetic operations (ELS-33 for calculating the illumination distance and luminous strength of high beams, and ELS-47 for calculating the maximum light intensity under over-voltage) since concrete integer values are not represented. The abstracted time also renders reasoning about real-time requirements infeasible, such as ELS-10 enforcing the duration of blinking cycles to 1 s, or the part of ELS-18 forcing the activation of the automatic low beams for 3 s. Some features were simplified to avoid additional internal states, namely the gentle fade-out of cornering lights (ELS-24) or the flashing of emergency brake lights (ELS-40). ELS-37, dealing with the interaction with the SCS, has been disregarded. Requirements related to periodic events \u2013 such as the bright and dark cycles of blinking lights \u2013 proved to be the most cumbersome to specify.",
            "cite_spans": [],
            "section": "Results Discussion",
            "ref_spans": []
        },
        {
            "text": "The multiple variants of the ELS requirements motivated the implementation of the feature annotations for Electrum and its Analyzer. Since the ELS is not particularly rich in variability, we did not find multi-variant modelling in a pure Electrum idiom to be unmanageable, but it did affect the comprehension of the model. In general, the colourful Electrum model is easier to understand. The exception is the axiomatization of the feature model, and we are already studying sensible ways to improve it, that we also expect to be useful in more advanced feature-oriented analysis procedures. The complexity of the case study also helped us identify additional operators whose annotation would be useful in colourful Electrum \u2013 namely, if-then-else expressions common in the definition of state machines, when certain branches are only relevant in certain variants.",
            "cite_spans": [],
            "section": "Results Discussion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Snippet of tabular data provided to our validator for sequence 1.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: Meta-model of the system environment model for low beam headlights.",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: A step of sequence 1 in the Analyzer under the developed theme. (Color figure online)",
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Fig. 3.: Electrum encoding of the sequence from Table 1.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Validating the hybrid ERTMS/ETCS level 3 concept with Electrum",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Cunha",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Macedo",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Int. J. Softw. Tools Technol. Transfer",
            "volume": "22",
            "issn": "",
            "pages": "281-296",
            "other_ids": {
                "DOI": [
                    "10.1007/s10009-019-00540-4"
                ]
            }
        },
        "BIBREF5": {
            "title": "Do background colors improve program comprehension in the #ifdef hell?",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Feigenspan",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Empir. Softw. Eng.",
            "volume": "18",
            "issn": "4",
            "pages": "699-745",
            "other_ids": {
                "DOI": [
                    "10.1007/s10664-012-9208-x"
                ]
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "Simplifying the analysis of software design variants with a colorful alloy",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Liu",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Macedo",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Cunha",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Dependable Software Engineering. Theories, Tools, and Applications",
            "volume": "",
            "issn": "",
            "pages": "38-55",
            "other_ids": {
                "DOI": []
            }
        }
    }
}