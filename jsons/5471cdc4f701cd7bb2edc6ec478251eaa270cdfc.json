{
    "paper_id": "5471cdc4f701cd7bb2edc6ec478251eaa270cdfc",
    "metadata": {
        "title": "QUEST: Practical and Oblivious Mitigation Strategies for COVID-19 using WiFi Datasets *",
        "authors": [
            {
                "first": "Peeyush",
                "middle": [],
                "last": "Gupta",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Sharad",
                "middle": [],
                "last": "Mehrotra",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine",
                        "country": "USA"
                    }
                },
                "email": "sharad@ics.uci.edu"
            },
            {
                "first": "Nisha",
                "middle": [],
                "last": "Panwar",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Augusta University",
                    "location": {
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Shantanu",
                "middle": [],
                "last": "Sharma",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine",
                        "country": "USA"
                    }
                },
                "email": "shantanu.sharma@uci.edu"
            },
            {
                "first": "Nalini",
                "middle": [],
                "last": "Venkatasubramanian",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine",
                        "country": "USA"
                    }
                },
                "email": ""
            },
            {
                "first": "Guoxi",
                "middle": [],
                "last": "Wang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "University of California",
                    "location": {
                        "settlement": "Irvine",
                        "country": "USA"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Contact tracing has emerged as one of the main mitigation strategies to prevent the spread of pandemics such as COVID-19. Recently, several efforts have been initiated to track individuals, their movements, and interactions using technologies, e.g., Bluetooth beacons, cellular data records, and smartphone applications. Such solutions are often intrusive, potentially violating individual privacy rights and are often subject to regulations (e.g., GDPR and CCPR) that mandate the need for opt-in policies to gather and use personal information. In this paper, we introduce QUEST, a system that empowers organizations to observe individuals and spaces to implement policies for social distancing and contact tracing using WiFi connectivity data in a passive and privacy-preserving manner. The goal is to ensure the safety of employees and occupants at an organization, while protecting the privacy of all parties. QUEST incorporates computationally-and informationtheoretically-secure protocols that prevent adversaries from gaining knowledge of an individual's location history (based on WiFi data); it includes support for accurately identifying users who were in the vicinity of a confirmed patient, and then informing them via opt-in mechanisms. QUEST supports a range of privacy-enabled applications to ensure adherence to social distancing, monitor the flow of people through spaces, identify potentially impacted regions, and raise exposure alerts. We describe the architecture, design choices, and implementation of the proposed security/privacy techniques in QUEST. We, also, validate the practicality of QUEST and evaluate it thoroughly via an actual campus-scale deployment at UC Irvine over a very large dataset of over 50M tuples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The ongoing COVID-19 pandemic with rapid and widespread global impact, has caused havoc over the past few months -at the time of writing of this paper, over 3 million individuals have been infected. The epidemic has caused over 200,000 global casualties, and the world economy to come to a screeching halt. Several (nonpharmacologic) steps are being taken by governments and organi- * We are thankful to Dhrubajyoti Ghosh for helping us in the system installation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "This material is based on research sponsored by DARPA under agreement number FA8750-16-2-0021. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government. This work is partially supported by NSF grants 1527536 and 1545071. zations to restrict the spread of the virus, including social distancing measures, quarantining of those with confirmed cases, lock-down of non-essential businesses, and contact-tracing methods to identify and warn potentially exposed individuals. These tracking and tracing measures utilize a range of technological solutions. Countries, e.g., Israel, Singapore, China, Taiwan, and Australia, utilize cellular data records or data from Bluetooth-enabled apps to perform contact tracing. Other countries, e.g., India, have begun manual contact tracing by interviewing patients.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "Recently, commercial and academic solutions (e.g., Apple-Google collaboration [1] , European PEPP-PT [2] , Israel's The Shield [3] , Singapore's TraceTogether [4] , South Korea's 100m [5] , and [40, 14, 28, 23, 57] ) aim to provide secure contact tracing using Bluetooth-based proximity-detection. Using this approach, users can check if they have been exposed to a potential carrier of the virus by performing a private set intersection of their data with the secured public registry of infected people. While this approach is a step towards protecting the privacy of individuals, there are several limitations: First, the collection and sharing of such personal information can compromise the privacy of individuals -there are growing fears that this could also lead to misuse of data (now or in the future), e.g., mass surveillance of communities and targeting of specific populations [24, 57] . Second, such methods require users to opt-in to broadcast, share, and collect the data using Bluetooth -past work has highlighted limited adoption of such technologies, especially, in parts of the world where privacy is considered to be a paramount concern [40, 19] . Third, contact tracing using Bluetooth or GPS-based proximity sensing has been shown to have false positives/negatives, leading to limited accuracy [23, 40] . Finally, past experiences have indicated that creating pathways for large organizations to capture personal data can lead to data theft, e.g., Facebook's Cambridge Analytica situation and [51] .",
            "cite_spans": [
                {
                    "start": 78,
                    "end": 81,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 101,
                    "end": 104,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 127,
                    "end": 130,
                    "text": "[3]",
                    "ref_id": null
                },
                {
                    "start": 159,
                    "end": 162,
                    "text": "[4]",
                    "ref_id": null
                },
                {
                    "start": 184,
                    "end": 187,
                    "text": "[5]",
                    "ref_id": null
                },
                {
                    "start": 194,
                    "end": 198,
                    "text": "[40,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 199,
                    "end": 202,
                    "text": "14,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 203,
                    "end": 206,
                    "text": "28,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 207,
                    "end": 210,
                    "text": "23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 211,
                    "end": 214,
                    "text": "57]",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 888,
                    "end": 892,
                    "text": "[24,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 893,
                    "end": 896,
                    "text": "57]",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 1156,
                    "end": 1160,
                    "text": "[40,",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 1161,
                    "end": 1164,
                    "text": "19]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 1315,
                    "end": 1319,
                    "text": "[23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1320,
                    "end": 1323,
                    "text": "40]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 1514,
                    "end": 1518,
                    "text": "[51]",
                    "ref_id": "BIBREF49"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "Contact tracing approaches are reactive in nature and aim to detect exposure after it occurs. We argue that proactive and preventive approaches are critical to contain and mitigate the spread. For instance, the ability to monitor public spaces (e.g., classrooms, restaurants, malls), which are expected to have significant density and population flow, can be used by organizations (e.g., campuses) to observe the extent to which employees (and employers) are adhering to social distancing directives. In fact, based on recent media articles [6, 7] and conversations with our university leadership, 1 the importance of such applications will increase further as organizations consider ways forward to reopen and resume operations. Today, organizations are working to help strike the right balance between onsite/online operations that afford both business continuity and public safety. This paper describes our proposed solution, entitled QUEST that exploits existing WiFi infrastructure (prevalent in almost every modern organization) to support a sleuth of applications that empower organizations to evaluate and tune directives for safe operation, while protecting the privacy of the individuals in their premises. Particularly, QUEST leverages WiFi connectivity data (the data generated when a device connects to wireless accesspoints, see \u00a74 for details) to support applications for social distancing adherence, crowd-flow, contact tracing, and exposure notifications within premises (both inside/outside buildings). The WiFi data collected is appropriately secured to prevent leakage of personally identifiable information (e.g., MAC address of the mobile device) and outsourced to a public (cloud) server. On the outsourced data, QUEST allows application execution to occur in a privacypreserving manner.",
            "cite_spans": [
                {
                    "start": 541,
                    "end": 544,
                    "text": "[6,",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 545,
                    "end": 547,
                    "text": "7]",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 598,
                    "end": 599,
                    "text": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "QUEST supports two different cryptographic alternatives for secure data processing; the choice of the approach is based on underlying security requirements of the organization. The first is a computationally secure encryption-based mechanism, entitled CQUEST that encrypts data using a variant of searchable encryption methods. The second approach called IQUEST, based on a string-matching technique [29] over secret-shares generated using Shamir's secretsharing algorithm [54] . Both methods support the above-mentioned applications. IQUEST offers a higher level of security, when using untrusted servers, since it is information-theoretically secure, and moreover, does not reveal access-patterns (i.e., the identity of tuples satisfying the query). We have deployed QUEST at UC Irvine [8] , as well as, tested the system on large WiFi datasets. These datasets were collected as a part of the TIPPERS smartspace testbed at UCI [48] and will also be used for scalability studies.",
            "cite_spans": [
                {
                    "start": 400,
                    "end": 404,
                    "text": "[29]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 473,
                    "end": 477,
                    "text": "[54]",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 788,
                    "end": 791,
                    "text": "[8]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 929,
                    "end": 933,
                    "text": "[48]",
                    "ref_id": "BIBREF46"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "QUEST offers several distinct advantages compared to other ongoing contact tracing efforts that have focused on using GPS, cellular infrastructure, and proximity sensors (e.g., Bluetooth) [9, 4, 1, 23, 28, 40] . These include:",
            "cite_spans": [
                {
                    "start": 192,
                    "end": 194,
                    "text": "4,",
                    "ref_id": null
                },
                {
                    "start": 195,
                    "end": 197,
                    "text": "1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 198,
                    "end": 201,
                    "text": "23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 202,
                    "end": 205,
                    "text": "28,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 206,
                    "end": 209,
                    "text": "40]",
                    "ref_id": "BIBREF38"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 A Decentralized organizational solution. QUEST is designed as a tool to be used independently and autonomously by organizations (e.g., universities, individual shops/shopping complexes, and airports) to monitor adherence of their policies for social distancing, crowd-flow, and, to warn people about possible exposure on their premise. The organizational aspect of QUEST brings several advantages. First, the solution is amenable for organizational-level control to ensure that warning and alerts are not misused to spread false information, unlike some of the recent tools which are being targeted by malicious adversaries to spread propaganda and misinformation [10, 11] . Second, unlike solutions such as the one being designed by mobile OS platform vendors (viz. Apple and Google), in QUEST, both data collection and usages remain decentralized to the level of an organization and, thus, end-users do not need to trust any single organization/authority with their data.",
            "cite_spans": [
                {
                    "start": 666,
                    "end": 670,
                    "text": "[10,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 671,
                    "end": 674,
                    "text": "11]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 A robust solution that works both inside buildings and outdoors.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "Since QUEST is based on WiFi technology, it has a distinct advantage of being able to monitor both inside buildings (organizational premises) and in outside spaces, due to the ubiquitous nature of WiFi coverage in both indoors and outdoors of campuses. The use of WiFi data brings in several additional advantages: First, QUEST does not require any additional hardware expenses or deployment of any new technology that might be prohibitive in terms of cost and limited in terms of deployment. Second, since WiFi connectivity events are generated automatically by current WiFi protocols, QUEST is entirely passive, i.e., it does not require users to deploy any new applications or make changes to their mobile devices. Third, the technology is platform independent, since data collection is implemented entirely on the infrastructure side.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "\u2022 Privacy-by-design. QUEST supports the above-mentioned applications in a privacy-preserving manner by exploiting computationally secure and information-theoretically secure techniques. Thus, QUEST does not provide additional information about people, their locations, or their health status to any organization that they do not already have. Also, an adversary cannot learn past behavior or predict the future behavior of any user. Since the ciphertext representations of a person across organizations are different, even from jointly observing data of multiple organizations to know any specific person has been to the premises of one or more organizations. 2 Outline. \u00a73 provides the model and security properties. \u00a74 provides an overview of QUEST and its applications. \u00a75 provides CQUEST protocol. \u00a76 provides IQUEST protocol. We evaluate QUEST in \u00a77 and compare it with other state-of-the-art approaches, e.g., Intel Software Guard Extensions (SGX) [26] based Opaque [62] and multi-party computation (MPC)-based Jana [17] ; we discuss tradeoffs between security and performance.",
            "cite_spans": [
                {
                    "start": 660,
                    "end": 661,
                    "text": "2",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 954,
                    "end": 958,
                    "text": "[26]",
                    "ref_id": null
                },
                {
                    "start": 972,
                    "end": 976,
                    "text": "[62]",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 1022,
                    "end": 1026,
                    "text": "[17]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "INTRODUCTION"
        },
        {
            "text": "In this section, we discuss the new approaches designed for COVID-19 contact tracing, several prior research approaches have explored proximity-based solutions to monitor the spread of infections, and compare against QUEST.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "Comparison with COVID-19 proximity finding approaches. Several recent approaches for preventing the spread of coronavirus are based on Bluetooth data-based secure proximity detection. For example, Canetti et al. [23] present a person proximity detection method based on Bluetooth-enabled devices. However, this method requires to store parts of the data at the user device. [23] , also, argued that GPS-based proximity detection inside a building can give false results. Stanford University [9] is also developing applications based on Bluetooth data. Singapore's TraceTogether application [4] , also, works based on Bluetooth-based tracking. However, [24] showed that TraceTogether jeopardizes the user privacy. DP-3T (decentralized privacy-preserving proximity tracing) [57] proposed a proximity tracing system based on Bluetooth data. Google and Apple [1] are developing Bluetooth beacon-based contact tracing, while preserving the user privacy and location privacy. Similar work is also proposed in [28, 40] for Bluetooth databased secure proximity detection, based on the private set intersection. Enigma MPC, Inc. [12] develops SafeTrace that requires users to send their encrypted Google Map timeline to a server equipped with Intel SGX [26] that executes contact tracing and finds whether the person got in contact with an impacted person or not. A survey of recent contact tracing application for COVID-19 may be found in [56] . However, all such methods require either to install an application [57, 4] at the device, to store some data [23, 28] at the device, to execute computation [23, 12, 28] at the device, to explicitly opt-in to enable Bluetooth-based beacon exchange [1, 28, 40] , or jeopardize the user privacy [24] .",
            "cite_spans": [
                {
                    "start": 212,
                    "end": 216,
                    "text": "[23]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 374,
                    "end": 378,
                    "text": "[23]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 590,
                    "end": 593,
                    "text": "[4]",
                    "ref_id": null
                },
                {
                    "start": 652,
                    "end": 656,
                    "text": "[24]",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 772,
                    "end": 776,
                    "text": "[57]",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 855,
                    "end": 858,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1003,
                    "end": 1007,
                    "text": "[28,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1008,
                    "end": 1011,
                    "text": "40]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 1120,
                    "end": 1124,
                    "text": "[12]",
                    "ref_id": null
                },
                {
                    "start": 1244,
                    "end": 1248,
                    "text": "[26]",
                    "ref_id": null
                },
                {
                    "start": 1431,
                    "end": 1435,
                    "text": "[56]",
                    "ref_id": "BIBREF54"
                },
                {
                    "start": 1505,
                    "end": 1509,
                    "text": "[57,",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 1510,
                    "end": 1512,
                    "text": "4]",
                    "ref_id": null
                },
                {
                    "start": 1547,
                    "end": 1551,
                    "text": "[23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1552,
                    "end": 1555,
                    "text": "28]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1594,
                    "end": 1598,
                    "text": "[23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 1599,
                    "end": 1602,
                    "text": "12,",
                    "ref_id": null
                },
                {
                    "start": 1603,
                    "end": 1606,
                    "text": "28]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1685,
                    "end": 1688,
                    "text": "[1,",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 1689,
                    "end": 1692,
                    "text": "28,",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 1693,
                    "end": 1696,
                    "text": "40]",
                    "ref_id": "BIBREF38"
                },
                {
                    "start": 1730,
                    "end": 1734,
                    "text": "[24]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "In contrast, QUEST does not require any effort by users, since we rely on WiFi data that is generated when a device connects with a WiFi network. QUEST discovers the most accurate proximity of 2 Organizations today, if they so desire, can capture and trace individuals based on their WiFi connectivity data. QUEST, obviously, cannot prevent such a use of WiFi data.",
            "cite_spans": [
                {
                    "start": 193,
                    "end": 194,
                    "text": "2",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "The key-point is that while QUEST stores secured WiFi data at the cloud, the data-atrest or query execution will not reveal any additional information to the organizations. a person inside a building, unlike GPS-based approaches. Also, while using the servers, IQUEST provides complete security, due to using secret-sharing based technique. QUEST not only provides contact tracing, but also provides other applications (Table 1) .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 419,
                    "end": 428,
                    "text": "(Table 1)",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "Comparison with other proximity finding approaches. Epic [15] and Enact [50] are based on WiFi signal strength, where a dynamic user scans the surrounding's wireless signals, accesspoints, and records in their phones. The infected user sends this information to a server that notifies other users and requests them to find their chances of contact. However, Epic [15] and Enact [50] consider trust in reporting by the infected users and requires storing some information at the smartphone, like Bluetooth-based solutions [57, 4, 23, 12, 28] . Another problem with such signal strength-based methods is in developing models to compare WiFi signals and have issues related to spatial, temporal, and infrastructural sensing [42] . NearMe [43] , ProbeTag [47] , [52] , [49] , and [44] proposed similar approaches for proximity detection. The seminal work [21] proposed distance-bounding protocol to estimate an upper-bound on the physical proximity of the device through the round-trip time measurements, by exchanging unique challenge-response pairs between a sender and a receiver. [34] provided a solution for proximity testing among the users while hiding their locations by encryption and considered user-to-userand server-based proximity testing. Note that all such methods require active participation from the users.",
            "cite_spans": [
                {
                    "start": 57,
                    "end": 61,
                    "text": "[15]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 72,
                    "end": 76,
                    "text": "[50]",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 363,
                    "end": 367,
                    "text": "[15]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 378,
                    "end": 382,
                    "text": "[50]",
                    "ref_id": "BIBREF48"
                },
                {
                    "start": 521,
                    "end": 525,
                    "text": "[57,",
                    "ref_id": "BIBREF55"
                },
                {
                    "start": 526,
                    "end": 528,
                    "text": "4,",
                    "ref_id": null
                },
                {
                    "start": 529,
                    "end": 532,
                    "text": "23,",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 533,
                    "end": 536,
                    "text": "12,",
                    "ref_id": null
                },
                {
                    "start": 537,
                    "end": 540,
                    "text": "28]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 721,
                    "end": 725,
                    "text": "[42]",
                    "ref_id": "BIBREF40"
                },
                {
                    "start": 735,
                    "end": 739,
                    "text": "[43]",
                    "ref_id": "BIBREF41"
                },
                {
                    "start": 751,
                    "end": 755,
                    "text": "[47]",
                    "ref_id": "BIBREF45"
                },
                {
                    "start": 758,
                    "end": 762,
                    "text": "[52]",
                    "ref_id": "BIBREF50"
                },
                {
                    "start": 765,
                    "end": 769,
                    "text": "[49]",
                    "ref_id": "BIBREF47"
                },
                {
                    "start": 776,
                    "end": 780,
                    "text": "[44]",
                    "ref_id": "BIBREF42"
                },
                {
                    "start": 851,
                    "end": 855,
                    "text": "[21]",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 1080,
                    "end": 1084,
                    "text": "[34]",
                    "ref_id": "BIBREF32"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "In contrast, QUEST does not require active participation from the user, since it relies on WiFi connectivity data, which is, obviously, generated when a device gets connected with a WiFi network.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "Background on cryptographic techniques. We may broadly classify existing cryptographic techniques into two categories: (i) Computationally secure solutions that includes encryption-based techniques such as symmetric-searchable encryption (SSE) [55, 27, 45, 46 ], deterministic encryption [18, 20] , and order-preserving encryption (OPE) [13] , (ii) information-theoretically secure solutions that include secret-sharing-based techniques [54, 29] and multiparty computation (MPC) techniques [17] . Computationally secure solutions, such as SSE -PB-tree [45] and IB-tree [46] , are efficient in terms of computational time. However, they (i) reveal access-patterns (i.e., the identity of the tuple satisfying the query), (ii) do not scale to a large-dataset due to dependence of a specific index structure, (iii) are not efficient for frequent data insertion, since it requires to rebuild the entire index at the trusted side, and (iv) cannot protect data from a computationally-efficient adversary or the government legislation/subpoena that may force to give them the data in cleartext. In contrast, information-theoretically secure solutions hide access-patterns, as well as, secure against a computationally-efficient adversary or the government legislation/subpoena, (if the shares of the data are placed at the public servers under the different jurisdiction). Instead of using any cryptographic solution, one may also use secure hardware-based solutions that include Intel Software Guard eXtension (SGX) [26] based systems, e.g., Opaque [62] , Bunker and Fort [16] , HardIDX [32] , and EncDBDB [33] . However, such solutions suffer from similar issues as computationally secure solutions and suffer from additional sidechannel attacks, such as cache-line [38] and branching attacks [59] that reveals access-patterns.",
            "cite_spans": [
                {
                    "start": 244,
                    "end": 248,
                    "text": "[55,",
                    "ref_id": "BIBREF53"
                },
                {
                    "start": 249,
                    "end": 252,
                    "text": "27,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 253,
                    "end": 256,
                    "text": "45,",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 257,
                    "end": 259,
                    "text": "46",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 288,
                    "end": 292,
                    "text": "[18,",
                    "ref_id": "BIBREF16"
                },
                {
                    "start": 293,
                    "end": 296,
                    "text": "20]",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 337,
                    "end": 341,
                    "text": "[13]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 437,
                    "end": 441,
                    "text": "[54,",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 442,
                    "end": 445,
                    "text": "29]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 490,
                    "end": 494,
                    "text": "[17]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 552,
                    "end": 556,
                    "text": "[45]",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 569,
                    "end": 573,
                    "text": "[46]",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 1509,
                    "end": 1513,
                    "text": "[26]",
                    "ref_id": null
                },
                {
                    "start": 1542,
                    "end": 1546,
                    "text": "[62]",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 1565,
                    "end": 1569,
                    "text": "[16]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 1580,
                    "end": 1584,
                    "text": "[32]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 1599,
                    "end": 1603,
                    "text": "[33]",
                    "ref_id": "BIBREF31"
                },
                {
                    "start": 1760,
                    "end": 1764,
                    "text": "[38]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 1787,
                    "end": 1791,
                    "text": "[59]",
                    "ref_id": "BIBREF57"
                }
            ],
            "ref_spans": [],
            "section": "RELATED WORK AND COMPARISON"
        },
        {
            "text": "This section explains the entities involved in deploying QUEST, the adversarial model, and the desired security properties.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "PRELIMINARY"
        },
        {
            "text": "We have the following two major entities in QUEST.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Entities"
        },
        {
            "text": "1. An organization oi, who owns and deploys WiFi infrastructure (e.g., WiFi access-points), and hosts QUEST that receives WiFi (connectivity) data (from the infrastructure) of the form: di, li, ti , where di is the i th device-id and ti is the time when di connects with a WiFi access-point li. Prior to outputting the data, QUEST appropriately implements a cryptographic technique to prevent misuse of the data from an adversary.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Entities"
        },
        {
            "text": "2. The untrusted public (cloud) servers that host the secured data, outsourced by QUEST, on which they execute applications. We assume that the servers support any database system, e.g., MySQL.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Entities"
        },
        {
            "text": "Also, we assume two additional entities: a querier and a publisher (P). A querier (which may be the organization or any (authenticated) person) is allowed to execute QUEST applications on the secured data (via QUEST). Further, only for contact tracing application, we assume a trusted publisher P (i.e., hospitals), who publishes a secured list L of device-ids of confirmed infected person. We assume that QUEST executes a secure authentication protocol with P to confirm the queried device-id as the device-id of an infected person, before executing contact tracing application. Thus, it prevents the querier to execute a query for any device-id.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Entities"
        },
        {
            "text": "As we have two entities in QUEST. Below, we discuss their adversarial behavior and our assumptions. Organizations. We assume that organizations have their own security keys (e.g., public and private keys). A system that hosts QUEST, its security keys, and programs must be secured and untampered by anyone including the organizations, and this is an inevitable assumption, as well as, similar to the database-as-a-service (DaS) model [39] , (where it is assumed that an adversary cannot filtrate the information stored at the database owners). Otherwise, any cryptographic mechanism cannot be implemented on WiFi data. Also, it is important to mention that oi can capture their infrastructure data and can do any computation on the data as per their desire, without informing anyone. Controlling such organizations and preventing the misuse of the data is not in the scope of QUEST. Recall that QUEST's goal is to prevent oi to track individuals or to run any applications other than those supported by QUEST on the data collected by QUEST. Cloud servers. We assume that the public servers are honestbut-curious (HBC) and/or malicious adversaries. Such adversarial models are considered widely in data outsourcing techniques [39, 27, 22, 41, 29, 58, 61 ]. An HBC adversary may wish to learn the user information by observing query execution, while a malicious adversary deviates from the algorithm. Since dealing with a malicious adversary, we use an information-theoretically secure solution that uses Shamir's secret-sharing [54] . Thus, we follow the restriction of Shamir's secret-sharing that the adversary cannot collude with all (or possibly the majority of) the servers. Prior to sending the data to the server, we assume that QUEST authenticates the servers. Also, we assume that the secret-shared data transmission to the servers is done using an anonymous routing protocol [36] , and it prevents an adversary to eavesdrop on a majority of communication channels between QUEST and the servers, and thus, preventing the adversary to know the servers that store the secret-shares. ",
            "cite_spans": [
                {
                    "start": 434,
                    "end": 438,
                    "text": "[39]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 1225,
                    "end": 1229,
                    "text": "[39,",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 1230,
                    "end": 1233,
                    "text": "27,",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 1234,
                    "end": 1237,
                    "text": "22,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 1238,
                    "end": 1241,
                    "text": "41,",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 1242,
                    "end": 1245,
                    "text": "29,",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 1246,
                    "end": 1249,
                    "text": "58,",
                    "ref_id": "BIBREF56"
                },
                {
                    "start": 1250,
                    "end": 1252,
                    "text": "61",
                    "ref_id": "BIBREF59"
                },
                {
                    "start": 1527,
                    "end": 1531,
                    "text": "[54]",
                    "ref_id": "BIBREF52"
                },
                {
                    "start": 1884,
                    "end": 1888,
                    "text": "[36]",
                    "ref_id": "BIBREF34"
                }
            ],
            "ref_spans": [],
            "section": "Adversarial Model"
        },
        {
            "text": "In the above-mentioned adversarial model, an adversary wishes to reveal user privacy by learning from data-at-rest and query execution. Thus, a secure algorithm must prevent an adversary to learn the data by just observing (ii) cryptographically-secure data and (ii) query execution and deduce which tuples satisfy the query (i.e., access-patterns). Also, we need to ensure that a querier cannot execute a query for device-ids not published by P. Thus, we need to maintain the following properties: Ciphertext indistinguishability. In the proposed scheme, the data contains user device-id. Thus, the indistinguishability of the user device-ids and locations is a vital requirement. Thus, the adversary, just by observing the secured dataset, cannot deduce that any two tuples belong to the same user/location or not. Note that satisfying indistinguishability property also prevents the adversary from learning any information from jointly observing two datasets belonging to two different organizations. Secure query execution. It requires to maintain: (i) Query privacy that prevents the adversary from distinguishing between two query predicates (for the same or different device-ids and locations) by observing the query predicates or by observing the two queries' execution, i.e., access-patterns. (ii) Execution privacy that enforces the adversary to behave identically and to provide an identical answer to the same query. (Since an adversary cannot distinguish between two query predicates, it should follow the same protocol for each query execution to prove its non-adversarial behavior.) Satisfying these two properties achieve indistinguishability property during data-at-rest/query execution and do not reveal any information about the device-ids/locations. We can, formally, define it using the algorithm's real execution at the servers against the algorithm's ideal execution at a trusted party having the same data and the same query predicate. An algorithm reveals nothing if the real and ideal executions of the algorithm return the same answer.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Security Properties"
        },
        {
            "text": "Definition: Query privacy. For any probabilistic polynomial time (PPT) adversary having a secured relation and any two input query predicates, say p1 and p2, the adversary cannot distinguish p1 or p2, either by observing the query predicates or by query output.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Security Properties"
        },
        {
            "text": "Definition: Execution privacy. For any given secured relation, any query predicate p issued by any real user U , there exists a PPT user U in the ideal execution, such that the outputs to U and U for the query predicate p on the secured data are identical.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Security Properties"
        },
        {
            "text": "Note that satisfying the above two requirements (which are widely considered in many cryptographic approaches [22, 41, 29] ) will hide access-patterns, thus, the adversary cannot distinguish two different queries and the satisfying output tuples. However, such a secure algorithm (as given in \u00a76) incurs the overhead. Thus, we relax the access-pattern-hiding property (similar to existing searchable encryption or secure-hardware-based algorithms) and, also, present efficient access-pattern revealing algorithm, CQUEST ( \u00a75). In Appendix A, we provide security property of CQUEST.",
            "cite_spans": [
                {
                    "start": 110,
                    "end": 114,
                    "text": "[22,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 115,
                    "end": 118,
                    "text": "41,",
                    "ref_id": "BIBREF39"
                },
                {
                    "start": 119,
                    "end": 122,
                    "text": "29]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Security Properties"
        },
        {
            "text": "QUEST contains the following three major components (see Figure 1) : Data collector. It collects WiFi connectivity (or association event) data of form di, lj, t k , when a device di connects to a WiFi access-point (AP) lj at time t k . Particularly, at the infrastructure side, the collector contains a wireless controller that receives WiFi data from several APs ( 0 ), via several methods, e.g., SNMP (Simple Network Management Protocol) traps [53, 63] , recent network management protocol NETCONF [30] , or Syslog [35] ) and forwards WiFi data to QUEST ( 1 ) over the network using the secure networking protocol (e.g., SSH [60] ). QUEST receives and handles a large amount of streaming WiFi data at a very high rate ( 1 ). However, the encrypter may not be able to handle a sudden burst of data, due to the overhead of security techniques and may drop some data. Thus, QUEST data collector includes an ingester (e.g., Apache Kafka, Storm, and Flume) that acts as a buffer between the wireless controller and the encrypter ( 2 ). Data encrypter. The encrypter collects data for a fixed interval duration, called epoch (the reason of creating epochs will be clear soon in \u00a75) and then implements a cryptographic technique (based on the desired security level, using CQUEST Algorithm 1 or IQUEST 3) and outputs the secured data that is outsourced to the servers ( 3 ). Trapdoor generator. A query/application is submitted to the trapdoor generator ( 4 ) that generates the secure trapdoor (using Algorithm 2 or 4) for query execution on secured data. For (user) contact tracing, it confirms the submitted device-id as the real device-id of an infected person or not, from the publisher ( 5 ). The trapdoors are sent to the servers that execute queries and send back encrypted results ( 6 ) . The results are decrypted before producing the final answer ( 7 ) . Further, the organization may alert the users appropriately (via emails or phones), if devices have allowed the organization to inform about it, during their registration ( 8 ) .",
            "cite_spans": [
                {
                    "start": 446,
                    "end": 450,
                    "text": "[53,",
                    "ref_id": "BIBREF51"
                },
                {
                    "start": 451,
                    "end": 454,
                    "text": "63]",
                    "ref_id": "BIBREF61"
                },
                {
                    "start": 500,
                    "end": 504,
                    "text": "[30]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 517,
                    "end": 521,
                    "text": "[35]",
                    "ref_id": "BIBREF33"
                },
                {
                    "start": 627,
                    "end": 631,
                    "text": "[60]",
                    "ref_id": "BIBREF58"
                },
                {
                    "start": 1785,
                    "end": 1790,
                    "text": "( 6 )",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1853,
                    "end": 1858,
                    "text": "( 7 )",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 2032,
                    "end": 2037,
                    "text": "( 8 )",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 57,
                    "end": 66,
                    "text": "Figure 1)",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "QUEST ARCHITECTURE"
        },
        {
            "text": "QUEST Applications. On the secured data, QUEST supports the following diverse applications, which monitor/mitigate the spread of COVID-19 (Table 1 lists the application in SQL):",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 138,
                    "end": 146,
                    "text": "(Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "QUEST ARCHITECTURE"
        },
        {
            "text": "1. Location tracing: traces all locations that were visited by an infected person in the past 14 days (the possible incubation time of coronavirus). Once the information of an infected person is provided to trapdoor generator, it, first, confirms from the publisher about the infected person, and then, generates trapdoors to find the locations visited by the person during the desired time interval.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QUEST ARCHITECTURE"
        },
        {
            "text": "2. User tracing: traces all users that were in the vicinity of an infected person in the past 14 days. Note that this is a natural extension of the previous application, by tracing all people who were at the infected locations at the (bounded) interval time (e.g., +/-15minutes), when an infected person was there.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "QUEST ARCHITECTURE"
        },
        {
            "text": "3. Social distancing: finds the locations and/or users in the campus that are not following social distancing rule. The idea is to use WiFi dataset to create a predefined occupancy knowledge at the granularity of buildings, floors, and regions within buildings. Now, the dynamic occupancy levels of such buildings (along with the knowledge of the capacity of rooms/floors/buildings) help in establishing to what degree different parts of the buildings are (or have been) occupied. Such a measure can help develop a quantitative metric, a social distance adherence index (e.g., at UCI, 6 feet distancing requirement was translated roughly into 12.5% occupancy). Figure 2 shows the interface of social distancing application at UCI before the lockdown was announced. Figure 2 shows social distancing at different granularity, such as regions, floors, and buildings, where red-colored dots show that the buildings are not following social distancing rule. Figure 3 shows the interface of social distancing application at UCI after the lockdown was announced, where green-colored dots show that the buildings are following social distancing rule.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 661,
                    "end": 669,
                    "text": "Figure 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 765,
                    "end": 773,
                    "text": "Figure 2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 953,
                    "end": 961,
                    "text": "Figure 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "QUEST ARCHITECTURE"
        },
        {
            "text": "4. Crowd-flow: finds locations that were visited by many people in a day, and hence, need frequent cleaning. Note that this is a natural extension of social distancing application. This application provides information to individuals about the number of people visiting a given region over a given time period. Such information can be vital for people wishing to avoid crowded areas and also for the cleaning staff to determine places where disinfecting might be necessary. Figure 4 shows the interface of crowd-flow application after the lockdown.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 474,
                    "end": 482,
                    "text": "Figure 4",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "QUEST ARCHITECTURE"
        },
        {
            "text": "Notification: enables all (desired) users to receive notifications, if they are tentative suspects. Note that often when connecting to a WiFi network, it may ask email address or phone number; QUEST exploits such information for notifications, (if allowed by the user).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "5."
        },
        {
            "text": "This section presents computationally-secure methods, CQUEST to encrypt WiFi data and to execute queries on encrypted WiFi data.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CQUEST PROTOCOL"
        },
        {
            "text": "Key generation. QUEST encrypter generates a symmetric key: (sq \u2295 k pko )||attributei, i.e, the key is generated for each attribute of R by XORing the secret-key of QUEST (sq) and public key of organization (k pko ), and then concatenating with the attribute-id. We denote the key for an attribute i by ki in Algorithm 1, and unless not clear, we drop the notation ki from the description.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "CQUEST PROTOCOL"
        },
        {
            "text": "Algorithm 1 provides pseudocode of proposed data encryption method that is executed at QUEST encrypter. It takes tuples of an epoch, produces an encrypted relation R with five attributes. Table 2b shows an example of the produced outputs by Algorithm 1, which works as follows: Selecting epoch. We use the bulk encryption method. Note that WiFi access-points capture time in milliseconds and ping the same device after a certain interval, during which the device can move. These two characteristics of WiFi data capture makes it hard to track a person based on time. 3 Thus, we discretize time into equallength intervals, called epoch, and store a special identifier for each interval (that maps to the wall-clock time). An epoch x is denoted by \u2206x and is identified as a range of begin and end time. All sensor readings during that time period are said to belong to that epoch. There are no gaps between epochs, i.e., the end time of the previous epoch is the same as the begin time of the next epoch. For simplicity, we identify each epoch by its beginning. Encrypting device-ids: Attribute A id (Lines 6-8). Since a device di can appear multiple times in an epoch, we need to prevent the To execute applications such as social distancing and crowd-flow, we need to know unique devices at each location in \u2206x. Thus, when a device di appears for the first time at a location in y th tuple, we add its uniqueness by E(1, y, \u2206x). (It will avoid QUEST to decrypt all encrypted device-ids for knowing distinct devices in \u2206x.) Encrypting locations: Attributes AL and ACL (Lines 9-12). First, we need to produce different ciphertexts for multiple appearances of a location to prevent frequency-count attack, while data-at-rest.",
            "cite_spans": [
                {
                    "start": 567,
                    "end": 568,
                    "text": "3",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "To do so, we use a counter variable for each location and increment by 1, when the same location appears again in a tuple of \u2206x (and could, also, add x, like di's encryption ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "Delete all hash tables for \u2206x Q) for those applications and query execution at the public server (denoted by S). 6 Location tracing (lines 1-5). First, Q verifies the identity of the infected user device di from the publisher P (line 2). Then, Q (or a join  query between a table having all trapdoors and another table having the encrypted WiFi data) to know the corresponding values of A id column (line 9). All such values are transmitted to Q that decrypts them to know the final answer (line 10). If any of the impacted users have subscribed to notification service, then they are informed. Example 5.2. Suppose, we wish to know the impacted people that may in contact with the infected person whose device-id is d1. From Example 5.1, we know that l1, l2 are the impacted locations. Suppose the maximum counter value for any location (cmax ) is two. Thus, Q generates trapdoors as follows: E(l1, 1), E(l1, 2), E(l2, 1), E(l2, 2), and sends them to S. S executes a selection query over AL column for such trapdoors and sends device-ids from A id column, corresponding to the trapdoors. After the decryption, Q knows that d2 is the device of a person that was in contact with the infected person whose device-id is d1.",
            "cite_spans": [
                {
                    "start": 113,
                    "end": 114,
                    "text": "6",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [
                {
                    "start": 246,
                    "end": 325,
                    "text": "(or a join  query between a table having all trapdoors and another table having",
                    "ref_id": null
                }
            ],
            "section": "Data Encryption Method"
        },
        {
            "text": "Social distancing (lines [11] [12] [13] [14] [15] . Q generates and sends trapdoors E(1, y, \u2206t) to S to find the unique devices in the desired epochs 7 Generating and sending trapdoors for impacted locations equals to the maximum counter value may incur computation and communication overheads. Thus, we will suggest an optimization for preventing this.",
            "cite_spans": [
                {
                    "start": 25,
                    "end": 29,
                    "text": "[11]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 30,
                    "end": 34,
                    "text": "[12]",
                    "ref_id": null
                },
                {
                    "start": 35,
                    "end": 39,
                    "text": "[13]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 40,
                    "end": 44,
                    "text": "[14]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 45,
                    "end": 49,
                    "text": "[15]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 150,
                    "end": 151,
                    "text": "7",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "(line 12). 8 S executes a selection query for the trapdoors (or a join  query between a table having all trapdoors and another table having the encrypted WiFi data) to know the unique devices in the desired epochs and sends the qualified values from AL column (line 13) to Q. Q decrypts the received locations and counts the appearance of each location (line 14). Then, Q issues an alarm, if the counter value for a location exceeds the predefined rule for social distancing, denoted by distanceIndex (line 15).",
            "cite_spans": [
                {
                    "start": 11,
                    "end": 12,
                    "text": "8",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 60,
                    "end": 139,
                    "text": "(or a join  query between a table having all trapdoors and another table having",
                    "ref_id": null
                }
            ],
            "section": "Data Encryption Method"
        },
        {
            "text": "Aside. Note that we can also know the devices that do not follow the predefined rule for social distancing, by fetching the qualified values from A id along with values of AL. Example 5.3. Assume that if more than one person appear at a location during a given epoch, then it shows that people at the location are not following the predefined social distancing rules, i.e., in this example, distanceIndex = 1. Q generates the following four trapdoors: E(1, 1, x) , E(1, 2, x), E (1, 3, x) , and E (1, 4, x) . Based on these trapdoors, S sends E(l1, 1), E(l2, 1), and E(l2, 2). On receiving the encrypted location values, Q decrypts them, counts the number of each location, and finds that the location l2 is not following the social distancing rule.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 452,
                    "end": 462,
                    "text": "E(1, 1, x)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 479,
                    "end": 488,
                    "text": "(1, 3, x)",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 497,
                    "end": 506,
                    "text": "(1, 4, x)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Data Encryption Method"
        },
        {
            "text": "Information leakage discussion. Although the data-at-rest does not reveal any information, the query execution reveals accesspatterns (like SSEs or SGX-based systems [38, 59, 62, 31, 33] ). Thus, an adversary, by just observing the query execution, may learn additional information, e.g., which of the tuples correspond to an infected person (by observing Location Trace), how many people may get infected by an infected person (by observing User Trace), which tuples correspond to unique devices by observing queries on Au or ACL, and which locations are frequently visited by users (by observing Social Distance). Also, since CQUEST is based on encryption, a computationally-efficient adversary can break the underlying encryption technique.",
            "cite_spans": [
                {
                    "start": 166,
                    "end": 170,
                    "text": "[38,",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 171,
                    "end": 174,
                    "text": "59,",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 175,
                    "end": 178,
                    "text": "62,",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 179,
                    "end": 182,
                    "text": "31,",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 183,
                    "end": 186,
                    "text": "33]",
                    "ref_id": "BIBREF31"
                }
            ],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "Pros. Though the approach is simple, CQUEST maintains hash tables during encryption of tuples belonging to an epoch. Nevertheless, the size of hash tables is small for an epoch, (see \u00a77). CQUEST efficiently deals with dynamic data, due to independence from an explicit indexable data structure, (unlike indexable SSE techniques [45, 46] that require to rebuild the entire index due to data insertion at the trusted size). Algorithm 2 avoids reading, decrypting the entire data of an epoch to execute a query, (unlike SGX-based systems [62] ); thus, saves computational overheads. Also, the key generation by XORing sq and k pko prevents the adversary to learn any information by observing at the encrypted data belonging to two different organizations, since one of the keys will be surely different at different organizations.",
            "cite_spans": [
                {
                    "start": 328,
                    "end": 332,
                    "text": "[45,",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 333,
                    "end": 336,
                    "text": "46]",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 535,
                    "end": 539,
                    "text": "[62]",
                    "ref_id": "BIBREF60"
                }
            ],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "Cons. Algorithm 1 increases the dataset size by adding two additional columns. Algorithm 2 reveals access-patterns; hence, the adversary may deduce information based on access-patterns. Similar to DaS model [39] , the trapdoor generator has to decrypt the retrieved tuples, possibly to filter them, and to execute a small computation (e.g., group by operation line 14 of Algorithm 2). Also, as we mentioned earlier that QUEST has a limitation that encrypter or trapdoor modules should not be tampered, by anyone, likewise DaS model [39] .",
            "cite_spans": [
                {
                    "start": 207,
                    "end": 211,
                    "text": "[39]",
                    "ref_id": "BIBREF37"
                },
                {
                    "start": 532,
                    "end": 536,
                    "text": "[39]",
                    "ref_id": "BIBREF37"
                }
            ],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "Optimizations. We provide four optimizations: two for trapdoor generation in User Trace(), and the other two for trapdoor generation for Social Distance(). \u00a77 will show the impact of such optimizations. We can avoid sending many trapdoors by encrypting uniqueness of the device, as follows: E k (E k (1, \u2206x), y) (at Line 6-8 of Algorithm 1), where k is known to S and k = (sq \u2295 k pko )||attribute is unknown to S. Thus, for social distancing query execution, Q needs to send to S only \u03b3 = E k (1, \u2206x), and then, S can generate all the desired trapdoors as E k (\u03b3, y), where y is the number of rows in the desired epoch.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Encryption Method"
        },
        {
            "text": "In the above-mentioned optimization, QUEST's encrypter does not need to generate all trapdoors and sends them the server, and the server will generate the desired trapdoors. While it will reduce the communication cost, the computation cost at the server will remain identical to the method given in Algorithm 2 Lines 9. Thus, in order to reduce the computation cost at the server, we can also outsource the hash table created for locations (HTabL, Line 3 Algorithm 1), after each epoch. Now, to execute the social distancing application, QUEST needs to ask the server to send the encrypted hash tables for all the desired epochs. Since the hash table contains the number of unique devices at each location, it will provide the correct answer to the social distancing application after decryption at QUEST.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Dev Loc Time"
        },
        {
            "text": "To overcome the information leakages due to CQUEST, we provide a completely secure solution, IQUEST that is based on stringmatching operation [29] on secret-shares [54] .",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 146,
                    "text": "[29]",
                    "ref_id": "BIBREF27"
                },
                {
                    "start": 164,
                    "end": 168,
                    "text": "[54]",
                    "ref_id": "BIBREF52"
                }
            ],
            "ref_spans": [],
            "section": "IQUEST PROTOCOL"
        },
        {
            "text": "Background: String-matching over secret-shares. As a building block, first, we explain the string matching of Dolev et al. [29] using the following example. Data Owner: outsourcing searchable-secret-share (SSS). Assume there are only two symbols: X and Y; thus, X and Y can be written as 1, 0 and 0, 1 . Suppose, the owner wishes to outsource Y; thus, she creates unary vector 0, 1 . But, to hide exact numbers in 0, 1 , she creates secret-shares of each number using polynomials of an identical degree (see Table 3 ) and sends shares to servers. Table 3 : Secret-shares of 1, 0, 0, 1 , created by the owner. User: SSS query generation. Suppose a user wishes to search for Y. She creates unary vectors of Y as 0, 1 , and then, creates secretshares of each number of 0, 1 using any polynomial of the same degree as used by the owner (see Table 4 ). Note that since a user can use any polynomial, it prevents an adversary to learn an equality condition by observing query predicates and databases. Table 4 : Secret-shares of 1, 0, 0, 1 , created by the user.",
            "cite_spans": [
                {
                    "start": 123,
                    "end": 127,
                    "text": "[29]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [
                {
                    "start": 508,
                    "end": 515,
                    "text": "Table 3",
                    "ref_id": null
                },
                {
                    "start": 547,
                    "end": 554,
                    "text": "Table 3",
                    "ref_id": null
                },
                {
                    "start": 837,
                    "end": 844,
                    "text": "Table 4",
                    "ref_id": null
                },
                {
                    "start": 996,
                    "end": 1003,
                    "text": "Table 4",
                    "ref_id": null
                }
            ],
            "section": "IQUEST PROTOCOL"
        },
        {
            "text": "Servers: String-matching operation. Now, each server has a secretshared database and a secret-shared query predicate. For executing the string-matching operation, the server performs bit-wise multiplication and then adds all outputs of multiplication (see Table 5 ). User: result reconstruction. User receives results from all servers and performs Lagrange interpolation [25] to obtain final answers:",
            "cite_spans": [
                {
                    "start": 371,
                    "end": 375,
                    "text": "[25]",
                    "ref_id": "BIBREF23"
                }
            ],
            "ref_spans": [
                {
                    "start": 256,
                    "end": 263,
                    "text": "Table 5",
                    "ref_id": "TABREF6"
                }
            ],
            "section": "IQUEST PROTOCOL"
        },
        {
            "text": "Now, if the final answer is 1, it shows that the secret-shared database at the server matches the user query.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "IQUEST PROTOCOL"
        },
        {
            "text": "IQUEST uses Algorithm 3 for creating secret-shares of input WiFi relation R. Note that Algorithm 3 when creating SSS or Shamir's secret-shares of a value (denoted by SSS(v) and S(v), respectively), randomly selects a polynomial of an identical degree. Table 2c shows an example of the output of Algorithm 3. Algorithm 3 selects an epoch duration (like CQUEST ( \u00a75)) and produces an i th secret-shared relation S(R)i with six attributes, denoted by A smid , A sid , Asu , AsmL, AsL, and A\u2206. Note that if the adversary cannot collude any two non-communicating servers, then we can use polynomials of degree one, and in this case, there is no need to create more than 2l + 2 shares, where l is the maximum length of a secret, to obtain an answer to a query in one communication round between the user and servers. Algorithm 3 works as follows: Secret-shares of devices: Attributes A smid , A sid (Lines 4-5). We create two types of shares of each device id, one is SSS that is used for string matching operation and stored in A smid , and another is just a Shamir's secret-share of the entire device-id stored in A sid . The purpose of storing the same device-id in two different formats is to speed-up the computation. Particularly, values in A smid help in string-matching operation, when we want to search for a device-id (e.g., location tracing application), and values in A sid helps in fetching the device-id (e.g., user tracking application for retrieving device-ids based on infected locations).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Outsourcing Method"
        },
        {
            "text": "Aside. Recall that creating secret-shares for string matching requires to convert the device-id into a unary vector; as shown in Table 3 . However, it increases the length of device-ids significantly (i.e., 12 \u00d7 16 = 192, often a device-id (MAC-ID) contains 12 hexadecimal digits (a combination of numbers 0, 1, . . . , 9 and alphabets A, B, . . . F), and thus, every single MAC-ID digit will use a unary vector of size 16). Thus, we, first, execute a hash function (only known to IQUEST) on each device-id to map to a smaller length string, by taking the last v < 12 digits of the digest. Hashing may result in a collision, by mapping two different device-ids to the same digest, with a very low probability. For example, for a 256-bit hash function, the probability of collision in mapping all possible 32-bit integers is 2 64 /2 256+1 = 1/2 193 , which is negligible. Uniqueness of devices: Attribute Asu (Lines 6-8).",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 129,
                    "end": 136,
                    "text": "Table 3",
                    "ref_id": null
                }
            ],
            "section": "Data Outsourcing Method"
        },
        {
            "text": "Similar to CQUEST's Algorithm 1, we assign value one when di appears for the first time at a location in an epoch; otherwise, zero. After that we create secret-shares of the value. Secret-shares of location: Attributes A smid , A sid (Line 9). Likewise two types of secret-shares for device-ids, we create two types of shares of each location, one is SSS -stored in AsmL, and another is a Shamir's secret-share of the location stored in AsL. Outsourcing epoch-ids: Attributes A\u2206 (Line 10). Finally, for all tuples of \u2206x, we outsource an epoch identifier in cleartext.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Data Outsourcing Method"
        },
        {
            "text": "Differences between data outsourcing methods of CQUEST and IQUEST. Though CQUEST is an encryption-based method and IQUEST is a secret-sharing-based method, they, also, differ the way of keeping metadata (in Algorithms 1 and 3) . First, IQUEST does not keep a hash table for locations to maintain their occurrences in tuples of an epoch. Second, IQUEST does not need to first find all locations visited by a device during an epoch and adds them in a special attribute; hence, IQUEST does not keep attribute ACL. Note that these differences occur, due to exploiting the capabilities of SSS and selecting different polynomials for creating shares of any value, thereby, different occurrences of an identical value appear different in secret-shared form. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 207,
                    "end": 226,
                    "text": "Algorithms 1 and 3)",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Data Outsourcing Method"
        },
        {
            "text": "Algorithm 4 explains secret-shared query generation at IQUEST (denoted by Q), query execution at the server (denoted by S), and final processing before producing the answer at Q. Note that in Algorithm 4, \u2297 denotes string-matching operation and \u00d7 denotes normal arithmetic multiplication. Below, we explain query execution for different applications over secret-shares.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Query Execution"
        },
        {
            "text": "Location tracing (lines 1-5). First, Q verifies the device id di (as the real device of an infected person) from the publisher P (line 2). Then, Q creates SSS of di (denoted by \u03b3) and sends it to each non-communicating server along with the desired epoch identifier (line 3). Each server executes string-matching operation over each value of A smid against \u03b3 in the desired epoch, and it will result in either 0 or 1 (recall that string-matching operation results in only 0 or 1 of secret-shared form). Then, the i th result of stringmatching operation is multiplied by i th value of AsL, resulting in the secret-shared location, if impacted by the user; otherwise, the secret-shared location value will become 0 of secret-shared form (line 4). Finally, Q receives shares from all servers, interpolates them, and it results in all locations visited by the infected person (line 5). Example 6.1. Suppose d1 belongs to an infected person in Table 2c . To execute location tracing, Q generates SSS of d1, say \u03b3. S checks \u03b3 against the four shares (via string-matching operation) in A smid and results in 1, 0, 1, 1 (of secret-shared form) that is position-wise multiplied by S(l1), S(l2), S(l2), S(l1) . Thus, S sends l1, 0, l2, l1 of secret-shared form to Q that interpolates them to obtain the final answer as l1, l2 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 939,
                    "end": 947,
                    "text": "Table 2c",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Query Execution"
        },
        {
            "text": "User tracing (lines 6-11). First, Q executes Location Trace() to know the impacted locations by the infected person (line 7). Then, Q creates SSS of all impacted locations (denoted by sssLoc[]) and sends them to the servers along with the desired epoch-identifer (which is the same as used when knowing infected locations in line 7). S executes string-matching operation over each value of AsmL against each value of sssLoc[] in the desired epoch, and it will result in either 0 or 1 of secret-shared form). Then, the i th result of string-matching operation is multiplied by i th value of A sid , resulting in the secret-shared device-ids, if impacted by the infected person; otherwise, the secret-shared location value will become 0 of secret-shared form (line 9). Finally, Q receives shares of all impacted people from all servers, interpolates them, and it results in all impacted people (line 10). All such impacted users are notified using Notification( * ) function of Algorithm 2. Example 6.2. We continue from Example 6.1, where d1 was the device of an infected person in Table 2c and impacted locations were l1, l2 that were known to Q after executing Location Trace( * ) (line 1). Now, to find impacted people, Q generates SSS of l1 and l2, say \u03b31 and \u03b32, respectively. S checks \u03b31 and \u03b32 against the four shares (via string-matching operation) in AsmL. It will result in two vectors: 1, 0, 1, 1 of secret-shared form corresponding to \u03b31 and 0, 1, 0, 0 of secret-shared form corresponding to \u03b32. Then, the vectors are position-wise multiplied by S(d1), S(d2), S(d1), S(d1) . Thus, S sends d1, 0, d1, d1 and 0, d2, 0, 0 of secret-shared form to Q. Q interpolates the vectors and knows that the device d2 belongs to an impacted person. Aside. Note that we can also know the devices that do not follow the predefined rule for social distancing, by multiplying the i th value of Asu with the i th value of A sid in the desired epoch, and in experiment section \u00a77, we will find all such device-ids in our experiments. Example 6.3. Suppose that distanceIndex = 1, i.e., if there are more than one person at a location during a given epoch, then it shows that people at the location are not following the predefined social distancing rules. Suppose all four tuples of Table 2c belongs to an epoch. S executes position-wise multiplication and send the output of the following to Q: S(1) \u00d7 S(l1), S(1) \u00d7 S(l2), S(1) \u00d7 S(l2), S(0) \u00d7 S(l1) . Q interpolates the received answers, counts the number of each location (as l1 = 1 and l2 = 2), and finds that the location l2 is not following the social distancing rule.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 1081,
                    "end": 1089,
                    "text": "Table 2c",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 2272,
                    "end": 2280,
                    "text": "Table 2c",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Query Execution"
        },
        {
            "text": "Information leakage discussion. Since Algorithm 3 uses different polynomials of the same degree for creating shares of a secret, an adversary cannot learn anything by observing the shares. Algorithm 4 creates secret-shares of a query predicate that appears different from the secret-shared data. Thus, the adversary by observing the query predicate cannot learn which tuples satisfy the query. Furthermore, since Algorithm 4 performs an identical operation on each share (e.g., lines 4, 9, 14) , it hides access-patterns; thus, the adversary cannot learn anything from the query execution, also. Hence, in IQUEST provides stronger security than CQUEST.",
            "cite_spans": [
                {
                    "start": 484,
                    "end": 486,
                    "text": "4,",
                    "ref_id": null
                },
                {
                    "start": 487,
                    "end": 489,
                    "text": "9,",
                    "ref_id": null
                },
                {
                    "start": 490,
                    "end": 493,
                    "text": "14)",
                    "ref_id": "BIBREF11"
                }
            ],
            "ref_spans": [],
            "section": "Query Execution"
        },
        {
            "text": "Pros. Due to hiding access-patterns, IQUEST provides stronger security and satisfies the security properties given in \u00a73.3, i.e., query and execution privacy. Also, it prevents a computationally efficient adversary to know anything from the ciphertext. Also, it is faulttolerant, due to using multiple servers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Query Execution"
        },
        {
            "text": "Cons. As known, a fully secure system incurs performance overheads. Due to executing an identical operation on each share, and hence, not using any index structure, IQUEST incurs the computational cost at the server. Also, since the servers send a secret-shared vector (having 0 or the desired value) of size equals to the numbers of tuples in the desired epoch, it incurs the communication cost. Nevertheless, \u00a77) will show that such overheads are not very high.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Query Execution"
        },
        {
            "text": "Optimization. In social distancing application using IQUEST, it may turn out that we need to send a significant amount of data from the servers to QUEST. To avoid such communication, Q can send SSS of all the locations (denoted by smLoc[]) to servers. The servers can do the following:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Query Execution"
        },
        {
            "text": "The servers execute string-matching operation for each location of smLoc[] against each value of AsmL in each desired epoch and adds the output of string matching operation. Thus, for each desired epoch, the servers send |sssLoc[]| numbers to Q that interpolates them to know the number of unique devices at each location in the desired epochs. Note that this method will outperform the method given in Algorithm 4 Line 13, if the number of tuples in each epoch are more than the number of locations in smLoc[].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Query Execution"
        },
        {
            "text": "QUEST is deployed at UCI, where it is being used to support social distancing and crowd flow applications [8] . This section evaluates the scalability of QUEST to evaluate its practicality for larger deployments and for all supported applications. We used AWS servers with 192GB RAM, 3.5GHz Intel Xeon CPU with 96 cores and installed MySQL to store secured dataset. A 16GB RAM machine at the local-side hosts QUEST that communicates with AWS servers. Dataset. We used WiFi association data generated using SNMP traps at the campus-level WiFi infrastructure at UCI that consists of 2000 access-points with four controllers. Experiments used realtime data received at one of the four controllers (that collects realtime WiFi data from 490 access-points spread over 40+ buildings). Using this WiFi data, we created two types of datasets, refer to Table 6 . For evaluating IQQUEST, we created nine shares, since at most 2(x + y) + 1 shares are required, where x = 3 (the length of device-ids, line 4 Algorithm 3) and y = 1 (a single secret value in column AsL, line 9 Algorithm 3). Queries. We executed all queries (Q1: social distancing, Q2: Contact tracing, Q4: Crowd-flow), see Table 1 . We modified 'Q3: social distancing query' by also fetching device-ids that do not follow distancing rules, in addition to fetching locations information. Epoch duration CQUEST IQUEST 15min",
            "cite_spans": [
                {
                    "start": 106,
                    "end": 109,
                    "text": "[8]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [
                {
                    "start": 844,
                    "end": 851,
                    "text": "Table 6",
                    "ref_id": "TABREF9"
                },
                {
                    "start": 1177,
                    "end": 1184,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "1.96MB 0.93MB 30min",
            "cite_spans": [],
            "ref_spans": [],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "3.40MB 1.37MB 60min 5.84MB 2.10MB Table 7 : Exp 2: Size of hash tables, for different epoch sizes. Exp 3: Scalability. We measured the scalability of QUEST in three scenarios, by varying the number of infected people, days for tracing, and dataset size. Figure 5 shows results for 1-100 infected users for Q1, Q2 and execution of Q1-Q4 over 1-14 days duration on 10M, 50M rows. In Q1, a device has visited between 1 to 55 locations in 1 epoch. Note that Q1 using CQUEST took less time in all four cases, since it uses an index on A id column (line 4 Algorithm 2); while IQUEST took more time, since it scans all data depending on the queried interval (line 4 Algorithm 4). As the number of infected people increases, the query time increases too. Cost analysis follows the same argument as Q2 that is an extension of Q1.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 34,
                    "end": 41,
                    "text": "Table 7",
                    "ref_id": null
                },
                {
                    "start": 254,
                    "end": 262,
                    "text": "Figure 5",
                    "ref_id": "FIGREF11"
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "For Q3 and Q4 in Figures 5a and 5b, IQUEST took less time than CQUEST. The reason is: IQUEST performs multiplication on i th values of AsL and Asu (line 14 Algorithm 4), and the cost depends on the number of tuples in the desired epochs. However, CQUEST joins a table of size y \u00d7 \u2206t \u00d7 x with the encrypted WiFi data table on AL column to obtain the number of locations having unique devices (line 13 Algorithm 2), where y is the maximum appearance of a location in any epoch (can be of the order of 10,000, causing a larger join table size), \u2206t is the number of desired epochs, and x is the number of locations. Also, note that for Q3 and Q4 in Figures 5c and 5d , IQUEST took more time than CQUEST, since the increase in the cost of multiplication operations (due to larger dataset of 14-days tracing period) in IQUEST overtook the increase in the cost of join in CQUEST. It shows CQUEST is more scalable than IQUEST.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 645,
                    "end": 662,
                    "text": "Figures 5c and 5d",
                    "ref_id": "FIGREF11"
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "Exp 4: Using other existing systems to support QUEST applications. We note an alternative solution, where one may output non-deterministically encrypted [37] or secret-shared WiFi data (via QUEST's encrypter), on which the queries can be executed using existing SSEs [45, 46] , secure hardware-based systems, e.g., Opaque [62] , or MPC-systems. Note that this solution does not need to develop any encryption or query execution algorithm. However, it may allow an adversary to deduce the user locations by observing datasets belonging to different organizations and may incur the high computational cost, as will be clear below.",
            "cite_spans": [
                {
                    "start": 153,
                    "end": 157,
                    "text": "[37]",
                    "ref_id": "BIBREF35"
                },
                {
                    "start": 267,
                    "end": 271,
                    "text": "[45,",
                    "ref_id": "BIBREF43"
                },
                {
                    "start": 272,
                    "end": 275,
                    "text": "46]",
                    "ref_id": "BIBREF44"
                },
                {
                    "start": 322,
                    "end": 326,
                    "text": "[62]",
                    "ref_id": "BIBREF60"
                }
            ],
            "ref_spans": [],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "Thus, to see the impact of using existing systems to support QUEST applications, we used SGX-based Opaque [62] and MPCbased Jana [17] on 10M rows only (since these systems were available to us and work on any dataset). Now, we can compare CQUEST against computationally-secure Opaque and IQUEST against information-theoretically-secure Jana. We inserted data, using non-deterministic encryption in Opaque and using the underlying secret-sharing mechanism in Jana. Then, we used their query execution mechanisms for queries Q1-Q4. Figure 6 shows the impact of using different systems for supporting our four queries on 10M rows. We drop any query that took more than 1000s.",
            "cite_spans": [
                {
                    "start": 106,
                    "end": 110,
                    "text": "[62]",
                    "ref_id": "BIBREF60"
                },
                {
                    "start": 129,
                    "end": 133,
                    "text": "[17]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [
                {
                    "start": 530,
                    "end": 538,
                    "text": "Figure 6",
                    "ref_id": "FIGREF12"
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "Observe that CQUEST works well compared to Opaque, since CQUEST uses index-based retrieval, while Opaque reads entire data in secure memory and decrypts it. CQUEST and Opaque provides the same security, i.e., ciphertext indistinguishability, and reveals access-patterns. Note that CQUEST reveals access-patterns via index-scan, while Opaque reveals access-patterns due to sidechannel (cache-line [38] and branch-shadow [59] ) attacks. Also, IQUEST is efficient compared to Jana that takes more than 1000s in each query. The reason is: IQUEST does not require communication among servers due to using string-matching over secretshares [29] , while Jana requires communication among servers, since Jana is based on MPC techniques that require communication among server during a computation to compute the answer. But, IQUEST and Jana provide identical security by hiding accesspatterns, due to executing identical operations on each tuple.",
            "cite_spans": [
                {
                    "start": 396,
                    "end": 400,
                    "text": "[38]",
                    "ref_id": "BIBREF36"
                },
                {
                    "start": 419,
                    "end": 423,
                    "text": "[59]",
                    "ref_id": "BIBREF57"
                },
                {
                    "start": 634,
                    "end": 638,
                    "text": "[29]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "Exp 5: Impact of optimization. We implemented improved methods to minimize the value of max location counter ( \u00a75) and mea- sured the performance improvement over 10M rows, while fixing the number of infected people to 100 and interval duration to 1-day. When we used counter per epoch for Q2, it reduced the computation time from 63 ( Figure 5b ) to \u224835s and used 128KB more space to maintain the counter; while using counter per epoch and per location, Q2 took only \u22482sec with 55MB space to store the counters.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 336,
                    "end": 345,
                    "text": "Figure 5b",
                    "ref_id": "FIGREF11"
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "We also implemented the improved method for uniqueness finding by outsourcing encrypted hash tables for each epoch. It reduced the time of Q4 (that finds unique devices in each epoch) from 179.4s to 1s. Further, we incorporated this improved method in Q3 (that also finds the devices that does not follow social distancing rule) with counter per epoch and per location optimization, and it reduced the time of Q3 from 206s to 2s.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "Exp 6: Access-patterns. Figure 7 shows a sequence of memory accesses by CQUEST and IQUEST. For this, we run Q2 multiple times, selecting different device-ids each time over a fixed set of epochs. It is clear that IQUEST accesses the same memory locations (accesses all the rows of the given set of epochs) and produces an output for each accessed row for different queries, while CQUEST accesses different memory locations (different rows for different device-ids) for answering different queries.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 24,
                    "end": 32,
                    "text": "Figure 7",
                    "ref_id": "FIGREF14"
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "Exp 7: Impact of communication. Table 8 shows the amount of data transfer using CQUEST and the data transfer time using different transfer speeds. From Table 8 , it is clear that CQUEST is communication efficient, while CQUEST reveals information from access-patterns. In particular, without using optimization methods (as described in \u00a75), Q3 and Q4 incur significant communication overheads, i.e., fetch \u224895MB data from the server. However, the optimization methods reduce such data size to \u224857KB. Table 9 shows the amount of data transfer using IQUEST and the data transfer time using different transfer speeds. From Table 9 , it is clear that IQUEST incurs communication overhead, while IQUEST provides a high-level of security. In particular, Q1 requires us to fetch \u224832MB data from each server when tracing period was 14days for an infected person. As Q2 requires two communication rounds (the first for knowing the impacted location and another for knowing the impacted device ids), it incurs signification communication cost by fetching \u22483.5GB data from each server. The reason is: we need to fetch data corresponding to 55 locations that a user can visit during an epoch. Q3, also, incurs the same communication overhead. Q4 requires to download \u224832MB data from each server for executing social distancing over 14-days. However, when we use the improved method (as described in \u00a76) for Q4, we need to fetch only 2.1MB data. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 32,
                    "end": 39,
                    "text": "Table 8",
                    "ref_id": null
                },
                {
                    "start": 152,
                    "end": 159,
                    "text": "Table 8",
                    "ref_id": null
                },
                {
                    "start": 500,
                    "end": 507,
                    "text": "Table 9",
                    "ref_id": null
                },
                {
                    "start": 620,
                    "end": 627,
                    "text": "Table 9",
                    "ref_id": null
                }
            ],
            "section": "EXPERIMENTAL EVALUATION"
        },
        {
            "text": "In this paper, we designed, developed, and validated a system, called QUEST for privacy-preserving presence and contact tracing at the organizational level using WiFi connectivity data to enable community safety in a pandemic. QUEST incorporates a flexible set of methods that can be customized depending on the desired privacy needs of the smartspace and its associated data. We anticipate that capabilities provided by QUEST are vital for organizations to resume operations after a community-scale lockdown -the passive approach to information gathering in QUEST can enable continuous information awareness to encourage social distancing measures and identify settings and scenarios, where additional caution should be exercised. Ongoing discussions with campus administration at UC Irvine to utilize QUEST's capabilities for a staged and guided reopening of campus have highlighted the value of the privacy and security features embedded in QUEST. The living lab experience at UC Irvine will enable us to tune the underlying cryptographic protocols for other useful applications including dynamic occupancy counts and context-aware messaging to encourage safe operations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "LESSONS LEARNT"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Apple's and Google's COVID-19 contact tracing technology",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Privacy-Preserving Proximity Tracing: available at",
            "authors": [
                {
                    "first": "",
                    "middle": [],
                    "last": "Pan-European",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Georgia's daily coronavirus deaths will nearly double by August with relaxed social distancing, model suggests",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Polls: Americans dont want to end social distancing policies despite financial devastation",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "QUEST Applications: available at",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Fake news about the coronavirus is hazardous to your health. Don't fall for it: Doctor",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "During this coronavirus pandemic",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Order-preserving encryption for numeric data",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "SIGMOD",
            "volume": "",
            "issn": "",
            "pages": "563--574",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Google COVID-19 community mobility reports: Anonymization process description",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Aktay",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "EPIC: efficient privacy-preserving contact tracing for infection detection",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Altuwaiyan",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "ICC",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Forward and backward private searchable encryption with SGX",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Amjad",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proceedings of the 12th European Workshop on Systems Security",
            "volume": "4",
            "issn": "",
            "pages": "1--4",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "From keys to databases -real-world applications of secure multi-party computation",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "W"
                    ],
                    "last": "Archer",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Comput. J",
            "volume": "61",
            "issn": "12",
            "pages": "1749--1771",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Deterministic and efficiently searchable encryption",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Bellare",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "CRYPTO",
            "volume": "",
            "issn": "",
            "pages": "535--552",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Familylog: A mobile system for monitoring family mealtime activities",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Bi",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "PerCom",
            "volume": "",
            "issn": "",
            "pages": "21--30",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "On notions of security for deterministic encryption, and efficient constructions without random oracles",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Boldyreva",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "CRYPTO",
            "volume": "",
            "issn": "",
            "pages": "335--359",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Distance-bounding protocols (extended abstract)",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Brands",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "EUROCRYPT",
            "volume": "",
            "issn": "",
            "pages": "344--359",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Adaptively secure multi-party computation",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Canetti",
                    "suffix": ""
                }
            ],
            "year": 1996,
            "venue": "STOC",
            "volume": "",
            "issn": "",
            "pages": "639--648",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Anonymous collocation discovery:taming the coronavirus while preserving privacy",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Canetti",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Trachtenberg",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Varia",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Contact tracing mobile apps for covid-19: Privacy considerations and related trade-offs",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Cho",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Ippolito",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [
                        "W"
                    ],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "A graduate introduction to numerical methods",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "M"
                    ],
                    "last": "Corless",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Fillion",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "AMC",
            "volume": "10",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "Searchable symmetric encryption: Improved definitions and efficient constructions",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Curtmola",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Journal of Computer Security",
            "volume": "19",
            "issn": "5",
            "pages": "895--934",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Tracking and controlling the spread of a virus in a privacy-preserving way. CoRR, abs",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Demirag",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Accumulating automata and cascaded equations automata for communicationless information theoretically secure multi-party computation",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Dolev",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Theor. Comput. Sci",
            "volume": "795",
            "issn": "",
            "pages": "81--99",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Netconf configuration protocol",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Enns",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "RFC",
            "volume": "4741",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Oblidb: Oblivious query processing for secure databases",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Eskandarian",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Proc. VLDB Endow",
            "volume": "13",
            "issn": "",
            "pages": "169--183",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Hardidx: Practical and secure index with SGX in a malicious environment",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Fuhry",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Journal of Computer Security",
            "volume": "26",
            "issn": "5",
            "pages": "677--706",
            "other_ids": {}
        },
        "BIBREF31": {
            "ref_id": "b31",
            "title": "Searchable encrypted, fast, compressed, in-memory database using enclaves. CoRR, abs",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Fuhry",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF32": {
            "ref_id": "b32",
            "title": "Multiparty proximity testing with dishonest majority from equality testing",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gelles",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ICALP",
            "volume": "",
            "issn": "",
            "pages": "537--548",
            "other_ids": {}
        },
        "BIBREF33": {
            "ref_id": "b33",
            "title": "The syslog protocol. Request for Comments",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Gerhards",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "5424",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF34": {
            "ref_id": "b34",
            "title": "Onion routing",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "M"
                    ],
                    "last": "Goldschlag",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Commun. ACM",
            "volume": "42",
            "issn": "2",
            "pages": "39--41",
            "other_ids": {}
        },
        "BIBREF35": {
            "ref_id": "b35",
            "title": "Probabilistic encryption",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Goldwasser",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Micali",
                    "suffix": ""
                }
            ],
            "year": 1984,
            "venue": "J. Comput. Syst. Sci",
            "volume": "28",
            "issn": "2",
            "pages": "270--299",
            "other_ids": {}
        },
        "BIBREF36": {
            "ref_id": "b36",
            "title": "Cache attacks on Intel SGX",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "G\u00f6tzfried",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "EUROSEC",
            "volume": "2",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF37": {
            "ref_id": "b37",
            "title": "Providing database as a service",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Hacig\u00fcm\u00fcs",
                    "suffix": ""
                }
            ],
            "year": 2002,
            "venue": "ICDE",
            "volume": "",
            "issn": "",
            "pages": "29--38",
            "other_ids": {}
        },
        "BIBREF38": {
            "ref_id": "b38",
            "title": "CONTAIN: privacy-oriented contact tracing protocols for epidemics. CoRR, abs",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Hekmati",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF39": {
            "ref_id": "b39",
            "title": "Private large-scale databases with distributed searchable symmetric encryption",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Ishai",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "RSA",
            "volume": "",
            "issn": "",
            "pages": "90--107",
            "other_ids": {}
        },
        "BIBREF40": {
            "ref_id": "b40",
            "title": "Challenges for social sensing using wifi signals",
            "authors": [
                {
                    "first": "M",
                    "middle": [
                        "B"
                    ],
                    "last": "Kjaergaard",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Workshop on Mobile systems for computational social science",
            "volume": "",
            "issn": "",
            "pages": "17--21",
            "other_ids": {}
        },
        "BIBREF41": {
            "ref_id": "b41",
            "title": "The nearme wireless proximity server",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Krumm",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "UbiComp",
            "volume": "",
            "issn": "",
            "pages": "283--300",
            "other_ids": {}
        },
        "BIBREF42": {
            "ref_id": "b42",
            "title": "Proximity detection using wireless signal strengths",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "C"
                    ],
                    "last": "Krumm",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "US Patent",
            "volume": "7",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF43": {
            "ref_id": "b43",
            "title": "Fast range query processing with strong privacy protection for cloud computing",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "",
            "volume": "7",
            "issn": "",
            "pages": "1953--1964",
            "other_ids": {}
        },
        "BIBREF44": {
            "ref_id": "b44",
            "title": "Adaptively secure conjunctive query processing over encrypted data for cloud computing",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ICDE",
            "volume": "",
            "issn": "",
            "pages": "697--708",
            "other_ids": {}
        },
        "BIBREF45": {
            "ref_id": "b45",
            "title": "Probetags: Privacy-preserving proximity detection using wi-fi management frames",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Maier",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "WiMob",
            "volume": "",
            "issn": "",
            "pages": "756--763",
            "other_ids": {}
        },
        "BIBREF46": {
            "ref_id": "b46",
            "title": "TIPPERS: A privacy cognizant iot environment",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Mehrotra",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "PerCom W",
            "volume": "",
            "issn": "",
            "pages": "1--6",
            "other_ids": {}
        },
        "BIBREF47": {
            "ref_id": "b47",
            "title": "Peer-to-peer determination of proximity using wireless network data",
            "authors": [
                {
                    "first": "J.-L",
                    "middle": [],
                    "last": "Meunier",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "PerComW",
            "volume": "",
            "issn": "",
            "pages": "70--74",
            "other_ids": {}
        },
        "BIBREF48": {
            "ref_id": "b48",
            "title": "ENACT: encounter-based architecture for contact tracing",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Prasad",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Kotz",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "WPA@MobiSys",
            "volume": "",
            "issn": "",
            "pages": "37--42",
            "other_ids": {}
        },
        "BIBREF49": {
            "ref_id": "b49",
            "title": "Quantifying surveillance in the networked age: Node-based intrusions and group privacy",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Radaelli",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF50": {
            "ref_id": "b50",
            "title": "Inferring person-to-person proximity using wifi signals",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Sapiezynski",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "IMWUT",
            "volume": "1",
            "issn": "2",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF51": {
            "ref_id": "b51",
            "title": "Flexible snmp trap mechanism",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Schlener",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Vasudev",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "US Patent",
            "volume": "6",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF52": {
            "ref_id": "b52",
            "title": "How to share a secret",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Shamir",
                    "suffix": ""
                }
            ],
            "year": 1979,
            "venue": "Commun. ACM",
            "volume": "22",
            "issn": "11",
            "pages": "612--613",
            "other_ids": {}
        },
        "BIBREF53": {
            "ref_id": "b53",
            "title": "Practical techniques for searches on encrypted data",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "X"
                    ],
                    "last": "Song",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "SP",
            "volume": "",
            "issn": "",
            "pages": "44--55",
            "other_ids": {}
        },
        "BIBREF54": {
            "ref_id": "b54",
            "title": "Privacy-preserving contact tracing: current solutions and open questions. CoRR, abs",
            "authors": [
                {
                    "first": "Q",
                    "middle": [],
                    "last": "Tang",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF55": {
            "ref_id": "b55",
            "title": "Decentralized privacy-preserving proximity tracing overview of data protection and security",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Troncoso",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF56": {
            "ref_id": "b56",
            "title": "Secure ranked keyword search over encrypted cloud data",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ICDCS",
            "volume": "",
            "issn": "",
            "pages": "253--262",
            "other_ids": {}
        },
        "BIBREF57": {
            "ref_id": "b57",
            "title": "Leaky cauldron on the dark land: Understanding memory side-channel hazards in SGX",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "CCS",
            "volume": "",
            "issn": "",
            "pages": "2421--2434",
            "other_ids": {}
        },
        "BIBREF58": {
            "ref_id": "b58",
            "title": "The secure shell (ssh) protocol architecture",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Ylonen",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF59": {
            "ref_id": "b59",
            "title": "Attribute based data sharing with attribute revocation",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Yu",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "ASIACCS",
            "volume": "",
            "issn": "",
            "pages": "261--270",
            "other_ids": {}
        },
        "BIBREF60": {
            "ref_id": "b60",
            "title": "Opaque: An oblivious and encrypted distributed analytics platform",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Zheng",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "NSDI",
            "volume": "",
            "issn": "",
            "pages": "283--298",
            "other_ids": {}
        },
        "BIBREF61": {
            "ref_id": "b61",
            "title": "EDUM: classroom education measurements via large-scale wifi networks",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zhou",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "UbiComp",
            "volume": "",
            "issn": "",
            "pages": "316--327",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "QUEST system.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Social distancing application interface before lockdown.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Social distancing application interface after lockdown.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Crowd-flow application interface after lockdown.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "User tracing (lines 6-10). First, Q executes Location Trace() to know the impacted locations by the infected person (line 7). Then, Q creates trapdoors for all such locations (line 8), as: E(li, m), where li is the i th impacted location and m is the maximum counter value for any location in any epoch, as obtained in Algorithm 1's line 14. 7 S executes a selection query for the trapdoor",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "(c) Secret-shared WiFi relation for an epoch.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Location counters. Note that Line 8 of Algorithm 2 requires us to generate the number of trapdoors equals to the maximum counter values (i.e., maximum connection events at a location in any epoch (Line 14 of Algorithm 1)). It may incur overhead in generating trapdoors and sending them to the server. Thus, we can reduce the number of trapdoors by keeping two types of counters: (i) counter per epoch to contain the maximum connection events at a location in each epoch, and (ii) counter per epoch and per location to contain the maximum connection events at each location in each epoch. Trapdoor generation for uniqueness finding. Line 12 Algorithm 2 requires QUEST's encrypter to generate and send the number of trapdoors equals to the maximum number of tuples in any epoch.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "Hash function. capacity l i : The capacity of location li. distanceIndex: Maximum % of allowed people. Output: Answers to queries. Functions: SSS(v ) and S(v ): From Algorithm 3. interpolate(shares): An interpolation function that takes shares as inputs and produces the secret value. S: \u03b3 \u2190 SSS(di), \u2206t: t covers the requested Time 4 S: sLoc[] \u2190 (A smid [j] \u2297 \u03b3) \u00d7 AsL, j \u2208 {1, y}, y = #tuples in \u2206t 5 Q: location[] \u2190 interpolate(sLoc[]) 6 Function User Trace(q(di, Time)) begin 7 Q: location[] \u2190 Location Trace(q(di, Time)) 8 Q \u2192 S: sssLoc[] \u2190 SSS(location[]), \u2206t: t covers the requested Time 9 S: \u2200i \u2208 {1, |sssLoc[]|}, \u2200j \u2208 {1, y}, y = #tuples in \u2206t, sID[i, j] \u2190 (sssloc[i] \u2297 AsmL[j]) \u00d7 A sid [j] 10 Q: id[] \u2190 interpolate(sID[ * , * ]), \u2200i \u2208 {1, |sID[ * , \u2192 S: \u2206t: t covers the requested Time 14 S \u2192 Q: sLoc[j] \u2190 Asu [j] \u00d7 AsL[j], \u2200j \u2208 \u2206t 15 Q: location[] \u2190 interpolate(sLoc[]) 16 Q: \u2200li \u2208 location[], count l i \u2190 count l i + 1 17 Q: if count l i > capacity l i \u00d7 distanceIndex then Issue alarm 18 Function Crowd Flow (q(Time)) begin 19 Q: Social Distance(q(Time))",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "Social distancing (lines[12][13][14][15][16][17]. Q sends the desired epoch identifier to the servers (line 13). Based on the desired identifier, each server multiplies the i th value of Asu with the i th value of AsL, and it results in all locations having the unique devices. The server sends all such locations to Q (line 14). First, Q interpolates the received locations (line 15) and then, counts the appearance of each location (line 16). Finally, Q issues an alarm, if the counter value for a location exceeds the predefined rule for social distancing, denoted by distanceIndex (line 17).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Exp 3: Scalability test of 10M and 50rows with varying other parameters.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Exp 4: Using other systems (secure hardware based Opaque and MPC-based Jana) vs CQUEST and IQUEST on 10M.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF14": {
            "text": "Exp 6: Access-patterns created by QUEST.",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "A sample of supported applications by QUEST in SQL.frequency-count attack, while data-at-rest. Also, during query execution, we want to know whether di is present in the desired epoch at least once or not. To do so, we encrypt the first appearance of di in the epoch as E(di, 1, x) and maintain a hash table with value one for di in the epoch. Otherwise, we use any random number r and encrypts as E(di, r). We add the epoch-id with E(di, 1, x) to make di's first appearance indistinguishable in other epochs.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "). Second, we need to deal with di that moves to different locations in \u2206x. Note that based on E(di, 1, x), we can search only the first appeared location of di in \u2206x. Thus, we collect all locations visited by di in \u2206x and add to the combined-locations attribute ACL in a tuple having E(di, 1, x). We pad the remaining values of ACL by encrypted fake values.Inputs: \u2206: duration. di, lj , t k : A tuple. H: Hash function. E: encryption function. PRF: a pseudo-random generator. Output: R(A id , Au, A L , ACL, A\u2206): An encrypted relation R with five attributes. Variable: c l i : A counter variable for location li. then R.A id [y] \u2190 E k1 (di, r), R.Au[y] \u2190 E k2 (1, y, \u2206x), \u03b1i[] \u2190 lj",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "CQUEST query execution algorithm. : H: Hash function. E: encryption function. capacity l i : The capacity of location li. distanceIndex: Maximum % of allowed people. Registry[]: The list of users allowed sending them notifications. Output: Answers to queries. 1 Function Location Trace(q(di, Time)) begin if Q \u2194 P: Verify di Successful then 3 Q: Generate trapdoors E(di, 1, \u2206t): t covers the requested Time 4 S \u2192 Q: loc[] \u2190 Location values from ACL corresponding to selection query for fetching the values of ACL column corresponding to all encrypted query trapdoors (line 4). The answers to the selection query are given to Q that decrypts them to know the impacted locations (line 5). Example 5.1. Suppose d1 belongs to an infected person inTable 2b, and all four tuples belong to an identical epoch x. To execute location tracing, Q creates trapdoor for d1, as: E(d1, 1, x). S checks the trapdoor in A id column and sends the corresponding value of ACL column, i.e., E k4 (r, l1, l2) to Q. On decrypting the received answer, Q knows the impacted locations as l1 and l2.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Original WiFi dataset, encrypted WiFi dataset using Algorithm 1, and secret-shared WiFi dataset using Algorithm 3.",
            "latex": null,
            "type": "table"
        },
        "TABREF6": {
            "text": "Servers' computation.",
            "latex": null,
            "type": "table"
        },
        "TABREF7": {
            "text": "Inputs: \u2206: duration. di, lj , t k : A tuple. H: A hash function known to only IQUEST. z: a secret of proxy, unknown to organization. Output: S(R)i(A smid , A sid , Asu , AsmL, AsL, A\u2206): An i th encrypted relation R with six attributes. Functions: SSS(v ): A function for creating searchable secret-shares of v . S(v ): A function for creating Shamir's secret-shares of v . 1 Function create shares(\u2206x) begin HTab id \u2190 init hash table device() for ty = di, lj , t k \u2208 \u2206x do val \u2190 last v bits(H(di)) R.A smid [y] \u2190 SSS(val), R.A sid [y] \u2190 S(val)",
            "latex": null,
            "type": "table"
        },
        "TABREF9": {
            "text": "Characteristics of the datasets used in experiments.",
            "latex": null,
            "type": "table"
        },
        "TABREF10": {
            "text": "Exp 1: Throughput. In order to evaluate the overhead of CQUEST and IQUEST at the ingestion time, we measured the throughput (rows/minute) that QUEST can sustain. CQUEST Algorithm 1 can encrypt \u2248494,226 tuples/min, and IQUEST Algorithm 3 can create secret-shares of \u224838,935 tuples/min. While the throughput of Algorithm 3's is significantly less than Algorithm 1, as it needs to create 9 (different) shares, it can sustain UCI level workload on the relatively weaker machine used for hosting QUEST.Exp 2: Metadata size. Recall that Algorithm 4 (Algorithm 2) for IQUEST (CQUEST) maintains hash-tables for a certain duration.Table 7shows the size of hash tables created for epochs of different sizes: 15min, 30min, and 60min. Note that the metadata size for CQUEST is larger than IQUEST, since CQUEST uses two hash tables (line 3 Algorithm 2) and one list of visited places by each device, while IQUEST uses only one hash table (line 2 Algorithm 4) and the list. Metadata overheads remain small for both techniques.(a) 1-infected, 1-day. (b) 100-infected, 1-day.(c) 1-infected, 14-days.(d) 100-infected, 14-days.",
            "latex": null,
            "type": "table"
        },
        "TABREF11": {
            "text": "Trans. speed 100MB/s Neg. Neg. \u22481m Neg. Trans. speed 500MB/s Neg. Neg. \u224811s Neg. Table 8: Exp 7: CQUEST: amount of data transfer and required time (Neg. refers to negligible).",
            "latex": null,
            "type": "table"
        },
        "TABREF12": {
            "text": "1MB Trans. speed 25MB/s Neg. \u22482.5m \u22482.5m Neg. Trans. speed 100MB/s Neg. \u22481m \u22481m Neg. Trans. speed 500MB/s Neg. \u224811s \u224811s Neg. Table 9: Exp 7: IQUEST: amount of data transfer and required time (Neg. refers to negligible).",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "In order to define security property of CQUEST, we follow the standard security definitions of symmetric searchable encryption techniques [27] that define the security in terms of leakages: setup leakage Ls (that includes the leakages from the encrypted database size and leakages from metadata size) and query leakage Lq (that includes search-patterns (i.e., revealing if and when a query is executed) and access-patterns (i.e., revealing which tuples are retrieved to answer a query)). Based on these leakages, the security notion provides a guarantees that an encrypted database reveals no other information about the data beyond leakages Ls and Lq. Now, before defining security property, we need to formally define CQUEST's query execution method that contains the following three algorithms:1. (K, R)) \u2190 Setup(1 k , R): is a probabilistic algorithm that takes as input a security parameter 1 k and a relation R. It outputs a secret key K and an encrypted relation R. This algorithm (as given in Algorithm 1) is executed at QUEST's encrypter, before outsourcing a relation to the cloud. 2. trapdoor {1, . . . , q} \u2190 Trapdoor Gen(K, query): is a deterministic algorithm that takes as input the secret key K and a query predicate query, and outputs a set of query trapdoors, denoted by trapdoor {1, . . . , q}. This algorithm (as given in Algorithm 2) is executed at QUEST's trapdoor generator and trapdoor {1, . . . , q} are sent to the server to retrieve the desired tuples. 3. results \u2190 Query Exe(trapdoor {1, . . . , q}, R): is a deterministic algorithm and executed at the server. It takes the encrypted relation R and the encrypted query trapdoors trapdoor {1, . . . , q} as the inputs. Based on the inputs, it produces the results.In order to define the security notion, we adopt the real and ideal game model security definition [27] . Based on this game, what the security property is provided is known as indistinguishability under chosen-keyword attack (IND-CKA) model [27] . IND-CKA prevents an adversary from deducing the cleartext values of data from the encrypted relation or from the query execution, except what is already known.",
            "cite_spans": [
                {
                    "start": 138,
                    "end": 142,
                    "text": "[27]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 1840,
                    "end": 1844,
                    "text": "[27]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 1983,
                    "end": 1987,
                    "text": "[27]",
                    "ref_id": "BIBREF25"
                }
            ],
            "ref_spans": [],
            "section": "APPENDIX A. SECURITY PROPERTY FOR ACCESS-PATTERN-REVEALING SOLUTIONS"
        },
        {
            "text": "Let \u03a8 = (Setup, Trapdoor Gen, Query Exe) be a tuple of algorithms. Let A be an adversary. Let Ls be the setup leakage, and let Lq be the query leakage.\u2022 Real \u03a8,A(k): The adversary produces a relation R and sends it to a simulator. The simulator runs Setup algorithm and produces an encrypted relations R that is sent to A. The adversary A executes a polynomial number of queries on the encrypted relations R by asking trapdoors for each of the queries from the simulator. Then, the adversary A executes queries using Query Exe() algorithm and produces a bit b. \u2022 Ideal \u03a8,A(k): The adversary A produces a relation R . Note that this relation may or may not be identical to the relation R, produced in Real \u03a8,A(k). However, Ls in the ideal world should be identical to the real world. The simulator has neither access to the real dataset R, nor access to the real queries. Instead, the simulator has, only, access to Ls and Lq. The simulator simulates Setup and Trapdoor Gen algorithms. Given Ls and Lq, the simulator produces an encrypted relation R and the trapdoors for all queries that were previously executed. The adversary executes the queries and produces a bit b.We say \u03a8 is (Ls, Lq)-secure against non-adaptive adversary, iff for any probabilistic polynomial time (PPT) adversary A, there exists a PPT simulator such that:The above real-ideal game provides the following intuition: an adversary selects two different relations, R1 and R2, having an identical number of attributes and an identical number of tuples. Relations R1 and R2 may or may not overlap. The simulator simulates the role of QUEST encrypter to produce an encrypted relation and provides it to the adversary. On the encrypted data, the adversary executes a polynomial number of queries. The adversarial task is to find the relation encrypted by the simulator, based on the query execution. The adversary cannot differentiate between the two encrypted relations, since if the adversary cannot find which encrypted relation is produced by the simulator with probability non-negligibly different from 1/2, then the query execution reveals nothing about the relation.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Security Definition."
        }
    ]
}