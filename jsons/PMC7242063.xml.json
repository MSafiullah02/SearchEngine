{
    "paper_id": "PMC7242063",
    "metadata": {
        "title": "Refinement and Verification of Responsive Control Systems",
        "authors": [
            {
                "first": "Alexander",
                "middle": [],
                "last": "Raschke",
                "suffix": "",
                "email": "alexander.raschke@uni-ulm.de",
                "affiliation": {}
            },
            {
                "first": "Dominique",
                "middle": [],
                "last": "M\u00e9ry",
                "suffix": "",
                "email": "dominique.mery@loria.fr",
                "affiliation": {}
            },
            {
                "first": "Frank",
                "middle": [],
                "last": "Houdek",
                "suffix": "",
                "email": "frank.houdek@daimler.com",
                "affiliation": {}
            },
            {
                "first": "Karla",
                "middle": [],
                "last": "Morris",
                "suffix": "",
                "email": "knmorri@sandia.gov",
                "affiliation": {}
            },
            {
                "first": "Colin",
                "middle": [],
                "last": "Snook",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Thai",
                "middle": [
                    "Son"
                ],
                "last": "Hoang",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Geoffrey",
                "middle": [],
                "last": "Hulette",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Robert",
                "middle": [],
                "last": "Armstrong",
                "suffix": "",
                "email": null,
                "affiliation": {}
            },
            {
                "first": "Michael",
                "middle": [],
                "last": "Butler",
                "suffix": "",
                "email": null,
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Reactive Statecharts are open systems capable of receiving potentially non-deterministic input. This work, which builds on our previous work [7, 8], exposes a srhallow embedding of open Statecharts semantics in\n\n. Statecharts provide a graphical language, generalized from state machines, that is popular with engineers, variants of which appear in Matlab Simulink/Stateflow [6] and the Ansys tools. Particularly attractive is providing accessibility to abstraction/refinement via Rodin/\n\nwhich has an intuitive metaphor in the\n\nsemantics [7, 8]. The commercial tools have similar ideas expressed as encapsulation and composition but not entailing any formal guarantees. The hope is that engineers can better understand the origin of proof obligations in refinements and achieve formal guarantees earlier in their designs where it is most tractable.",
            "cite_spans": [
                {
                    "start": 142,
                    "end": 143,
                    "mention": "7",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 145,
                    "end": 146,
                    "mention": "8",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 376,
                    "end": 377,
                    "mention": "6",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 540,
                    "end": 541,
                    "mention": "7",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 543,
                    "end": 544,
                    "mention": "8",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Related work has developed a number of different semantics all with different purposes and outcomes [2, 3, 5]. Because our contribution is focused on a mapping to\n\n, safety property preserving refinement is key.\n\nprovides not only a definition of refinement but a rubric for finding valid refinements and this is carried over into the Statecharts work presented here. In our version of\n\nsemantics, refinement means a subsetting of traces from an abstraction. This has the beneficial effect of preserving safety properties from abstraction to refinement and permits proofs to be discharged at the highest tractable level of abstraction. It is at the highest level of abstraction that proofs are presumably the easiest to discharge.",
            "cite_spans": [
                {
                    "start": 101,
                    "end": 102,
                    "mention": "2",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 104,
                    "end": 105,
                    "mention": "3",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 107,
                    "end": 108,
                    "mention": "5",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "SCXML is a modelling language based on Harel statecharts [12]. State-Chart XML (SCXML) follows a \u2018run to completion\u2019 semantics, where trigger events may be needed to enable transitions. Trigger events are queued when they are raised, and then one is de-queued and consumed by firing all the transitions that it enables, followed by any (un-triggered) transitions that then become enabled due to the change of state caused by the initial transition firing. This is repeated until no transitions are enabled, and then the next trigger is de-queued and consumed. There are two kinds of triggers: internal triggers are raised by transitions and external triggers are raised by the environment (non-deterministically for the purpose of our analysis). An external trigger may only be consumed when the internal trigger queue has been emptied.",
            "cite_spans": [
                {
                    "start": 58,
                    "end": 60,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "Event-B is a formal method for system design [1, 4]. It uses refinement to introduce system details gradually into the formal model. An\n\nmodel contains two parts: contexts and machines. Contexts contain carrier sets, constants, and axioms constraining the carrier sets and constants. Machines contain variables\n\n, invariants\n\nconstraining the variables, and events. An event consists of a guard denoting its enabled-condition and an action defining the value of variables after the event is executed. In general, an event\n\nhas the form:\n\nwhere\n\nare the event parameters,\n\nis the guard of the event, and\n\nis the action of the event.",
            "cite_spans": [
                {
                    "start": 46,
                    "end": 47,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 49,
                    "end": 50,
                    "mention": "4",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "Machines can be refined by adding more details. Refinement can be done by extending the machine to include additional variables (superposition refinement) representing new features of the system, or by replacing some (abstract) variables by new (concrete) variables (data refinement).",
            "cite_spans": [],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "UML-B State-machines provides a diagrammatic modelling notation for\n\nin the form of state-machines and class diagrams [9\u201311]. The diagrammatic models relate to an\n\nmachine and generate or contribute to parts of it.",
            "cite_spans": [
                {
                    "start": 119,
                    "end": 120,
                    "mention": "9",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 121,
                    "end": 123,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "Each state is encoded as a boolean variable and the current state is indicated by one of the boolean variables being set to\n\n. An invariant ensures that only one state is set to\n\nat a time. Events change the values of state variables to move the\n\nvalue according to the transitions in the state-machine.",
            "cite_spans": [],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "While the\n\ntranslation deals with the basic data formalisation of state-machines it differs significantly from the semantics discussed in this manuscript.\n\nadopts\n\nsimple guarded action semantics and does not have a concept of triggers and run-to-completion. Here we make use of\n\nstate-machine translation but provide a completely different semantic by generating a behaviour into the underlying\n\nevents that are linked to the generated\n\ntransitions.",
            "cite_spans": [],
            "section": "Background",
            "ref_spans": []
        },
        {
            "text": "The run to completion semantics is specified via an abstract basis that is extended by the model. The specification of this basis consists of an\ncontext and machine that are the same for all input models and are refined by the specific output of the translation. This allows us to introduce an abstract behaviour of transitions queueing and using triggers which is gradually refined to introduce the actual triggering and transitions of the specific example being modelled. It would not otherwise be possible for newly introduced transitions to modify the abstract queues. The basis context introduces a set of all possible triggers, which is partitioned into internal and external triggers (e.g.\n\nand\n\nrespectively), some of which will be introduced in future refinements. Each refinement partitions these trigger sets further to introduce concrete triggers, leaving a new abstract set to represent the remaining triggers yet to be introduced.",
            "cite_spans": [],
            "section": "Run to Completion",
            "ref_spans": []
        },
        {
            "text": "The basis machine declares variables that correspond to the internal and external queues, the dequeued trigger and a flag that signals when a run to completion macro-step has been completed (no un-triggered transitions are enabled). The abstract event\n\nrepresents a combination of transitions that are triggered by the trigger presently ready to dequeue, |dt|. The actions of these transitions may also raise triggers of their own.",
            "cite_spans": [],
            "section": "Run to Completion",
            "ref_spans": []
        },
        {
            "text": "In the process of refining a model, a designer takes advantage of the non-determinism in the abstraction to introduce new triggers and state-chart behaviour that refines abstract events. By default a run may non-deterministically complete at any stage until no un-triggered transitions are enabled (when completion is the only choice left). This allows for future refinements that may strengthen the guards of transitions (e.g. by introducing new nested states as the source of a transition) Such guard strengthening refinements correspond to earlier (i.e. weaker) completion, hence the need to allow for this behaviour in the abstraction. When a refinement level is reached for which the designer wants to verify a property that relies on a particular control response within the current run, early completion must be disallowed. This is done by specifying (as an annotation in the SCXML model) that the transitions involved in the run are finalized. The SCXML translation tool will then automatically strengthens the guards of the completion events to ensure that the run to completion sequence is not interrupted early by non-deterministic behaviour.",
            "cite_spans": [],
            "section": "Run to Completion",
            "ref_spans": []
        },
        {
            "text": "The translation of a specific SCXML model extends that described in [7, 8] with the following additions:Trigger Queues in Basis: The encoding of trigger queues in the abstract basis machine has been improved so that triggers are properly dequeued before potential use, which allows triggers to be discarded if the controller cannot respond to them. This more accurately reflects the SCXML semantics.Finalisation: Transitions can be flagged as finalised which means their guards can not be strengthened in subsequent refinements. This allows them to be \u2018enforced\u2019 when they are enabled (i.e. completion cannot occur until they have fired) which is needed for verification.Restricted Raising of Internal Triggers: Once a trigger is introduced it must immediately be raised at that refinement level by any transitions that wish to do so. It cannot be raised in later refinements except by newly introduced transitions. This restriction was necessary to make simulation more useful by removing non-deterministic raising of triggers in anticipation of refinements.Context Instantiation: The axioms of the basis context, that allow future triggers to be added, have been improved so that\n\n1can automatically create an instantiation.\n",
            "cite_spans": [
                {
                    "start": 69,
                    "end": 70,
                    "mention": "7",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 72,
                    "end": 73,
                    "mention": "8",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Run to Completion",
            "ref_spans": []
        },
        {
            "text": "A tool to automatically translate SCXML models into\n\nhas been produced.",
            "cite_spans": [],
            "section": "Run to Completion",
            "ref_spans": []
        },
        {
            "text": "Our system includes three refinement rules.",
            "cite_spans": [],
            "section": "Statechart Refinement",
            "ref_spans": []
        },
        {
            "text": "\nGuard conditions on a transition can be strengthened; this can done by adding textual guards to the transition, or changing the source of the transition to a nested state.Transitions can have additional actions, provided they do not modify variables appearing in the abstraction; this can be accomplished by adding textual action to the transition or by changing the target to nested state.A statechart can be embedded within a state of another statechart \u2013 sometimes called hierarchical composition or hierarchical refinement.\n",
            "cite_spans": [],
            "section": "Statechart Refinement",
            "ref_spans": []
        },
        {
            "text": "Via the translation explained in Sect. 3, these rules rely on the usual Event-B proof obligations to ensure that they do indeed yield refinements in the Event-B semantics.",
            "cite_spans": [],
            "section": "Statechart Refinement",
            "ref_spans": []
        },
        {
            "text": "In a state-chart model we naturally wish to verify properties\n\n, about other parallel statechart regions and auxiliary data, that are expected to hold true in a particular state\n\n. Hence, all of the safety properties that we consider are of the form:\n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\Rightarrow $$\\end{document}\n\n, where the antecedent is implicit from the containment of\n\nwithin\n\n.",
            "cite_spans": [],
            "section": "Verification of Safety Properties",
            "ref_spans": []
        },
        {
            "text": "SCXML models represent components that respond to received triggers and are not perfectly synchronised with changes in the monitored properties. Hence,\n\nmay be temporarily violated until the system responds by leaving the state\n\nin which the property is expected to hold. To cater for this we express\n\nin a modified form\n\nthat allows time for the response to take place. There are two forms of reaction that can be used to exit\n\n; a) an untriggered transition, or b) a transition that is triggered by an internally raised trigger. For a), the modified property\n\nbecomes\n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\vee $$\\end{document}\nuntriggered transitions are not complete, and for b)\n\nbecomes\n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$\\vee $$\\end{document}\ntrigger\nis in the internal queue or dequeued (where\n\nis the internal trigger raised when the violation of\n\nis detected).",
            "cite_spans": [],
            "section": "Verification of Safety Properties",
            "ref_spans": []
        },
        {
            "text": "It is sometimes possible to construct a model that satisfies some invariant (e.g. safety) properties, but does not behave in a useful way. Therefore, as well as verifying invariant properties, we would like to verify the system\u2019s responsiveness. More specifically in this case, we want to ensure that the controller responds to external triggers to make appropriate modifications to the system variables. These kind of live responses can not be verified by proof of invariants since they are temporal properties. Instead, we can express the property in Linear Temporal Logic (LTL) and use the\n\nmodel checker to verify it.",
            "cite_spans": [],
            "section": "Verification of Control Responses",
            "ref_spans": []
        },
        {
            "text": "In general, our liveness properties will have the following form:  where the predicate concerns variables\n\nthat the system maintains, and may refer to old values\n\nthat existed when the external trigger occurred. To specify a liveness property to be verified, a special LTL element is added to the SCXML model with attributes, property (a string of the above form) and refinement (an integer indicating the refinement level at which the property should be verified). The translator generates a separate \u2018branch\u2019 refinement for each LTL property to be verified. In this special refinement, history variables are added to record the value at the state when the external trigger occurs, of any variables that are referenced as \u2018old\u2019 values. A text file is automatically generated containing the LTL property to be checked.",
            "cite_spans": [],
            "section": "Verification of Control Responses",
            "ref_spans": []
        },
        {
            "text": "In this generated version, an assumption of strong fairness is added for all other events in the model. (This assumption is stronger than necessary since some events will not affect the outcome, but is easier to generate and is sufficient for our verification aim).  This property is then verified using the LTL facility of the\n\nmodel checker.",
            "cite_spans": [],
            "section": "Verification of Control Responses",
            "ref_spans": []
        },
        {
            "text": "Statecharts are useful and widely used by engineers for modelling the design of control systems that respond to sensed changes in the environment.\n\nprovides an effective language for formally verifying properties via incremental refinements. However, it is not straightforward to apply the latter to the former. We have developed a technique for introducing refinement of Statecharts that can be translated to\n\nfor verification. Invariant properties about the expected coordination of states can be added and are interpreted with additional allowance for the reactions to take place in the control system. Such invariants prove automatically with the existing Rodin theorem provers. We use an LTL model checker as a complementary process for verifying expected reactions to environmental triggers.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        },
        {
            "text": "In future work we intend to formalise the semantics of our extended SCXML notation in order to define its notion of refinement and correspondence to\n\n.",
            "cite_spans": [],
            "section": "Conclusion",
            "ref_spans": []
        }
    ],
    "ref_entries": {},
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [
                {
                    "first": "J-R",
                    "middle": [],
                    "last": "Abrial",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Modeling in Event-B: System and Software Engineering",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "UML-B: formal modeling and design aided by UML",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Snook",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "ACM Trans. Softw. Eng. Methodol.",
            "volume": "15",
            "issn": "1",
            "pages": "92-122",
            "other_ids": {
                "DOI": [
                    "10.1145/1125808.1125811"
                ]
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "Structure and behavior preserving statecharts refinements",
            "authors": [
                {
                    "first": "LLE",
                    "middle": [],
                    "last": "Syriani",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Sousa",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Sci. Comput. Program.",
            "volume": "170",
            "issn": "15",
            "pages": "45-79",
            "other_ids": {
                "DOI": [
                    "10.1016/j.scico.2018.10.005"
                ]
            }
        },
        "BIBREF5": {
            "title": "Statecharts: a visual formalism for complex systems",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Harel",
                    "suffix": ""
                }
            ],
            "year": 1987,
            "venue": "Sci. Comput. Program.",
            "volume": "8",
            "issn": "3",
            "pages": "231-274",
            "other_ids": {
                "DOI": [
                    "10.1016/0167-6423(87)90035-9"
                ]
            }
        },
        "BIBREF6": {
            "title": "An introduction to the Event-B modelling method",
            "authors": [
                {
                    "first": "TS",
                    "middle": [],
                    "last": "Hoang",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Industrial Deployment of System Engineering Methods",
            "volume": "",
            "issn": "",
            "pages": "211-236",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Refinement of statecharts with run-to-completion semantics",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Morris",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Snook",
                    "suffix": ""
                },
                {
                    "first": "TS",
                    "middle": [],
                    "last": "Hoang",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Armstrong",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Formal Techniques for Safety-Critical Systems",
            "volume": "",
            "issn": "",
            "pages": "121-138",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "A method of refinement in UML-B",
            "authors": [
                {
                    "first": "MY",
                    "middle": [],
                    "last": "Said",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Butler",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Snook",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Softw. Syst. Model.",
            "volume": "14",
            "issn": "4",
            "pages": "1557-1580",
            "other_ids": {
                "DOI": [
                    "10.1007/s10270-013-0391-z"
                ]
            }
        }
    }
}