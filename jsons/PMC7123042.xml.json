{
    "paper_id": "PMC7123042",
    "metadata": {
        "title": "A Pairwise Alignment Algorithm for Long Sequences of High Similarity",
        "authors": [
            {
                "first": "Durgesh",
                "middle": [
                    "Kumar"
                ],
                "last": "Mishra",
                "suffix": "",
                "email": "drdurgeshmishra@gmail.com",
                "affiliation": {}
            },
            {
                "first": "Ahmad",
                "middle": [
                    "Taher"
                ],
                "last": "Azar",
                "suffix": "",
                "email": "ahmad_t_azar@ieee.org",
                "affiliation": {}
            },
            {
                "first": "Amit",
                "middle": [],
                "last": "Joshi",
                "suffix": "",
                "email": "amitjoshiudr@gmail.com",
                "affiliation": {}
            },
            {
                "first": "Chien-Tai",
                "middle": [],
                "last": "Lee",
                "suffix": "",
                "email": "slpeng@mail.ndhu.edu.tw",
                "affiliation": {}
            },
            {
                "first": "Sheng-Lung",
                "middle": [],
                "last": "Peng",
                "suffix": "",
                "email": null,
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Sequence alignment is an important technique for comparing the similarity of two biological sequences in bioinformatics. In 1970, biologists Needleman and Wunsch were the first to analyze biological hereditary information by using electronic calculator. They applied the method of dynamic programming to analyze the similarity between two amino acid sequences [1]. In 1988, the US government established the National Center for Biotechnology Information (NCBI) to help in creating automatic analyzing system of biological information. This further enhances the ability for biomedical researchers to search and analyze biological information more efficiently and accurately. In 1992, the most famous nuclear acid sequence database, GenBank, began the service for the whole world. It collected more than 150 billion of base pairs counted to February 2013. Meanwhile, in Europe, the European Molecular Biology Laboratory (EMBL) was founded in 1988. In 1990, Japan established their DNA database of Japan (DDBJ). Currently, GenBank, EMBL, and DDBJ provide best quality in the search of gene sequence globally.",
            "cite_spans": [
                {
                    "start": 361,
                    "end": 362,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "DNA is the most important element in the study of life science. After knowing the sequences of DNA and RNA, the next important thing is to analyze all the information originated from the DNA sequences. There are three billion of bases to form chromosomes in human beings. It would take tremendous time to know all the sequences in human genes. It could be more difficult to analyze the underlying meaning in the DNA sequences. Recently, the rapid development in information science and technology has resolved a lot of problems. It has become more popular to combine information technology and biological science, thereby trying to have a big breakthrough in the fields of biomedicine and pharmaceutical research. With the help of computer technology, this goal may be expected in the future.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "The main subjects in biological information science include prediction of a protein structure, comparison of the similarity and the homology of sequences, phylogeny construction, genome sequence analysis. In this paper, we study the DNA strains of Severe Acute Respiratory Syndrome (SARS) viruses. We propose an algorithm for aligning two highly similar sequences. In our experimental result, if these two sequences are highly similar, the expected time for alignment is almost linear.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Dynamic programming is an important technique for algorithm design. It usually solved an optimization problem by caching subproblem solutions rather than recomputing them [3\u20135]. Needleman\u2013Wunsch\u2019s algorithm [1] uses dynamic programming technique to compute an optimal alignment for two sequences. It uses a two-dimensional array D to store the best scores for each entry. Therefore, they can guarantee to find an optimal solution, but consume resources very much, and it is not efficient for comparing with long sequences. This method has two main steps:",
            "cite_spans": [
                {
                    "start": 172,
                    "end": 173,
                    "mention": "3",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 174,
                    "end": 175,
                    "mention": "5",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 208,
                    "end": 209,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                }
            ],
            "section": "Global Alignment ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "\nCompute similarity scoresA score is computed for each entry in the array according to their similarity.The similarity score is usually defined as [6, 7]:\n\n\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$ D\\left( {i,j} \\right) = \\hbox{max} \\left( {\\begin{array}{*{20}l} {D(i - 1,j - 1) + \\delta (a_{i} ,b_{j} )} \\hfill \\\\ {D(i - 1,j) + \\delta (a_{i} , - )} \\hfill \\\\ {D(i,j - 1) + \\delta ( - ,b_{j} )} \\hfill \\\\ \\end{array} } \\right). $$\\end{document}\n",
            "cite_spans": [
                {
                    "start": 148,
                    "end": 149,
                    "mention": "6",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 151,
                    "end": 152,
                    "mention": "7",
                    "ref_id": "BIBREF13"
                }
            ],
            "section": "Global Alignment ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "\n2.Construct an alignmentBacktrack the matrix to obtain an optimal alignment.\n\n",
            "cite_spans": [],
            "section": "Global Alignment ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "In the optimization of the alignment algorithm, we may need to add some gaps to the sequence. The frequency of \u201cinsertion\u201d or \u201cdeletion\u201d events causes gap insertions. Thus, we can use different penalty parameters to define a gap insertion.",
            "cite_spans": [],
            "section": "Global Alignment ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "In Needleman\u2013Wunsch\u2019s algorithm, we need to store (n + 1) (m + 1) numbers for aligning a sequence of length n with another sequence of length m. By the above-mentioned formula, each number takes a constant number of computations. Thus, the algorithm runs in O(nm) time and requires O(nm) memory. For whole-genome alignment, this running time is still too slow. In other words, it is not feasible for real biological applications.",
            "cite_spans": [],
            "section": "Global Alignment ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Generally speaking, aligning two sequences with length at most n, the time complexity is O(n\n2). This is by no means the best time bound. However, when aligning three sequences, it consumes longer execution time, e.g., O(n\n3). How to reduce the time complexity is the most important work while performing the whole-genome alignment. Many heuristic methods are proposed. The kind of these methods is an algorithm that usually but not always gives an optimal answer.",
            "cite_spans": [],
            "section": "Heuristic Algorithms ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "For example, to use the most famous tools such as FASTA or BLAST (Basic Local Alignment Search Tool) programs to speed up the performance, the problem is to compromise its sensitivity. Therefore, they do not guarantee to find an optimal solution, but can improve the efficiency.FASTA series [8]: The method of these series is quite precise, but the speed is slower. It can only compare a nucleic acid sequence to the nucleic acid information bank, or compare a protein sequence to the protein information bank [8\u201311].BLAST series [12]: The method of these series has a very quick search speed but has the fault when the sequences have low similarity. It contains a group of programs and can automatically execute according to the information bank type of input sequences [12, 13].\n",
            "cite_spans": [
                {
                    "start": 292,
                    "end": 293,
                    "mention": "8",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 511,
                    "end": 512,
                    "mention": "8",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 513,
                    "end": 515,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 531,
                    "end": 533,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 772,
                    "end": 774,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 776,
                    "end": 778,
                    "mention": "13",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Heuristic Algorithms ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "MUMmer is a tool for aligning entire genomes [14]. It has three main steps:Computing MUMs: A MUM (maximal unique match) for two sequences x and y is a pair of subsequences (x\u2032, y\u2032), that is, an exact match, and there is no other matching subsequence pair containing x\u2032 and y\u2032 simultaneously. During the computation, MUMmer first constructs a suffix tree for sequence x. Then, the suffixes of y are inserted to the constructed tree. It is called a generalized suffix tree. Finally, all the MUMs can be computed by traversing this generalized suffix tree.Finding the backbone of the alignment: All the MUMs in x are arranged in an increasing order. Then, we find a longest increasing subsequence of MUMs for y with respect to the MUMs of x. These MUMs define the backbone of the alignment.Closing gaps: To obtain a final result, the gaps between consecutive MUMs of the backbone are aligned by using the Smith\u2013Waterman algorithm [15].\n",
            "cite_spans": [
                {
                    "start": 46,
                    "end": 48,
                    "mention": "14",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 928,
                    "end": 930,
                    "mention": "15",
                    "ref_id": "BIBREF6"
                }
            ],
            "section": "Genome-Scale Alignment: MUMmer ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "MUMmer is also suitable for two sequences with high similarity. However, it has two flaws: One is that it needs a very large space to save the suffix tree, and the other is that MUMs cannot be found when the same substring appeared more than once. Recently, by using the computational power of GPUs, an algorithm for very long sequence is proposed [16].",
            "cite_spans": [
                {
                    "start": 349,
                    "end": 351,
                    "mention": "16",
                    "ref_id": "BIBREF7"
                }
            ],
            "section": "Genome-Scale Alignment: MUMmer ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "In bioinformatics, pairwise sequence alignment is the most important tool. Many tools use it as a core for approximating the multiple sequence alignment or comparing the similarity of two genes. The Needleman\u2013Wunsch alignment is the best pairwise sequence alignment algorithm for finding an optimal solution. It uses a dynamic programming approach and runs in O(mn) time where m and n are the lengths of the two input sequences, respectively. However, while considering the whole genome as an input, this algorithm is impractical. Many heuristic algorithms occur for aligning two whole-genome sequences. For example, MUMmer uses the maximal unique matching sequences as a base for aligning two entire genomes. MUMmer uses the data structure of suffix tree to find all the maximal unique matching sequences. Although genomes have high similarity, it still needs a very large space. Thus, we propose a new method for saving space and time to align two entire highly similar sequences.",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": []
        },
        {
            "text": "SARS virus, one kind of coronavirus, is a highly transmissible and virulent virus that caused a disastrous outbreak in the Southeast Asia in 2003. Many scientists and physicians wanted to know more about different strains of SRAS viruses and tried their best to prevent the spread of this disease. Its DNA sequence is approximately 29,700 base pairs. Here, we propose an algorithm to do the alignments for SARS viruses. Our algorithm can be divided into three phases.",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": []
        },
        {
            "text": "\nThe first phase is Dot Matrix Phase: We use dot matrix to find the longest common substring (LCS) in a sliding window. The segment in sliding window is broken into three parts by the LCS: the LCS itself, prefix string that before the LCS, and the suffix string that after the LCS.The second phase is Needleman\u2013Wunsch Phase: Let the prefix strings be aligned by the Needleman\u2013Wunsch\u2019s algorithm, the follow-up for getting optimal alignment with appending the LCS.The third phase is the Liner Comparison Phase: If there is only one remaining suffix string, then we compare it with the other uncompared string. If the two sequences are highly similar, then we obtain a linear alignment.\n",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": []
        },
        {
            "text": "We define three variables SW, SR, and MES as follows:Sliding window (SW): determination of a length for Dot Matrix Phase.Similarity rate threshold (SR): a threshold of similarity ratio for the two subsequences in sliding window.Max continuous equal substring length threshold (MES): a threshold for the length of LCS in sliding window.\n",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": []
        },
        {
            "text": "First, let S1 and S2 be two sequences for doing an alignment. From the beginning of the two sequences, determine a sliding window size SW to perform dot matrix. An example is shown in Fig. 1. The plots in dot matrix provide an easy and efficient way to find similarity between two sequences.\n",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": [
                {
                    "start": 189,
                    "end": 190,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "The alignment should be a diagonal of continuous dots. Sometimes, it is broken at a point of mutation and shifting to another diagonal because of indels. In this method, we find the LCS and determine whether the similarity is greater than SR and the length of LCS is greater than MES. If the answer is no, then we double the window size. We then repeat the procedures until one of the previous two conditions is satisfiable. Then, we do an alignment using Needleman\u2013Wunsch\u2019s algorithm on the prefix strings.",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": []
        },
        {
            "text": "After finishing a partial alignment, we then extend the alignment from LCS by comparing it with the follow-up sequences until they are different. Finally, we repeat the above procedure for the remaining subsequences. Figure 2 shows the concept of a phase of our algorithm.\n",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": [
                {
                    "start": 224,
                    "end": 225,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                }
            ]
        },
        {
            "text": "For any two sequences with high similarity, the alignment is very efficient because the liner comparison does a favor. However, this method is only suitable for highly similar sequences.",
            "cite_spans": [],
            "section": "The Proposed Algorithm",
            "ref_spans": []
        },
        {
            "text": "For obtaining a quantitative comparison, we use an old computer system to run the proposed algorithm. Our experimental environment is as follows:Machine: CompaqCPU: IntelR Xeon\u2122 CPU 3.06 GHz (2CPUs)Memory: 1024 MBOperating system: Microsoft Windows 2000\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "We use 102 SARS sequences of FASTA format as an input (which are downloaded from NCBI). The FASTA format begins with a single-line description and is followed by lines of sequence data. The description line starts with \u201c>\u201d symbol for distinguishing from the other sequence data. It is recommended that each line of text should be shorter than 80 characters. An example of FASTA format is given as follows:",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "A SARS of whole genome has about 29,700 base pairs. We use our algorithm to align and analyze similar degree according to the matching rules of IUPAC (International Union of Pure and Applied Chemistry).",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": []
        },
        {
            "text": "Clustalx is famous software in bioinformatics. It performs alignments and calculates distances for all pairs of sequences. We randomly take out 10 sequences from 102 SARS sequences to do a comparison with SARS NC004718.3. Table 1 shows the results.\n",
            "cite_spans": [],
            "section": "Experimental Results",
            "ref_spans": [
                {
                    "start": 228,
                    "end": 229,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Bioinformatics has become the key to answer the mystery of life in the post-genomic era. This paper proposes a sequence alignment algorithm for those DNAs of high similarity. Although the Needleman\u2013Wunsch alignment is the best pairwise sequence alignment algorithm for finding an optimal solution, it is impractical for whole genomes. MUMmer\u2019s algorithm needs a very large extra space for saving the suffix tree, and it is also time-consuming for searching MUMs in the suffix tree. We provide another kind of alignment algorithms. It cannot avoid the limitation of O(n\n2), but it has a good performance for highly similar sequences.",
            "cite_spans": [],
            "section": "Conclusions",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table\u00a01: A comparison with Clustalx\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig.\u00a01: Dot matrix",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig.\u00a02: Complete alignment in sliding window",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF1": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF2": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF3": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF4": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF5": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF6": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF7": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF12": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF13": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF14": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF15": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}