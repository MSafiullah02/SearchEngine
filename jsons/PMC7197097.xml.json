{
    "paper_id": "PMC7197097",
    "metadata": {
        "title": "Linear Time Algorithm for Tree-Child Network Containment",
        "authors": [
            {
                "first": "Carlos",
                "middle": [],
                "last": "Mart\u00edn-Vide",
                "suffix": "",
                "email": "carlos.martin@urv.cat",
                "affiliation": {}
            },
            {
                "first": "Miguel",
                "middle": [
                    "A."
                ],
                "last": "Vega-Rodr\u00edguez",
                "suffix": "",
                "email": "mavega@unex.es",
                "affiliation": {}
            },
            {
                "first": "Travis",
                "middle": [],
                "last": "Wheeler",
                "suffix": "",
                "email": "travis.wheeler@umontana.edu",
                "affiliation": {}
            },
            {
                "first": "Remie",
                "middle": [],
                "last": "Janssen",
                "suffix": "",
                "email": "R.Janssen-2@tudelft.nl",
                "affiliation": {}
            },
            {
                "first": "Yukihiro",
                "middle": [],
                "last": "Murakami",
                "suffix": "",
                "email": "Y.Murakami@tudelft.nl",
                "affiliation": {}
            }
        ]
    },
    "body_text": [
        {
            "text": "Phylogenetic networks are gaining popularity in the study of the evolutionary history of taxa [1, 12]. However, small stretches of DNA (e.g., pieces of DNA coding for protein domains) evolve tree-like. Therefore, the network representing the species\u2019 evolution must contain the trees for such pieces of DNA. This leads to the following mathematical problem. For a given network N and a tree T on the same set of taxa, decide whether N contains T.",
            "cite_spans": [
                {
                    "start": 95,
                    "end": 96,
                    "mention": "1",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 98,
                    "end": 100,
                    "mention": "12",
                    "ref_id": "BIBREF3"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "This problem, called Tree Containment, is NP-complete for general rooted phylogenetic networks [10]. The problem remains NP-complete for certain network classes (networks with particular topological restrictions), such as tree-sibling, time-consistent, and regular networks [8]. However, for other network classes, the problem becomes easier. For example, it is known that Tree Containment can be solved in polynomial time for normal networks, tree-child networks, and level-k networks [8].",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 98,
                    "mention": "10",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 275,
                    "end": 276,
                    "mention": "8",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 487,
                    "end": 488,
                    "mention": "8",
                    "ref_id": "BIBREF10"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "There are even stronger results for some network classes: deciding whether a tree is contained in a genetically stable network can be done in quadratic time [5], and making this decision for a binary nearly-stable network takes linear time [6]. For the class of tree-child networks, Tree Containment is known to be solvable in linear time [6, 7].",
            "cite_spans": [
                {
                    "start": 158,
                    "end": 159,
                    "mention": "5",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 241,
                    "end": 242,
                    "mention": "6",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 340,
                    "end": 341,
                    "mention": "6",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 343,
                    "end": 344,
                    "mention": "7",
                    "ref_id": "BIBREF9"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "From a biological and a computational perspective, there is no reason why we should restrict ourselves to inputs of a tree and a network. Indeed, while small stretches of DNA may evolve tree-like, it is possible for another part of the genome to evolve as a network. In such instances, it is of great interest to consider a more general version of Tree Containment, which we call Network Containment: For given networks N and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} on the same set of taxa, decide whether N contains \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document}. By extension, the problem remains NP-complete for inputs of general rooted phylogenetic networks. Computationally, it is natural to wonder whether network classes that can solve Tree Containment efficiently can also solve Network Containment in a similar fashion. To date, no study has ever considered this problem, and we take the first steps in this endeavour.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "We solve the Network Containment problem for tree-child networks (defined formally in Sect. 2) by considering tree-child sequences. These sequences were developed to tackle the problem of finding a \u201csimple\u201d network that contains a given set of trees [4, 11]. Two leaves of a tree form a cherry if they share a common parent\u2014by successively picking cherries (removing one of the leaves in a cherry) from the set of input trees, we obtain a sequence of cherries that ultimately reduce each input tree to a tree on a single leaf. This sequence of cherries then corresponds to some network that contains the set of all input trees.",
            "cite_spans": [
                {
                    "start": 251,
                    "end": 252,
                    "mention": "4",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 254,
                    "end": 256,
                    "mention": "11",
                    "ref_id": "BIBREF2"
                }
            ],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Previously, these reductions were only defined on trees, and not on networks. In this paper, we start by defining tree-child sequences and their actions on tree-child networks. We show that for every tree-child network, there exists a sequence of ordered pairs of leaves that reduces it to a network on a single leaf. The order in which these pairs are picked does not matter. We also show that a tree-child network is contained in another tree-child network if and only if a sequence that reduces the first network also reduces the second one. Combining these results culminates in a linear-time algorithm for solving the Network Containment problem for tree-child networks.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "Structure of the Paper. We start by giving all relevant definitions and outlining how to construct networks from tree-child sequences (Sect. 2). In Sect. 3, we investigate properties of tree-child sequences, and their relation to tree-child networks. In particular, we focus on the relation between tree-child subsequences, and subnetworks of tree-child networks. This section also includes an algorithm to solve Tree-child Network Containment. Then, in Sect. 4, we present an efficient implementation of this algorithm in Python, and show that the theoretical running time is achievable in practice. We test our implementation on simulated data, and show that even for large data sets (1000 leaves and 1000 reticulations), the software outputs the solution within a tenth of a second. Lastly, in Sect. 5, we conclude with open problems and future directions for the use of cherry-picking strategies.",
            "cite_spans": [],
            "section": "Introduction",
            "ref_spans": []
        },
        {
            "text": "A phylogenetic semi-binary network\nN is a DAG with one outdegree-1 source (the root), a set L(N) of indegree-1 sinks (leaves) bijectively labelled with a set X, and all other nodes are either of indegree-1 and outdegree-2 (tree nodes) or of indegree at least 2 and outdegree-1 (reticulations).",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "A network is binary if all reticulations have indegree-2. In this paper, all networks we consider are phylogenetic semi-binary networks unless stated otherwise, so we call these networks for short. Furthermore, all networks have the leaf set \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$X = \\{1,2,\\ldots , n\\}$$\\end{document}, unless stated otherwise.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "An edge feeding into reticulations is called a reticulation edge. Given an edge uv in N, we say that u is a parent of v and that v is a child of u. The node u is above v if there is a directed path from u to v in N. The network N is tree-child if every non-leaf node in N is a parent of a tree node or a leaf. The reticulation number is the total number of reticulation edges minus the total number of reticulations.",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let N and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} be tree-child networks on the same set of taxa X. Then N\ncontains \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} can be obtained from N by deleting reticulation edges and suppressing degree-2 nodes. We now formally define the Tree-child Network Containment problem.\n",
            "cite_spans": [],
            "section": "Definition 1 ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let x be a leaf in a network N. If a reducible pair with x as the second element of the pair exists, then Algorithm 1 finds this pair in constant time. Otherwise it returns the empty set in constant time.",
            "cite_spans": [],
            "section": "Lemma 2 ::: Reducible Pairs ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Lemma 2 ::: Reducible Pairs ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let x be a leaf in a network N, and let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_x$$\\end{document} denote the parent of x. Let I denote the indegree of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_x$$\\end{document}. Algorithm 2 finds the set of all reticulated cherries that has x as the first coordinate in O(I) time.",
            "cite_spans": [],
            "section": "Lemma 3 ::: Reducible Pairs ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let N be a network and let (x, y) be an ordered pair of leaves. Reducing (x, y) in N is the action ofdeleting x and suppressing its parent node in N if (x, y) is a cherry in N;deleting the reticulation edge between the parents of x and y and subsequently suppressing degree-2 nodes, if (x, y) is a reticulated cherry;doing nothing to N otherwise.\n",
            "cite_spans": [],
            "section": "Definition 4 ::: Reducing Pairs from Networks ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "In all cases, the resulting network is denoted N(x, y).",
            "cite_spans": [],
            "section": "Definition 4 ::: Reducing Pairs from Networks ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "We refer to this as picking a reducible pair (x, y) from N. We transform this definition into an algorithm, and show that a reduction of a pair from a network can be done in constant time.\n",
            "cite_spans": [],
            "section": "Definition 4 ::: Reducing Pairs from Networks ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Algorithm 3 correctly reduces a given reducible pair in a network N in constant time.",
            "cite_spans": [],
            "section": "Lemma 5 ::: Reducing Pairs from Networks ::: Preliminaries",
            "ref_spans": []
        },
        {
            "text": "Let N be a network and let (x, y) be reducible pair. Then we may construct N from N(x, y)\u2014also called add (x, y) to N(x, y)\u2014by applying the following.",
            "cite_spans": [],
            "section": "Definition 6 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "\nIf x is a leaf in N(x, y) (i.e., if (x, y) is a reticulated cherry in N), and if p, the parent of x in N(x, y), is a reticulation then add a node q directly above y, and add an edge qp.otherwise, add nodes p and q directly above x and y respectively, and add an edge qp.\nIf x is not a leaf in N(x, y) (i.e., if (x, y) is a cherry in N) then add a labelled node x, insert a node q directly above y, and add an edge qx.\n",
            "cite_spans": [],
            "section": "Definition 6 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Observe that when adding (x, y) to N(x, y), we assume that y is a leaf in the network N(x, y). Otherwise, adding (x, y) to N(x, y) is not well-defined.",
            "cite_spans": [],
            "section": "Definition 6 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Now let \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S = S_1S_2\\cdots S_{|S|} = (x_1,y_1)(x_2,y_2)\\cdots (x_{|S|},y_{|S|})$$\\end{document} be a sequence of ordered pairs with the condition that the second coordinate of each pair occurs as a first coordinate in the rest of the sequence, or as the second coordinate of the last pair. Starting with a network on a single leaf \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_{|S|}$$\\end{document}, we may iteratively add \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$S_i$$\\end{document} to the network for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i=|S|,|S|-1,\\ldots ,1$$\\end{document} (i.e., backwards through the sequence S) to obtain some network. We call this the network obtained from S. This condition ensures that when adding \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$(x_i,y_i)$$\\end{document} to the network, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$y_i$$\\end{document} is already a leaf in the network so that the operation is well-defined.",
            "cite_spans": [],
            "section": "Definition 6 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Now suppose that we add a second condition on S that the first coordinate of each pair does not appear as a second coordinate of another pair in the remainder of the sequence. We will sometimes refer to this condition as the tree-child condition. Then, we claim that the network obtained from S is tree-child. By construction, we never obtain reticulation nodes that are adjacent to one another. In particular, every reticulation edge is inserted to existing reticulation nodes whenever possible (Definition 6.1a). Hence, we may only violate the tree-child property from a tree node having two reticulation children. So say that we have just added a reticulated cherry (x, y) to a network N. In N, the tree node parent \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_y$$\\end{document} of y currently has one reticulation child and one leaf child y. For \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_y$$\\end{document} to have two reticulation children, we require some reticulation node to be inserted between \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$p_y$$\\end{document} and y, which can only happen if we add some ordered pair (y, z) to N. However, this would mean that y appears as a first coordinate of some pair and also as a second coordinate of some pair later on in the sequence, which contradicts our second condition. If, on the other hand, we have just added a cherry (x, y) to N, then the parent p of x cannot be a parent of two reticulations after adding more reducible pairs. Indeed, this would imply that we have added some reducible pair (y, z) later on to the network (and hence it would appear earlier in the sequence), which again contradicts our second condition.",
            "cite_spans": [],
            "section": "Definition 6 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "This brings us to the following definition.",
            "cite_spans": [],
            "section": "Definition 6 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "A tree-child sequence (TCS) is a sequence of ordered pairs of two leaves such thatthe second coordinate of each pair occurs as a first coordinate in the rest of the sequence, or as the second coordinate of the last pair; andno first coordinate leaf is used as a second coordinate in the remainder of the sequence.\n",
            "cite_spans": [],
            "section": "Definition 7 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Let N be a network and let S be a TCS. Denote by NS the network obtained by repeatedly reducing N with each element of S in order. We say that S\nreduces\nN if NS is a network with a single leaf (for any leaf in N), a root, and no other nodes. We call a TCS S\nminimal for a tree-child network N if S reduces N and if \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$NS_1\\cdots S_{i-1} \\ne NS_1\\cdots S_i$$\\end{document} for all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i\\in [|S|]$$\\end{document}. Suppose that N contains n leaves and has reticulation number r. Then any minimal TCS for N is of length \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n+r-1$$\\end{document}.",
            "cite_spans": [],
            "section": "Definition 7 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Using the operations outlined in Definition 6, one may obtain a tree-child network N from a given TCS S. As each addition of an ordered pair creates either a cherry or a reticulated cherry in the network, we may simply reverse the operations to see that S reduces N. This brings us to the following correspondence.",
            "cite_spans": [],
            "section": "Definition 7 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Let N be a tree-child network. Then there exists a minimal TCS S that reduces it. The network obtained from S is isomorphic to N.",
            "cite_spans": [],
            "section": "Theorem 8 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Let S be a TCS. Then the network obtained from S is unique and is tree-child. Furthermore, S is a minimal TCS for this network.",
            "cite_spans": [],
            "section": "Theorem 8 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "While each TCS gives rise to a unique tree-child network, there can be many TCSs that reduce the same tree-child network. In particular, given a tree-child network, we may pick the reducible pairs in any order.",
            "cite_spans": [],
            "section": "Theorem 8 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Let N be a tree-child network and let (x, y) be a reducible pair of N. Then there exists a minimal TCS of N whose first element is (x, y).",
            "cite_spans": [],
            "section": "Theorem 9 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "In the setting of Theorem 9, we have that N(x, y) is a tree-child network. Then, by iteratively applying the theorem to the reduced network each time, it is indeed the case that we may pick the reducible pairs in any order\u2014making sure the second property of a TCS is not violated. The following algorithm then shows how we may obtain a minimal TCS for a tree-child network by picking reducible pairs in any order, and maintaining a list of all reducible pairs in the network.\n",
            "cite_spans": [],
            "section": "Theorem 9 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Let N be a tree-child network on X with reticulation number r. Algorithm 4 finds a minimal TCS for N in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n+r)$$\\end{document} time.",
            "cite_spans": [],
            "section": "Lemma 10 ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Let N and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} be two tree-child networks on the same leaf-sets. N contains \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} if and only if any minimal TCS of N reduces \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document}.",
            "cite_spans": [],
            "section": "Theorem 11 ::: Putting It All Together ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Therefore, using the subroutines that we have introduced previously (Algorithms 1\u20134), we obtain the following algorithm that solves the Tree-child Network Containment problem. Let N and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} be two tree-child networks on the same leaf-sets. Using Theorem 9, we first obtain some minimal sequence S that reduces N by picking reducible pairs in any order (Algorithm 4). By Theorem 11, if S reduces \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document}, then \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} is contained in N; otherwise, \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} is not contained in N.\n",
            "cite_spans": [],
            "section": "Theorem 11 ::: Putting It All Together ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Given two tree-child networks N and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} on the same taxa set X where the reticulation number of N is r, it can be decided in time \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n+r)$$\\end{document} whether \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} is contained in N.",
            "cite_spans": [],
            "section": "Theorem 12 ::: Putting It All Together ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "The theorem has the following corollary regarding the network Isomorphism problem, which asks whether two given networks are isomorphic. Indeed, we can solve this problem by running Algorithm 5 twice, since two networks are isomorphic if and only if they are contained in one another. The problem for tree-child networks was previously shown to be solvable in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n^2)$$\\end{document} time [3]. Therefore, we present the first linear-time algorithm for checking whether two tree-child networks are isomorphic.",
            "cite_spans": [
                {
                    "start": 658,
                    "end": 659,
                    "mention": "3",
                    "ref_id": "BIBREF5"
                }
            ],
            "section": "Theorem 12 ::: Putting It All Together ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "Given two tree-child networks N and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} on taxa set X where the reticulation number of N is r, it can be decided in \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$O(n+r)$$\\end{document} time whether N is isomorphic to \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$N'$$\\end{document} (Fig. 1).",
            "cite_spans": [],
            "section": "Corollary 13 ::: Putting It All Together ::: Tree-Child Sequence",
            "ref_spans": [
                {
                    "start": 1018,
                    "end": 1019,
                    "mention": "1",
                    "ref_id": "FIGREF0"
                }
            ]
        },
        {
            "text": "\n\n",
            "cite_spans": [],
            "section": "Corollary 13 ::: Putting It All Together ::: Tree-Child Sequence",
            "ref_spans": []
        },
        {
            "text": "For the test data, we generated 131200 instances of the Tree-child Network Containment problem: two yes-instances and two no-instances for all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$n,r,r'\\in \\{25,50,\\ldots ,975,1000\\}$$\\end{document} with \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'\\le r$$\\end{document}, where n is the number of leaves of both networks, r is the reticulation number in the first network, and \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} the reticulation number in the second network. Each instance consists of two semi-binary tree-child networks on the same leaf-set, for which we asked whether the first network contained the second network.",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "For each instance, we generated the first network with n leaves and reticulation number r using Algorithm 6. The second network was generated depending on whether it was a yes- or a no-instance. If it was a yes-instance, a subnetwork with reticulation number \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} was obtained using Algorithm 7; for a no-instance, a network on the same number of leaves and reticulation number \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} was randomly generated with the same process as the first network (using Algorithm 6).",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "This way, each generated yes-instance is always a yes-instance for the Tree-child Network Containment problem. For the no-instances, however, the random generation of the second network could also give a subnetwork of the first network, but the probability of that happening is very small, as the number of tree-child networks grows very quickly with the number of leaves and reticulations [2].",
            "cite_spans": [
                {
                    "start": 391,
                    "end": 392,
                    "mention": "2",
                    "ref_id": "BIBREF4"
                }
            ],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "The dataset used for the experiment along with the code for generating random datasets, and the actual implementation of Algorithm 5 can be found on https://github.com/RemieJanssen/Cherry-picking_TC_Network_Containment.",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "Generating Random Networks. The tree-child networks were randomly generated as TCSs using Algorithm 6. This algorithm takes two positive integers n and r, and outputs a tree-child network with n leaves and reticulation number r. It starts with the cherry (1, 2), and successively adds leaves as cherries, and reticulated cherries between two leaves that already exist in the network (respecting the tree-child condition).",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "In the algorithm, this is achieved by building a tree-child sequence backwards. It chooses to add a reducible pair corresponding to a cherry or reticulated cherry uniformly at random until we have added the required number of leaves and reticulation number. To make sure the sequence is a tree-child sequence, we keep a list NF of taxa that are \u2018non-forbidden\u2019, which, in this case, means that the taxon is not currently the child of a tree node that has a reticulation as the other child (i.e., the leaf has not appeared as a second coordinate element of a reducible pair). If a taxon is in NF, it is possible to take this taxon as the first element of a pair appended at the start of the sequence. As a tree-child network always has a cherry or a reticulated cherry, NF is never empty. This implies that the algorithm should never output False, but lines 15 and 16 are kept so that the algorithm can easily be adapted to return only binary tree-child networks. To achieve this, one only has to add the line \u201c\\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$NF = NF\\setminus \\{\\mathrm {first\\_element}\\}$$\\end{document}\u201d between lines 21 and 22 in the algorithm. Finally, the algorithm outputs a TCS, from which we can uniquely construct a TCN.\n",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "Note that each tree-child network has positive probability of appearing for this process. In fact, each tree-child sequence ending with (2, 1) has positive probability.",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "Let us now turn to the procedure to generate a tree-child subnetwork (i.e., generating the second network in a yes-instance). For this purpose, we again work with the representation of the networks as tree-child sequences.",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "We first select ordered pairs from the sequence of the first network, such that the resulting subsequence corresponds to a tree. This is simply done by selecting a pair with first element x for all \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$x\\in X$$\\end{document} uniformly at random. Because the sequence we started with is a tree-child sequence, the subsequence consisting of the chosen pairs is a tree-child sequence as well: suppose (x, y) and (y, z) are selected. Then (y, z) must appear after (x, y), because otherwise y appears as a first element after it has appeared as a second element in the original sequence.",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "After selecting the pairs that form a base tree of the network (a spanning tree contained by the network), we select \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} additional pairs that will form the \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} reticulations of the subnetwork. By a similar argument as for the base tree, this subsequence is a tree-child sequence. And as it is reduced by the subsequence, it is also reduced by the sequence of the original network. Hence, the network corresponding to the chosen pairs is a tree-child subnetwork of the original network.\n",
            "cite_spans": [],
            "section": "Generating the Datasets ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "For all yes-instance tests in which the second network was a subnetwork of the first (i.e., the ones generated by Algorithms 7) and 5 correctly returned a true value. Similarly, for all no-instance tests in which the second network was generated randomly and independently from the first network, Algorithm 5 correctly found that the second network was not a subnetwork of the first. This means that, even though there was a non-zero probability that the second network was a subnetwork, this did not happen in any of the instances. We expected this, as the probability of this happening is extremely small.",
            "cite_spans": [],
            "section": "Results ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "Note that the largest test instances (1000 leaves, 1000 reticulations) had a running time of approximately 0.1s. This is expected to scale well for even larger instances, as the linear fit of the data is very good. The \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R^2$$\\end{document} values for the fits and the linear dependence of the running time on the number of leaves and reticulations can be found in Table 1. For this fit, we performed a standard linear regression with an intercept of 0 (i.e., forced through the origin), which makes sense because the running time should be zero for an empty instance.",
            "cite_spans": [],
            "section": "Results ::: Implementation",
            "ref_spans": [
                {
                    "start": 638,
                    "end": 639,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "Note that the fits become much better when we split the data in instances where the second network is or is not a subnetwork of the first (i.e., between the yes- and the no- instances), even though the dependence of the running time on the parameters does not change much after this split. The most striking difference we can see in this analysis, is the dependence on the reticulation number of the second network.\n",
            "cite_spans": [],
            "section": "Results ::: Implementation",
            "ref_spans": []
        },
        {
            "text": "As shown in Fig. 2, the no-instances were consistently, and marginally, faster than the yes-instances. For varying leaf numbers, the instances where the second network was not a subnetwork (no-instances), were consistently, but marginally, faster than when the second network was a subnetwork (yes-instances) (Fig. 2, Left). This was similarly true for when we varied the reticulation number \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} of the second network. The effect of varying \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} on instances for when the second network was not a subnetwork (no-instances) was negligible. This can be seen in the right figure of Fig. 2, but also in Table 1, where the order of the slope of \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} for the no-instances is far smaller than all other slopes in all the instances. For the yes-instances, the running time of the algorithm displayed a linear dependence on \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document}, which was in the same order as the other parameters. This can be explained as follows. When the second network is not a subnetwork, Algorithm 5 will seldom need to reduce a pair in Line 3: it will check whether the pair in the sequence is reducible in the second network. As the second network is randomly generated independently of the first network, it will not have many pairs in common with the first network, which means it will not have to reduce pairs often.\n",
            "cite_spans": [],
            "section": "Results ::: Implementation",
            "ref_spans": [
                {
                    "start": 17,
                    "end": 18,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 315,
                    "end": 316,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1151,
                    "end": 1152,
                    "mention": "2",
                    "ref_id": "FIGREF1"
                },
                {
                    "start": 1172,
                    "end": 1173,
                    "mention": "1",
                    "ref_id": "TABREF0"
                }
            ]
        },
        {
            "text": "In this paper, we have looked at tree-child sequences and how they can be used to solve the Network Containment problem for tree-child networks. A theoretical linear-time algorithm was given for this, and we have shown that our Python implementation also runs in linear time, in the number of leaves and the reticulation number.",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "In an effort to generalize our results, a natural question would be to ask what would happen if we weakened our current notion of a tree-child sequence. In Definition 7, we stated that the tree-child sequences must satisfy two conditions. The first condition ensures that each sequence corresponds to some network; the second condition ensures that the network is tree-child. Therefore we may consider networks that are more general than tree-child networks, by removing this second condition. These new sequences (which we call cherry-picking sequences) may be used to construct networks (called cherry-picking networks), with the operations as in Definition 6. This raises two questions. Do our Network Containment results hold when we consider inputs of cherry-picking networks? And, is there a structural characterization of these networks? To partly answer these questions for cherry-picking sequences, in [9], we have shown that a network can be reduced in any order (if it can be reduced at all). Furthermore, if a network is reduced by a minimal sequence for another network, the first is contained in the second. However, for cherry-picking sequences, it is no longer true that a subnetwork is reduced by any of the minimal sequences of the original network (Figure 3 of [9]). Therefore, Network Containment cannot be solved using cherry-picking sequences; in fact, the counter-example shows that even Tree Containment cannot be solved using cherry-picking sequences. The second question, about the structural characterization, remains open.",
            "cite_spans": [
                {
                    "start": 912,
                    "end": 913,
                    "mention": "9",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1281,
                    "end": 1282,
                    "mention": "9",
                    "ref_id": "BIBREF11"
                }
            ],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "On a similar note, one can attempt to use tree-child sequences to solve a new problem related to Hybridization, where the input is a set of tree-child networks instead of trees. The problem aims to find a tree-child network with minimal reticulation number, containing all input networks. This problem has not been studied before, but could be very important, as there is a dire need of methods for finding a consensus network for a given set of networks.",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        },
        {
            "text": "As a follow-up, it would be interesting to extend our Network Containment results to a more general framework. In this paper, we have presented a linear time algorithm for checking whether a tree-child network contains another tree-child network on the same set of taxa. What is the change in complexity (if there is one) when we consider tree-child networks on different sets of taxa? Does the problem become NP-hard, or does it remain polynomial time? Could a modified version of our algorithm be used to solve this problem?",
            "cite_spans": [],
            "section": "Discussion",
            "ref_spans": []
        }
    ],
    "ref_entries": {
        "TABREF0": {
            "text": "Table 1.: Linear regression analysis for tree-child network containment on 131200 instances, for which half were yes-instances and the other half no-instances. The high \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R^2$$\\end{document} value indicates that the fit of the curve is essentially linear (where an \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$R^2$$\\end{document} value of 1 indicates a perfect linear fit) and the slopes indicate the change in running time for every increase in the number of leaves, reticulation number r, and reticulation number \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document}.\n",
            "type": "table"
        },
        "FIGREF0": {
            "text": "Fig. 1.: A binary tree-child network N (grey and black) reduced to a leaf 4 by a tree-child sequence S. The reduction is shown as a sequence of networks \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$NS_{[:i]}$$\\end{document} for \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$i=0,1,\\ldots ,6$$\\end{document} from left to right, in which an element of S is applied to the network successively. This sequence is minimal for the network, as every element of the sequence reduces either a cherry or a reticulated cherry of the network. An example of a cherry (3, 1) can be seen in the network \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$NS_{[:3]}$$\\end{document}, and a reticulated cherry (3, 4) can be seen in the network N. The reduction of both reducible pairs is carried out as in Subsect. 2.1. Observe that this sequence is a tree-child sequence. The black subnetwork is also reduced by S, and the embedding can be constructed by building both networks simultaneously and keeping track of the edges added by the pairs that change the subnetwork (black pairs and arrows).",
            "type": "figure"
        },
        "FIGREF1": {
            "text": "Fig. 2.: The dependence of the running time on the number of leaves n (left) and the number of reticulations in the second network \\documentclass[12pt]{minimal}\n\t\t\t\t\\usepackage{amsmath}\n\t\t\t\t\\usepackage{wasysym} \n\t\t\t\t\\usepackage{amsfonts} \n\t\t\t\t\\usepackage{amssymb} \n\t\t\t\t\\usepackage{amsbsy}\n\t\t\t\t\\usepackage{mathrsfs}\n\t\t\t\t\\usepackage{upgreek}\n\t\t\t\t\\setlength{\\oddsidemargin}{-69pt}\n\t\t\t\t\\begin{document}$$r'$$\\end{document} (right). This was visualized by fixing the other parameters to a set value of 1000 in both plots. Fitted lines are independent of Table 1.",
            "type": "figure"
        }
    },
    "back_matter": [],
    "bib_entries": {
        "BIBREF0": {
            "title": "Networks: expanding evolutionary thinking",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Bapteste",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Trends Genet.",
            "volume": "29",
            "issn": "8",
            "pages": "439-441",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tig.2013.05.007"
                ]
            }
        },
        "BIBREF1": {
            "title": "Seeing the trees and their branches in the network is hard",
            "authors": [
                {
                    "first": "IA",
                    "middle": [],
                    "last": "Kanj",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Nakhleh",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Than",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Xia",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "Theoret. Comput. Sci.",
            "volume": "401",
            "issn": "1\u20133",
            "pages": "153-164",
            "other_ids": {
                "DOI": [
                    "10.1016/j.tcs.2008.04.019"
                ]
            }
        },
        "BIBREF2": {
            "title": "Attaching leaves and picking cherries to characterise the hybridisation number for a set of phylogenies",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Linz",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Semple",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Adv. Appl. Math.",
            "volume": "105",
            "issn": "",
            "pages": "102-129",
            "other_ids": {
                "DOI": [
                    "10.1016/j.aam.2019.01.004"
                ]
            }
        },
        "BIBREF3": {
            "title": "Networks in phylogenetic analysis: new tools for population biology",
            "authors": [
                {
                    "first": "DA",
                    "middle": [],
                    "last": "Morrison",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Int. J. Parasitol.",
            "volume": "35",
            "issn": "5",
            "pages": "567-582",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ijpara.2005.02.007"
                ]
            }
        },
        "BIBREF4": {
            "title": "Generation of binary tree-child phylogenetic networks",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cardona",
                    "suffix": ""
                },
                {
                    "first": "JC",
                    "middle": [],
                    "last": "Pons",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Scornavacca",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "PLoS Comput. Biol.",
            "volume": "15",
            "issn": "9",
            "pages": null,
            "other_ids": {
                "DOI": [
                    "10.1371/journal.pcbi.1007347"
                ]
            }
        },
        "BIBREF5": {
            "title": "Comparison of tree-child phylogenetic networks",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Cardona",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Rossello",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Valiente",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "IEEE/ACM Trans. Comput. Biol. Bioinf.",
            "volume": "6",
            "issn": "4",
            "pages": "552-569",
            "other_ids": {
                "DOI": [
                    "10.1109/TCBB.2007.70270"
                ]
            }
        },
        "BIBREF6": {
            "title": "Deciding the existence of a cherry-picking sequence is hard on two trees",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "D\u00f6cker",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "van Iersel",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Kelk",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Linz",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Discrete Appl. Math.",
            "volume": "260",
            "issn": "",
            "pages": "131-143",
            "other_ids": {
                "DOI": [
                    "10.1016/j.dam.2019.01.031"
                ]
            }
        },
        "BIBREF7": {
            "title": "Solving the tree containment problem for genetically stable networks in quadratic time",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gambette",
                    "suffix": ""
                },
                {
                    "first": "ADM",
                    "middle": [],
                    "last": "Gunawan",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Labarre",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Vialette",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Combinatorial Algorithms",
            "volume": "",
            "issn": "",
            "pages": "197-208",
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF8": {
            "title": "Solving the tree containment problem in linear time for nearly stable phylogenetic networks",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Gambette",
                    "suffix": ""
                },
                {
                    "first": "AD",
                    "middle": [],
                    "last": "Gunawan",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Labarre",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Vialette",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Discrete Appl. Math.",
            "volume": "246",
            "issn": "",
            "pages": "62-79",
            "other_ids": {
                "DOI": [
                    "10.1016/j.dam.2017.07.015"
                ]
            }
        },
        "BIBREF9": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        },
        "BIBREF10": {
            "title": "Locating a tree in a phylogenetic network",
            "authors": [
                {
                    "first": "LV",
                    "middle": [],
                    "last": "Iersel",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Semple",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Steel",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Inf. Process. Lett.",
            "volume": "110",
            "issn": "23",
            "pages": "1037-1043",
            "other_ids": {
                "DOI": [
                    "10.1016/j.ipl.2010.07.027"
                ]
            }
        },
        "BIBREF11": {
            "title": "",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": null,
            "other_ids": {
                "DOI": []
            }
        }
    }
}