{
    "paper_id": "956ed73c60311f2f22b12ad5424dc56083a42cdd",
    "metadata": {
        "title": "Inferring Restricted Regular Expressions with Interleaving from Positive and Negative Samples",
        "authors": [
            {
                "first": "Yeting",
                "middle": [],
                "last": "Li",
                "suffix": "",
                "affiliation": {
                    "laboratory": "State Key Laboratory of Computer Science",
                    "institution": "Chinese Academy of Sciences",
                    "location": {
                        "postCode": "100190",
                        "settlement": "Beijing",
                        "country": "China"
                    }
                },
                "email": ""
            },
            {
                "first": "Haiming",
                "middle": [],
                "last": "Chen",
                "suffix": "",
                "affiliation": {
                    "laboratory": "State Key Laboratory of Computer Science",
                    "institution": "Chinese Academy of Sciences",
                    "location": {
                        "postCode": "100190",
                        "settlement": "Beijing",
                        "country": "China"
                    }
                },
                "email": ""
            },
            {
                "first": "Lingqi",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Beijing University of Technology",
                    "location": {
                        "settlement": "Beijing",
                        "country": "China"
                    }
                },
                "email": "zhanglingqisteve@gmail.com"
            },
            {
                "first": "Bo",
                "middle": [],
                "last": "Huang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Northwestern Polytechnical University",
                    "location": {
                        "settlement": "Xi'an",
                        "country": "China"
                    }
                },
                "email": ""
            },
            {
                "first": "Jianzhao",
                "middle": [],
                "last": "Zhang",
                "suffix": "",
                "affiliation": {
                    "laboratory": "State Key Laboratory of Computer Science",
                    "institution": "Chinese Academy of Sciences",
                    "location": {
                        "postCode": "100190",
                        "settlement": "Beijing",
                        "country": "China"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "The presence of a schema for XML documents has numerous advantages. Unfortunately, many XML documents in practice are not accompanied by a schema or a valid schema. Therefore, it is essential to devise algorithms to infer schemas. The fundamental task in XML schema inference is to learn regular expressions. In this paper, we focus on learning the subclass of RE(&) called SIREs (the subclass of regular expressions with interleaving). Previous work in this direction lacks inference algorithms that support inference from positive and negative examples. We provide an algorithm to learn SIREs from positive and negative examples based on genetic algorithms and parallel techniques. Our algorithm also has better expansibility, which means that our algorithm not only supports learning with positive and negative examples, but also supports learning with positive or negative examples only. Experimental results demonstrate the effectiveness of our algorithm.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "A classical problem in grammatical inference is to identify a language from positive examples and negative examples. We study learning regular expressions (REs) with interleaving (shuffle), denoted by RE(&). Since RE(&) are widely used in various areas of computer science [1] , including XML database systems [5, 12, 26] , complex event processing [24] , system verification [4, 13, 15] , plan recognition [18] and natural language processing [21, 28] .",
            "cite_spans": [
                {
                    "start": 273,
                    "end": 276,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                },
                {
                    "start": 310,
                    "end": 313,
                    "text": "[5,",
                    "ref_id": null
                },
                {
                    "start": 314,
                    "end": 317,
                    "text": "12,",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 318,
                    "end": 321,
                    "text": "26]",
                    "ref_id": "BIBREF25"
                },
                {
                    "start": 349,
                    "end": 353,
                    "text": "[24]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 376,
                    "end": 379,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 380,
                    "end": 383,
                    "text": "13,",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 384,
                    "end": 387,
                    "text": "15]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 407,
                    "end": 411,
                    "text": "[18]",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 444,
                    "end": 448,
                    "text": "[21,",
                    "ref_id": "BIBREF20"
                },
                {
                    "start": 449,
                    "end": 452,
                    "text": "28]",
                    "ref_id": "BIBREF27"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Studying the inference of RE(&) has several practical motivations, such as schema inference. The presence of a schema for XML documents has many advantages, such as for query processing and optimization, data integration and exchange [11, 30] . However, many XML documents in practice are not accompanied by a valid schema [16] , making schema inference an attractive research topic [2, 3, 10, 14, 31] . Learning Relax NG schemas is an important research problem for schema inference, since it is more powerful than other XML schema languages, such as DTD or XSD [5] and has unrestricted supports for the interleaving operator. It is known that the essential task in Relax NG schema inference is learning RE(&) from a set of given sample [23, 31] .",
            "cite_spans": [
                {
                    "start": 234,
                    "end": 238,
                    "text": "[11,",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 239,
                    "end": 242,
                    "text": "30]",
                    "ref_id": "BIBREF29"
                },
                {
                    "start": 323,
                    "end": 327,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 383,
                    "end": 386,
                    "text": "[2,",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 387,
                    "end": 389,
                    "text": "3,",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 390,
                    "end": 393,
                    "text": "10,",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 394,
                    "end": 397,
                    "text": "14,",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 398,
                    "end": 401,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 563,
                    "end": 566,
                    "text": "[5]",
                    "ref_id": null
                },
                {
                    "start": 738,
                    "end": 742,
                    "text": "[23,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 743,
                    "end": 746,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Previously, RE(&) learning has been studied from positive examples only [23, 29, 31] . However, negative examples might be useful in some applications. For instance, the schema evolution [8, 9] can be done incrementally, with little feedback needed from the user, when we also allow negative examples. Learning RE(&) from positive and negative examples may have other crucial applications, such as mining scientific workflows. REs have already been used in the literature as a well-suited mechanism for inter-workflow coordination [17] . The user labeled some sequences of modules from a set of available workflows as positive or negative examples. So such algorithms can be thus applied to infer the workflow pattern that the user has in mind.",
            "cite_spans": [
                {
                    "start": 72,
                    "end": 76,
                    "text": "[23,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 77,
                    "end": 80,
                    "text": "29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 81,
                    "end": 84,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                },
                {
                    "start": 187,
                    "end": 190,
                    "text": "[8,",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 191,
                    "end": 193,
                    "text": "9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 531,
                    "end": 535,
                    "text": "[17]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Such kinds of applications motivate us to investigate the problem of learning RE(&) from positive and negative examples. Most researchers have studied subclasses of REs, which are expressive enough to cover the vast majority of real-world applications [6, 7, 22] and perform better on several decision problems than general ones [6, 7, 19, 20, 25, 27] . Bex et al. [3] proposed learning algorithms for two subclasses of REs: SOREs and CHAREs, which capture many practical DTDs/XSDs and are both single occurrence REs. Bex et al. [2] also studied learning algorithms, based on the Hidden Markov Model, for the subclass of REs in which each alphabet symbol occurs at most k times (k-OREs). More recently, Freydenberger and K\u00f6tzing [10] proposed more efficient algorithms for the above-mentioned SOREs and CHAREs. Existing work on RE(&) learning mentioned above [23, 29, 31] are all working on specific subclasses of REs. The aim of these approaches is to infer restricted subclasses of single occurrence REs with interleaving starting from a positive set of words representing XML documents based on maximum clique or maximum independent set.",
            "cite_spans": [
                {
                    "start": 252,
                    "end": 255,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 256,
                    "end": 258,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 259,
                    "end": 262,
                    "text": "22]",
                    "ref_id": "BIBREF21"
                },
                {
                    "start": 329,
                    "end": 332,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 333,
                    "end": 335,
                    "text": "7,",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 336,
                    "end": 339,
                    "text": "19,",
                    "ref_id": "BIBREF18"
                },
                {
                    "start": 340,
                    "end": 343,
                    "text": "20,",
                    "ref_id": "BIBREF19"
                },
                {
                    "start": 344,
                    "end": 347,
                    "text": "25,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 348,
                    "end": 351,
                    "text": "27]",
                    "ref_id": "BIBREF26"
                },
                {
                    "start": 365,
                    "end": 368,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 529,
                    "end": 532,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 729,
                    "end": 733,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                },
                {
                    "start": 859,
                    "end": 863,
                    "text": "[23,",
                    "ref_id": "BIBREF22"
                },
                {
                    "start": 864,
                    "end": 867,
                    "text": "29,",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 868,
                    "end": 871,
                    "text": "31]",
                    "ref_id": "BIBREF30"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper, we focus on learning the subclass of RE(&), called SIREs (see Definition 1) [29] . It has been proved that the problem of learning SIREs is NP-hard [29] . Here, we solve this problem by using genetic algorithms and parallel techniques. Genetic algorithms have been used to solve NP problems, and parallel techniques can make programs more efficient. As a result, when given both positive and negative examples, we can effectively learn a SIRE.",
            "cite_spans": [
                {
                    "start": 91,
                    "end": 95,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 163,
                    "end": 167,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The main contributions of this paper are listed as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "- ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Regular Expression with Interleaving. Let \u03a3 be a finite alphabet of symbols. The set of all words over \u03a3 is denoted by \u03a3 * . The empty word is denoted by \u03b5. A RE with interleaving over \u03a3 is defined inductively as follows: \u03b5 or a \u2208 \u03a3 is a RE, for REs r 1 and r 2 , the disjunction r 1 |r 2 , the concatenation r 1 \u00b7r 2 , the interleaving r 1 &r 2 , or the Kleene-Star r * 1 is also a RE. r ? and r + are abbreviations of r|\u03b5 and r\u00b7r * , respectively. They are denoted as RE(&).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "The size of a RE r, denoted by |r|, is the total number of symbols and operators occurred in r. The language L(r) of a RE r is defined as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "where a, b \u2208 \u03a3 and u , v \u2208 \u03a3 * , then u&\u03b5 = \u03b5&u = u and u&v = a(u &v)\u222a b(u&v ). For example, L(ab cd) = {cdab, cadb, cabd, acdb, acbd, abcd}.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "A RE with interleaving r is SOIRE, if every alphabet symbol occurs at most once in r. We consider the subclass of REs with interleaving (SIREs) defined by the following grammar. For instance, a * b ? &cd + is a SIRE, but a + b&c + a is not because a appears twice.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Preliminaries"
        },
        {
            "text": "We use candidate region to define the skeleton structure of a SIRE. Let N ={0,1,2 ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 68,
                    "end": 81,
                    "text": "Let N ={0,1,2",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Definition 2 Candidate Region (CR)."
        },
        {
            "text": "For a given alphabet |\u03a3| = n, it is easy to see there are 2 n\u22121 CRs. For example, consider \u03a3={a, b, c, d, e} and |\u03a3|=5. As is shown in Fig. 1 , we can get 16 CRs. The number of squares with the same color represents the |D i |, e.g., the 6th CR denotes 1&1&3 and the 12th CR denotes 1&1&1&2. So, the SIRE r 1 = a + &b&c * d + e ? belongs to the 6th CR 1&1&3 and the SIRE r 2 = a + &b&c * &d + e ? belongs to the 12th CR 1&1&1&2. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 135,
                    "end": 141,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Definition 2 Candidate Region (CR)."
        },
        {
            "text": "Our algorithm aims to obtain an accurate and precise SIRE, which should accept as many positive samples as possible and reject as many negative samples as possible. We show the major technical details of our algorithm in this section. The main algorithm is presented in Sect. 3.1. Initializing all the simplified candidate regions (SCRs) is introduced in Sect. 3.2. Selecting the best candidate SIRE from each SCR is given in Sect. 3.3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Learning Algorithm"
        },
        {
            "text": "The algorithm iSIRE first figures out the SCRs of the expression to be learned, then for each SCR, employs genetic algorithms to learn character sequence and multiplicity sequence in parallel, and decodes each learned sequence to a SIRE according to its SCR. After multi-generation evolution and iteration, the best SIRE is selected by function bestRE(). The main procedures of the algorithm are presented in Algorithm 1, and are illustrated as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Main Algorithm"
        },
        {
            "text": "-Scan positive examples S + and negative examples S to get the alphabet \u03a3, then call function getSCRs() to initialize all the SCRs based on |\u03a3|. -In parallel, call algorithm candSIRE to select the best SIRE from each SCR, and put them in the candidate set C. -Call function bestRE() to select the best SIRE from C and output it.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Main Algorithm"
        },
        {
            "text": "Function bestRE() is designed to select the best SIRE. It measures two metrics of SIREs: K(r) for accuracy and CC(r) [23] for preciseness. For a SIRE r, ",
            "cite_spans": [
                {
                    "start": 117,
                    "end": 121,
                    "text": "[23]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "The Main Algorithm"
        },
        {
            "text": "Note that K(r) has a higher priority than CC(r) when selecting the best SIRE. If the value of K(r) is larger, then it means r can accept more positive examples and reject more negative examples. Smaller the CC(r) is, the more precise the SIRE will be. In the rest of this section, we will discuss the implementations of lines 3, 4 and 5 in detail.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Main Algorithm"
        },
        {
            "text": "Next, we will give a detailed explanation of Line 3 of Algorithm 1 (initializing all the SCRs) in this section.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Initializing All the Simplified Candidate Regions (SCRs)"
        },
        {
            "text": "From Definition 2, when |\u03a3| = n, there are 2 n\u22121 CRs. Because of the unorder features of SIREs, we can easily find that for a SIRE r = D 1 & \u00b7 \u00b7 \u00b7 &D n , the order of D i can be arbitrary, where 1 \u2264 i \u2264 n. Hence, we can merge some equivalent CRs and get the SCRs. For instance, in Fig. 1 , we can merge the 6th CR 1&1&3, the 8th CR 1&3&1 and the 11th CR 3&1&1 together. After the merger of some equivalent CRs, we get the SCRs shown in Fig. 2 .",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 281,
                    "end": 287,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                },
                {
                    "start": 436,
                    "end": 442,
                    "text": "Fig. 2",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Algorithm 1: iSIRE"
        },
        {
            "text": "When the |\u03a3| = n, how many SCRs are there? This problem is equivalent to Integer Partition, e.g., when |\u03a3| = 5, there are 7 SCRs, including 5, 4&1, 3&2, 3&1&1, 2&2&1, 2&1&1&1 and 1&1&1&1&1. Meanwhile, the 7 partitions of 5 are: 5 = 5, 5 = 4 + 1, 5 = 3 + 2, 5 = 3 + 1 + 1, 5 = 2 + 2 + 1, 5 = 2 + 1 + 1 + 1 and 5 = 1 + 1 + 1 + 1 + 1. In general, approximation formulas exist that can calculate the number of partitions. For n \u2208 N, the number of partitions of n p(n) \u2248 3 is far less than 2 n\u22121 . It can be seen from Table 1 intuitively that the number of SCRs is far less than CRs. So we use function getSCRs() to get SCRs instead of CRs in our algorithm iSIRE. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 513,
                    "end": 520,
                    "text": "Table 1",
                    "ref_id": "TABREF1"
                }
            ],
            "section": "Algorithm 1: iSIRE"
        },
        {
            "text": "For each SCR obtained in first step, we employ the algorithm candSIRE (shown in Algorithm 2) to find the best candidate SIRE. Because each SCR is independent of each other and does not interfere with each other, we use multi-thread on our multi-core processor to run the candSIRE algorithm in parallel. By using parallel processing, we can infer the best candidate SIRE for each SCR with numerous SIREs simultaneously, which makes a huge difference when there are often hundreds of SIREs to evaluate per SCR. The algorithm candSIRE uses a number of genetic operators. Using the alphabet \u03a3 = {a, b, c, d, e} as an example, we introduce some of them as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "-character crossover: in the character population, we randomly select two character sequences p 1 = ebdac and p 2 = eabdc as parents (in Fig. 3) . First, we select the genetic information (bd) and (ab) of the parent p 1 and p 2 at the same position, and put them into the children c 1 and c 2 at the corresponding position respectively. Then we explain how to add the genetic information of the parent p 2 into the child c 1 . Our method starts from the ending position of genetic information of p 2 , and then passes each gene of parent p 2 , which has not appeared in c 1 , to c 1 . In this example, we start with the gene d of p 2 , because d is already in c 1 , we skip it and move to c. Since c is not in c 1 , we can put c to the first available location of c 1 . As we arrived at the end of p 2 , we moved to the first gene e. This time, e is not in c 1 , so we can add e to the next available location of c 1 . Continue the process we get c 1 = cbdea. In the same way, we generate c 2 = cabed, and they are shown in Fig. 3 . -character mutation: the principle of character mutation is to traverse each gene and determine the mutation according to the mutation rate. If the selected gene mutates, the method randomly selects another gene and exchange their positions. For example, for a character sequence p 1 = abcde, we assume the selected gene a mutates, then we select gene c and exchange the position of a and c, thus finally get p 1 = ebcda shown in Fig. 4 . -chromosome encoding: as is shown in Fig. 5 , when we encode SIRE r = d ? b + c * &e + &a, we can extract a SCR 3&1&1, a multiplicity sequence \"?+ * +1\" and a character sequence dbcea. -chromosome decoding: we decode a SCR 2&2&1, a multiplicity sequence \" * ?? + * \" and a character sequence abcde to get a SIRE r = a * b ? &c ? d + &e * . The example is shown in Fig. 6 . 1. Initialize the population of candidate character sequences. Here we set the population size to 500. 2. Select the best multiplicity sequence for each character sequence using algorithm selectMuls in parallel. The pseudocode of selectMuls is presented in Algorithm 3, we will explain its details later. 3. Decode each pair of character sequences, corresponding best multiplicity sequences and the given SCR to get the population of candidate SIREs by calling function decode(). 4. Call function calcValues(), calculate fitness value f (r) for each SIRE r. The fitness value f (r) of r is defined as follows.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 137,
                    "end": 144,
                    "text": "Fig. 3)",
                    "ref_id": "FIGREF10"
                },
                {
                    "start": 1024,
                    "end": 1030,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF10"
                },
                {
                    "start": 1463,
                    "end": 1469,
                    "text": "Fig. 4",
                    "ref_id": null
                },
                {
                    "start": 1509,
                    "end": 1515,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF7"
                },
                {
                    "start": 1836,
                    "end": 1842,
                    "text": "Fig. 6",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "f (r) = (K(r), CC(r)),",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "For the detailed definitions of K(r) and CC(r), see Sect. 3.1. Our fitness function gives priority to K(r), and then compare the CC(r), that is, on the basis of selecting the SIRE that can accept more positive examples and reject more negative examples, then consider the more precise ones. 5. Call function select() to generate the next generation SIREs. The method first retains the best 20% of SIREs by the fitness f (r) in the current population unchanged, and then applies roulette-wheel selection to the remaining 80% to get the next generation SIREs. Meanwhile, it is also important to note that K(r) is the top priority when choosing SIREs. When the values of K(r) are the same, we choose the SIRE which CC(r) is minimum. 6. Call function charCrossover(), select some pairs of character sequences according to the crossover rate (0.8), and construct new pairs of character sequences by applying the character crossover.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "7. Call function charMutate(), select some character sequences according to the mutation rate (0.03), and modify the selected sequences by applying the character mutation. 8. Iterate 2\u22128 steps until the number of generations reaches the given threshold C Gmax. Here we set C Gmax=300. Finally, we call function bestRE() (see Sect. 3.1) to select the best SIRE from the last generation of SIREs.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "In order to improve the efficiency of evolution, we adopt two tricks to optimize algorithm candSIRE. In the second step of candSIRE, it needs to select the best multiplicity sequence for each character sequence. Obviously, this process can be executed in parallel because these character sequences are independent of each other when finding the best multiplicity sequence. Besides, as is well known, the fitness function is usually the most computationally expensive component of the genetic algorithm. Thus, we use value hashing to reduce the amount of time spent on calculating fitness values by storing previously computed fitness values in a hash table. During execution, solutions found previously will be revisited due to the random mutations and recombinations of SIREs, then we just revisit its fitness value directly from the hash table instead of recalculation. Inevitably, the storage of the hash table consumes memory usage. Now we introduce the algorithm selectMuls used in the second step of algorithm candSIRE (shown in Algorithm 3), it aims to select best multiplicity sequence for each character sequence. Before introducing the details of select-Muls, we illustrate its genetic operators as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "-multiplicity crossover: randomly select crossover points of two parents, and then exchange the selected genes to get children. In the multiplicity population, e.g., we randomly select two multiplicity sequences p 1 = \" * +1?+\" and p 2 = \" * ?? + +\" as parents. Then we exchange \"+1\" of p 1 and \"??\" of p 2 to get children c 1 = \" * ???+\" and c 2 = \" * +1 + +\" in The main procedures of selectMuls are illustrated as follows.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "1. Initialize the population of candidate multiplicity sequences. Here we set the population size to 200.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "2. Call function decode(), decode each group of multiplicity sequences, the character sequences and the SCR to get the population of candidate SIREs. 3. Call function calcValues(), calculate fitness value f (r) for each SIRE r. 4. Call function select(), use roulette-wheel selection to generate a next generation from the current population according to fitness values. 5. Call function mulCrossover(), select some pairs of multiplicity sequences according to the crossover rate (0.8), and construct new pairs of multiplicity sequences by multiplicity crossover. 6. Call function mulMutate(), select some multiplicity sequences according to the mutation rate (0.03), and modify the sequences by applying the multiplicity mutation. 7. Iterate 2-8 steps until the number of generations reaches the given threshold M Gmax. Here we set M Gmax=100. Then, we call function bestRE() to select the best SIRE r from the last generation of SIREs in the given SCR. Finally, we call function encode(r).muls to get a multiplicity sequence. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Selecting the Best Candidate SIRE from Each SCR"
        },
        {
            "text": "In this section, we validate our algorithm by means of experimental analysis. All experiments were performed using a prototype implementation of iSIRE written in Python 3.6 executed on a machine with sixteen-core Intel Xeon CPU E5620@2.4 GHz, 24 GB memory.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Experiments"
        },
        {
            "text": "To compare the algorithms Exact Minimal [29] , conMiner [29] , conDAG [29] and iSIRE, we generate 9 datasets of positive examples with alphabet size |\u03a3| = {5, 10, 15} and example size |S| = {100, 500, 1000}. Table 2 presents the K(r) values and CC(r) values of the learned SIREs. From Table 2 we can see that for all the 9 datasets, the K(r) values of learned SIREs with both algorithms are all 100%, which means both algorithms can guarantee the learned SIREs to cover all positive examples 1 . According to the CC(r) values of SIREs learned by the four algorithms in Table 2 , we observe that when the alphabet size |\u03a3| is smaller (|\u03a3| = 5), the learned SIREs by Exact Minimal, conMiner, conDAG and iSIRE have the same smaller CC(r) values. However, as the alphabet size |\u03a3| grows larger (|\u03a3| = 15), the CC(r) values of learned SIREs by Exact Minimal, conMiner or conDAG is much larger than that of iSIRE, that means the results learned by iSIRE is more precise than the other 3 algorithms. ",
            "cite_spans": [
                {
                    "start": 40,
                    "end": 44,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 56,
                    "end": 60,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                },
                {
                    "start": 70,
                    "end": 74,
                    "text": "[29]",
                    "ref_id": "BIBREF28"
                }
            ],
            "ref_spans": [
                {
                    "start": 208,
                    "end": 215,
                    "text": "Table 2",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 285,
                    "end": 292,
                    "text": "Table 2",
                    "ref_id": "TABREF2"
                },
                {
                    "start": 569,
                    "end": 576,
                    "text": "Table 2",
                    "ref_id": "TABREF2"
                }
            ],
            "section": "Learning SIREs from Positive Examples"
        },
        {
            "text": "In order to evaluate the effectiveness of our learning algorithm on learning examples of both positive and negative cases, we would have liked to compare iSIRE with other approaches, but this was impossible, since we found no other tools or algorithms supporting learning SIREs from both positive and negative examples. Thus we only conducted experiment with our own algorithm. According to the alphabet size, example size, and the proportion of positive and negative examples, we made 27 datasets of examples and conducted experiment on these examples (shown in Table 3 ). As Table 3 shows, more than 74% K(r) values of inferred SIREs are above 75%, that is, majority of SIREs learned by iSIRE accept most of positive examples and reject most of negative examples, which demonstrates the high effectiveness of our algorithms. ",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 563,
                    "end": 570,
                    "text": "Table 3",
                    "ref_id": "TABREF3"
                },
                {
                    "start": 577,
                    "end": 584,
                    "text": "Table 3",
                    "ref_id": "TABREF3"
                }
            ],
            "section": "Learning SIREs from Positive and Negative Examples"
        },
        {
            "text": "In this paper, we provided algorithm iSIRE to learn a SIRE from positive and negative examples based on genetic algorithms and parallel techniques. Then we conducted experiments with alphabets of different sizes, and results showed that with only positive examples, our learning results are more precise compared with the state-of-the-art algorithms, and when given both positive and negative examples, we can learn SIREs with high accuracy.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusions"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Shuffled languages -representation and recognition",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Berglund",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Bj\u00f6rklund",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Bj\u00f6rklund",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theor. Comput. Sci. 489",
            "volume": "490",
            "issn": "",
            "pages": "1--20",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Learning deterministic regular expressions for the inference of schemas from XML data",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "J"
                    ],
                    "last": "Bex",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Gelade",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Vansummeren",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "TWEB",
            "volume": "4",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Inference of concise DTDs from XML data",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "J"
                    ],
                    "last": "Bex",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schwentick",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Tuyls",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the 32nd VLDB",
            "volume": "",
            "issn": "",
            "pages": "115--126",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Two-variable logic on words with data",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Boja&apos;nczyk",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Muscholl",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schwentick",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Segoufin",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                }
            ],
            "year": 2006,
            "venue": "Proceedings of the 21st LICS",
            "volume": "",
            "issn": "",
            "pages": "7--16",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Efficient asymmetric inclusion of regular expressions with interleaving and counting for XML type-checking",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Colazzo",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ghelli",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Pardini",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sartiani",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Theor. Comput. Sci",
            "volume": "492",
            "issn": "",
            "pages": "88--116",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Linear time membership in a class of regular expressions with counting, interleaving, and unordered concatenation",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Colazzo",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Ghelli",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sartiani",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "ACM Trans. Database Syst",
            "volume": "42",
            "issn": "4",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Update rewriting and integrity constraint maintenance in a schema evolution support system: PRISM++",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Curino",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "J"
                    ],
                    "last": "Moon",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Deutsch",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Zaniolo",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "PVLDB",
            "volume": "4",
            "issn": "2",
            "pages": "117--128",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Managing semi-structured data",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Florescu",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "ACM Queue",
            "volume": "3",
            "issn": "8",
            "pages": "18--24",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Fast learning of restricted regular expressions and DTDs",
            "authors": [
                {
                    "first": "D",
                    "middle": [
                        "D"
                    ],
                    "last": "Freydenberger",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "K\u00f6tzing",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Theory Comput. Syst",
            "volume": "57",
            "issn": "4",
            "pages": "1114--1158",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Schema profiling of document-oriented databases",
            "authors": [
                {
                    "first": "E",
                    "middle": [],
                    "last": "Gallinucci",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Golfarelli",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Rizzi",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Inf. Syst",
            "volume": "75",
            "issn": "",
            "pages": "13--25",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Gao",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "M"
                    ],
                    "last": "Sperberg-Mcqueen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [
                        "S"
                    ],
                    "last": "Thompson",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "Concurrent regular expressions and their relationship to petri nets",
            "authors": [
                {
                    "first": "V",
                    "middle": [
                        "K"
                    ],
                    "last": "Garg",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "T"
                    ],
                    "last": "Ragunath",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "Theor. Comput. Sci",
            "volume": "96",
            "issn": "2",
            "pages": "285--304",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "XTRACT: learning document type descriptors from XML document collections",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Garofalakis",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Gionis",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shim",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shim",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Shim",
                    "suffix": ""
                }
            ],
            "year": 2003,
            "venue": "Data Min. Knowl. Disc",
            "volume": "7",
            "issn": "1",
            "pages": "23--56",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Shuffle languages, petri nets, and context-sensitive grammars",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "L"
                    ],
                    "last": "Gischer",
                    "suffix": ""
                }
            ],
            "year": 1981,
            "venue": "Commun. ACM",
            "volume": "24",
            "issn": "9",
            "pages": "597--605",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "The quality of the XML Web",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Grijzenhout",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Marx",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "J. Web Semant",
            "volume": "19",
            "issn": "",
            "pages": "59--68",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Workflow and process synchronization with interaction expressions and graphs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Heinlein",
                    "suffix": ""
                }
            ],
            "year": 2001,
            "venue": "Proceedings of the 17th ICDE",
            "volume": "",
            "issn": "",
            "pages": "243--252",
            "other_ids": {}
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Weighted unranked tree automata as a framework for plan recognition",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "H\u00f6gberg",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kaati",
                    "suffix": ""
                }
            ],
            "year": 2010,
            "venue": "Proceedings of the 13th FUSION",
            "volume": "",
            "issn": "",
            "pages": "1--8",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "The inclusion problem for regular expressions",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hovland",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "J. Comput. Syst. Sci",
            "volume": "78",
            "issn": "6",
            "pages": "1795--1813",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "The membership problem for regular expressions with unordered concatenation and numerical constraints",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Hovland",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Proceedings of the 6th LATA",
            "volume": "",
            "issn": "",
            "pages": "313--324",
            "other_ids": {}
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Treebank grammar techniques for non-projective dependency parsing",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kuhlmann",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [],
                    "last": "Satta",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the 12th EACL",
            "volume": "",
            "issn": "",
            "pages": "478--486",
            "other_ids": {}
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Practical study of deterministic regular expressions from large-scale XML and schema data",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Chu",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Mou",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Dong",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 22nd IDEAS",
            "volume": "",
            "issn": "",
            "pages": "45--53",
            "other_ids": {}
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Learning concise Relax NG schemas supporting interleaving from XML documents",
            "authors": [
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "X",
                    "middle": [],
                    "last": "Mou",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 14th ADMA",
            "volume": "",
            "issn": "",
            "pages": "303--317",
            "other_ids": {}
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "PIE: approximate interleaving event matching over sequences",
            "authors": [
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Ge",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 31st ICDE",
            "volume": "",
            "issn": "",
            "pages": "747--758",
            "other_ids": {}
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "Closure properties and descriptional complexity of deterministic regular expressions",
            "authors": [
                {
                    "first": "K",
                    "middle": [],
                    "last": "Losemann",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Martens",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Niewerth",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Theor. Comput. Sci",
            "volume": "627",
            "issn": "",
            "pages": "54--70",
            "other_ids": {}
        },
        "BIBREF25": {
            "ref_id": "b25",
            "title": "BonXai: combining the simplicity of DTD with the expressiveness of XML schema",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Martens",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Niewerth",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schwentick",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Proceedings of the 34th PODS",
            "volume": "",
            "issn": "",
            "pages": "145--156",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "Complexity of decision problems for XML Schemas and chain regular expressions",
            "authors": [
                {
                    "first": "W",
                    "middle": [],
                    "last": "Martens",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Neven",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Schwentick",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "SIAM J. Comput",
            "volume": "39",
            "issn": "4",
            "pages": "1486--1530",
            "other_ids": {}
        },
        "BIBREF27": {
            "ref_id": "b27",
            "title": "Non-projective dependency parsing in expected linear time",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Nivre",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "Proceedings of the 47th ACL",
            "volume": "",
            "issn": "",
            "pages": "351--359",
            "other_ids": {}
        },
        "BIBREF28": {
            "ref_id": "b28",
            "title": "Discovering restricted regular expressions with interleaving",
            "authors": [
                {
                    "first": "F",
                    "middle": [],
                    "last": "Peng",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Cheng",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Cui",
                    "suffix": ""
                },
                {
                    "first": "Z",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Cai",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "APWeb 2015",
            "volume": "9313",
            "issn": "",
            "pages": "104--115",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-25255-1_9"
                ]
            }
        },
        "BIBREF29": {
            "ref_id": "b29",
            "title": "Schema management for document stores",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Wang",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "PVLDB",
            "volume": "8",
            "issn": "9",
            "pages": "922--933",
            "other_ids": {}
        },
        "BIBREF30": {
            "ref_id": "b30",
            "title": "Inference of a concise regular expression considering interleaving from XML documents",
            "authors": [
                {
                    "first": "X",
                    "middle": [],
                    "last": "Zhang",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Li",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Cui",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Dong",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "Proceedings of the 22nd PAKDD",
            "volume": "",
            "issn": "",
            "pages": "389--401",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "The subclass of REs with interleaving (SIREs) are SOIREs over \u03a3 defined by the following grammar: S :: = T &S|T T :: = \u03b5|a|a * |T T, where a \u2208 \u03a3",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "All the candidate regions of |\u03a3| = 5",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "the set of positive examples and S is the set of negative examples. The Combinatorial Cardinality (CC(r), introduced in [23]) of r can be computed as follows:",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "n \u2192 \u221e. As n increases,",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "All the simplified candidate regions of |\u03a3| = 5",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "candSIRE Input: positive examples S+, negative examples S , an SCR scr Output: a SIRE r 1 initialize character population C P OP 2 for g = 1 to C Gmax do 3 initialize candidate list SIREs \u2190 \u2205 4foreach cs \u2208 C P OP in parallel do5 add decode(cs,selectMuls(cs, scr),scr) to SIREs 6 C P OP \u2190 select(C P OP ,calcValues(SIREs, S+, S )) r \u2190 bestRE(SIREs)",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "Character Character mutationd ? b + c * &e + &a ? + * + 1 d b c e a",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Chromosome encoding * ? ? + * a * b ? &c ? d + &e * a b c d e",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Chromosome decodingIn the algorithm candSIRE, for a given SCR, positive examples S + and negative examples S , we select the best candidate SIRE that accepts as many positive samples as possible, rejects as many negative samples as possible, and as precise as possible. The main procedures are as follows.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "-multiplicity mutation: replacing the mutated gene with an element of the set { * , +, ?, 1}. The principle of character mutation is to traverse each gene of the chromosome and determine the mutation according to the mutation rate. The example is shown inFig. 8. Multiplicity crossover p1 * ? ? + + mutate p 1 * ? ? + * Multiplicity mutation",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "selectMuls Input: positive examples S+, negative examples S , character sequence cs, an SCR scr Output: a multiplicity sequence ms 1 initialize multiplicity population M P OP 2 for g = 1 to M Gmax do 3 initialize candidate list SIREs \u2190 \u2205 4 foreach ms \u2208 M P OP in parallel do 5 add decode(cs, ms, scr) to SIREs 6 M P OP \u2190 select(M P OP ,calcValues(SIREs, S+, S )) SIREs \u2190 ModifyMuls(SIREs) 10 r = bestRE(SIREs) 11 return ms \u2190 encode(r).ms",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "We design algorithm iSIRE based on genetic algorithm, which can learn SIREs from both positive and negative examples. To the best of our knowledge, our work is the first one to infer the subclass of RE(&) from positive and negative examples. We hope our work may shed some light on further research. We conduct a series of experiments with alphabets of different sizes. The results reveal the effectiveness of iSIRE, show the high accuracy and preciseness of our work.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "The number of CRs and SCRs of varying alphabet size.",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Result of learning SIREs from positive examples.",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "Results of learning SIREs from positive and negative examples. |S+| |S\u2212| K(r) CC(r) |\u03a3| |S+| |S\u2212| K(r) CC(r) |\u03a3| |S+| |S\u2212| K(r) CC(r)",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}