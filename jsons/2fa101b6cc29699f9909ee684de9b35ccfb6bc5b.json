{
    "paper_id": "2fa101b6cc29699f9909ee684de9b35ccfb6bc5b",
    "metadata": {
        "title": "Group Testing for COVID-19: How to Stop Worrying and Test More",
        "authors": [
            {
                "first": "Lakshmi",
                "middle": [],
                "last": "Narasimhan",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Indian Institute of Technology Palakkad",
                    "location": {}
                },
                "email": ""
            },
            {
                "first": "Theagarajan",
                "middle": [],
                "last": "",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Indian Institute of Technology Palakkad",
                    "location": {}
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "The corona virus disease 2019 caused by the novel corona virus has an exponential rate of infection. COVID-19 is particularly notorious as the onset of symptoms in infected patients are usually delayed and there exists a large number of asymptomatic carriers. In order to prevent overwhelming of medical facilities and large fatality rate, early stage testing and diagnosis are key requirements. In this article, we discuss the methodologies from the group testing literature and its relevance to COVID-19 diagnosis. Specifically, we investigate the efficiency of group testing using polymerase chain reaction (PCR) for COVID-19. Group testing is a method in which multiple samples are pooled together in groups and fewer tests are performed on these groups to discern all the infected samples. We study the effect of dilution due to pooling in group testing and show that group tests can perform well even in the presence of dilution effects. We present multiple group testing algorithms that could reduce the number of tests performed for COVID-19 diagnosis. We analyze the efficiency of these tests and provide insights on their practical relevance. With the use of algorithms described here, test plans can be developed that can enable testing centers to increase the number of diagnosis performed without increasing the number of PCR tests. The codes for generating test plans are available online at [1].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "The novel corona virus has caused a pandemic in early 2020. The reproduction rate of the corona virus is estimated to be between 1.4 and 3.9 [2] . From an infected patient, COVID spreads to 1.4 to 3.9 others on an average. As the virus spreads through respiratory droplets, it spreads at an exponential rate, especially, in densely populated locations. The infected patients become carriers at an early stage even before the onset of symptoms [3] . Thus, it becomes imperative to test a large number of people and identify early stage infections to contain the spread of COVID-19. The PCR based testing is considered to be one of the best techniques for early stage diagnosis [4] . Group testing is well known methodology in the combinatorics and compressed sensing literature [5] . In group testing(GT), multiple samples are pooled together to form groups (fewer in number than the total number of samples). Tests are performed on these groups and from the outcome of these tests, the infected samples are inferred. Group testing relies on the fact that not all of the tested samples may be infected. Thus, by employing group testing for COVID-19 diagnosis, the number of samples tested can be increased, the tests performed can be made economical and the speed of detection can be improved. This can lead to efficient containment of the spread of COVID-19.",
            "cite_spans": [
                {
                    "start": 141,
                    "end": 144,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 443,
                    "end": 446,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 676,
                    "end": 679,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 777,
                    "end": 780,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this article, we investigate group testing for COVID diagnosis using PCRs from a practical view. We analytically study the effect of dilution, caused by pooling in group tests, on the accuracy of the tests. We present multiple group testing algorithms with which a test plan for diagnosis of a pool of samples can be generated. We analyze and present the scenarios in which the presented algorithms are appropriate. We show through simulations that group testing can provide considerable gains in the number of tests performed. Finally, we provide some guidelines for performing COVID diagnosis in practice. A practitioner can directly generate the test plans using the MATLAB codes that are available online at [1] .",
            "cite_spans": [
                {
                    "start": 715,
                    "end": 718,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Certain key findings and discussions of this article can be listed as follows:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "\u2022 When the infection rate is less than 33%, group test can help to reduce the number of tests significantly. Some examples on the gains obtained through group testing (with a sensitivity of more than 99%) are given below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Number of samples to test 16 16 16 32 32 32 Infection rate 5% 10% 20% 5% 10% 20% Number of tests required by group testing 6 8 12 11 16 26",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 31,
                    "text": "16",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 130,
                    "end": 132,
                    "text": "11",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "\u2022 Replication or repeating a test is required to improve the accuracy of any qRT-PCR test outcome. We find that replicating the test twice could be sufficient to get high accuracy. Further, group testing could provide inherent replication and reduce the number of replicates required. For details refer to Sections 3.1 and 5.3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "\u2022 We also analyzed the effect of dilution caused by dividing a swab sample's content to smaller portions and mixing multiple samples together. This helped us to determine an upper limit on the number of samples that can be pooled together. It was found that up to 57 samples can be pooled together without reducing the test accuracy. For details refer to Section 5.2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "\u2022 It was found that different group testing strategies are optimal under different conditions. The diagnostician should adapt the test plan depending on the infection rate of a given cluster or local community. Test plans that are optimal for a given infection rate are discussed in Section 6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Further guidelines to follow while testing for COVID-19 through group testing are discussed in Section 7. Notations: . denotes the floor operation, i.e., largest integer lesser than or equal to the given number. . denotes the ceil operation, i.e., smallest integer greater than or equal to the given number. . denotes rounding off operation. |A| denotes the cardinality of the set A, i.e., the total number of elements in the set A.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The real time or quantitative reverse transcription polymerase chain reaction (qRT-PCR) is the testing method used for early detection of COVID. In RT-PCR, the viral RNA molecules present in the test medium are first reverse transcribed into DNA, which is referred to as the complementary DNA (cDNA). The cDNA corresponding to the COVID genes are amplified using PCR, which is performed through thermal cycling. In the high temperature cycle, the target cDNA's double-helix strands are separated (referred to as the denaturation process). In the low temperature cycle, the primers bind onto the cDNA strands (referred to as annealing) to initiate the polymerization through which the free nucleotides assemble on the DNA strands to form a new double-helix DNA (referred to as the elongation process). Thus, in every cycle the number of DNA particles present are doubled; refer Fig. 1 . After several cycles, the total number of target DNA present is increased to an exponentially large volume. Finally, fluorescent dyes that fluoresce in the presence of the target DNA are used to visually identify the presence or absence of the virus. The number of thermal cycles determine the final volume of target DNA present; hence, by increasing the thermal cycles (also referred to as amplification cycle), the sensitivity or the detection accuracy of qRT-PCR can be improved. A detailed procedure and reagents used in qRT-PCR for detection of COVID can be found in [6] . ",
            "cite_spans": [
                {
                    "start": 1458,
                    "end": 1461,
                    "text": "[6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [
                {
                    "start": 877,
                    "end": 883,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Real-Time Reverse Transcription-PCR"
        },
        {
            "text": "Using qRT-PCR, it was found that 10 virus particles are sufficient to successfully detect the presence of the virus in a test sample with very high accuracy (>99.9%) [7] . However, this accuracy or goodness of test may vary with the qRT-PCR kit used. We define the following metrics to compare and analyze the goodness of tests.",
            "cite_spans": [
                {
                    "start": 166,
                    "end": 169,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Goodness of Test"
        },
        {
            "text": "Let X be a binary random variable that denotes the presence (X = 1) or absence (X = 0) of the virus in a test sample. Let X t be a binary random variable that denotes the outcome of a test.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Goodness of Test"
        },
        {
            "text": "Definition -False negative rate : \u03b3 = Pr(X t = 0|X = 1) The rate or probability of the outcome of a test being negative when the virus is actually present in the sample. Alternatively, the sensitivity is defined as the probability of the test outcome being positive when the virus is actually present in the sample; this is given by 1\u2212\u03b3 = Pr(X t = 1|X = 1). It is desirable for the test to have a low value for \u03b3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Goodness of Test"
        },
        {
            "text": "Definition -False positive rate : \u03b2 = Pr(X t = 1|X = 0) The rate or probability of the outcome of a test being positive when the virus is actually absent in the sample. It is desirable for the test to have a low value for \u03b2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Goodness of Test"
        },
        {
            "text": "Definition -Prior : \u03b1 = Pr(X = 1) The rate of occurrence of the virus in a given population.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Goodness of Test"
        },
        {
            "text": "The prior can be approximately computed, using previous history, as the ratio of the number of positive cases to the total number of tests performed. It is important to minimize sample bias in this heuristic computation. According to [8] , the prior (at the time of writing this article) for United States of America is about 0.1973 and for India is about 0.0379. Among the countries where more than 10 5 tests were performed, the lowest prior is for UAE (about 0.005) and the highest is for Spain (about 0.4423). In real life, we are more concerned about the false negative rate (as opposed to false positive rate). It is very important to have the least \u03b3 to minimize the spread of COVID and fatality caused by it. Further, the value of these rates depend on the viral load or the number of viral RNA copies present in the test (denoted by l). We denote the false negative and positive rates as a function of l using \u03b3(l) and \u03b2(l), respectively. It was found in [7] that \u03b3(5) \u2248 0.07. Therefore, the goodness or efficiency of a testing technique is given by \u03b3(l) and \u03b2(l). It is necessary to know these parameters for a given testing technique before we can analyze the efficiency of group testing using the same.",
            "cite_spans": [
                {
                    "start": 234,
                    "end": 237,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                },
                {
                    "start": 964,
                    "end": 967,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Goodness of Test"
        },
        {
            "text": "Often tests are performed multiple times on a single sample to confirm the outcome and account for any variability in the testing procedure, thereby improving the accuracy of the test. Here, we shall analyze the improvement in accuracy when tests are replicated for a given sample. When the test is replicated r times, the outcome is declared based on the majority rule. To declare the final decision as negative, the APR should have a value greater than 1. The expressions to compute the sensitivity and APR due to replication are derived in Appendix A. Figure 2 illustrates the improvement in accuracy for double and triple replication. From Fig. 2a , one can choose the value of r, i.e., how many tests to perform depending on the \u03b3 of the testing technique and the \u03b3 r that is desired. For example, when \u03b3 is small (< 0.05), double and triple replicates give very similar performance; hence, double replication will suffice. Figure 2b shows us that replication is necessary when the prior is more than 8% at a false negative and positive rates of 5% and 10%, respectively, for the testing technique.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 555,
                    "end": 563,
                    "text": "Figure 2",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 644,
                    "end": 651,
                    "text": "Fig. 2a",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 929,
                    "end": 938,
                    "text": "Figure 2b",
                    "ref_id": "FIGREF3"
                }
            ],
            "section": "Replication"
        },
        {
            "text": "Group testing(GT) refers to the idea of pooling multiple samples together and performing tests on certain subsets of these samples to discern the infected samples. First, we illustrate GT through a simple example given in Fig. 3 Here, we have utilized only 6 tests to diagnose 8 samples -a 25% reduction in the number of tests. Note that, if we had known that there was exactly one infected sample, then only 4 tests would be required (tests 4 and 6 would not be required). This GT algorithm is referred to as the binary search and is the optimal GT when there is exactly one infected sample in a given pool. In general, to test a pool of N samples with up to one infected sample, we require at most 2 log 2 N tests and at least log 2 N tests. This gain increases exponentially with N ; for example, N = 64 requires at most 14 tests with GT as opposed to 64 tests without GT.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 222,
                    "end": 228,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Group Testing"
        },
        {
            "text": "The theory of group testing deals with the design and analysis of algorithms that tell us how to choose subsets (groups) of samples to pool together and test, and identify the infected samples. In other words, GT aims to minimize the number of tests (T ) required to identify at most D number of infected samples among N number of given samples (pool size); 0 \u2264 D < N and T \u2264 N . In practice, the value of D is not known. Nevertheless, depending on the value of the prior, an upper bound on the number of infected samples can be chosen 1 as D for a given N .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Group Testing"
        },
        {
            "text": "There are two paradigms of GT, namely,",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "\u2022 Combinatorial group testing (CGT): The combinatorial algorithms require the exact number (or an upper bound) of the infected samples D. As long as the chosen value of D is greater than or equal to the true number of infected samples, CGT algorithms always identifies the infected samples correctly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "\u2022 Probabilistic group testing (PGT): The probabilistic algorithms require an upper bound on \u03b1 and identify all infected samples with certain probability P D . Usually, the detection probability P D is very close to 1; however, there still may be a non-zero probability of the infected cases going unidentified. For small values of \u03b1, the average number of tests performed in PGT is less than N ; however, there can exist cases for which the number of tests performed by PGT might be greater than N , albeit, the probability of occurrence of such cases will be relatively small. In PGT, there exists a trade-off between P D and the average value of T .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "From the above discussion, it can be seen that, due to their deterministic nature, CGT algorithms are preferred in practice to test for diseases. When an upper bound on D cannot be reliably established, PGT algorithms may prove to be more efficient as opposed to CGT. There exists PGT algorithms in which P D = 1. In the worst case (i.e., when D = N \u2212 1), the value of T can be greater than N , but the average value of T can still be much less than N . This is further discussed in Section 6. CGT and PGT algorithms are further classified into",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "\u2022 Adaptive tests: Here, the tests are performed sequentially. First a group is chosen randomly based on D N or \u03b1 and tested, the outcome of this test determines the next group to test and so on. Thus, the size and samples of a group are chosen adaptively based on previous group and its test outcome. The GT described in Figure 3 is an example of adaptive CGT.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 321,
                    "end": 329,
                    "text": "Figure 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Types of Group Tests"
        },
        {
            "text": "\u2022 Non-adaptive tests: When the test plan is fixed for a given D and N , then it is known as the non-adaptive GT. Here, a fixed number of tests are always performed irrespective of the number of infected samples present in the pool. An advantage of non-adaptive GT is that, if T N is the number of groups to be tested, then all the T N tests can be simultaneously run in parallel.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "The non-adaptive GT can be represented by a matrix of dimension T N \u00d7N (referred to as the measurement matrix), and the samples can be represented by a N \u00d7 1 vector with 0's for uninfected samples and 1's for infected samples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "The measurement matrix consists of 0's and 1's, the 1's in a row correspond to the samples included in a test and the 1's in a column correspond to the number of times a particular sample is tested. The Boolean OR operation between the measurement matrix and the samples vector gives the GT outcomes. Now, designing a non-adaptive GT algorithm becomes a problem of designing efficient measurement matrices 2 and decoding algorithms to discern the positions of 1's in the sparse samples vector with the given T N test measurements. The non-adaptive test algorithms can be studied with the aid of compressed sensing literature [9] , [5] .",
            "cite_spans": [
                {
                    "start": 625,
                    "end": 628,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                },
                {
                    "start": 631,
                    "end": 634,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "A key drawback of the non-adaptive GT algorithms is that it requires a large value of N (in the order of 10 3 \u221210 6 ) to be efficient and provide reliable performance. Also, when the number of testing kits are limited and the prior is small, sequential tests are more efficient and quicker in identifying and discarding uninfected samples than parallel tests. Therefore, in this article, we shall limit our study only to adaptive tests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Types of Group Tests"
        },
        {
            "text": "In this section, we shall discuss some limitations and surprising advantages of performing group tests for COVID diagnosis in practice using qRT-PCR.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Practical Considerations in Performing Group Tests for COVID"
        },
        {
            "text": "A key question in the application of GT for COVID testing is how small should D be, relative to N ? That is, what is the range of values of D N for which GT reduces the total number of tests required? This was first answered in [10] ; GT is said to reduce the number of tests required when D N < 3\u2212 \u221a 5",
            "cite_spans": [
                {
                    "start": 228,
                    "end": 232,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "When is GT Efficient?"
        },
        {
            "text": "2 . As a general rule of thumb, considerable reduction in the total number of tests can be achieved when D N or the prior \u03b1 is less than 33% ; in all other cases, it is best to perform individual tests. As discussed in Section 3, typical value of \u03b1 for COVID is less than 0.33. Thus, GT can be utilized to efficiently increase the number of samples tested for COVID with minimal number of tests performed.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "When is GT Efficient?"
        },
        {
            "text": "In group testing, dilution occurs in two stages, namely, preparation and pooling. We shall discuss the effects of these dilutions on the allowable sample size and goodness of test. The following discussion will also help us to determine a practically appropriate value of the pool size N that provides reliable test outcomes.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Effect of Dilution"
        },
        {
            "text": "When preparing the samples for GT, each sample needs to be divided into multiple portions for usage in multiple groups. In the example in Fig. 3 , each sample is required to be divided into 3 portions since any sample could be involved in a maximum of 3 groups. In general, a sample may be involved in at most log 2 N groups 3 while testing N samples [11] . If each test is replicated r times, then a sample may have to be divided into r log 2 N portions. However, we shall see in the next subsection that each test need not be replicated in GT as it could provide inherent replication. In practice, to test for COVID, swabs from nasopharynx or throat [3] are taken. The swab samples can be dissolved in liquid buffer media [12] and this can be divided into multiple portions. When the samples are divided into multiple portions, the viral load gets distributed across the divided portions. Therefore, each sample can be divided only into certain number of portions such that the viral load in each portion can still be detected reliably by qRT-PCR. The swab from nasopharynx contains 10 6 \u2212 10 9 corona viral particles [3] , if L is the amount of viral load required for reliable detection, then each sample can be divided into at most V l L portions, where V l is the amount of viral particles in the swab. As discussed in Section 3, the false negative rate \u03b3(l) depends on the viral load in the test sample. If \u03b3 * is the required false negative rate for each test, then the corresponding viral load is given by the inverse function \u03b3 \u22121 (\u03b3 * ), and each sample can be divided into at most V l \u03b3 \u22121 (\u03b3 * ) . In Figure 4 , using the \u03b3(l) from [7] for qRT-PCR, we plot the number of portions into which a swab containing V l viral load can be divided to achieve a given false negative rate with three replicates. It can be seen that, when the swab has a viral load of 10 4 , we can still obtain about 220 portions for \u03b3 = 0.02. When portions of N swabs, of which D are infected, are mixed or pooled together for a qRT-PCR test, the viral load in D samples are diluted by the N \u2212 D virusfree samples. This dilution is referred to as the pooling dilution. The effect of this dilution on the performance of virus detection has been studied in [13] . Based on the probit model described in [14] , the effect of pooling dilution was derived in [13] . Though the model derived in [13] is for testing HIV, the authors mention that the model is applicable to other viral tests. Simplifying the model in [13] for COVID, the sensitivity after pooling dilution is given by",
            "cite_spans": [
                {
                    "start": 351,
                    "end": 355,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 652,
                    "end": 655,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 724,
                    "end": 728,
                    "text": "[12]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1120,
                    "end": 1123,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1645,
                    "end": 1648,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 2241,
                    "end": 2245,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 2287,
                    "end": 2291,
                    "text": "[14]",
                    "ref_id": "BIBREF13"
                },
                {
                    "start": 2340,
                    "end": 2344,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 2375,
                    "end": 2379,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                },
                {
                    "start": 2496,
                    "end": 2500,
                    "text": "[13]",
                    "ref_id": "BIBREF12"
                }
            ],
            "ref_spans": [
                {
                    "start": 138,
                    "end": 144,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF4"
                },
                {
                    "start": 1614,
                    "end": 1622,
                    "text": "Figure 4",
                    "ref_id": "FIGREF5"
                }
            ],
            "section": "Sample Preparation"
        },
        {
            "text": "where \u03a6(.) is the CDF of the normal distribution, \u03c7 is the number of RNA copies per viral particle (\u03c7 = 1 in the case of corona virus), D is the number of infected samples, V p is the viral load in each infected sample, V 50 and V 95 are the viral loads corresponding to a sensitivity of 0.5 and 0.95, respectively, for the considered testing 3 The maximum number of groups in which a sample will be involved may vary depending on the GT algorithms. It can be proved that log 2 N are sufficient to identify an infected sample among an arbitrary number of infected samples [11] . Further, once identified, as infected or uninfected, that sample is not used in any subsequent groups for testing.",
            "cite_spans": [
                {
                    "start": 343,
                    "end": 344,
                    "text": "3",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 572,
                    "end": 576,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Sample Pooling"
        },
        {
            "text": "technique, i.e., V x = \u03b3 \u22121 (1 \u2212 x). In Fig. 5 , we show the reduction in sensitivity of the pooled test when different number of samples (N ) are pooled together with different number of infected samples (D). It can be seen that the pool size of 32 still provides a very high sensitivity after pooling dilution even when a single sample is infected. A similar conclusion on the pool size was reported through experimentation in [15] . In general, if T is the number of tests for COVID that are to be performed on a swab with viral load V l with r replicates to achieve a sensitivity of 1 \u2212 \u03b3 * , then the maximum pool size can be derived as",
            "cite_spans": [
                {
                    "start": 429,
                    "end": 433,
                    "text": "[15]",
                    "ref_id": "BIBREF14"
                }
            ],
            "ref_spans": [
                {
                    "start": 40,
                    "end": 46,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF7"
                }
            ],
            "section": "Sample Pooling"
        },
        {
            "text": "To achieve a sensitivity of 95%, the above equation can be simplified 4 to N = V l rT V95 . For T = log 2 N , we get",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sample Pooling"
        },
        {
            "text": "where W 0 (.) is the Lambert W function. This formulation includes the effect of dilution in both the sample preparation and pooling stages. Example: For a swab containing a viral load of 10 6 viral particles, and a testing technique that requires 10 3 viral particles to achieve 95% sensitivity, the maximum pool size for 95% sensitivity of the group test should be N = 57.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sample Pooling"
        },
        {
            "text": "As seen from the above example, an efficient group test which performs the least number of total tests (T ) per sample can enable us to increase the pool size, which, in turn, increases the testing speed and cost. Therefore, employing an efficient GT algorithm for COVID testing is the key component in pooling tests. We shall discuss some practically relevant algorithms in Section 6.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Sample Pooling"
        },
        {
            "text": "In group testing, samples that belong to a group, which has a test outcome of positive, are often tested again in smaller groups. This ensures that multiple tests are performed for some samples. This can be observed in the example described in Fig. 3 ; sample 5 is involved in 3 tests that are positive. In GT, almost every sample that tests positive is replicated at least twice. This inherent replication reduces drastically the false positive rates of GT without an explicit replication of the individual tests. The exact amount of reduction of the false positive rate depends on the GT algorithm. Note that the group tests whose outcome are negative may not be replicated in GT and may require explicit replication to reduce false negative rates. Therefore, the false negative rates or the sensitivity would suffice to be an appropriate metric to evaluate group tests and one can focus on reducing \u03b3 to improve GT. In this section, we discuss two combinatorial group tests and a probabilistic group test which could be practically useful in testing for COVID-19. The generalized binary splitting (GBS) and multi-stage testing (MST) are the CGT algorithms, and nested testing (NT) is the PGT algorithm that we describe in the following subsections.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 244,
                    "end": 250,
                    "text": "Fig. 3",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Inherent Replication in GT"
        },
        {
            "text": "The generalized binary splitting (GBS) is the most commonly used adaptive algorithm in the CGT literature [11] . GBS is the generalization of the binary splitting procedure (BSP). First, we describe BSP, and generalize it to obtain GBS. The binary splitting procedure assumes that there exists at least one infected sample in a given pool and the goal of BSP is to identify exactly one infected sample in the least number of tests. That is, BSP works on a pool of size N with D \u2265 1 and identifies an infected sample in exactly log 2 N tests.",
            "cite_spans": [
                {
                    "start": 106,
                    "end": 110,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "The steps in BSP are given below:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022 Step 1 Split the N samples into two halves, say groups G 1 and G 2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022 Step 2 Test G 1 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "Step 3 When the test is positive: (i) continue performing all future tests with the samples from only G 1 , (ii) set N = |G 1 |, and (iii) if the number of samples in G 1 is 1, then one infected sample has been identified and the algorithm is terminated.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "Step 4 When the test is negative: (i) continue performing all future tests with the samples from only G 2 , (ii) set N = |G 2 |, and (iii) if the number of samples in G 2 is 1, then one infected sample has been identified and the algorithm is terminated. Note that, since D \u2265 1, if G 1 tests negative, then G 2 must test positive.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "Step 5 With the updated N and samples pool, goto Step 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "The GBS algorithm simply attempts to perform the BSP D times to identify at most D infected samples in a given pool of size N . The pseudocode and the steps in GBS algorithm are given in Algorithm 2. Analysis: Since the outcome of a test performed at each step determines the next group for testing, the total number of tests varies for different inputs for a given N and D. The number of tests performed in the worst case, i.e., the maximum value that T can attain in GBS is given by T \u2264 log 2 N D + D. Figure 6 shows the maximum number of tests required by GBS with each test replicated twice for different values of N and D. It can be seen that GBS testing requires lesser number of tests, even in the worst case, than the conventional 5 testing, which is 2N . In GBS, each sample may be involved in up to log 2 N D + 1 tests; the sample preparation stage should provide at least log 2 N D + 1 portions for each sample.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 504,
                    "end": 512,
                    "text": "Figure 6",
                    "ref_id": "FIGREF8"
                }
            ],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "Practical considerations: When employing GBS in practice, the following points need to be kept in mind.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022 The tests in GBS are sequential. That is, all the group tests have to be performed adaptively and in-order to obtain the final result.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022 The gains of GBS are higher for large values of N. From simulations, we observed that GBS is suited for D N \u2264 20% and the average number of tests required can be reduced by up to 50% of that of conventional tests. \u2022 A key thing to note in GBS is that the algorithm can fail if the value of D is underestimated. If the pool contains lesser number of infected samples than D, then GBS identifies all infected samples perfectly.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022 Inherent replication: In GBS, when a group is tested positive, often it gets tested again in the subsequent groups, thereby providing inherent replication. However, due to BSP, there exists scenarios where no samples are involved in multiple tests. Therefore, in practice, one has to explicitly watch out for such samples and replicate the test, if required.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "\u2022 At the end of GBS tests, the N \u2212 D samples, that are marked as uninfected, can be pooled into one group and tested. This ensures that D is not underestimated.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "Some of the disadvantages of GBS are overcome by the multi-stage testing algorithm, which is described in the next subsection.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Generalized Binary Splitting"
        },
        {
            "text": "A disadvantage in GBS tests is that the number of group tests that a particular sample undergoes is difficult to compute. To overcome this issue, we can employ C. H. Li's multi-stage testing (MST) [11] . In MST, each sample undergoes exactly s number of tests. The value of s can be chosen as dictated by any practical restrictions; however, there is an optimal number of stages that would minimize the total number of tests performed, this is given by [11] s = arg min",
            "cite_spans": [
                {
                    "start": 197,
                    "end": 201,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                },
                {
                    "start": 453,
                    "end": 457,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "The pseudocode of the MST algorithm is given in Algorithm 1. It can be explained as follows. Maintain three bins: infected samples' bin (ISB), uninfected samples' bin (USB) and queued samples' bin (QSB). Initially, all N are in QSB. In the ith stage (i = 1, 2, \u00b7 \u00b7 \u00b7 , s), form g i groups with all samples in QSB and test them. The samples that belong to groups which tested negative are moved to USB. If the group size is more than one, then the samples that belong to groups that tested positive are retained in QSB, else they are moved to ISB. Proceed to i + 1th stage and repeat the above steps till the group sizes become 1. Analysis: The group size g i is computed as g i = N i\u22121 /k i , where k i = \u03b4 1\u2212 i s is the average number of samples in a group. In practice, some groups of g i may contain k i samples and the rest may contain k i + 1 samples. Note that, in the last stage, all groups contain exactly one sample, i.e., k s = 1. The total number of tests performed in MST is T = s i=1 g i . The value of T is not fixed for a given N and D as it depends on the group test outcomes. However, we can determine the value of T in the worst case, i.e., the maximum value that T can take for a given N and D. This is given by T \u2264 eD ln \u03b4 [11] .",
            "cite_spans": [
                {
                    "start": 1243,
                    "end": 1247,
                    "text": "[11]",
                    "ref_id": "BIBREF10"
                }
            ],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "Practical considerations: When used in practice, MST has the following advantages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "\u2022 All groups in each stage can be tested in parallel. Thus, despite being an adaptive GT, testing can be sped up using MST.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "\u2022 When more than D groups test positive at any stage, then it can be inferred that the estimate of D is incorrect. In this case, the remaining samples in QSB can be tested with an MST test plan for the updated value of D and N (the number of samples in QSB will be the new value of N ). This ensures that the tests performed in all previous stages are still useful even when the value of D is incorrect.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "\u2022 When the true number of infected samples is less than or equal to D, MST identifies all infected samples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "\u2022 Since the number of stages s is known, the number of times any sample will be tested is at most s. Thus, in the sample preparation, it is sufficient to divide each swab content to only sr portions, where r is the number of replicates.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "\u2022 Inherent replication: Since all the samples in QSB at the end of stage-i are tested again in stage-i + 1, the tests for infected samples are automatically replicated. Therefore, only those groups that test negative at each stage needs replication. The groups that test positive are replicated inherently at least s times, thereby increasing the test accuracy and reducing false positives. This inherent replication further reduces the total number of tests required. We derived that the total number of tests reduced due to inherent replication in MST is at least k 1",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "\u2022 The maximum number of tests required by MST is always bounded above by N , i.e., T \u2264 N .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Multi-stage Testing"
        },
        {
            "text": "In Fig. 7a , we plot the optimal number of stages required in MST for different values of D and N . Note that, when the number of stages increase, the inherent replication for infected samples increase and improves the accuracy without any additional tests for replication. In Fig. 7b , we plot the number of tests required by MST in the worst case scenario for different values of D and N with double replication. For N = 16, the maximum number of tests required for MST saturates at 30 as opposed to 32 in the conventional testing with double replicates. It can be seen that MST requires uniformly lesser number of tests than the conventional testing. Though these numbers represent the worst case scenario, simulations show that the average number of tests required to detect infected samples could be 40% less than the conventional testing. GBS vs MST: Figure 8 shows the total number of tests required in the worst case for GBS and MST at different values of N and D = 1, \u00b7 \u00b7 \u00b7 , 6. The number of tests required by conventional testing is also indicated for baseline comparison. It can be seen that for small values of \u03b4, GBS outperforms MST. As D increases for a fixed N , GBS may sometimes require more number of tests than the conventional testing; however, MST always requires less than or equal number of tests as conventional testing. In general, for large values of N (>24), GBS may be appropriate, and MST may be appropriate in the other regime. Figure 8 can be used as a guideline to choose the best test for a given value of N and D.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 3,
                    "end": 10,
                    "text": "Fig. 7a",
                    "ref_id": "FIGREF11"
                },
                {
                    "start": 277,
                    "end": 284,
                    "text": "Fig. 7b",
                    "ref_id": "FIGREF11"
                },
                {
                    "start": 857,
                    "end": 865,
                    "text": "Figure 8",
                    "ref_id": "FIGREF13"
                },
                {
                    "start": 1459,
                    "end": 1467,
                    "text": "Figure 8",
                    "ref_id": "FIGREF13"
                }
            ],
            "section": "Multi-stage Testing"
        },
        {
            "text": "The value of D played an important role in the adaptive CGT algorithms discussed in the previous subsections. When the value of D is an underestimate, then the test plan provided by CGT may fail or may turn out to be suboptimal. This shortcoming can be addressed by the usage of PGT algorithms. Here, we shall describe a probabilistic group testing algorithm known as the nested testing (NT) [16] . The NT algorithm takes N and \u03b1 as the input and provides an adaptive test plan that minimizes the average number of total tests required to diagnose N samples. The actual number of infected samples in a pool or its estimate is not required for NT, only the prior probability of the presence of an infected sample is needed. Nested testing is an optimal PGT which identifies all infected samples without failure [16] . The algorithm proceeds by testing a group of samples from UB and moving them to PIB, if they test positive, then transferring the diagnosed samples to DB and returning the rest to UB, and repeating the whole process till all samples are diagnosed.",
            "cite_spans": [
                {
                    "start": 392,
                    "end": 396,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                },
                {
                    "start": 810,
                    "end": 814,
                    "text": "[16]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "Analysis: The NT algorithm models the presence of the virus in each sample as an independent Bernoulli random variable with probability \u03b1. Thus, NT can identify any number of infected samples in a pool, i.e., 0 \u2264 D \u2264 N . The probability Pr(D = i), i = 0, \u00b7 \u00b7 \u00b7 , N , is given by the Binomial distribution; nested testing exploits this fact to identify the group that has the highest probability to contain infected samples and tests it. The NT algorithm gives the least number of tests for which Pr(D = i) is the maximum. When the number of infected samples is i, such that Pr(D = i) is the least, the total number of tests required by NT may be more than N . However, when the NT test plan is applied to multiple pools of size N , the average number of tests required per pool will be lesser than N . The average number of tests required by NT is given by G(0, N ) , where G() is as given in (9) 6 . Figure 9 plots the average number of tests required by NT for different values of N and \u03b1. It is clear that, for smaller values of the prior probability, NT can provide large gains in terms of the average number of tests performed without any knowledge of D.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 854,
                    "end": 865,
                    "text": "by G(0, N )",
                    "ref_id": null
                },
                {
                    "start": 901,
                    "end": 909,
                    "text": "Figure 9",
                    "ref_id": "FIGREF12"
                }
            ],
            "section": "Nested Testing"
        },
        {
            "text": "Practical considerations: When used in practice, NT has the following advantages.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "\u2022 Nested testing can identify all infected samples irrespective of the actual value of D. The probability of detection of infected samples by NT is 1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "\u2022 A key condition for NT to perform well in practice is the availability of independent samples. That is, the probability of each sample being infected should be independent of the other samples in the pool and equal \u03b1. This can be achieved in practice through randomization of samples. That is, constituting a pool with samples from reasonably separated geographical locations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "\u2022 The value of the prior \u03b1 can be estimated based on the past history as discussed in Section 3. Further, this value should be continuously updated based on the outcomes of the tests performed each time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "\u2022 Inherent replication: In NT, an infected sample has very high probability of getting tested in at least two groups. Hence, NT can ensure at least double replication for samples that test negative.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "\u2022 To create an NT test plan, the algorithm needs to evaluate the expression in (9) ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Nested Testing"
        },
        {
            "text": "Group Testing is a promising method that can be effectively utilized to ramp up the number of tests performed in COVID-19 diagnosis. GT can help us quickly identify several early stage infections. By reducing the number of tests performed, GT can make the testing less expensive and economical. The following are some guidelines that can be followed in employing GT for COVID-19 diagnosis.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 Before employing pooling, the sensitivity of the testing technique needs to be characterized. Some qRT-PCR kits are known to provide accurate results with smaller viral load, whereas some are known to require a large amount of viral load to detect the virus. This sensitivity characteristics, i.e., \u03b3(l), needs to be understood before the formulation of GT test plans. The knowledge of \u03b3(l) would help us to decide the optimal pool size and number of replications required.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 When the testing speed is a primary factor, it may be better to employ MST as it enables to perform parallel group tests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 In CGT algorithms such as GBS or MST, randomization is not required. The statistical relation between the samples are irrelevant in CGT group tests. However, the estimate of the upper bound on the number of infected samples in a pool is an important parameter that needs to be accurate. The value of D can be estimated by observing the history of a location or cluster. When more samples from a location test positive, then the estimate of D should be correspondingly increased and vice versa.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 PGT algorithms such as NT has the advantage of not requiring the exact value or an upper bound on the number of infected samples in a pool. PGT algorithms require the prior probability values (\u03b1). Once again, this can be obtained from the history of the tests performed for a location or cluster. The ratio of the number of samples tested positive to the total number of tests performed can give us this estimate (refer Section 3). This estimate needs to be update continuously over time.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 Randomization could significantly reduce the number of tests performed in PGT. When samples from a small community or cluster are pooled together, most of them are likely to have a similar test outcome. However, PGT works best when the samples are independent. Hence, the testing center should randomize by picking samples from different communities or clusters to form a pool. This randomization can bring down the average fraction of samples that are positive in a pool and the dependence among the samples.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 In practice, PGT tests are suited well for locations where the infection rate is higher and the CGT tests are suited well for locations where the infection rate is small. This is because, PGT does not need the value of D and an underestimated value could cause failure of CGT tests.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 When choosing a GT algorithm to perform diagnosis, the practitioner can intelligently switch between GBS, MST and NT, depending on the estimate of D and \u03b1, and their accuracy. The performance plots provided in Section 6 can be utilized in choosing the best test for a given scenario.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 From the study so far, it is clear that considerable reduction in the total number of tests can be achieved when D N or the prior \u03b1 is less than 33%.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 Note that when D > N 2 or \u03b1 > 1 2 , group testing can still be helpful. Under this condition, the goal of GT would be reversed, i.e., to identify the uninfected samples rather than the infected samples. All our discussions so far remain applicable with this switch.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "\u2022 The MATLAB codes for simulating the results and generating group test plans are available online at [1] .",
            "cite_spans": [
                {
                    "start": 102,
                    "end": 105,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "where X t is the random variable denoting the outcome of the tth replicate. When the test is replicated twice, Pr(X 1 = 0, X 2 = 0|X = 1) = \u03b3 2 . For triple replication, Pr(X 1 + X 2 + X 3 \u2264 1|X = 1) = 3\u03b3 2 (1 \u2212 \u03b3) + \u03b3 3 and Pr(X 1 = 0, X 2 = 0, X 3 = 0|X = 1) = \u03b3 3 . For a given set of test replicate outcomes X 1 , \u00b7 \u00b7 \u00b7 , X r , the probability of the sample actually containing the virus is given by Pr(X = 1|X 1 , \u00b7 \u00b7 \u00b7 , X r ) -this is referred to as the a posteriori probability. The a posteriori probability ratio (APR) Pr(X=0|X1,\u00b7\u00b7\u00b7 ,Xr)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "Pr(X=1|X1,\u00b7\u00b7\u00b7 ,Xr) is easier to compute than the individual a posteriori probabilities. The APR for a given set of outcomes is AP R = Pr(X = 0|X 1 , \u00b7 \u00b7 \u00b7 , X r ) Pr(X = 1|X 1 , \u00b7 \u00b7 \u00b7 , X r ) = Pr(X 1 , \u00b7 \u00b7 \u00b7 , X r |X = 0) Pr(X 1 , \u00b7 \u00b7 \u00b7 , X r |X = 1)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "where m is the number of negative outcomes (i.e., X t = 0) in r replicates. Divide P i\u22121 into g i disjoint groups -G 1 , G 2 , \u00b7 \u00b7 \u00b7 , G gi such that G 1 \u222a G 2 \u222a \u00b7 \u00b7 \u00b7 \u222a G gi = P i\u22121",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Guidelines to Employ Group Testing for COVID-19 diagnosis"
        },
        {
            "text": "Test groups G 1 , G 2 , \u00b7 \u00b7 \u00b7 , G gi 8:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "7:"
        },
        {
            "text": "Discard groups that tested negative Test group G \u2286 P",
            "cite_spans": [],
            "ref_spans": [],
            "section": "7:"
        },
        {
            "text": "if test outcome is positive then 6: Identify an infected sample in G with BSP (Since the group tested positive, it must contain at least one infected sample)",
            "cite_spans": [
                {
                    "start": 33,
                    "end": 35,
                    "text": "6:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "5:"
        },
        {
            "text": "Update N = N \u2212 1 \u2212 g (where g is the number of uninfected items diagnosed from BSP, remove these from the pool) Test the N samples individually 15: end if",
            "cite_spans": [
                {
                    "start": 144,
                    "end": 147,
                    "text": "15:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "7:"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Available online: Matlab codes for test plan generation",
            "authors": [
                {
                    "first": "L",
                    "middle": [
                        "N"
                    ],
                    "last": "Theagarajan",
                    "suffix": ""
                }
            ],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Pattern of early human-to-human transmission of wuhan 2019 novel coronavirus (2019-ncov)",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Riou",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [
                        "L"
                    ],
                    "last": "Althaus",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "",
            "volume": "25",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Sars-cov-2 (covid-19) by the numbers",
            "authors": [
                {
                    "first": "Y",
                    "middle": [
                        "M"
                    ],
                    "last": "Bar-On",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Flamholz",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Phillips",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Milo",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "9",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Coronavirus and the race to distribute reliable diagnostics",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sheridan",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Nat Biotechnol",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Group testing and sparse signal recovery",
            "authors": [
                {
                    "first": "A",
                    "middle": [
                        "C"
                    ],
                    "last": "Gilbert",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "A"
                    ],
                    "last": "Iwen",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "J"
                    ],
                    "last": "Strauss",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "2008 42nd Asilomar Conference on Signals, Systems and Computers",
            "volume": "",
            "issn": "",
            "pages": "1059--1063",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Diagnostic detection of 2019-ncov by real-time rt-pcr",
            "authors": [
                {
                    "first": "V",
                    "middle": [],
                    "last": "Corman",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bleicker",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Br\u00fcnink",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Drosten",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Zambon",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "World Health Organization",
            "volume": "17",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Detection of 2019 novel coronavirus (2019-ncov) by real-time rt-pcr",
            "authors": [
                {
                    "first": "V",
                    "middle": [
                        "M"
                    ],
                    "last": "Corman",
                    "suffix": ""
                },
                {
                    "first": "O",
                    "middle": [],
                    "last": "Landt",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kaiser",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Molenkamp",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Meijer",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "K"
                    ],
                    "last": "Chu",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Bleicker",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Br\u00fcnink",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Schneider",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [
                        "L"
                    ],
                    "last": "Schmidt",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Eurosurveillance",
            "volume": "25",
            "issn": "3",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "Coronavirus disease (covid-19)-statistics and research",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Roser",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Ritchie",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ortiz-Ospina",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "Our World in Data",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Boolean compressed sensing and noisy group testing",
            "authors": [
                {
                    "first": "G",
                    "middle": [
                        "K"
                    ],
                    "last": "Atia",
                    "suffix": ""
                },
                {
                    "first": "V",
                    "middle": [],
                    "last": "Saligrama",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "IEEE Transactions on Information Theory",
            "volume": "58",
            "issn": "3",
            "pages": "1880--1901",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "On the cut-off point for combinatorial group testing",
            "authors": [
                {
                    "first": "P",
                    "middle": [],
                    "last": "Fischer",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Klasner",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Wegenera",
                    "suffix": ""
                }
            ],
            "year": 1999,
            "venue": "Discrete Applied Mathematics",
            "volume": "91",
            "issn": "1-3",
            "pages": "83--92",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Combinatorial group testing and its applications",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Du",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [
                        "K"
                    ],
                    "last": "Hwang",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Hwang",
                    "suffix": ""
                }
            ],
            "year": 2000,
            "venue": "",
            "volume": "12",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Transport of viral specimens",
            "authors": [
                {
                    "first": "F",
                    "middle": [
                        "B"
                    ],
                    "last": "Johnson",
                    "suffix": ""
                }
            ],
            "year": 1990,
            "venue": "Clinical microbiology reviews",
            "volume": "3",
            "issn": "2",
            "pages": "120--131",
            "other_ids": {}
        },
        "BIBREF12": {
            "ref_id": "b12",
            "title": "A methodology for deriving the sensitivity of pooled testing, based on viral load progression and pooling dilution",
            "authors": [
                {
                    "first": "N",
                    "middle": [
                        "T"
                    ],
                    "last": "Nguyen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Aprahamian",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [
                        "K"
                    ],
                    "last": "Bish",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [
                        "R"
                    ],
                    "last": "Bish",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "Journal of translational medicine",
            "volume": "17",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "Refinement of a viral transmission risk model for blood donations in seroconversion window phase screened by nucleic acid testing in different pool sizes and repeat test algorithms",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Weusten",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Vermeulen",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Van Drimmelen",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Lelie",
                    "suffix": ""
                }
            ],
            "year": 2011,
            "venue": "Transfusion",
            "volume": "51",
            "issn": "1",
            "pages": "203--215",
            "other_ids": {}
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Evaluation of covid-19 rt-qpcr test in multi-sample pools",
            "authors": [
                {
                    "first": "I",
                    "middle": [],
                    "last": "Yelin",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Aharony",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Shaer-Tamar",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Argoetti",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Messer",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Berenbaum",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Shafran",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Kuzli",
                    "suffix": ""
                },
                {
                    "first": "N",
                    "middle": [],
                    "last": "Gandali",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Hashimshony",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Born again group testing: Multiaccess communications",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Wolf",
                    "suffix": ""
                }
            ],
            "year": 1985,
            "venue": "IEEE Transactions on Information Theory",
            "volume": "31",
            "issn": "2",
            "pages": "185--191",
            "other_ids": {}
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "Group testing to eliminate efficiently all defectives in a binomial sample",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Sobel",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [
                        "A"
                    ],
                    "last": "Groll",
                    "suffix": ""
                }
            ],
            "year": 1959,
            "venue": "Bell System Technical Journal",
            "volume": "38",
            "issn": "5",
            "pages": "1179--1252",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "Illustration of polymerase chain reaction (PCR). Source: en.wikipedia.org/wiki/Polymerase chain reaction",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": ") Variation of sensitivity for different replicates.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": ") Variation of APR for different replicates.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Effect of replication on the accuracy of the tests for r replicates and m number of negative outcomes.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Illustration of group testing with a simple example.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "False negative rates achieved by different portion size at different sample viral loads (V l ).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Effect of pooling dilution on sensitivity.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "Worst case number of tests required by GBS with double replication for different values of N and D.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "number of stages in MST.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "case number of tests required by MST with double replication.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF11": {
            "text": "Optimal number of stages and the maximum value of T (each test replicated twice) in MST for different values of N and D.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF12": {
            "text": "Average number of tests required by nested testing for different prior probabilities. The NT algorithm can be explained by considering three bins: 1. Undiagnosed bin (UB) -this contains all the samples that are yet to be diagnosed, 2. Potentially infected bin (PIB) -this contains a group of samples with at least one of them being an infected sample, and 3. Diagnosed bin (DB) -this contains all the samples that are diagnosed as either positive or negative.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF13": {
            "text": "Comparison of the maximum number of tests required in group testing based on MST and GBS. The straight lines correspond to the number of tests required by conventional testing.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF15": {
            "text": "= {samples from groups that tested positive}, P i \u2282 P i\u22121 10:N i = |P i |11: end for 12: Return P s as the set of infected samples Algorithm 2 Generalized Binary Splitting Test 1: Input: N, D and samples pool P = {1, 2, \u00b7 \u00b7 \u00b7 , N }. 2: while N \u2265 2D \u2212 1 and D > 0 do 3:Choose a group G of size 2 log 2",
            "latex": null,
            "type": "figure"
        },
        "FIGREF16": {
            "text": "Update D = D \u2212 1 (remove the identified infected sample from the pool) Update N = N \u2212 |G| (|G| is the number of uninfected items in G, remove these from the pool) 11: end if 12: end while 13: if D > 0 and N > 0 then 14:",
            "latex": null,
            "type": "figure"
        },
        "TABREF2": {
            "text": ", this can be computationally intensive due to the recursive nature of the expressions. Thankfully, the expressions can be computed offline for different values of N and \u03b1, and stored as a look-up table. This look-up table can be used in the algorithm to speed up the testing in real-time.",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "The author thanks Namrata M. Nilavar, Indian Institute of Science, Bangalore, for useful discussions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Acknowledgments"
        },
        {
            "text": "Hence, the false negative and positive rates for r tests are given by (each replicate is assumed to be independent of the other) Compute h =G(0, |U|) using (8)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Replication analysis"
        },
        {
            "text": "Test a group G \u2286 U of size h 6:if Test is negative then 8:else 10:if h == 1 then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "5:"
        },
        {
            "text": "Update D = D + G and make P empty while P is not empty do",
            "cite_spans": [],
            "ref_spans": [],
            "section": "12:"
        },
        {
            "text": "Compute g =G(|P|, |P \u222a U|) using (8)",
            "cite_spans": [],
            "ref_spans": [],
            "section": "15:"
        },
        {
            "text": "Test a group G \u2286 P of size g 17: if Test is positive then G(1, m) = G(0, m \u2212 1), G(0, 1) = 1, G(0, 0) = 0.",
            "cite_spans": [
                {
                    "start": 29,
                    "end": 32,
                    "text": "17:",
                    "ref_id": null
                }
            ],
            "ref_spans": [],
            "section": "16:"
        }
    ]
}