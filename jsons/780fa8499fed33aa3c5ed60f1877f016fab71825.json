{
    "paper_id": "780fa8499fed33aa3c5ed60f1877f016fab71825",
    "metadata": {
        "title": "Extending Maximal Perfect Haplotype Blocks to the Realm of Pangenomics",
        "authors": [
            {
                "first": "Lucia",
                "middle": [],
                "last": "Williams",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Montana State University",
                    "location": {
                        "postCode": "59718",
                        "settlement": "Bozeman",
                        "region": "MT",
                        "country": "USA"
                    }
                },
                "email": "lucia.williams@montana.edu"
            },
            {
                "first": "Brendan",
                "middle": [],
                "last": "Mumey",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "Montana State University",
                    "location": {
                        "postCode": "59718",
                        "settlement": "Bozeman",
                        "region": "MT",
                        "country": "USA"
                    }
                },
                "email": ""
            }
        ]
    },
    "abstract": [
        {
            "text": "Recent work provides the first method to measure the relative fitness of genomic variants within a population that scales to large numbers of genomes. A key component of the computation involves finding conserved haplotype blocks, which can be done in linear time. Here, we extend the notion of conserved haplotype blocks to pangenomes, which can store more complex variation than a single reference genome. We define a maximal perfect pangenome haplotype block and give a lineartime, suffix tree based approach to find all such blocks from a set of pangenome haplotypes. We demonstrate the method by applying it to a pangenome built from yeast strains.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Given the availability of sequenced genome data for many individuals of the same species, it is now possible to study population genetics and evolution at a level of detail not before possible. An established method for quantifying the relative fitness of two genetic variants uses the selection coefficient [6, Chapter 5.3] . Recent work by Cunha et al. [4] describes a method to scale the computation of selection coefficients across an entire genome, even when the number of individuals being analyzed is large. They adopt the maximum-likelihood based method from Chen et al. [3] for computing the selection coefficient for a maximally conserved portion of the genome. These conserved portions of the genome can be identified using haplotypes: sequences of single nucleotide polymorphism (SNP) sites defined with respect to a reference sequence for the population. However, Cunha et al. note that, prior to their work, no efficient method existed to compute all maximally conserved blocks from a set of haplotypes. They give an algorithm for locating the blocks that is quadratic in the length of the haplotypes. More recently, Alanko et al. [1] give a method for finding haplotype blocks in linear time. However, both haplotype block location algorithms assume that all genomes under consideration have been aligned to the same reference genome.",
            "cite_spans": [
                {
                    "start": 308,
                    "end": 311,
                    "text": "[6,",
                    "ref_id": "BIBREF5"
                },
                {
                    "start": 312,
                    "end": 324,
                    "text": "Chapter 5.3]",
                    "ref_id": null
                },
                {
                    "start": 355,
                    "end": 358,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 579,
                    "end": 582,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                },
                {
                    "start": 1145,
                    "end": 1148,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A pangenome allows us to consider more complex variation in multiple individuals or organisms from a related group or species [10] . Pangenomic sequence data are often studied using graphs, where each sequence in a data set is represented by a path in the graph. In this work, we reformulate the problem of finding maximal haplotype blocks in the context of pangenomics. We give a method for finding pangenome SNPs in a De Bruijn graph in Sect. 3, define the pangenome maximal perfect haplotype block problem in Section 4, and describe a suffix tree approach to find all blocks in linear time relative to the input in Sect. 5. Finally, we find maximal perfect pangenome haplotype blocks in a ten-strain yeast pangenome and report results in Sect. 6.",
            "cite_spans": [
                {
                    "start": 126,
                    "end": 130,
                    "text": "[10]",
                    "ref_id": "BIBREF9"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Given a set of binary sequences representing the presence (or absence) of SNPs in a chromosome, the authors of [4] define a maximal perfect haplotype block as follows:",
            "cite_spans": [
                {
                    "start": 111,
                    "end": 114,
                    "text": "[4]",
                    "ref_id": "BIBREF3"
                }
            ],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "Then, the maximal perfect haplotype block (MPHB) problem is to find all maximal perfect haplotypes in a given set of sequences. For example, Fig. 1 shows a set of three sequences containing five MPHBs.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 141,
                    "end": 147,
                    "text": "Fig. 1",
                    "ref_id": "FIGREF0"
                }
            ],
            "section": "Background"
        },
        {
            "text": "In the case of pangenomic data it may not be possible to align each chromosome to a reference so we consider a generalized setting of the problem in which the SNPs occur in an arbitrary directed graph, rather than a linear sequence. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Background"
        },
        {
            "text": "We assume that a compressed De Bruijn graph (cDBG) has been built for the pangenomic data set we wish to study [2] . In this case the data set consists of a set of pangenomic sequences and the cDBG graph G consists of a set of nodes representing specific k-mers (or \u2265 k-mers if the graph has been compressed). The parameter k must be specified. An edge (u, v) is present in G provided the last k \u22121 nucleotides of u match the first k \u22121 nucleotides of v. Each pangenomic sequence is associated with a path in G, where each path node appends all nonoverlapping characters from the previous node in the path. Let P denote the collection of sequence paths in G.",
            "cite_spans": [
                {
                    "start": 111,
                    "end": 114,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                }
            ],
            "ref_spans": [],
            "section": "Building the SNP Graph"
        },
        {
            "text": "Bruijn graph that represents a SNP; we arbitrarily consider one side of the bubble to be the '0' path and the other to be the '1' path. In the compressed De Bruijn graph, the '0' and '1' paths are each a single node.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Fig. 2. A bubble in a De"
        },
        {
            "text": "We identify pangenomic SNPs by looking for \"bubbles\" in G. Bubbles, as shown in Fig. 2 , occur when paths diverge into exactly two subpaths and then rejoin, and no additional edges enter or leave the interior of the bubble. We view one side of the bubble as a '0' and the other as a '1'. Some bubbles will be longer than one nucleotide, but we still refer to them as SNPs for simplicity of notation. All SNPs can be found in O(|G|) time, since bubble nodes in a cDBG can be recognized in O(1) time. We form the SNP graph by retaining only those vertices of the cDBG graph that correspond to the '0' and '1' branches for each identified SNP. The paths P in G induce new SNP paths by deleting the non-SNP nodes in each path. The resulting SNP path sequences are used as input to maximal perfect perfect pangenome haplotype block problem, defined in the next section.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 80,
                    "end": 86,
                    "text": "Fig. 2",
                    "ref_id": null
                }
            ],
            "section": "Fig. 2. A bubble in a De"
        },
        {
            "text": "Given a SNP graph and a sequence, a pangenome haplotype is the list of nodes that the sequence follows through the SNP graph. Due to large structural variations such as strain-specific genes, segmental deletions, insertions, and rearrangements, certain regions of the pangenome may be missed by some sequences but followed by others. Thus, not all pangenome haplotypes have the exact same set of SNPs, and the position of a node within the path does not indicate which SNP the node corresponds to as it does in the single-reference case. Instead, the node labels indicate both the SNP identifier and the call (either a '0' or a '1'). Figure 3 lists four example pangenome haplotypes.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 634,
                    "end": 642,
                    "text": "Figure 3",
                    "ref_id": "FIGREF2"
                }
            ],
            "section": "Problem Definition"
        },
        {
            "text": "We define a maximal perfect pangenome haplotype block. Just as in the standard MPHB problem, the maximal perfect pangenome haplotype block (MPPHB) problem is to find all maximal perfect pangenome haplotype blocks among the k paths.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Definition"
        },
        {
            "text": "We note that if n is the length of the longest path in P , then there are no more than (n + 1)k MPPHBs in any set of paths P . A proof is given in Sect. 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Problem Definition"
        },
        {
            "text": "As in [1] , we can use a suffix tree to solve the MPPHB problem in linear time.",
            "cite_spans": [
                {
                    "start": 6,
                    "end": 9,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "Alanko et al. [1] note that all MPHBs in a set of sequences S = {s 1 , s 2 , . . . , s k } correspond to maximal repeats (repeated substrings that cannot be extended; see [7, Section 7.12]) in the string S = s 1 $ 1 s 2 $ 2 . . . s k $ l . However, not all maximal repeats in S are MPHBs, since any s i may contain repeated substrings and a pair s i and s j may contain the same substring beginning at different positions. Neither of these is a MPHB.",
            "cite_spans": [
                {
                    "start": 14,
                    "end": 17,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "They propose adding n + 1 unique \"index characters\" to each sequence, alternating with the existing characters. This way, substrings can only match to other substrings if they occur in exactly the same position in two different sequences. This process creates the string S + so that there is a maximal repeat in S + if and only if there is a MPHB in S. It is possible to find all maximal repeats in a string using a suffix tree in linear time and space [7, Section 7.12].",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "In the pangenome case, the suffix tree approach can still be applied. Because haplotype blocks need not begin at the same position in the path, the index characters are not needed. If the SNP graph contains cycles, then there may be maximal repeats within a single path; we can mark and ignore all internal suffix tree nodes that contain only a single haplotype path sequence in linear time using a standard method [9] . Thus, a simple procedure for locating pangenome haplotype blocks is as follows:",
            "cite_spans": [
                {
                    "start": 415,
                    "end": 418,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "1. Build the string P = p 1 $ 1 p 2 $ 2 . . . p k $ k , where each $ i is a distinct character not used in the p i strings. 2. Build a suffix tree on P. 3. Use the suffix tree to find all maximal repeats (K, S) in P. The SNP path and the set of sequences K are represented implicitly by the suffix tree node.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "Building a suffix tree can be done in O(nk) time and space [5] , and, as noted above, finding all maximal repeats in the suffix tree is also linear time. Thus, each step of the procedure takes linear time and space.",
            "cite_spans": [
                {
                    "start": 59,
                    "end": 62,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "Since the MPPHBs correspond to internal nodes in the suffix tree on P, we can give a bound on the number of MPPHB in P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Linear Time Method Based on Suffix Trees"
        },
        {
            "text": "Given a set of k pangenome paths P with maximum length n, there are at most (n + 1)k MPPHBs in P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "Proof. As argued above, every MPPHB in P corresponds to a maximal repeat in P. Because each path in P contains no more than n nodes, |P| \u2264 (n + 1)k. Then, because the maximal repeats of a string are the internal nodes in the suffix tree of that string [7, Theorem 7.12.1], there are at most (n + 1)k maximal repeats in P, and thus at most (n + 1)k MPPHBs in P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Lemma 1."
        },
        {
            "text": "We tested our method for finding MPPHBs using a moderately-sized pangenomic yeast data set. Yeast is a well-studied model system with a genome size of approximately 12 Mb. We created a yeast data set using assemblies from 10 yeast strains from the Saccharomyces Genome Database 1 used in either wine or bread-making. To investigate the maximal perfect pangenome haplotype blocks present in the data set, we construct a compressed De Bruijn graph for k \u2208 {25, 100, 1000} using the cdbg package [2] and extract SNPs from each using the method described in Sect. 3. Each yeast sequence then corresponds to a path through the SNP graph p i ; that is, a sequence of pangenome SNP calls. Then, as in Sect. 5, we find maximal repeats in the string p 1 $ 1 p 2 $ 2 . . . p k $ k in order to find MPPHBs. We use repeat-match from MUMmer 4.0 [8] to compute maximal repeats and identify all maximal pangenomic haplotype blocks using these reported repeats.",
            "cite_spans": [
                {
                    "start": 493,
                    "end": 496,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 832,
                    "end": 835,
                    "text": "[8]",
                    "ref_id": "BIBREF7"
                }
            ],
            "ref_spans": [],
            "section": "Experimental Results"
        },
        {
            "text": "Compressed De Bruijn graph and SNP graph generation takes a few minutes on a moderate workstation 2 for this data set. In order to find maximal repeats using MUMmer, we encode SNP nodes using 19 alphabet characters. When running repeat-match, we use the -f flag to find forward repeats only and the -n flag to return only encoded repeats long enough to represent full SNP nodes (in our case, 19 characters). For all k values, repeat-match took at most a few seconds to run. We then use a simple Python script to decode the output back to SNP labels and process it into haplotype blocks. For k = 25 and k = 100, this takes a few minutes; for the other two values tested, it takes a few seconds or less. Table 1 shows the number of SNPs found in each experiment, as well the number of haplotype blocks found and their average number of sequences and SNP path length. When k = 1000 fewer SNPs are found since there are fewer bubbles in the cDB graph and the blocks are smaller in size. As the number of bubbles in the cDB graph increases, more blocks are found. We leave a more thorough investigation of the relationship between k, the number of bubbles, and the number of blocks to future work. We compare the distributions of these data for k = 500 and k = 100 in Fig. 4 . In Fig. 5 we show a plot of several of the maximal haplotype blocks found in the k = 100 graph. The graph shows an introgressed region of SNPs that occurs in approximately half of the sequences that traverse the region shown.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 702,
                    "end": 709,
                    "text": "Table 1",
                    "ref_id": "TABREF1"
                },
                {
                    "start": 1263,
                    "end": 1269,
                    "text": "Fig. 4",
                    "ref_id": "FIGREF3"
                },
                {
                    "start": 1275,
                    "end": 1281,
                    "text": "Fig. 5",
                    "ref_id": "FIGREF4"
                }
            ],
            "section": "Experimental Results"
        },
        {
            "text": "In this work, we define the maximal perfect pangenome haplotype block problem and give a linear time method to solve it. Single-reference haplotype blocks can be used to compute a selection coefficient measuring the relative fitness of two genetic variants in a population; a natural next step in the pangenome case is to precisely define a pangenomic selection coefficient based on MPPHBs, or to explore other applications of MPPHBs in population genetics.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        },
        {
            "text": "We note that the positional Burrows-Wheeler Transform approach from [1] cannot be directly adapted for pangenome haplotype blocks since the SNP graph is not generally linear and paths may skip SNPs or contain cycles, etc. However, we are interested in extending both the pangenome and single-reference maximal perfect haplotype block problem to include inputs with SNPs that are not called, in order to include genomes with low coverage in some regions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Finding all maximal perfect haplotype blocks in linear time",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Alanko",
                    "suffix": ""
                },
                {
                    "first": "H",
                    "middle": [],
                    "last": "Bannai",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Cazaux",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Peterlongo",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Stoye",
                    "suffix": ""
                }
            ],
            "year": 2019,
            "venue": "19th International Workshop on Algorithms in Bioinformatics, WABI 2019. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "A representation of a compressed de Bruijn graph for pan-genome analysis that enables search",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Beller",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Ohlebusch",
                    "suffix": ""
                }
            ],
            "year": 2016,
            "venue": "Algorithms Mol. Biol",
            "volume": "11",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "A hidden markov model for investigating recent positive selection through haplotype structure",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hey",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Slatkin",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Theoret. Popul. Biol",
            "volume": "99",
            "issn": "",
            "pages": "18--30",
            "other_ids": {}
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Identifying maximal perfect haplotype blocks",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Cunha",
                    "suffix": ""
                },
                {
                    "first": "Y",
                    "middle": [],
                    "last": "Diekmann",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Kowada",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Stoye",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "BSB 2018",
            "volume": "11228",
            "issn": "",
            "pages": "26--37",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-01722-4_3"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Optimal suffix tree construction with large alphabets",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Farach",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "Proceedings 38th Annual Symposium on Foundations of Computer Science",
            "volume": "",
            "issn": "",
            "pages": "137--143",
            "other_ids": {}
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "Population Genetics: a Concise Guide",
            "authors": [
                {
                    "first": "J",
                    "middle": [
                        "H"
                    ],
                    "last": "Gillespie",
                    "suffix": ""
                }
            ],
            "year": 2004,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gusfield",
                    "suffix": ""
                }
            ],
            "year": 1997,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "MUMmer4: a fast and versatile genome alignment system",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Mar\u00e7ais",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "L"
                    ],
                    "last": "Delcher",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [
                        "M"
                    ],
                    "last": "Phillippy",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Coston",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [
                        "L"
                    ],
                    "last": "Salzberg",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Zimin",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "PLoS Comput. Biol",
            "volume": "14",
            "issn": "1",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Algorithms in Bioinformatics: A Practical Introduction",
            "authors": [
                {
                    "first": "W",
                    "middle": [
                        "K"
                    ],
                    "last": "Sung",
                    "suffix": ""
                }
            ],
            "year": 2009,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF9": {
            "ref_id": "b9",
            "title": "Genome analysis of multiple pathogenic isolates of streptococcus agalactiae: implications for the microbial \"pan-genome",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Tettelin",
                    "suffix": ""
                }
            ],
            "year": 2005,
            "venue": "Proc. Natl. Acad. Sci",
            "volume": "102",
            "issn": "",
            "pages": "13950--13955",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "The five maximal perfect haplotype blocks in this set of sequences are ({1, 3}, 1, 2), ({1, 3}, 2, 2), ({1, 2, 3}, 3, 4), ({2, 3}, 3, 6), and ({1, 2, 3}, 5, 5).",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "Three pangenome sequences represented as paths through a SNP graph containing ten SNPs. The subpath [2:0 3:1] and sequences {1, 2} represent one maximal perfect pangenome haplotype block. Subpath [6:1, 7:0, 8:0] and sequences {2, 3} is another.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "Scatterplot showing each distribution of maximal perfect pangenome haplotype sizes for k = 100 and k = 500.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "Sample haplotype block paths from a pangenomic data set comprised of 10 yeast genomes. Each colored path represents a haplotype block and the line thickness is proportional to the number of sequences in the block. SNPs 7778, 8174 and 25508 represent an introgressed region.(Color figure online)",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "There is no out-neighbor v of s[m] such that s, v is a subpath of p i for all i \u2208 K (right maximality), 4. There is no K \u2286 {1, 2, . . . , k} such that K K and s is a subpath of p i for all i \u2208 K (path set maximality).",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "Summary statistics for different k values. Decreasing k from 1000 to to 25 results in a larger SNP graph and more and bigger blocks found. k # SNPs # blocks avg. |K| avg. |S|",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": [
        {
            "text": "Acknowledgements. Support provided by US National Science Foundation grants DBI-1759522 and DBI-1661530. We thank the anonymous reviewers for their thoughtful feedback and questions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "acknowledgement"
        }
    ]
}